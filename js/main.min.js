(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi.js":[function(require,module,exports){
/* =========================================================================
 * Bragi (Javascript Logger - Browser)
 *
 * ----------------------------------
 *
 * Distributed under MIT license
 * Author : Erik Hazzard ( http://vasir.net )
 *
 * Provides a LOGGER object which can be used to perform logging
 *      LOGGER.log('group1', 'hello world');
 *
 *      // Also, parasm can be passed in
 *      LOGGER.log('group1', 'message', param1, param2, etc...);
 *      
 *      // And subgroups can be logged
 *      LOGGER.log('group1:subgroup', 'message %j', param1); 
 *      
 * To change logger options:
 *      // Shows ALL messages (false to show none)
 *      LOGGER.options.groupsEnabled = true; 
 *
 *      // Shows only specific groups
 *      LOGGER.options.groupsEnabled = ['error', 'debug']; // only shows passed in groups 
 *
 *      // Can also filter on subgroups
 *      LOGGER.options.groupsEnabled = ['group1:subgroup1']; 
 *
 *      // Or regular expressions
 *      LOGGER.options.groupsEnabled = [/^start:to:end$/]
 *
 * To change storing stack traces (gives more info, but adds a nontrivial amount 
 *      of time), change the `storeStackTrace` property. It is `false` by default
 *
 *      LOGGER.options.storeStackTrace = true;
 *
 * TRANSPORTS
 *      Logs are output / written to a file / pipped to a server by means
 *      of transports
 *
 * ========================================================================= */
var util = require('util');

var canLog = require('./bragi/canLog');

// Transports is an object which we can add / remove transport objects to
var Transports = require('./bragi/transports/Transports');

// transports is an object containing all available transports
var transports = require('./bragi/transports');

// TODO: This should probably be in the transports
var SYMBOLS = require('./bragi/symbols');

(function(root, factory) {
    // Setup logger for the environment
    if(typeof define === 'function' && define.amd) {
        // RequireJS / AMD
        define(['exports'], function(exports) {
            root = factory(root, exports);
            return root;
        });
    } else if (typeof exports !== 'undefined') {
        // CommonJS
        factory(root, exports); 
        module.exports = factory();
    } else {
        // browser global if neither are supported
        root.logger = factory(root, {});
    }
}(this, function(root, logger) {

    // --------------------------------------
    //
    // Setup logger object
    //
    // --------------------------------------
    // Here, we use only a single LOGGER object which is shared among all files
    // which import Bragi. 
    // NOTE: Why use a single object? What are benefits? Could expose a "new"
    //  logger object

    // NOTE: It might be useful to have multiple loggers?
    var LOGGER = {
        util: {},

        // reference to canLog function
        canLog: canLog
    };

    // Setup line number / function name logging 
    // --------------------------------------
    LOGGER.util.__stack = function() {
        // Utility to get stack information
        var stack = null;
        try{
            var orig = Error.prepareStackTrace;
            Error.prepareStackTrace = function(_, stack) { return stack; };
            var err = new Error();
            Error.captureStackTrace(err, arguments.callee);
            stack = err.stack;
            Error.prepareStackTrace = orig;
        } catch(e){ }

        return stack;
    };

    // --------------------------------------
    // Expose styles to users
    // --------------------------------------
    // some symbols for the user
    LOGGER.util.symbols = SYMBOLS; 

    // --------------------------------------
    //
    // Setup options
    //
    // --------------------------------------
    LOGGER.options = {
        // default options
        // Primary configuration options
        // ----------------------------------
        // groupsEnabled: specifies what logs to display. Can be either:
        //      1. an {array} of log levels 
        //          e.g,. ['error', 'myLog1', 'myLog2']
        //    or
        //
        //      2. a {Boolean} : true to see *all* log messages, false to
        //          see *no* messages
        //
        // groupsEnabled acts as a "whitelist" for what messages to log
        groupsEnabled: true,

        // blackList is an array of log level groups which will always be excluded.
        // Levels specified here take priority over log groups specified in groupsEnabled
        groupsDisabled: [],

        // Store stack trace? Provides more info, but adds overhead. Very useful
        // when in development, tradeoffs should be considered when in production
        storeStackTrace: false
    };


    // Setup default transports
    // --------------------------------------
    // transports is the transports array the logger users. 
    LOGGER.transports = new Transports();

    // Default transports
    // ----------------------------------
    // NOTE:  see the Console transport for info on the configuration options.
    // NOTE: Do not 
    var _defaultTransports = [
        new transports.Console({
            showMeta: true,
            showStackTrace: false
        })
    ];

    // Other transports include:
    //      new transports.ConsoleJSON({}) 
    // 
    //      new transports.History({
    //          storeEverything: false
    //      })
    //
    //      new transports.File({
    //          filename: '/tmp/test.json'
    //         })

    for(var i = 0; i < _defaultTransports.length; i++){
        LOGGER.transports.add( _defaultTransports[i] );
    }

    // Expose a reference to all available transports
    // NOTE: This isn't the cleanest way to do this, could use improvement
    LOGGER.transportClasses = transports;

    // ----------------------------------
    //
    // Group Addition / Removal Functions
    //
    // ----------------------------------
    LOGGER.addGroup = function addGroup ( group ){
        // Add a passed in group (either a {String} or {RegExp}) to the
        // groupsEnabled array

        // If groupsEnabled is true or false, turn it into an array
        var groupsEnabled = LOGGER.options.groupsEnabled;

        if(groupsEnabled === true || groupsEnabled === false){
            LOGGER.options.groupsEnabled = groupsEnabled = [];
        }

        // Ensure it does not exist
        var i = 0, len = groupsEnabled.length;
        for(i = 0; i < len; i++){
            if(groupsEnabled[i].toString() === group.toString()){
                return LOGGER;
            }
        }

        // Group wasn't found yet, add it
        groupsEnabled.push( group );

        return LOGGER;
    };

    LOGGER.removeGroup = function removeGroup ( group ){
        // Takes in a group and removes all occurences of it from 
        // groupsEnabled
        
        // If groupsEnabled is true or false, turn it into an array
        var groupsEnabled = LOGGER.options.groupsEnabled;

        if(groupsEnabled === true || groupsEnabled === false){
            LOGGER.options.groupsEnabled = groupsEnabled = [];
        }

        // Ensure it does not exist
        var i = 0, len = groupsEnabled.length;
        var groupsEnabledWithoutGroup = [];

        for(i = 0; i < len; i++){
            if(groupsEnabled[i].toString() !== group.toString()){
                groupsEnabledWithoutGroup.push( groupsEnabled[i] );
            }
        }

        // update the groupsEnabled
        LOGGER.options.groupsEnabled = groupsEnabledWithoutGroup;

        return LOGGER;
    };

    // ----------------------------------
    //
    // UTIL functions
    //
    // ----------------------------------
    LOGGER.util.print = function print(message, color){
        // NOTE: This is a stub function which exists in Bragi, but not in
        // the browser version. We could print individual colors, but it 
        // requires adding an additional CSS string to console.log(). This is
        // a TODO
        return message;
    };

    // ----------------------------------
    //
    // LOG function
    //
    // ----------------------------------
    LOGGER.log = function loggerLog(group, message){
        // Main logging function. Takes in two (plus n) parameters:
        //   group: {String} specifies the log level, or log group
        //
        //   message: {String} the message to log. The message must be a single
        //      string, but can have multiple objects inside using `%O`. e.g.,
        //          logger.log('test', 'some object: %O', {answer: 42});
        //
        //   all other parameters are objects or strings that will be formatted
        //   into the message
        //
        var groupsEnabled, groupsDisabled, currentTransport;
        var transportFuncsToCall = [];

        // Check if this can be logged or not. All transports must be checked as
        // well, as they can override LOGGER.options.groupsEnabled 
        // ----------------------------------
        // For each transport, if it can be logged, log it
        for(var transport in LOGGER.transports._transports){
            currentTransport = LOGGER.transports._transports[transport];

            // by default, use the groupsEnabled and groupsDisabled specified in 
            // options
            groupsEnabled = LOGGER.options.groupsEnabled;
            groupsDisabled = LOGGER.options.groupsDisabled;

            // If transport overrides exist, use them
            if(currentTransport.groupsEnabled !== undefined){
                groupsEnabled = currentTransport.groupsEnabled;
            }
            if(currentTransport.groupsDisabled !== undefined){
                groupsDisabled = currentTransport.groupsDisabled;
            }

            // check if message can be logged
            if(canLog(group, groupsEnabled, groupsDisabled)){
                transportFuncsToCall.push( currentTransport );
            }
        }

        // can this message be logged? If not, do nothing
        if(transportFuncsToCall.length < 1){ 
            // Can NOT be logged if there are no transportFuncs to call 
            //
            // If storeAllHistory is not true, return immediately (if it is
            // true, the message will get stored just not passed to any
            // transports)
            if(!LOGGER.options.storeAllHistory){
                return false;
            }
        }

        // get all arguments
        // ----------------------------------
        // remove the group and message from the args array, so the new args array will
        // just be an array of the passed in arguments
        var extraArgs = Array.prototype.slice.call(arguments, 2);

        // ----------------------------------
        // Build up a `loggedObject`, a structured object containing log 
        // information. It can be output to the console, to another file, to
        // a remote host, etc.
        // ------------------------------
        var loggedObject = {};

        // Caller info
        var caller = null;

        // Only capture caller if storeStackTrace is true.
        // NOTE: This will not work in strict mode, as we cannot access
        // the caller's name
        if(LOGGER.options.storeStackTrace){
            caller = 'global scope';
            if(loggerLog.caller && loggerLog.caller.name){
                caller = loggerLog.caller.name;
            } else if((loggerLog.caller+'').indexOf('function ()') === 0){
                caller = 'anonymous function';
            }
        }

        // Setup properties on the loggedObject based on passed in properties
        // ----------------------------------
        // These are set before any of our library setters to ensure clients do not
        // override properties set by Bragi
        // NOTE: All properties set by Bragi are prefixed with an underscore
        loggedObject.properties = {};
        loggedObject.originalArgs = [];

        for(var i = 0; i < extraArgs.length; i++){
            // For each argument, we need to check its type. If it's an object, then
            // we'll extend the loggedObject `properties` object
            // (if there are multiple keys, the last
            // key found takes priority). If it's an array or any other data type,
            // we'll set a new property called `argumentX` and set the value

            if(!(extraArgs[i] instanceof Array) && typeof extraArgs[i] === 'object'){
                for(var key in extraArgs[i]){
                    loggedObject.properties[key] = extraArgs[i][key];
                }
            } else {
                loggedObject.properties['_argument' + i] = extraArgs[i];
            }

            // add to originalArgs array, so we can know by index what args were
            // passed in
            loggedObject.originalArgs.push(extraArgs[i]);
        }

        // setup meta
        // ----------------------------------
        loggedObject.meta = {
            caller: caller,
            date: new Date().toJSON()
        };
        loggedObject.unixTimestamp = new Date().getTime() / 1000;

        var stack = false;
        if(LOGGER.options.storeStackTrace){
            // Store and use stack trace if set. Aides in developing, but adds
            // some overhead
            stack = LOGGER.util.__stack();
            // Currently, getting stack info via this method
            // is unsupported in many browsers
            if(stack){
                var stackLength = stack.length;
                var trace = [];

                for(i = 1; i < stack.length; i++){
                    trace.push(stack[i] + '');
                }

                loggedObject.meta.file = stack[1].getFileName();
                loggedObject.meta.line = stack[1].getLineNumber();
                loggedObject.meta.column = stack[1].getColumnNumber();
                loggedObject.meta.trace = trace;
            }
        }

        // Setup group, message, other params
        // ----------------------------------
        loggedObject.group = group;

        // Setup the message
        // ----------------------------------
        loggedObject.message = message;

        // Send loggedObject to each transport
        // ----------------------------------
        // The loggedObject is setup now, call each of the transport log calls that
        // can be called
        var len;
        for(i = 0, len = transportFuncsToCall.length; i < len; i++){
            transportFuncsToCall[i].log.call( transportFuncsToCall[i], loggedObject );
        }
    };

    // Expose this to the window
    if(!(typeof define === 'function' && define.amd)) {
        window.BRAGI = LOGGER;
    }
    return LOGGER;
}));

},{"./bragi/canLog":"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/canLog.js","./bragi/symbols":"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/symbols.js","./bragi/transports":"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports.js","./bragi/transports/Transports":"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports/Transports.js","util":"/Users/seiyria/GitHub/Roguathia/node_modules/util/util.js"}],"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/canLog.js":[function(require,module,exports){
/* =========================================================================
 *
 * canLog
 *
 *      Function which takes in a gropu and groupsEnabled and returns a {Boolean}
 *      indicating if message can be logged
 *
 * ========================================================================= */
function canLog(group, groupsEnabled, groupsDisabled){ 
    // Check if a passed in group {string} can be logged based on the passed in
    // groupsEnabled ({Array} or {Boolean}). 
    // If the message cannot be logged, return false - otherwise, return true
    //
    //  NOTE: errors will always be logged unless explictly disabled

    if(groupsEnabled === undefined){
        groupsEnabled = true;
    }
    var i,len;

    // by default, allow logging
    var canLogIt = true;

    // First, check for allowed groups (whitelist)
    // ----------------------------------
    if(groupsEnabled === true){
        canLogIt = true;

    } else if(groupsEnabled === false || groupsEnabled === null){
        // Don't ever log if logging is disabled
        canLogIt = false;

    } else if(groupsEnabled instanceof Array){
        // if an array of log levels is set, check it
        canLogIt = false;

        for(i=0, len=groupsEnabled.length; i<len; i++){
            // the current groupsEnabled will be a string we check group against;
            // for instance,
            //      if group is "group1:group2", and if the current log level
            //      is "group1:group3", it will NOT match; but, "group1:group2" 
            //      would match.
            //          Likewise, "group1:group2:group3" WOULD match

            // If the current item is a regular expression, run the regex
            if(groupsEnabled[i] instanceof RegExp){
                if(groupsEnabled[i].test(group)){
                    canLogIt = true;
                    break;
                }
            } else if(group.indexOf(groupsEnabled[i]) === 0){
                canLogIt = true;
                break;
            }
        }
    } 

    // set error and warn to be always on unless explictly disabled
    if(group.indexOf('error') === 0 || group.indexOf('warn') === 0){
        canLogIt = true;
    }

    // Second, check disallowed groups (blacklist)
    if(groupsDisabled && groupsDisabled instanceof Array){
        for(i=0, len=groupsDisabled.length; i<len; i++){
            // Same logic as checking groupsEnabled, just the inverse
            //
            // If the current item is a regular expression, run the regex
            if(groupsDisabled[i] instanceof RegExp){
                if(groupsDisabled[i].test(group)){
                    canLogIt = false;
                    break;
                }
            } else if(group.indexOf(groupsDisabled[i]) === 0){
                canLogIt = false;
                break;
            }
        }
    }

    return canLogIt;
}

module.exports = canLog;

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/symbols.js":[function(require,module,exports){
/* =========================================================================
 *
 *  symbols
 *      Defines special symbols used by logger
 *
 * ========================================================================= */
module.exports = {
    success: '✔︎ ',
    error: '✘ ',
    warn: '⚑ ',
    arrow: '➤ ',
    star: '☆ ',
    box: '☐ ',
    boxSuccess: '☑︎ ',
    boxError: '☒ ',
    circle: '◯ ',
    circleFilled: '◉ ',
    asterisk: '✢',
    floral: '❧',
    snowflake: '❄︎',
    fourDiamond:'❖',
    spade: '♠︎',
    club: '♣︎',
    heart: '♥︎',
    diamond: '♦︎',
    queen: '♛',
    rook: '♜',
    pawn: '♟',
    atom: '⚛'
};

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports.js":[function(require,module,exports){
/* =========================================================================
 *  transports
 *      Handles all transports
 *
 * ========================================================================= */
var files = require('./transports/index');

var transports = {};

for(var file in files){ 
    transports[file] = files[file];
}

module.exports = transports;

},{"./transports/index":"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports/index.js"}],"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports/Console.js":[function(require,module,exports){
/* =========================================================================
 *
 * Console
 *      Default transport - console
 *
 * ========================================================================= */
var SYMBOLS = require('../symbols');

// In < IE10 console is undefined unless the developer tools have at some
// point been opened in that tab. However, even after console and console.log
// exist, typeof console.log still evaluate to object, not function, so
// methods like .apply will cause errors
if (window.console && window.console.log) {
    if (typeof window.console.log !== 'function') {
        window.console.log = function () {};
    }
} else {
    window.console = {};
    window.console.log = function () {};
}

// --------------------------------------
//
// Setup group Colors to print
//
// --------------------------------------
var GROUP_COLORS = [
    // first is BG color, second is foreground color, third is border
    ['#3182bd', '#ffffff', '#225588'],
    ['#f38630', '#ffffff'],
    ['#e0e4cc', '#000000', '#c8cbb6'],
    ['#8c510a', '#ffffff'],
    ['#35978f', '#ffffff', "#13756d"],
    ['#c51b7d', '#ffffff'],
    ['#c6dbef', '#000000'],
    ['#af8dc3', '#000000'],
    ['#543005', '#ffffff', "#321002"],
    ['#7fbf7b', '#000000'],
    ['#dfc27d', '#000000', "#bda05b"],
    ['#f5f5f5', '#000000'],
    ['#e9a3c9', '#000000'],
    ['#59323C', '#ffffff'],
    ['#66c2a5', '#000000'],
    ['#f6e8c3', '#000000'],
    ['#606060', '#f0f0f0'],
    ['#8c510a', '#ffffff'],
    ['#80cdc1', '#000000'],
    ['#542788', '#ffffff'],
    ['#FB8AFE', '#343434'],
    ['#003c30', '#ffffff'],
    ['#e6f598', '#000000'],
    ['#c7eae5', '#000000'],
    ['#000000', '#f0f0f0'],
    ['#C3FF0E', '#343434']
];
var OVERFLOW_SYMBOLS = [
    'asterisk', 'floral', 'snowflake', 'fourDiamond', 'spade', 'club', 'heart',
    'diamond', 'queen', 'rook', 'pawn', 'atom'
];

var BASE_CSS = 'padding: 2px; margin:2px; line-height: 1.8em;';
var META_STYLE = BASE_CSS + 'font-size:0.9em; color: #cdcdcd; padding-left:30px;';

// ======================================
//
// Console Transport
//
// ======================================
function TransportConsole ( options ){
    options = options || {};
    // Transport must set groupsEnabled and groupsDisabled to provide transport
    // level support for overriding what groups to log
    // (NOTE - the user does not need to pass in groupsEnabled, but the
    // transport must set these properties)
    this.groupsEnabled = options.groupsEnabled;
    this.groupsDisabled = options.groupsDisabled;

    // Display / meta related config options
    // ----------------------------------
    // Add a line break after the last thing sent?
    this.addLineBreak = options.addLineBreak !== undefined ? options.addLineBreak : false;

    // showMeta: {Boolean} Show the meta info (calling func, time, line num, etc)
    //  `false` by default
    //  NOTE: This is primarily used only if you want to disable everything.
    //  If this is true and showStackTrace 
    //  options will be checked. If it is set to false, nothing will be shown
    this.showMeta = options.showMeta !== undefined ? options.showMeta : false;

    // showStackTrace: {Boolean} provide the full stack trace? Enabled by default,
    // but will only be shown if meta is shown
    this.showStackTrace = options.showStackTrace !== undefined ? options.showStackTrace: true;

    // Transport specific settings
    // ----------------------------------
    this.showColors = options.showColors === undefined ? true : options.showColor;

    this._foundColors = [];
    this._colorDict = {
        error: BASE_CSS + 'background: #ff0000; color: #ffffff; font-style: bold; border: 4px solid #cc0000;',
        warn: BASE_CSS + 'padding: 2px; background: #ffff00; color: #343434; font-style: bold; border: 4px solid #cccc00;'
    };

    this.curSymbolIndex = 0;

    return this;
}

TransportConsole.prototype.getColor = function getColor(group){
    // Color Formatting
    // ----------------------------------
    // Returns the background color for a passed in log group
    // TODO: if more found colors exist than the original length of the
    // COLOR array, cycle back and modify the original color
    //
    var color = '';
    var baseColor = '';
    var curSymbol;
    var cssString = '';

    // For color, get the first group
    group = group.split(':')[0];

    // if a color exists for the passed in log group, use it
    if(this._colorDict[group]){
        return this._colorDict[group];
    }

    if(this._foundColors.length >= GROUP_COLORS.length){
        // is the index too high? loop around if so
        color = GROUP_COLORS[this._foundColors.length % GROUP_COLORS.length];
        baseColor = color;

        // add underline if odd
        // ------------------------------
        cssString += 'font-style: italic;';

    } else {

        // We haven't yet exhausted all the colors
        color = GROUP_COLORS[this._foundColors.length];
    }

    var borderColor = color[2];
    // If no border color was provided, just bring all values down by 3
    // and use the result
    if(!color[2]){
        borderColor = '#';
        for(var i = 1; i < color[0].length; i++){
            borderColor += (
                (Math.max( 0, (parseInt(color[0][i], 16) - 2) )).toString(16)
            );
        }
    }


    cssString += BASE_CSS +
        "background: " + color[0] + ";" +
        "border: 1px solid " + borderColor + ";" +
        "color: " + color[1] + ";";

    // update the stored color info
    this._foundColors.push(color);
    this._colorDict[group] = cssString;

    return cssString;
};


// Prototype properties (All these must exist to be a valid transport)
// --------------------------------------
TransportConsole.prototype.name = 'Console';

TransportConsole.prototype.log = function transportConsoleLog( loggedObject ){
    // log
    //  Logs a passed object to the console
    //
    //  params:
    //      loggedObject: {Object} the log object to log
    //      options : {Object} the logger options
    //
    // Setup message for console output
    // ------------------------------
    //  The final message will look like: 
    //      [ group ]      message 
    //      meta info (function caller, time, file info)
    //
    var consoleMessage = "";
    if(this.showColors){
        consoleMessage += "%c";
    }

    var i;

    // Setup final log message format, depending on if it's a browser or not
    // ------------------------------
    consoleMessage +=
        "[ " +
            loggedObject.group + ' ' +
        " ] \t";

    // NOTE: Use the full styledMessage property
    consoleMessage += loggedObject.message + ' \t';

    // add line break to console messages if set
    if(this.addLineBreak){
        consoleMessage += '\n';
    }

    // Setup final log array to call console.log with
    var toLogArray = [];
    toLogArray.push(consoleMessage);

    if(this.showColors){
        toLogArray.push(this.getColor(loggedObject.group));
    }
    toLogArray = toLogArray.concat(loggedObject.originalArgs);

    // Log it
    // ------------------------------
    console.log.apply( console, toLogArray );

    // ----------------------------------
    // Log meta info?
    // ----------------------------------
    var metaConsoleMessage = '';
    var metaLogArray = [];

    if(this.showMeta){
        // push style for meta if there is meta
        if(this.showColors){
            metaConsoleMessage += '%c';
        }

        // JSON timestamp
        metaConsoleMessage += new Date().toJSON() + ' \t \t ';

        // Show the name of the calling function
        if(loggedObject.meta.caller){
            metaConsoleMessage += 'caller: ' + loggedObject.meta.caller + ' \t \t ';
        }

        // For node, log line number and filename
        if(loggedObject.meta.file && loggedObject.meta.line ){
            metaConsoleMessage += loggedObject.meta.file +
                ':' + loggedObject.meta.line +
                ':' + loggedObject.meta.column +
                '';
        }
    }

    if(this.showMeta && this.showStackTrace && loggedObject.meta.trace){
        // Show full stack trace if set
        // --------------------------
        metaConsoleMessage += '\n' +
            '(Stack Trace)' +
            '\n';

        // Skip the first item in the stack (this function)
        for(i = 0; i < loggedObject.meta.trace.length; i++){
            metaConsoleMessage += '\t' +
                loggedObject.meta.trace[i] + '\n';
        }
    }

    // push style for meta if there is meta
    if(this.showMeta && this.showColors){
        metaLogArray.push(metaConsoleMessage);
        metaLogArray.push(META_STYLE);
    }

    if(metaLogArray.length > 0){
        console.log.apply(console, metaLogArray);
    }

    return this;
};

module.exports = TransportConsole;

},{"../symbols":"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/symbols.js"}],"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports/History.js":[function(require,module,exports){
/* =========================================================================
 *
 * History
 *      Logs to console, but just outputs raw JSON
 *
 * ========================================================================= */
function TransportHistory ( options ){
    options = options || {};

    this.groupsEnabled = options.groupsEnabled;
    this.groupsDisabled = options.groupsDisabled;

    // Store *everything*?
    this.storeEverything = false;
    if(options.storeEverything === true){
        this.storeEverything = true;

        // Also, log *everything*
        this.groupsEnabled = true;
    }

    // Set history size per log group
    //  NOTE: if historySize is 0 or false, it has no limit
    this.historySize = options.historySize !== undefined ? options.historySize : 200;

    // History object
    this.history = {};

    return this;
}

// Prototype properties (All these must exist to be a valid transport)
// --------------------------------------
TransportHistory.prototype.name = 'History';

TransportHistory.prototype.log = function transportHistoryLog( loggedObject ){
    // log
    //  Logs a passed object to the console
    //
    //  params:
    //      loggedObject: {Object} the log object to log
    //      options : {Object} the logger options
    //
    // Setup message for console output
    // ------------------------------
    // store the key by the first root group
    var group = loggedObject.group.split(':')[0];

    // Keep track of message
    if(this.history[group] === undefined){
        this.history[group] = [];
    }

    // store the key by the first root group
    this.history[group].push(loggedObject);

    // Trim history
    if(this.historySize > 0 && 
       this.history[group].length > this.historySize
    ){
        this.history[group].shift();
    }

    return this;
};

module.exports = TransportHistory;

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports/Transports.js":[function(require,module,exports){
/* =========================================================================
 *
 * Transports
 *      Transports is an object which contains transports the logger uses
 *      to output logs
 *
 * ========================================================================= */
function Transports (){
    // This function is used by Bragi to keep track of what the currently
    // enabled transports to be used are
    
    this._transports = {};

    // Contains a count of # of transports by type
    this._transportCount = {};
    
    return this;
}

// ======================================
//
// access
//
// ======================================
Transports.prototype.get = function get( transportName ){
    // Returns a transport object that matches the passed in name
    var returnedTransportObjects = new Array();

    for(var key in this._transports){
        // If the name is part of of the key, remove it
        if(key.toLowerCase().indexOf(transportName.toLowerCase()) > -1){
            returnedTransportObjects.push(this._transports[key]);
        }
    }

    returnedTransportObjects.property = function transportProperty( keyOrObject, value ){
        // Allow `.property()` to be called, which will return an array of 
        // values if just the `keyOrObject` is passed in. If `value` is also passed in 
        // as a string, it will set all returned transports's key to that value
        //
        // An object containing property keys and values can also be passed in
        // as the first and only argument to set multiple properties at once
        //
        // example calls: .property( 'showMeta', true );
        //                .property( {showMeta: true} );

        var i = 0;
        var len = this.length;

        if(typeof keyOrObject === 'string' && value === undefined){
            // Getter called. called like `.property('showMeta');`
            var vals = [];
            for(i=0; i<len; i++){ 
                vals.push(this[i][keyOrObject]);
            }
            return vals;

        } 
        else if( typeof keyOrObject === 'string' && value !== undefined ){
            // Setter called. called like `.property('showMeta', true);`
            for(i=0; i<len; i++){ 
                this[i][keyOrObject] = value;
            }
        }
        else if( typeof keyOrObject === 'object' ){
            // Object passed in like `.property( {showMeta: true} )`
            for(i=0; i<len; i++){ 
                for( var keyName in keyOrObject ){
                    this[i][keyName] = keyOrObject[keyName];
                }
            }
        }

        return this;
    };

    return returnedTransportObjects;
};

// ======================================
//
// Add / Remove
//
// ======================================
Transports.prototype.add = function add( transport ){
    // Takes in a transport object and adds it to the transport object.
    //  If a transport object already exists (e.g., if there are two "File"
    //  transports already), the transport name will be transport.name + number

    if(this._transportCount[transport.name] === undefined){
        // Transport does not yet exist
        this._transportCount[transport.name] = 1;
        this._transports[transport.name] = transport;
    } else {
        // Transport already exists
        this._transportCount[transport.name] += 1;
        this._transports[transport.name + '' + (this._transportCount[transport.name] - 1)] = transport;
    }

    return this;
};

Transports.prototype.remove = function remove( transportName, index ){
    // Takes in the name of a transport (e.g., Console) and an optional index.
    // If no index is passed in, all transports that match the name will be 
    // removed. If an index is passed in, only the index will be removed. e.g.,
    // if there are two `File` transports, passed in index `1` will remove the
    // second file transport

    transportName = transportName;
    // if a transport object was passed in, remove the transport by name
    if(transportName.name){ transportName = transportName.name; }

    for(var key in this._transports){
        if(index !== undefined){
            if((transportName + '' + index) === key){
                delete this._transports[key];
            }
        } else {
            // If the name is part of of the key, remove it
            if(key.indexOf(transportName) > -1){
                delete this._transports[key];
            }
        }
    }

    return this;
};

Transports.prototype.empty = function empty (){
    // Removes all transports
    for(var key in this._transports){
        delete this._transports[key];
    }

    return this;
};

module.exports = Transports;

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports/index.js":[function(require,module,exports){
/* =========================================================================
 *
 * index.js
 *      Exports all available transports
 *
 * ========================================================================= */
module.exports.Console = require('./Console');
module.exports.History = require('./History');

},{"./Console":"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports/Console.js","./History":"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi/transports/History.js"}],"/Users/seiyria/GitHub/Roguathia/node_modules/dice.js/package.json":[function(require,module,exports){
module.exports={
  "_args": [
    [
      {
        "raw": "dice.js@^0.8.0",
        "scope": null,
        "escapedName": "dice.js",
        "name": "dice.js",
        "rawSpec": "^0.8.0",
        "spec": ">=0.8.0 <0.9.0",
        "type": "range"
      },
      "/Users/seiyria/GitHub/Roguathia"
    ]
  ],
  "_from": "dice.js@>=0.8.0 <0.9.0",
  "_id": "dice.js@0.8.0",
  "_inCache": true,
  "_location": "/dice.js",
  "_nodeVersion": "0.12.7",
  "_npmUser": {
    "name": "lordnull",
    "email": "micahw@lordnull.com"
  },
  "_npmVersion": "2.12.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "dice.js@^0.8.0",
    "scope": null,
    "escapedName": "dice.js",
    "name": "dice.js",
    "rawSpec": "^0.8.0",
    "spec": ">=0.8.0 <0.9.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/dice.js/-/dice.js-0.8.0.tgz",
  "_shasum": "1712d2c97d33572dbb99c02552e37b504f2f33c0",
  "_shrinkwrap": null,
  "_spec": "dice.js@^0.8.0",
  "_where": "/Users/seiyria/GitHub/Roguathia",
  "author": {
    "name": "Micah Warren",
    "url": "Lord Null"
  },
  "bugs": {
    "url": "https://github.com/lordnull/dice.js/issues"
  },
  "dependencies": {},
  "description": "A parser and evaluator for a useful rpg dice syntax.",
  "devDependencies": {
    "browserify": "~11.0.1",
    "jasmine-node": "~1.14.5",
    "karma": "~0.10.8",
    "karma-chrome-launcher": "~0.1.1",
    "karma-coffee-preprocessor": "~0.1.1",
    "karma-firefox-launcher": "~0.1.2",
    "karma-html2js-preprocessor": "~0.1.0",
    "karma-jasmine": "~0.1.5",
    "karma-phantomjs-launcher": "~0.1.1",
    "karma-requirejs": "~0.2.0",
    "karma-script-launcher": "~0.1.0",
    "pegjs": "~0.9.0",
    "requirejs": "~2.1.9"
  },
  "directories": {
    "test": "tests"
  },
  "dist": {
    "shasum": "1712d2c97d33572dbb99c02552e37b504f2f33c0",
    "tarball": "https://registry.npmjs.org/dice.js/-/dice.js-0.8.0.tgz"
  },
  "gitHead": "c326f12d06e47c635afba681ad54a43deb019082",
  "homepage": "https://github.com/lordnull/dice.js",
  "keywords": [
    "rpg",
    "dice",
    "parser",
    "roll",
    "peg"
  ],
  "license": "MIT",
  "main": "src/dice.js",
  "maintainers": [
    {
      "name": "lordnull",
      "email": "micahw@lordnull.com"
    }
  ],
  "name": "dice.js",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/lordnull/dice.js.git"
  },
  "scripts": {
    "test": "make test"
  },
  "version": "0.8.0"
}

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/dice.js/src/dice.js":[function(require,module,exports){
var dice = {
	parse: require('./parser').parse,
	eval: require('./evaluate').eval,
	version: require('../package').version
};

function roll(str, scope){
	var parsed = dice.parse(str);
	var evaled = dice.eval(parsed, scope);
	return evaled;
};

dice.roll = roll;

dice.statistics = function(str, scope, samples){
	if(typeof(scope) == "number"){
		samples = scope;
		scope = {};
	}
	scope = scope || {};
	samples = samples || 1000;
	var resultSet = [];
	var i;
	for(i = 0; i < samples; i++){
		resultSet.push(roll(str, scope));
	}
	var mean = resultSet.reduce(function(n, acc){ return n + acc; }, 0) / samples;
	var min = resultSet.reduce(function(n, acc){ return n < acc ? n : acc; }, resultSet[0]);
	var max = resultSet.reduce(function(n, acc){ return n > acc ? n : acc; }, resultSet[0]);
	return {
		'results': resultSet,
		'mean': mean,
		'min': parseInt(min.toFixed()),
		'max': parseInt(max.toFixed())
	};
};

function stringify_expression(evaled_op){
	var sub = stringify(evaled_op.expression);
	var prefix = evaled_op.op[0];
	if(prefix === 'p'){
		prefix = '';
	}
	
	return prefix + "( " + sub + " )";
};

function stringify_op(evaled_op){
	var rs = stringify(evaled_op.rightSide);
	var ls = stringify(evaled_op.leftSide);
	return rs + ' ' + evaled_op.op + ' ' + ls;
};

function stringify_rolls(evaled_roll){
	var minStr = evaled_roll.min > 1 ? evaled_roll.min + '..' : '';
	var preamble = evaled_roll.x + evaled_roll.mode + minStr + evaled_roll.max + ':[';
	return preamble + evaled_roll.rolls.join(', ') + ']';
};

function stringify(evaled){
	if(evaled.expression){
		return stringify_expression(evaled);
	}

	if(evaled.op){
		return stringify_op(evaled);
	}

	if(evaled.rolls){
		return stringify_rolls(evaled);
	}

	return evaled.toString();
};

dice.stringify = stringify;

var k;
for(k in dice){
    exports[k] = dice[k];
}

return dice;

},{"../package":"/Users/seiyria/GitHub/Roguathia/node_modules/dice.js/package.json","./evaluate":"/Users/seiyria/GitHub/Roguathia/node_modules/dice.js/src/evaluate.js","./parser":"/Users/seiyria/GitHub/Roguathia/node_modules/dice.js/src/parser.js"}],"/Users/seiyria/GitHub/Roguathia/node_modules/dice.js/src/evaluate.js":[function(require,module,exports){

function makeSeq(endIndex){
	var seq = [];
	seq[endIndex] = true;
	for(var i = 0; i < seq.length; i++){
		seq[i] = true;
	}
	return seq;
};

var ops = {

	'static': function(){
		var outValue = this.value;
		return function(){
			return outValue;
		};
	},

	'lookup': function(){
		var variableName = this.value;
		return function(scope){
			return scope[variableName];
		}
	},

	'floor': function(value){
		return function(scope){
			var floorable = value(scope);
			var tots = new Number(Math.floor(floorable));
			tots.op = 'floor';
			tots.expression = floorable;
			return tots;
		}
	},

	'ceil': function(value){
		return function(scope){
			var ceilable = value(scope);
			var tots = new Number(Math.ceil(ceilable));
			tots.op = 'ceil';
			tots.expression = ceilable;
			return tots;
		}
	},

	'round': function(value){
		return function(scope){
			var roundable = value(scope);
			var tots = new Number(Math.round(roundable));
			tots.op = 'round';
			tots.expression = roundable;
			return tots;
		}
	},

	'd': function(numRolls, minMax){
		return function(scope){
			var x = numRolls(scope);
			var seq = makeSeq(x - 1);
			var outMin, outMax;
			var rolled = seq.map(function(){
				var rolledRet = minMax(scope);
				outMin = rolledRet.min;
				outMax = rolledRet.max;
				return rolledRet;
			});
			var out = rolled.reduce(function(sum, val){
				return sum + val;
			}, 0);
			out = new Number(out);
			out.rolls = rolled;
			out.min = outMin;
			out.max = outMax;
			out.x = x;
			out.mode = 'd';
			return out;
		};
	},

	'w': function(numRolls, minMax){
		return function(scope){
			var x = numRolls(scope);
			var seq = makeSeq(x - 1);
			var outMin, outMax;
			var rolled = seq.map(function(){
				var lastRolled = minMax(scope);
				var wildrolled = 0;
				outMin = minMax.min;
				outMax = minMax.max;
				if(minMax.min === minMax.max){
					return lastRolled;
				}
				while(lastRolled === minMax.max){
					wildrolled += lastRolled;
					lastRolled = mimMax(scope);
				}
				return wildrolled;
			});
			var out = rolled.reduce(function(sum, val){
				return sum + val;
			}, 0);
			out = new Number(out);
			out.rolls = rolled;
			out.min = outMin;
			out.max = outMax;
			out.x = x;
			out.mode = 'w';
			return out;
		};
	},

	'random': function(minFun, maxFun){
		return function(scope){
			var rawRandom = Math.random();
			var max = maxFun(scope);
			var min = minFun(scope);
			var diff = max - min;
			var rawRandom = diff * rawRandom;
			var rndNumber = Math.round(rawRandom + min);
			rndNumber = new Number(rndNumber);
			rndNumber.min = min;
			rndNumber.max = max;
			return rndNumber;
		};
	},

	'+': function(v1, v2){
		return function(scope){
			var rightSide = v1(scope);
			var leftSide = v2(scope);
			var sum = rightSide + leftSide;
			sum = new Number(sum);
			sum.op = '+';
			sum.rightSide = rightSide;
			sum.leftSide = leftSide;
			return sum;
		};
	},

	'-': function(v1, v2){
		return function(scope){
			var rightSide = v1(scope);
			var leftSide = v2(scope);
			var sum = rightSide - leftSide;
			sum = new Number(sum);
			sum.op = '-';
			sum.rightSide = rightSide;
			sum.leftSide = leftSide;
			return sum;
		};
	},

	'*': function(v1, v2){
		return function(scope){
			var rightSide = v1(scope);
			var leftSide = v2(scope);
			var tots = rightSide * leftSide;
			tots = new Number(tots);
			tots.op = '*';
			tots.rightSide = rightSide;
			tots.leftSide = leftSide;
			return tots;
		};
	},

	'/': function(v1, v2){
		return function(scope){
			var rightSide = v1(scope);
			var leftSide = v2(scope);
			var tots = rightSide / leftSide;
			tots = new Number(tots);
			tots.op = '/';
			tots.rightSide = rightSide;
			tots.leftSide = leftSide;
			return tots;
		};
	},

	'paren_express': function(op){
		return function(scope){
			var tots = op(scope);
			outtots = new Number(tots);
			outtots.op = 'paren_express';
			outtots.expression = tots;
			return outtots;
		};
	}

};

function resolve_ops(args){
	args = args || [];
	return args.map(resolve_op);
};

function resolve_op(opObj){
	var subArgs = resolve_ops(opObj.args);
	return ops[opObj.op].apply(opObj, subArgs);
};


exports.eval = function(parsed, scope){
	scope = scope || {};
	var ops = resolve_op(parsed)
	return ops(scope);

	/*var acc = {sum: 0, mode: "+", rolls: [], 'scope':scope}
	var reduced = parsed.reduce(reduceThemBones, acc);
	return {sum: reduced.sum, rolls: reduced.rolls};*/
}

exports.ops = ops;


},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/dice.js/src/parser.js":[function(require,module,exports){
module.exports = (function() {
  "use strict";

  /*
   * Generated by PEG.js 0.9.0.
   *
   * http://pegjs.org/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  function peg$parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        parser  = this,

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = function(v1, op, v2) { return {'op':op, args: [v1, v2] }; },
        peg$c1 = function(out) { return out; },
        peg$c2 = "(",
        peg$c3 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c4 = ")",
        peg$c5 = { type: "literal", value: ")", description: "\")\"" },
        peg$c6 = function(rolls) { return {'op':'paren_express', args: [rolls]} },
        peg$c7 = "*",
        peg$c8 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c9 = function() { return '*'; },
        peg$c10 = "/",
        peg$c11 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c12 = function() { return '/'; },
        peg$c13 = function(v1, op, v2) { return {'op':op, args:[v1, v2] }; },
        peg$c14 = function(d) { return d; },
        peg$c15 = function(paren) { return paren; },
        peg$c16 = function(v1, op, v2) { return {'op':op, args:[v1, v2]}; },
        peg$c17 = function(op) { return op; },
        peg$c18 = "+",
        peg$c19 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c20 = function() { return "+"; },
        peg$c21 = "-",
        peg$c22 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c23 = function() { return "-"; },
        peg$c24 = function(x, mode, mm) { return {'op':mode, 'args':[x, mm]} },
        peg$c25 = function(mode, mm) { return {'op':mode, 'args':[{'op':'static', 'value':1}, mm]}; },
        peg$c26 = function(mm) { return { 'op':'d', 'args':[ {'op':'static', 'value':1}, mm]}; },
        peg$c27 = function(x) { return x; },
        peg$c28 = "d",
        peg$c29 = { type: "literal", value: "d", description: "\"d\"" },
        peg$c30 = "w",
        peg$c31 = { type: "literal", value: "w", description: "\"w\"" },
        peg$c32 = function(mm) { return mm; },
        peg$c33 = function(max) { return {'op':'random', 'args':[{'op':'static', 'args':[], 'value':1}, max]}; },
        peg$c34 = "..",
        peg$c35 = { type: "literal", value: "..", description: "\"..\"" },
        peg$c36 = function(min, max) { return {'op':'random', 'args':[min, max]}; },
        peg$c37 = /^[ ]/,
        peg$c38 = { type: "class", value: "[ ]", description: "[ ]" },
        peg$c39 = function(i) {
        		return {'op': 'static', value: i};
        	},
        peg$c40 = function(l) {
        		return l;
        	},
        peg$c41 = function(f, v) {
        		return {'op':f, args:[v]};
        	},
        peg$c42 = function(f, ex) {
            return {'op':f, args:ex.args};
        	},
        peg$c43 = "f",
        peg$c44 = { type: "literal", value: "f", description: "\"f\"" },
        peg$c45 = function() { return 'floor'; },
        peg$c46 = "r",
        peg$c47 = { type: "literal", value: "r", description: "\"r\"" },
        peg$c48 = function() { return 'round'; },
        peg$c49 = "c",
        peg$c50 = { type: "literal", value: "c", description: "\"c\"" },
        peg$c51 = function() { return 'ceil'; },
        peg$c52 = function(v) { return {'op':'lookup', 'value':v}; },
        peg$c53 = "[",
        peg$c54 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c55 = /^[a-zA-Z 0-9]/,
        peg$c56 = { type: "class", value: "[a-zA-Z 0-9]", description: "[a-zA-Z 0-9]" },
        peg$c57 = "]",
        peg$c58 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c59 = function(varname) { return varname.join(""); },
        peg$c60 = { type: "other", description: "integer" },
        peg$c61 = /^[0-9]/,
        peg$c62 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c63 = function(digits) { return parseInt(digits.join(""), 10); },
        peg$c64 = function(digits) { return parseInt(digits.join(""), 10) * -1; },

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function error(message) {
      throw peg$buildException(
        message,
        null,
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
          p, ch;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column,
          seenCR: details.seenCR
        };

        while (p < pos) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, found, location) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new peg$SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsedicerolls();

      return s0;
    }

    function peg$parsedicerolls() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsemultiplicationSeq();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseadditionOp();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseadditionSeq();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseadditionSeq();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseparenExpress();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseparenExpress() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c2;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedicerolls();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsews();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c4;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c5); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsemultiplicationOp() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s2 = peg$c7;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsews();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c11); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsews();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c12();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsemultiplicationSeq() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsediceroll();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsemultiplicationOp();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemultiplicationSeq();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c13(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseparenExpress();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsemultiplicationOp();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsemultiplicationSeq();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsediceroll();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c14(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseparenExpress();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c15(s1);
            }
            s0 = s1;
          }
        }
      }

      return s0;
    }

    function peg$parseadditionSeq() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsemultiplicationSeq();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseadditionOp();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseadditionSeq();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c16(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsemultiplicationSeq();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c17(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseparenExpress();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c17(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseadditionOp() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s2 = peg$c18;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c19); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c20();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsews();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s2 = peg$c21;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsews();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c23();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsediceroll() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseintval();
      if (s1 !== peg$FAILED) {
        s2 = peg$parserollmode();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemaybe_minmax();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c24(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parserollmode();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsemaybe_minmax();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c25(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseminmax();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseintval();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c27(s1);
            }
            s0 = s1;
          }
        }
      }

      return s0;
    }

    function peg$parserollmode() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 100) {
        s0 = peg$c28;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c29); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 119) {
          s0 = peg$c30;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c31); }
        }
      }

      return s0;
    }

    function peg$parsemaybe_minmax() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseminmax();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c32(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseintval();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseminmax() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseintval();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c34) {
          s2 = peg$c34;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c35); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseintval();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c36(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsews() {
      var s0, s1;

      s0 = [];
      if (peg$c37.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c37.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
      }

      return s0;
    }

    function peg$parseintval() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseinteger();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c39(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parselookup();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsemathit();
          if (s1 !== peg$FAILED) {
            s2 = peg$parselookup();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c41(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsemathit();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseparenExpress();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c42(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }

      return s0;
    }

    function peg$parsemathit() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 102) {
        s1 = peg$c43;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c44); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c45();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 114) {
          s1 = peg$c46;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c47); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 99) {
            s1 = peg$c49;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c50); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51();
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parselookup() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parsevariable();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c52(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsevariable() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c53;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c54); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c55.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c56); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c55.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c56); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c57;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c58); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c59(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseinteger() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c61.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c61.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c63(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c21;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c22); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c61.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c61.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c62); }
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c60); }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(
        null,
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})();

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/eventemitter2/lib/eventemitter2.js":[function(require,module,exports){
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
;!function(undefined) {

  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {

      this._conf = conf;

      conf.delimiter && (this.delimiter = conf.delimiter);
      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);
      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this.newListener = conf.newListener);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    }
  }

  function EventEmitter(conf) {
    this._events = {};
    this.newListener = false;
    configure.call(this, conf);
  }

  //
  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i) {
    if (!tree) {
      return [];
    }
    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
        typeLength = type.length, currentType = type[i], nextType = type[i+1];
    if (i === typeLength && tree._listeners) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //
      if (typeof tree._listeners === 'function') {
        handlers && handlers.push(tree._listeners);
        return [tree];
      } else {
        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
          handlers && handlers.push(tree._listeners[leaf]);
        }
        return [tree];
      }
    }

    if ((currentType === '*' || currentType === '**') || tree[currentType]) {
      //
      // If the event emitted is '*' at this part
      // or there is a concrete match at this patch
      //
      if (currentType === '*') {
        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
          }
        }
        return listeners;
      } else if(currentType === '**') {
        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
        if(endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
        }

        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            if(branch === '*' || branch === '**') {
              if(tree[branch]._listeners && !endReached) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
              }
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            } else if(branch === nextType) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
            } else {
              // No match on this one, shift into the tree but not in the type array.
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            }
          }
        }
        return listeners;
      }

      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
    }

    xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i+1);
    }

    xxTree = tree['**'];
    if(xxTree) {
      if(i < typeLength) {
        if(xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength);
        }

        // Build arrays of matching next branches and others.
        for(branch in xxTree) {
          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
            if(branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i+2);
            } else if(branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i+1);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
            }
          }
        }
      } else if(xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength);
      } else if(xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener) {

    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    for(var i = 0, len = type.length; i+1 < len; i++) {
      if(type[i] === '**' && type[i+1] === '**') {
        return;
      }
    }

    var tree = this.listenerTree;
    var name = type.shift();

    while (name) {

      if (!tree[name]) {
        tree[name] = {};
      }

      tree = tree[name];

      if (type.length === 0) {

        if (!tree._listeners) {
          tree._listeners = listener;
        }
        else if(typeof tree._listeners === 'function') {
          tree._listeners = [tree._listeners, listener];
        }
        else if (isArray(tree._listeners)) {

          tree._listeners.push(listener);

          if (!tree._listeners.warned) {

            var m = defaultMaxListeners;

            if (typeof this._events.maxListeners !== 'undefined') {
              m = this._events.maxListeners;
            }

            if (m > 0 && tree._listeners.length > m) {

              tree._listeners.warned = true;
              console.error('(node) warning: possible EventEmitter memory ' +
                            'leak detected. %d listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit.',
                            tree._listeners.length);
              console.trace();
            }
          }
        }
        return true;
      }
      name = type.shift();
    }
    return true;
  }

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    this._events || init.call(this);
    this._events.maxListeners = n;
    if (!this._conf) this._conf = {};
    this._conf.maxListeners = n;
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn) {
    this.many(event, 1, fn);
    return this;
  };

  EventEmitter.prototype.many = function(event, ttl, fn) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      fn.apply(this, arguments);
    }

    listener._origin = fn;

    this.on(event, listener);

    return self;
  };

  EventEmitter.prototype.emit = function() {

    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
      if (!this._events.newListener) { return false; }
    }

    // Loop through the *_all* functions and invoke them.
    if (this._all) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        this._all[i].apply(this, args);
      }
    }

    // If there is no 'error' event listener then throw.
    if (type === 'error') {

      if (!this._all &&
        !this._events.error &&
        !(this.wildcard && this.listenerTree.error)) {

        if (arguments[1] instanceof Error) {
          throw arguments[1]; // Unhandled 'error' event
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
        return false;
      }
    }

    var handler;

    if(this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    }
    else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      if (arguments.length === 1) {
        handler.call(this);
      }
      else if (arguments.length > 1)
        switch (arguments.length) {
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower
          default:
            var l = arguments.length;
            var args = new Array(l - 1);
            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
            handler.apply(this, args);
        }
      return true;
    }
    else if (handler) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];

      var listeners = handler.slice();
      for (var i = 0, l = listeners.length; i < l; i++) {
        this.event = type;
        listeners[i].apply(this, args);
      }
      return (listeners.length > 0) || !!this._all;
    }
    else {
      return !!this._all;
    }

  };

  EventEmitter.prototype.on = function(type, listener) {

    if (typeof type === 'function') {
      this.onAny(type);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);

    if(this.wildcard) {
      growListenerTree.call(this, type, listener);
      return this;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    }
    else if(typeof this._events[type] === 'function') {
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];
    }
    else if (isArray(this._events[type])) {
      // If we've already got an array, just append.
      this._events[type].push(listener);

      // Check for listener leak
      if (!this._events[type].warned) {

        var m = defaultMaxListeners;

        if (typeof this._events.maxListeners !== 'undefined') {
          m = this._events.maxListeners;
        }

        if (m > 0 && this._events[type].length > m) {

          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' +
                        'leak detected. %d listeners added. ' +
                        'Use emitter.setMaxListeners() to increase limit.',
                        this._events[type].length);
          console.trace();
        }
      }
    }
    return this;
  };

  EventEmitter.prototype.onAny = function(fn) {

    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    if(!this._all) {
      this._all = [];
    }

    // Add the function to the event listener collection.
    this._all.push(fn);
    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
    }
    else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          continue;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1);
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }
        return this;
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }
    }

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          return this;
        }
      }
    } else {
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function(type) {
    if (arguments.length === 0) {
      !this._events || init.call(this);
      return this;
    }

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        leaf._listeners = null;
      }
    }
    else {
      if (!this._events[type]) return this;
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    if(this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers;
    }

    this._events || init.call(this);

    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  if (typeof define === 'function' && define.amd) {
     // AMD. Register as an anonymous module.
    define(function() {
      return EventEmitter;
    });
  } else if (typeof exports === 'object') {
    // CommonJS
    exports.EventEmitter2 = EventEmitter;
  }
  else {
    // Browser global.
    window.EventEmitter2 = EventEmitter;
  }
}();

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js":[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      if (!(funcName in LazyWrapper.prototype)) {
        return false;
      }
      var other = lodash[funcName];
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it is invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it is
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it is invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it is created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), path + '');
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js":[function(require,module,exports){
(function (process,global){
/*
	This is rot.js, the ROguelike Toolkit in JavaScript.
	Version 0.6~dev, generated on Tue Mar  3 11:42:50 CET 2015.
*/
/**
 * Add objects for Node.js environment
 */
window = global;
document = {
	body: {
		appendChild: function(child) {},
		scrollLeft: 0,
		scrollTop: 0
	},
	createElement: function(type) {
		var canvas;
		return canvas = {
			getBoundingClientRect: function() {
				var rect;
				return rect = {
					left: 0,
					top: 0
				};
			},
			getContext: function(type) {
				var context;
				return context = {
					_termcolor: null,
					beginPath: function() {},
					canvas: canvas,
					drawImage: function(a, b, c, d, e, f, g, h, i) {},
					fill: function() {},
					fillRect: function(x, y, w, h) {
						if(this._termcolor !== null) {
							var clearCmd = this._termcolor.clearToAnsi(this.fillStyle);
							process.stdout.write(clearCmd);
						}
					},
					fillStyle: "#000",
					fillText: function(chs, x, y) {},
					font: "monospace",
					lineTo: function(x, y) {},
					measureText: function(ch) {
						var result;
						return result = {
							width: 12
						};
					},
					moveTo: function(x, y) {},
					textAlign: "center",
					textBaseline: "middle"
				};
			},
			height: 0,
			style: {
				left: "100px",
				position: "absolute",
				top: "100px",
				visibility: "hidden"
			},
			width: 0
		};
	},
	documentElement: {
		scrollLeft: 0,
		scrollTop: 0
	}
};
/**
 * @namespace Top-level ROT namespace
 */
var ROT = {
	/**
	 * @returns {bool} Is rot.js supported by this browser?
	 */
	isSupported: function() {
		return !!(document.createElement("canvas").getContext && Function.prototype.bind);
	},

	/** Default with for display and map generators */
	DEFAULT_WIDTH: 80,
	/** Default height for display and map generators */
	DEFAULT_HEIGHT: 25,

	/** Directional constants. Ordering is important! */
	DIRS: {
		"4": [
			[ 0, -1],
			[ 1,  0],
			[ 0,  1],
			[-1,  0]
		],
		"8": [
			[ 0, -1],
			[ 1, -1],
			[ 1,  0],
			[ 1,  1],
			[ 0,  1],
			[-1,  1],
			[-1,  0],
			[-1, -1]
		],
		"6": [
			[-1, -1],
			[ 1, -1],
			[ 2,  0],
			[ 1,  1],
			[-1,  1],
			[-2,  0]
		]
	},

	/** Cancel key. */
	VK_CANCEL: 3, 
	/** Help key. */
	VK_HELP: 6, 
	/** Backspace key. */
	VK_BACK_SPACE: 8, 
	/** Tab key. */
	VK_TAB: 9, 
	/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */
	VK_CLEAR: 12, 
	/** Return/enter key on the main keyboard. */
	VK_RETURN: 13, 
	/** Reserved, but not used. */
	VK_ENTER: 14, 
	/** Shift key. */
	VK_SHIFT: 16, 
	/** Control key. */
	VK_CONTROL: 17, 
	/** Alt (Option on Mac) key. */
	VK_ALT: 18, 
	/** Pause key. */
	VK_PAUSE: 19, 
	/** Caps lock. */
	VK_CAPS_LOCK: 20, 
	/** Escape key. */
	VK_ESCAPE: 27, 
	/** Space bar. */
	VK_SPACE: 32, 
	/** Page Up key. */
	VK_PAGE_UP: 33, 
	/** Page Down key. */
	VK_PAGE_DOWN: 34, 
	/** End key. */
	VK_END: 35, 
	/** Home key. */
	VK_HOME: 36, 
	/** Left arrow. */
	VK_LEFT: 37, 
	/** Up arrow. */
	VK_UP: 38, 
	/** Right arrow. */
	VK_RIGHT: 39, 
	/** Down arrow. */
	VK_DOWN: 40, 
	/** Print Screen key. */
	VK_PRINTSCREEN: 44, 
	/** Ins(ert) key. */
	VK_INSERT: 45, 
	/** Del(ete) key. */
	VK_DELETE: 46, 
	/***/
	VK_0: 48,
	/***/
	VK_1: 49,
	/***/
	VK_2: 50,
	/***/
	VK_3: 51,
	/***/
	VK_4: 52,
	/***/
	VK_5: 53,
	/***/
	VK_6: 54,
	/***/
	VK_7: 55,
	/***/
	VK_8: 56,
	/***/
	VK_9: 57,
	/** Colon (:) key. Requires Gecko 15.0 */
	VK_COLON: 58, 
	/** Semicolon (;) key. */
	VK_SEMICOLON: 59, 
	/** Less-than (<) key. Requires Gecko 15.0 */
	VK_LESS_THAN: 60, 
	/** Equals (=) key. */
	VK_EQUALS: 61, 
	/** Greater-than (>) key. Requires Gecko 15.0 */
	VK_GREATER_THAN: 62, 
	/** Question mark (?) key. Requires Gecko 15.0 */
	VK_QUESTION_MARK: 63, 
	/** Atmark (@) key. Requires Gecko 15.0 */
	VK_AT: 64, 
	/***/
	VK_A: 65,
	/***/
	VK_B: 66,
	/***/
	VK_C: 67,
	/***/
	VK_D: 68,
	/***/
	VK_E: 69,
	/***/
	VK_F: 70,
	/***/
	VK_G: 71,
	/***/
	VK_H: 72,
	/***/
	VK_I: 73,
	/***/
	VK_J: 74,
	/***/
	VK_K: 75,
	/***/
	VK_L: 76,
	/***/
	VK_M: 77,
	/***/
	VK_N: 78,
	/***/
	VK_O: 79,
	/***/
	VK_P: 80,
	/***/
	VK_Q: 81,
	/***/
	VK_R: 82,
	/***/
	VK_S: 83,
	/***/
	VK_T: 84,
	/***/
	VK_U: 85,
	/***/
	VK_V: 86,
	/***/
	VK_W: 87,
	/***/
	VK_X: 88,
	/***/
	VK_Y: 89,
	/***/
	VK_Z: 90,
	/***/
	VK_CONTEXT_MENU: 93,
	/** 0 on the numeric keypad. */
	VK_NUMPAD0: 96, 
	/** 1 on the numeric keypad. */
	VK_NUMPAD1: 97, 
	/** 2 on the numeric keypad. */
	VK_NUMPAD2: 98, 
	/** 3 on the numeric keypad. */
	VK_NUMPAD3: 99, 
	/** 4 on the numeric keypad. */
	VK_NUMPAD4: 100, 
	/** 5 on the numeric keypad. */
	VK_NUMPAD5: 101, 
	/** 6 on the numeric keypad. */
	VK_NUMPAD6: 102, 
	/** 7 on the numeric keypad. */
	VK_NUMPAD7: 103, 
	/** 8 on the numeric keypad. */
	VK_NUMPAD8: 104, 
	/** 9 on the numeric keypad. */
	VK_NUMPAD9: 105, 
	/** * on the numeric keypad. */
	VK_MULTIPLY: 106,
	/** + on the numeric keypad. */
	VK_ADD: 107, 
	/***/
	VK_SEPARATOR: 108,
	/** - on the numeric keypad. */
	VK_SUBTRACT: 109, 
	/** Decimal point on the numeric keypad. */
	VK_DECIMAL: 110, 
	/** / on the numeric keypad. */
	VK_DIVIDE: 111, 
	/** F1 key. */
	VK_F1: 112, 
	/** F2 key. */
	VK_F2: 113, 
	/** F3 key. */
	VK_F3: 114, 
	/** F4 key. */
	VK_F4: 115, 
	/** F5 key. */
	VK_F5: 116, 
	/** F6 key. */
	VK_F6: 117, 
	/** F7 key. */
	VK_F7: 118, 
	/** F8 key. */
	VK_F8: 119, 
	/** F9 key. */
	VK_F9: 120, 
	/** F10 key. */
	VK_F10: 121, 
	/** F11 key. */
	VK_F11: 122, 
	/** F12 key. */
	VK_F12: 123, 
	/** F13 key. */
	VK_F13: 124, 
	/** F14 key. */
	VK_F14: 125, 
	/** F15 key. */
	VK_F15: 126, 
	/** F16 key. */
	VK_F16: 127, 
	/** F17 key. */
	VK_F17: 128, 
	/** F18 key. */
	VK_F18: 129, 
	/** F19 key. */
	VK_F19: 130, 
	/** F20 key. */
	VK_F20: 131, 
	/** F21 key. */
	VK_F21: 132, 
	/** F22 key. */
	VK_F22: 133, 
	/** F23 key. */
	VK_F23: 134, 
	/** F24 key. */
	VK_F24: 135, 
	/** Num Lock key. */
	VK_NUM_LOCK: 144, 
	/** Scroll Lock key. */
	VK_SCROLL_LOCK: 145, 
	/** Circumflex (^) key. Requires Gecko 15.0 */
	VK_CIRCUMFLEX: 160, 
	/** Exclamation (!) key. Requires Gecko 15.0 */
	VK_EXCLAMATION: 161, 
	/** Double quote () key. Requires Gecko 15.0 */
	VK_DOUBLE_QUOTE: 162, 
	/** Hash (#) key. Requires Gecko 15.0 */
	VK_HASH: 163, 
	/** Dollar sign ($) key. Requires Gecko 15.0 */
	VK_DOLLAR: 164, 
	/** Percent (%) key. Requires Gecko 15.0 */
	VK_PERCENT: 165, 
	/** Ampersand (&) key. Requires Gecko 15.0 */
	VK_AMPERSAND: 166, 
	/** Underscore (_) key. Requires Gecko 15.0 */
	VK_UNDERSCORE: 167, 
	/** Open parenthesis (() key. Requires Gecko 15.0 */
	VK_OPEN_PAREN: 168, 
	/** Close parenthesis ()) key. Requires Gecko 15.0 */
	VK_CLOSE_PAREN: 169, 
	/* Asterisk (*) key. Requires Gecko 15.0 */
	VK_ASTERISK: 170,
	/** Plus (+) key. Requires Gecko 15.0 */
	VK_PLUS: 171, 
	/** Pipe (|) key. Requires Gecko 15.0 */
	VK_PIPE: 172, 
	/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */
	VK_HYPHEN_MINUS: 173, 
	/** Open curly bracket ({) key. Requires Gecko 15.0 */
	VK_OPEN_CURLY_BRACKET: 174, 
	/** Close curly bracket (}) key. Requires Gecko 15.0 */
	VK_CLOSE_CURLY_BRACKET: 175, 
	/** Tilde (~) key. Requires Gecko 15.0 */
	VK_TILDE: 176, 
	/** Comma (,) key. */
	VK_COMMA: 188, 
	/** Period (.) key. */
	VK_PERIOD: 190, 
	/** Slash (/) key. */
	VK_SLASH: 191, 
	/** Back tick (`) key. */
	VK_BACK_QUOTE: 192, 
	/** Open square bracket ([) key. */
	VK_OPEN_BRACKET: 219, 
	/** Back slash (\) key. */
	VK_BACK_SLASH: 220, 
	/** Close square bracket (]) key. */
	VK_CLOSE_BRACKET: 221, 
	/** Quote (''') key. */
	VK_QUOTE: 222, 
	/** Meta key on Linux, Command key on Mac. */
	VK_META: 224, 
	/** AltGr key on Linux. Requires Gecko 15.0 */
	VK_ALTGR: 225, 
	/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */
	VK_WIN: 91, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_KANA: 21, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_HANGUL: 21, 
	/** 英数 key on Japanese Mac keyboard. Requires Gecko 15.0 */
	VK_EISU: 22, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_JUNJA: 23, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_FINAL: 24, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_HANJA: 25, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_KANJI: 25, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_CONVERT: 28, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_NONCONVERT: 29, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_ACCEPT: 30, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_MODECHANGE: 31, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_SELECT: 41, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_PRINT: 42, 
	/** Linux support for this keycode was added in Gecko 4.0. */
	VK_EXECUTE: 43, 
	/** Linux support for this keycode was added in Gecko 4.0.	 */
	VK_SLEEP: 95 
};
/**
 * @namespace
 * Contains text tokenization and breaking routines
 */
ROT.Text = {
	RE_COLORS: /%([bc]){([^}]*)}/g,

	/* token types */
	TYPE_TEXT:		0,
	TYPE_NEWLINE:	1,
	TYPE_FG:		2,
	TYPE_BG:		3,

	/**
	 * Measure size of a resulting text block
	 */
	measure: function(str, maxWidth) {
		var result = {width:0, height:1};
		var tokens = this.tokenize(str, maxWidth);
		var lineWidth = 0;

		for (var i=0;i<tokens.length;i++) {
			var token = tokens[i];
			switch (token.type) {
				case this.TYPE_TEXT:
					lineWidth += token.value.length;
				break;

				case this.TYPE_NEWLINE:
					result.height++;
					result.width = Math.max(result.width, lineWidth);
					lineWidth = 0;
				break;
			}
		}
		result.width = Math.max(result.width, lineWidth);

		return result;
	},

	/**
	 * Convert string to a series of a formatting commands
	 */
	tokenize: function(str, maxWidth) {
		var result = [];

		/* first tokenization pass - split texts and color formatting commands */
		var offset = 0;
		str.replace(this.RE_COLORS, function(match, type, name, index) {
			/* string before */
			var part = str.substring(offset, index);
			if (part.length) {
				result.push({
					type: ROT.Text.TYPE_TEXT,
					value: part
				});
			}

			/* color command */
			result.push({
				type: (type == "c" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),
				value: name.trim()
			});

			offset = index + match.length;
			return "";
		});

		/* last remaining part */
		var part = str.substring(offset);
		if (part.length) {
			result.push({
				type: ROT.Text.TYPE_TEXT,
				value: part
			});
		}

		return this._breakLines(result, maxWidth);
	},

	/* insert line breaks into first-pass tokenized data */
	_breakLines: function(tokens, maxWidth) {
		if (!maxWidth) { maxWidth = Infinity; };

		var i = 0;
		var lineLength = 0;
		var lastTokenWithSpace = -1;

		while (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */
			var token = tokens[i];
			if (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */
				lineLength = 0; 
				lastTokenWithSpace = -1;
			}
			if (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */
				i++;
				continue; 
			}

			/* remove spaces at the beginning of line */
			while (lineLength == 0 && token.value.charAt(0) == " ") { token.value = token.value.substring(1); }

			/* forced newline? insert two new tokens after this one */
			var index = token.value.indexOf("\n");
			if (index != -1) { 
				token.value = this._breakInsideToken(tokens, i, index, true); 

				/* if there are spaces at the end, we must remove them (we do not want the line too long) */
				var arr = token.value.split("");
				while (arr[arr.length-1] == " ") { arr.pop(); }
				token.value = arr.join("");
			}

			/* token degenerated? */
			if (!token.value.length) {
				tokens.splice(i, 1);
				continue;
			}

			if (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */

				/* is it possible to break within this token? */
				var index = -1;
				while (1) {
					var nextIndex = token.value.indexOf(" ", index+1);
					if (nextIndex == -1) { break; }
					if (lineLength + nextIndex > maxWidth) { break; }
					index = nextIndex;
				}

				if (index != -1) { /* break at space within this one */
					token.value = this._breakInsideToken(tokens, i, index, true);
				} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */
					var token = tokens[lastTokenWithSpace];
					var breakIndex = token.value.lastIndexOf(" ");
					token.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);
					i = lastTokenWithSpace;
				} else { /* force break in this token */
					token.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);
				}

			} else { /* line not long, continue */
				lineLength += token.value.length;
				if (token.value.indexOf(" ") != -1) { lastTokenWithSpace = i; }
			}
			
			i++; /* advance to next token */
		}


		tokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */

		/* remove trailing space from text tokens before newlines */
		var lastTextToken = null;
		for (var i=0;i<tokens.length;i++) {
			var token = tokens[i];
			switch (token.type) {
				case ROT.Text.TYPE_TEXT: lastTextToken = token; break;
				case ROT.Text.TYPE_NEWLINE: 
					if (lastTextToken) { /* remove trailing space */
						var arr = lastTextToken.value.split("");
						while (arr[arr.length-1] == " ") { arr.pop(); }
						lastTextToken.value = arr.join("");
					}
					lastTextToken = null;
				break;
			}
		}

		tokens.pop(); /* remove fake token */

		return tokens;
	},

	/**
	 * Create new tokens and insert them into the stream
	 * @param {object[]} tokens
	 * @param {int} tokenIndex Token being processed
	 * @param {int} breakIndex Index within current token's value
	 * @param {bool} removeBreakChar Do we want to remove the breaking character?
	 * @returns {string} remaining unbroken token value
	 */
	_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {
		var newBreakToken = {
			type: ROT.Text.TYPE_NEWLINE
		}
		var newTextToken = {
			type: ROT.Text.TYPE_TEXT,
			value: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))
		}
		tokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);
		return tokens[tokenIndex].value.substring(0, breakIndex);
	}
}
/**
 * @returns {any} Randomly picked item, null when length=0
 */
Array.prototype.random = function() {
	if (!this.length) { return null; }
	return this[Math.floor(ROT.RNG.getUniform() * this.length)];
}

/**
 * @returns {array} New array with randomized items
 * FIXME destroys this!
 */
Array.prototype.randomize = function() {
	var result = [];
	while (this.length) {
		var index = this.indexOf(this.random());
		result.push(this.splice(index, 1)[0]);
	}
	return result;
}
/**
 * Always positive modulus
 * @param {int} n Modulus
 * @returns {int} this modulo n
 */
Number.prototype.mod = function(n) {
	return ((this%n)+n)%n;
}
/**
 * @returns {string} First letter capitalized
 */
String.prototype.capitalize = function() {
	return this.charAt(0).toUpperCase() + this.substring(1);
}

/** 
 * Left pad
 * @param {string} [character="0"]
 * @param {int} [count=2]
 */
String.prototype.lpad = function(character, count) {
	var ch = character || "0";
	var cnt = count || 2;

	var s = "";
	while (s.length < (cnt - this.length)) { s += ch; }
	s = s.substring(0, cnt-this.length);
	return s+this;
}

/** 
 * Right pad
 * @param {string} [character="0"]
 * @param {int} [count=2]
 */
String.prototype.rpad = function(character, count) {
	var ch = character || "0";
	var cnt = count || 2;

	var s = "";
	while (s.length < (cnt - this.length)) { s += ch; }
	s = s.substring(0, cnt-this.length);
	return this+s;
}

/**
 * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.
 * @param {string} template
 * @param {any} [argv]
 */
String.format = function(template) {
	var map = String.format.map;
	var args = Array.prototype.slice.call(arguments, 1);

	var replacer = function(match, group1, group2, index) {
		if (template.charAt(index-1) == "%") { return match.substring(1); }
		if (!args.length) { return match; }
		var obj = args[0];

		var group = group1 || group2;
		var parts = group.split(",");
		var name = parts.shift();
		var method = map[name.toLowerCase()];
		if (!method) { return match; }

		var obj = args.shift();
		var replaced = obj[method].apply(obj, parts);

		var first = name.charAt(0);
		if (first != first.toLowerCase()) { replaced = replaced.capitalize(); }

		return replaced;
	}
	return template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);
}

String.format.map = {
	"s": "toString"
}

/**
 * Convenience shortcut to String.format(this)
 */
String.prototype.format = function() {
	var args = Array.prototype.slice.call(arguments);
	args.unshift(this);
	return String.format.apply(String, args);
}

if (!Object.create) {  
	/**
	 * ES5 Object.create
	 */
	Object.create = function(o) {  
		var tmp = function() {};
		tmp.prototype = o;
		return new tmp();
	};  
}  
/**
 * Sets prototype of this function to an instance of parent function
 * @param {function} parent
 */
Function.prototype.extend = function(parent) {
	this.prototype = Object.create(parent.prototype);
	this.prototype.constructor = this;
	return this;
}
if (typeof window != "undefined") {
	window.requestAnimationFrame =
		window.requestAnimationFrame
		|| window.mozRequestAnimationFrame
		|| window.webkitRequestAnimationFrame
		|| window.oRequestAnimationFrame
		|| window.msRequestAnimationFrame
		|| function(cb) { return setTimeout(cb, 1000/60); };

	window.cancelAnimationFrame =
		window.cancelAnimationFrame
		|| window.mozCancelAnimationFrame
		|| window.webkitCancelAnimationFrame
		|| window.oCancelAnimationFrame
		|| window.msCancelAnimationFrame
		|| function(id) { return clearTimeout(id); };
}
/**
 * @class Visual map display
 * @param {object} [options]
 * @param {int} [options.width=ROT.DEFAULT_WIDTH]
 * @param {int} [options.height=ROT.DEFAULT_HEIGHT]
 * @param {int} [options.fontSize=15]
 * @param {string} [options.fontFamily="monospace"]
 * @param {string} [options.fontStyle=""] bold/italic/none/both
 * @param {string} [options.fg="#ccc"]
 * @param {string} [options.bg="#000"]
 * @param {float} [options.spacing=1]
 * @param {float} [options.border=0]
 * @param {string} [options.layout="rect"]
 * @param {int} [options.tileWidth=32]
 * @param {int} [options.tileHeight=32]
 * @param {object} [options.tileMap={}]
 * @param {image} [options.tileSet=null]
 * @param {image} [options.tileColorize=false]
 */
ROT.Display = function(options) {
	var canvas = document.createElement("canvas");
	this._context = canvas.getContext("2d");
	this._data = {};
	this._dirty = false; /* false = nothing, true = all, object = dirty cells */
	this._options = {};
	this._backend = null;
	
	var defaultOptions = {
		width: ROT.DEFAULT_WIDTH,
		height: ROT.DEFAULT_HEIGHT,
		transpose: false,
		layout: "rect",
		fontSize: 15,
		spacing: 1,
		border: 0,
		fontFamily: "monospace",
		fontStyle: "",
		fg: "#ccc",
		bg: "#000",
		tileWidth: 32,
		tileHeight: 32,
		tileMap: {},
		tileSet: null,
		tileColorize: false,
		termColor: "xterm"
	};
	for (var p in options) { defaultOptions[p] = options[p]; }
	this.setOptions(defaultOptions);
	this.DEBUG = this.DEBUG.bind(this);

	this._tick = this._tick.bind(this);
	requestAnimationFrame(this._tick);
}

/**
 * Debug helper, ideal as a map generator callback. Always bound to this.
 * @param {int} x
 * @param {int} y
 * @param {int} what
 */
ROT.Display.prototype.DEBUG = function(x, y, what) {
	var colors = [this._options.bg, this._options.fg];
	this.draw(x, y, null, null, colors[what % colors.length]);
}

/**
 * Clear the whole display (cover it with background color)
 */
ROT.Display.prototype.clear = function() {
	this._data = {};
	this._dirty = true;
}

/**
 * @see ROT.Display
 */
ROT.Display.prototype.setOptions = function(options) {
	for (var p in options) { this._options[p] = options[p]; }
	if (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {
		if (options.layout) { 
			this._backend = new ROT.Display[options.layout.capitalize()](this._context);
		}

		var font = (this._options.fontStyle ? this._options.fontStyle + " " : "") + this._options.fontSize + "px " + this._options.fontFamily;
		this._context.font = font;
		this._backend.compute(this._options);
		this._context.font = font;
		this._context.textAlign = "center";
		this._context.textBaseline = "middle";
		this._dirty = true;
	}
	return this;
}

/**
 * Returns currently set options
 * @returns {object} Current options object 
 */
ROT.Display.prototype.getOptions = function() {
	return this._options;
}

/**
 * Returns the DOM node of this display
 * @returns {node} DOM node
 */
ROT.Display.prototype.getContainer = function() {
	return this._context.canvas;
}

/**
 * Compute the maximum width/height to fit into a set of given constraints
 * @param {int} availWidth Maximum allowed pixel width
 * @param {int} availHeight Maximum allowed pixel height
 * @returns {int[2]} cellWidth,cellHeight
 */
ROT.Display.prototype.computeSize = function(availWidth, availHeight) {
	return this._backend.computeSize(availWidth, availHeight, this._options);
}

/**
 * Compute the maximum font size to fit into a set of given constraints
 * @param {int} availWidth Maximum allowed pixel width
 * @param {int} availHeight Maximum allowed pixel height
 * @returns {int} fontSize
 */
ROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {
	return this._backend.computeFontSize(availWidth, availHeight, this._options);
}

/**
 * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.
 * @param {Event} e event
 * @returns {int[2]} -1 for values outside of the canvas
 */
ROT.Display.prototype.eventToPosition = function(e) {
	if (e.touches) {
		var x = e.touches[0].clientX;
		var y = e.touches[0].clientY;
	} else {
		var x = e.clientX;
		var y = e.clientY;
	}

	var rect = this._context.canvas.getBoundingClientRect();
	x -= rect.left;
	y -= rect.top;
	
	if (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }

	return this._backend.eventToPosition(x, y);
}

/**
 * @param {int} x
 * @param {int} y
 * @param {string || string[]} ch One or more chars (will be overlapping themselves)
 * @param {string} [fg] foreground color
 * @param {string} [bg] background color
 */
ROT.Display.prototype.draw = function(x, y, ch, fg, bg) {
	if (!fg) { fg = this._options.fg; }
	if (!bg) { bg = this._options.bg; }
	this._data[x+","+y] = [x, y, ch, fg, bg];
	
	if (this._dirty === true) { return; } /* will already redraw everything */
	if (!this._dirty) { this._dirty = {}; } /* first! */
	this._dirty[x+","+y] = true;
}

/**
 * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.
 * @param {int} x
 * @param {int} y
 * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.
 * @param {int} [maxWidth] wrap at what width?
 * @returns {int} lines drawn
 */
ROT.Display.prototype.drawText = function(x, y, text, maxWidth) {
	var fg = null;
	var bg = null;
	var cx = x;
	var cy = y;
	var lines = 1;
	if (!maxWidth) { maxWidth = this._options.width-x; }

	var tokens = ROT.Text.tokenize(text, maxWidth);

	while (tokens.length) { /* interpret tokenized opcode stream */
		var token = tokens.shift();
		switch (token.type) {
			case ROT.Text.TYPE_TEXT:
				var isSpace = isPrevSpace = isFullWidth = isPrevFullWidth = false;
				for (var i=0;i<token.value.length;i++) {
					var cc = token.value.charCodeAt(i);
					var c = token.value.charAt(i);
					// Assign to `true` when the current char is full-width.
					isFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;
					// Current char is space, whatever full-width or half-width both are OK.
					isSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);
					// The previous char is full-width and
					// current char is nether half-width nor a space.
					if (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position
					// The current char is full-width and
					// the previous char is not a space.
					if(isFullWidth && !isPrevSpace) { cx++; } // add an extra position
					this.draw(cx++, cy, c, fg, bg);
					isPrevSpace = isSpace;
					isPrevFullWidth = isFullWidth;
				}
			break;

			case ROT.Text.TYPE_FG:
				fg = token.value || null;
			break;

			case ROT.Text.TYPE_BG:
				bg = token.value || null;
			break;

			case ROT.Text.TYPE_NEWLINE:
				cx = x;
				cy++;
				lines++
			break;
		}
	}

	return lines;
}

/**
 * Timer tick: update dirty parts
 */
ROT.Display.prototype._tick = function() {
	requestAnimationFrame(this._tick);

	if (!this._dirty) { return; }

	if (this._dirty === true) { /* draw all */
		this._context.fillStyle = this._options.bg;
		this._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);

		for (var id in this._data) { /* redraw cached data */
			this._draw(id, false);
		}

	} else { /* draw only dirty */
		for (var key in this._dirty) {
			this._draw(key, true);
		}
	}

	this._dirty = false;
}

/**
 * @param {string} key What to draw
 * @param {bool} clearBefore Is it necessary to clean before?
 */
ROT.Display.prototype._draw = function(key, clearBefore) {
	var data = this._data[key];
	if (data[4] != this._options.bg) { clearBefore = true; }

	this._backend.draw(data, clearBefore);
}
/**
 * @class Abstract display backend module
 * @private
 */
ROT.Display.Backend = function(context) {
	this._context = context;
}

ROT.Display.Backend.prototype.compute = function(options) {
}

ROT.Display.Backend.prototype.draw = function(data, clearBefore) {
}

ROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {
}

ROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {
}

ROT.Display.Backend.prototype.eventToPosition = function(x, y) {
}
/**
 * @class Rectangular backend
 * @private
 */
ROT.Display.Rect = function(context) {
	ROT.Display.Backend.call(this, context);
	
	this._spacingX = 0;
	this._spacingY = 0;
	this._canvasCache = {};
	this._options = {};
}
ROT.Display.Rect.extend(ROT.Display.Backend);

ROT.Display.Rect.cache = false;

ROT.Display.Rect.prototype.compute = function(options) {
	this._canvasCache = {};
	this._options = options;

	var charWidth = Math.ceil(this._context.measureText("W").width);
	this._spacingX = Math.ceil(options.spacing * charWidth);
	this._spacingY = Math.ceil(options.spacing * options.fontSize);
	this._context.canvas.width = options.width * this._spacingX;
	this._context.canvas.height = options.height * this._spacingY;
}

ROT.Display.Rect.prototype.draw = function(data, clearBefore) {
	if (this.constructor.cache) {
		this._drawWithCache(data, clearBefore);
	} else {
		this._drawNoCache(data, clearBefore);
	}
}

ROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {
	var x = data[0];
	var y = data[1];
	var ch = data[2];
	var fg = data[3];
	var bg = data[4];

	var hash = ""+ch+fg+bg;
	if (hash in this._canvasCache) {
		var canvas = this._canvasCache[hash];
	} else {
		var b = this._options.border;
		var canvas = document.createElement("canvas");
		var ctx = canvas.getContext("2d");
		canvas.width = this._spacingX;
		canvas.height = this._spacingY;
		ctx.fillStyle = bg;
		ctx.fillRect(b, b, canvas.width-b, canvas.height-b);
		
		if (ch) {
			ctx.fillStyle = fg;
			ctx.font = this._context.font;
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";

			var chars = [].concat(ch);
			for (var i=0;i<chars.length;i++) {
				ctx.fillText(chars[i], this._spacingX/2, this._spacingY/2);
			}
		}
		this._canvasCache[hash] = canvas;
	}
	
	this._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);
}

ROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {
	var x = data[0];
	var y = data[1];
	var ch = data[2];
	var fg = data[3];
	var bg = data[4];

	if (clearBefore) { 
		var b = this._options.border;
		this._context.fillStyle = bg;
		this._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);
	}
	
	if (!ch) { return; }

	this._context.fillStyle = fg;

	var chars = [].concat(ch);
	for (var i=0;i<chars.length;i++) {
		this._context.fillText(chars[i], (x+0.5) * this._spacingX, (y+0.5) * this._spacingY);
	}
}

ROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {
	var width = Math.floor(availWidth / this._spacingX);
	var height = Math.floor(availHeight / this._spacingY);
	return [width, height];
}

ROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {
	var boxWidth = Math.floor(availWidth / this._options.width);
	var boxHeight = Math.floor(availHeight / this._options.height);

	/* compute char ratio */
	var oldFont = this._context.font;
	this._context.font = "100px " + this._options.fontFamily;
	var width = Math.ceil(this._context.measureText("W").width);
	this._context.font = oldFont;
	var ratio = width / 100;
		
	var widthFraction = ratio * boxHeight / boxWidth;
	if (widthFraction > 1) { /* too wide with current aspect ratio */
		boxHeight = Math.floor(boxHeight / widthFraction);
	}
	return Math.floor(boxHeight / this._options.spacing);
}

ROT.Display.Rect.prototype.eventToPosition = function(x, y) {
	return [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];
}
/**
 * @class Hexagonal backend
 * @private
 */
ROT.Display.Hex = function(context) {
	ROT.Display.Backend.call(this, context);

	this._spacingX = 0;
	this._spacingY = 0;
	this._hexSize = 0;
	this._options = {};
}
ROT.Display.Hex.extend(ROT.Display.Backend);

ROT.Display.Hex.prototype.compute = function(options) {
	this._options = options;

	/* FIXME char size computation does not respect transposed hexes */
	var charWidth = Math.ceil(this._context.measureText("W").width);
	this._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);
	this._spacingX = this._hexSize * Math.sqrt(3) / 2;
	this._spacingY = this._hexSize * 1.5;

	if (options.transpose) {
		var xprop = "height";
		var yprop = "width";
	} else {
		var xprop = "width";
		var yprop = "height";
	}
	this._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );
	this._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );
}

ROT.Display.Hex.prototype.draw = function(data, clearBefore) {
	var x = data[0];
	var y = data[1];
	var ch = data[2];
	var fg = data[3];
	var bg = data[4];

	var px = [
		(x+1) * this._spacingX,
		y * this._spacingY + this._hexSize
	];
	if (this._options.transpose) { px.reverse(); }

	if (clearBefore) { 
		this._context.fillStyle = bg;
		this._fill(px[0], px[1]);
	}
	
	if (!ch) { return; }

	this._context.fillStyle = fg;

	var chars = [].concat(ch);
	for (var i=0;i<chars.length;i++) {
		this._context.fillText(chars[i], px[0], px[1]);
	}
}

ROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {
	if (this._options.transpose) {
		availWidth += availHeight;
		availHeight = availWidth - availHeight;
		availWidth -= availHeight;
	}

	var width = Math.floor(availWidth / this._spacingX) - 1;
	var height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);
	return [width, height];
}

ROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {
	if (this._options.transpose) {
		availWidth += availHeight;
		availHeight = availWidth - availHeight;
		availWidth -= availHeight;
	}

	var hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;
	var hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));
	var hexSize = Math.min(hexSizeWidth, hexSizeHeight);

	/* compute char ratio */
	var oldFont = this._context.font;
	this._context.font = "100px " + this._options.fontFamily;
	var width = Math.ceil(this._context.measureText("W").width);
	this._context.font = oldFont;
	var ratio = width / 100;

	hexSize = Math.floor(hexSize)+1; /* closest larger hexSize */

	/* FIXME char size computation does not respect transposed hexes */
	var fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));

	/* closest smaller fontSize */
	return Math.ceil(fontSize)-1;
}

ROT.Display.Hex.prototype.eventToPosition = function(x, y) {
	if (this._options.transpose) {
		x += y;
		y = x-y;
		x -= y;
		var prop = "width";
	} else {
		var prop = "height";
	}
	var size = this._context.canvas[prop] / this._options[prop];
	y = Math.floor(y/size);

	if (y.mod(2)) { /* odd row */
		x -= this._spacingX;
		x = 1 + 2*Math.floor(x/(2*this._spacingX));
	} else {
		x = 2*Math.floor(x/(2*this._spacingX));
	}
	
	return [x, y];
}

/**
 * Arguments are pixel values. If "transposed" mode is enabled, then these two are already swapped.
 */
ROT.Display.Hex.prototype._fill = function(cx, cy) {
	var a = this._hexSize;
	var b = this._options.border;
	
	this._context.beginPath();

	if (this._options.transpose) {
		this._context.moveTo(cx-a+b,	cy);
		this._context.lineTo(cx-a/2+b,	cy+this._spacingX-b);
		this._context.lineTo(cx+a/2-b,	cy+this._spacingX-b);
		this._context.lineTo(cx+a-b,	cy);
		this._context.lineTo(cx+a/2-b,	cy-this._spacingX+b);
		this._context.lineTo(cx-a/2+b,	cy-this._spacingX+b);
		this._context.lineTo(cx-a+b,	cy);
	} else {
		this._context.moveTo(cx,					cy-a+b);
		this._context.lineTo(cx+this._spacingX-b,	cy-a/2+b);
		this._context.lineTo(cx+this._spacingX-b,	cy+a/2-b);
		this._context.lineTo(cx,					cy+a-b);
		this._context.lineTo(cx-this._spacingX+b,	cy+a/2-b);
		this._context.lineTo(cx-this._spacingX+b,	cy-a/2+b);
		this._context.lineTo(cx,					cy-a+b);
	}
	this._context.fill();
}
/**
 * @class Tile backend
 * @private
 */
ROT.Display.Tile = function(context) {
	ROT.Display.Rect.call(this, context);
	
	this._options = {};
	this._colorCanvas = document.createElement("canvas");
}
ROT.Display.Tile.extend(ROT.Display.Rect);

ROT.Display.Tile.prototype.compute = function(options) {
	this._options = options;
	this._context.canvas.width = options.width * options.tileWidth;
	this._context.canvas.height = options.height * options.tileHeight;
	this._colorCanvas.width = options.tileWidth;
	this._colorCanvas.height = options.tileHeight;
}

ROT.Display.Tile.prototype.draw = function(data, clearBefore) {
	var x = data[0];
	var y = data[1];
	var ch = data[2];
	var fg = data[3];
	var bg = data[4];

	var tileWidth = this._options.tileWidth;
	var tileHeight = this._options.tileHeight;

	if (clearBefore) {
		var b = this._options.border;
		this._context.fillStyle = bg;

		if (this._options.tileColor) {this._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);} else {
			this._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);
		}
		
	}

	if (!ch) { return; }

	var chars = [].concat(ch);
	for (var i=0;i<chars.length;i++) {
		var tile = this._options.tileMap[chars[i]];
		if (!tile) { throw new Error("Char '" + chars[i] + "' not found in tileMap"); }
		
		if (this._options.tileColorize) { /* apply colorization */
			var canvas = this._colorCanvas;
			var context = canvas.getContext("2d");
			context.clearRect(0, 0, tileWidth, tileHeight);

			context.drawImage(
				this._options.tileSet,
				tile[0], tile[1], tileWidth, tileHeight,
				0, 0, tileWidth, tileHeight
			);

			if (fg != "transparent") {
				context.fillStyle = fg;
				context.globalCompositeOperation = "source-atop";
				context.fillRect(0, 0, tileWidth, tileHeight);
			}

			if (bg != "transparent") {
				context.fillStyle = bg;
				context.globalCompositeOperation = "destination-over";
				context.fillRect(0, 0, tileWidth, tileHeight);
			}

			this._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);

		} else { /* no colorizing, easy */
			this._context.drawImage(
				this._options.tileSet,
				tile[0], tile[1], tileWidth, tileHeight,
				x*tileWidth, y*tileHeight, tileWidth, tileHeight
			);
		}
	}
}

ROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {
	var width = Math.floor(availWidth / this._options.tileWidth);
	var height = Math.floor(availHeight / this._options.tileHeight);
	return [width, height];
}

ROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {
	var width = Math.floor(availWidth / this._options.width);
	var height = Math.floor(availHeight / this._options.height);
	return [width, height];
}

ROT.Display.Tile.prototype.eventToPosition = function(x, y) {
	return [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];
}
/**
 * @namespace
 * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baagøe.
 * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.
 */
ROT.RNG = {
	/**
	 * @returns {number} 
	 */
	getSeed: function() {
		return this._seed;
	},

	/**
	 * @param {number} seed Seed the number generator
	 */
	setSeed: function(seed) {
		seed = (seed < 1 ? 1/seed : seed);

		this._seed = seed;
		this._s0 = (seed >>> 0) * this._frac;

		seed = (seed*69069 + 1) >>> 0;
		this._s1 = seed * this._frac;

		seed = (seed*69069 + 1) >>> 0;
		this._s2 = seed * this._frac;

		this._c = 1;
		return this;
	},

	/**
	 * @returns {float} Pseudorandom value [0,1), uniformly distributed
	 */
	getUniform: function() {
		var t = 2091639 * this._s0 + this._c * this._frac;
		this._s0 = this._s1;
		this._s1 = this._s2;
		this._c = t | 0;
		this._s2 = t - this._c;
		return this._s2;
	},

	/**
	 * @param {int} lowerBound The lower end of the range to return a value from, inclusive
	 * @param {int} upperBound The upper end of the range to return a value from, inclusive
	 * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value
	 */
	getUniformInt: function(lowerBound, upperBound) {
		var max = Math.max(lowerBound, upperBound);
		var min = Math.min(lowerBound, upperBound);
		return Math.floor(this.getUniform() * (max - min + 1)) + min;
	},

	/**
	 * @param {float} [mean=0] Mean value
	 * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.
	 * @returns {float} A normally distributed pseudorandom value
	 */
	getNormal: function(mean, stddev) {
		do {
			var u = 2*this.getUniform()-1;
			var v = 2*this.getUniform()-1;
			var r = u*u + v*v;
		} while (r > 1 || r == 0);

		var gauss = u * Math.sqrt(-2*Math.log(r)/r);
		return (mean || 0) + gauss*(stddev || 1);
	},

	/**
	 * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed
	 */
	getPercentage: function() {
		return 1 + Math.floor(this.getUniform()*100);
	},
	
	/**
	 * @param {object} data key=whatever, value=weight (relative probability)
	 * @returns {string} whatever
	 */
	getWeightedValue: function(data) {
		var avail = [];
		var total = 0;
		
		for (var id in data) {
			total += data[id];
		}
		var random = Math.floor(this.getUniform()*total);
		
		var part = 0;
		for (var id in data) {
			part += data[id];
			if (random < part) { return id; }
		}
		
		return null;
	},

	/**
	 * Get RNG state. Useful for storing the state and re-setting it via setState.
	 * @returns {?} Internal state
	 */
	getState: function() {
		return [this._s0, this._s1, this._s2, this._c];
	},

	/**
	 * Set a previously retrieved state.
	 * @param {?} state
	 */
	setState: function(state) {
		this._s0 = state[0];
		this._s1 = state[1];
		this._s2 = state[2];
		this._c  = state[3];
		return this;
	},

	/**
	 * Returns a cloned RNG
	 */
	clone: function() {
		var clone = Object.create(this);
		clone.setState(this.getState());
		return clone;
	},

	_s0: 0,
	_s1: 0,
	_s2: 0,
	_c: 0,
	_frac: 2.3283064365386963e-10 /* 2^-32 */
}

ROT.RNG.setSeed(Date.now());
/**
 * @class (Markov process)-based string generator. 
 * Copied from a <a href="http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme">RogueBasin article</a>. 
 * Offers configurable order and prior.
 * @param {object} [options]
 * @param {bool} [options.words=false] Use word mode?
 * @param {int} [options.order=3]
 * @param {float} [options.prior=0.001]
 */
ROT.StringGenerator = function(options) {
	this._options = {
		words: false,
		order: 3,
		prior: 0.001
	}
	for (var p in options) { this._options[p] = options[p]; }

	this._boundary = String.fromCharCode(0);
	this._suffix = this._boundary;
	this._prefix = [];
	for (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }

	this._priorValues = {};
	this._priorValues[this._boundary] = this._options.prior;

	this._data = {};
}

/**
 * Remove all learning data
 */
ROT.StringGenerator.prototype.clear = function() {
	this._data = {};
	this._priorValues = {};
}

/**
 * @returns {string} Generated string
 */
ROT.StringGenerator.prototype.generate = function() {
	var result = [this._sample(this._prefix)];
	while (result[result.length-1] != this._boundary) {
		result.push(this._sample(result));
	}
	return this._join(result.slice(0, -1));
}

/**
 * Observe (learn) a string from a training set
 */
ROT.StringGenerator.prototype.observe = function(string) {
	var tokens = this._split(string);

	for (var i=0; i<tokens.length; i++) {
		this._priorValues[tokens[i]] = this._options.prior;
	}

	tokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */

	for (var i=this._options.order; i<tokens.length; i++) {
		var context = tokens.slice(i-this._options.order, i);
		var event = tokens[i];
		for (var j=0; j<context.length; j++) {
			var subcontext = context.slice(j);
			this._observeEvent(subcontext, event);
		}
	}
}

ROT.StringGenerator.prototype.getStats = function() {
	var parts = [];

	var priorCount = 0;
	for (var p in this._priorValues) { priorCount++; }
	priorCount--; /* boundary */
	parts.push("distinct samples: " + priorCount);

	var dataCount = 0;
	var eventCount = 0;
	for (var p in this._data) { 
		dataCount++; 
		for (var key in this._data[p]) {
			eventCount++;
		}
	}
	parts.push("dictionary size (contexts): " + dataCount);
	parts.push("dictionary size (events): " + eventCount);

	return parts.join(", ");
}

/**
 * @param {string}
 * @returns {string[]}
 */
ROT.StringGenerator.prototype._split = function(str) {
	return str.split(this._options.words ? /\s+/ : "");
}

/**
 * @param {string[]}
 * @returns {string} 
 */
ROT.StringGenerator.prototype._join = function(arr) {
	return arr.join(this._options.words ? " " : "");
}

/**
 * @param {string[]} context
 * @param {string} event
 */
ROT.StringGenerator.prototype._observeEvent = function(context, event) {
	var key = this._join(context);
	if (!(key in this._data)) { this._data[key] = {}; }
	var data = this._data[key];

	if (!(event in data)) { data[event] = 0; }
	data[event]++;
}

/**
 * @param {string[]}
 * @returns {string}
 */
ROT.StringGenerator.prototype._sample = function(context) {
	context = this._backoff(context);
	var key = this._join(context);
	var data = this._data[key];

	var available = {};

	if (this._options.prior) {
		for (var event in this._priorValues) { available[event] = this._priorValues[event]; }
		for (var event in data) { available[event] += data[event]; }
	} else { 
		available = data;
	}

	return this._pickRandom(available);
}

/**
 * @param {string[]}
 * @returns {string[]}
 */
ROT.StringGenerator.prototype._backoff = function(context) {
	if (context.length > this._options.order) {
		context = context.slice(-this._options.order);
	} else if (context.length < this._options.order) {
		context = this._prefix.slice(0, this._options.order - context.length).concat(context);
	}

	while (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }

	return context;
}


ROT.StringGenerator.prototype._pickRandom = function(data) {
	var total = 0;
	
	for (var id in data) {
		total += data[id];
	}
	var random = ROT.RNG.getUniform()*total;
	
	var part = 0;
	for (var id in data) {
		part += data[id];
		if (random < part) { return id; }
	}
}
/**
 * @class Generic event queue: stores events and retrieves them based on their time
 */
ROT.EventQueue = function() {
	this._time = 0;
	this._events = [];
	this._eventTimes = [];
}

/**
 * @returns {number} Elapsed time
 */
ROT.EventQueue.prototype.getTime = function() {
	return this._time;
}

/**
 * Clear all scheduled events
 */
ROT.EventQueue.prototype.clear = function() {
	this._events = [];
	this._eventTimes = [];
	return this;
}

/**
 * @param {?} event
 * @param {number} time
 */
ROT.EventQueue.prototype.add = function(event, time) {
	var index = this._events.length;
	for (var i=0;i<this._eventTimes.length;i++) {
		if (this._eventTimes[i] > time) {
			index = i;
			break;
		}
	}

	this._events.splice(index, 0, event);
	this._eventTimes.splice(index, 0, time);
}

/**
 * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.
 * @returns {? || null} The event previously added by addEvent, null if no event available
 */
ROT.EventQueue.prototype.get = function() {
	if (!this._events.length) { return null; }

	var time = this._eventTimes.splice(0, 1)[0];
	if (time > 0) { /* advance */
		this._time += time;
		for (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }
	}

	return this._events.splice(0, 1)[0];
}

/**
 * Remove an event from the queue
 * @param {?} event
 * @returns {bool} success?
 */
ROT.EventQueue.prototype.remove = function(event) {
	var index = this._events.indexOf(event);
	if (index == -1) { return false }
	this._remove(index);
	return true;
}

/**
 * Remove an event from the queue
 * @param {int} index
 */
ROT.EventQueue.prototype._remove = function(index) {
	this._events.splice(index, 1);
	this._eventTimes.splice(index, 1);
}
/**
 * @class Abstract scheduler
 */
ROT.Scheduler = function() {
	this._queue = new ROT.EventQueue();
	this._repeat = [];
	this._current = null;
}

/**
 * @see ROT.EventQueue#getTime
 */
ROT.Scheduler.prototype.getTime = function() {
	return this._queue.getTime();
}

/**
 * @param {?} item
 * @param {bool} repeat
 */
ROT.Scheduler.prototype.add = function(item, repeat) {
	if (repeat) { this._repeat.push(item); }
	return this;
}

/**
 * Clear all items
 */
ROT.Scheduler.prototype.clear = function() {
	this._queue.clear();
	this._repeat = [];
	this._current = null;
	return this;
}

/**
 * Remove a previously added item
 * @param {?} item
 * @returns {bool} successful?
 */
ROT.Scheduler.prototype.remove = function(item) {
	var result = this._queue.remove(item);

	var index = this._repeat.indexOf(item);
	if (index != -1) { this._repeat.splice(index, 1); }

	if (this._current == item) { this._current = null; }

	return result;
}

/**
 * Schedule next item
 * @returns {?}
 */
ROT.Scheduler.prototype.next = function() {
	this._current = this._queue.get();
	return this._current;
}
/**
 * @class Simple fair scheduler (round-robin style)
 * @augments ROT.Scheduler
 */
ROT.Scheduler.Simple = function() {
	ROT.Scheduler.call(this);
}
ROT.Scheduler.Simple.extend(ROT.Scheduler);

/**
 * @see ROT.Scheduler#add
 */
ROT.Scheduler.Simple.prototype.add = function(item, repeat) {
	this._queue.add(item, 0);
	return ROT.Scheduler.prototype.add.call(this, item, repeat);
}

/**
 * @see ROT.Scheduler#next
 */
ROT.Scheduler.Simple.prototype.next = function() {
	if (this._current && this._repeat.indexOf(this._current) != -1) {
		this._queue.add(this._current, 0);
	}
	return ROT.Scheduler.prototype.next.call(this);
}
/**
 * @class Speed-based scheduler
 * @augments ROT.Scheduler
 */
ROT.Scheduler.Speed = function() {
	ROT.Scheduler.call(this);
}
ROT.Scheduler.Speed.extend(ROT.Scheduler);

/**
 * @param {object} item anything with "getSpeed" method
 * @param {bool} repeat
 * @see ROT.Scheduler#add
 */
ROT.Scheduler.Speed.prototype.add = function(item, repeat) {
	this._queue.add(item, 1/item.getSpeed());
	return ROT.Scheduler.prototype.add.call(this, item, repeat);
}

/**
 * @see ROT.Scheduler#next
 */
ROT.Scheduler.Speed.prototype.next = function() {
	if (this._current && this._repeat.indexOf(this._current) != -1) {
		this._queue.add(this._current, 1/this._current.getSpeed());
	}
	return ROT.Scheduler.prototype.next.call(this);
}
/**
 * @class Action-based scheduler
 * @augments ROT.Scheduler
 */
ROT.Scheduler.Action = function() {
	ROT.Scheduler.call(this);
	this._defaultDuration = 1; /* for newly added */
	this._duration = this._defaultDuration; /* for this._current */
}
ROT.Scheduler.Action.extend(ROT.Scheduler);

/**
 * @param {object} item
 * @param {bool} repeat
 * @param {number} [time=1]
 * @see ROT.Scheduler#add
 */
ROT.Scheduler.Action.prototype.add = function(item, repeat, time) {
	this._queue.add(item, time || this._defaultDuration);
	return ROT.Scheduler.prototype.add.call(this, item, repeat);
}

ROT.Scheduler.Action.prototype.clear = function() {
	this._duration = this._defaultDuration;
	return ROT.Scheduler.prototype.clear.call(this);
}

ROT.Scheduler.Action.prototype.remove = function(item) {
	if (item == this._current) { this._duration = this._defaultDuration; }
	return ROT.Scheduler.prototype.remove.call(this, item);
}

/**
 * @see ROT.Scheduler#next
 */
ROT.Scheduler.Action.prototype.next = function() {
	if (this._current && this._repeat.indexOf(this._current) != -1) {
		this._queue.add(this._current, this._duration || this._defaultDuration);
		this._duration = this._defaultDuration;
	}
	return ROT.Scheduler.prototype.next.call(this);
}

/**
 * Set duration for the active item
 */
ROT.Scheduler.Action.prototype.setDuration = function(time) {
	if (this._current) { this._duration = time; }
	return this;
}
/**
 * @class Asynchronous main loop
 * @param {ROT.Scheduler} scheduler
 */
ROT.Engine = function(scheduler) {
	this._scheduler = scheduler;
	this._lock = 1;
}

/**
 * Start the main loop. When this call returns, the loop is locked.
 */
ROT.Engine.prototype.start = function() {
	return this.unlock();
}

/**
 * Interrupt the engine by an asynchronous action
 */
ROT.Engine.prototype.lock = function() {
	this._lock++;
	return this;
}

/**
 * Resume execution (paused by a previous lock)
 */
ROT.Engine.prototype.unlock = function() {
	if (!this._lock) { throw new Error("Cannot unlock unlocked engine"); }
	this._lock--;

	while (!this._lock) {
		var actor = this._scheduler.next();
		if (!actor) { return this.lock(); } /* no actors */
		var result = actor.act();
		if (result && result.then) { /* actor returned a "thenable", looks like a Promise */
			this.lock();
			result.then(this.unlock.bind(this));
		}
	}

	return this;
}
/**
 * @class Base map generator
 * @param {int} [width=ROT.DEFAULT_WIDTH]
 * @param {int} [height=ROT.DEFAULT_HEIGHT]
 */
ROT.Map = function(width, height) {
	this._width = width || ROT.DEFAULT_WIDTH;
	this._height = height || ROT.DEFAULT_HEIGHT;
};

ROT.Map.prototype.create = function(callback) {}

ROT.Map.prototype._fillMap = function(value) {
	var map = [];
	for (var i=0;i<this._width;i++) {
		map.push([]);
		for (var j=0;j<this._height;j++) { map[i].push(value); }
	}
	return map;
}
/**
 * @class Simple empty rectangular room
 * @augments ROT.Map
 */
ROT.Map.Arena = function(width, height) {
	ROT.Map.call(this, width, height);
}
ROT.Map.Arena.extend(ROT.Map);

ROT.Map.Arena.prototype.create = function(callback) {
	var w = this._width-1;
	var h = this._height-1;
	for (var i=0;i<=w;i++) {
		for (var j=0;j<=h;j++) {
			var empty = (i && j && i<w && j<h);
			callback(i, j, empty ? 0 : 1);
		}
	}
	return this;
}
/**
 * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method
 * @augments ROT.Map
 */
ROT.Map.DividedMaze = function(width, height) {
	ROT.Map.call(this, width, height);
	this._stack = [];
}
ROT.Map.DividedMaze.extend(ROT.Map);

ROT.Map.DividedMaze.prototype.create = function(callback) {
	var w = this._width;
	var h = this._height;
	
	this._map = [];
	
	for (var i=0;i<w;i++) {
		this._map.push([]);
		for (var j=0;j<h;j++) {
			var border = (i == 0 || j == 0 || i+1 == w || j+1 == h);
			this._map[i].push(border ? 1 : 0);
		}
	}
	
	this._stack = [
		[1, 1, w-2, h-2]
	];
	this._process();
	
	for (var i=0;i<w;i++) {
		for (var j=0;j<h;j++) {
			callback(i, j, this._map[i][j]);
		}
	}
	this._map = null;
	return this;
}

ROT.Map.DividedMaze.prototype._process = function() {
	while (this._stack.length) {
		var room = this._stack.shift(); /* [left, top, right, bottom] */
		this._partitionRoom(room);
	}
}

ROT.Map.DividedMaze.prototype._partitionRoom = function(room) {
	var availX = [];
	var availY = [];
	
	for (var i=room[0]+1;i<room[2];i++) {
		var top = this._map[i][room[1]-1];
		var bottom = this._map[i][room[3]+1];
		if (top && bottom && !(i % 2)) { availX.push(i); }
	}
	
	for (var j=room[1]+1;j<room[3];j++) {
		var left = this._map[room[0]-1][j];
		var right = this._map[room[2]+1][j];
		if (left && right && !(j % 2)) { availY.push(j); }
	}

	if (!availX.length || !availY.length) { return; }

	var x = availX.random();
	var y = availY.random();
	
	this._map[x][y] = 1;
	
	var walls = [];
	
	var w = []; walls.push(w); /* left part */
	for (var i=room[0]; i<x; i++) { 
		this._map[i][y] = 1;
		w.push([i, y]); 
	}
	
	var w = []; walls.push(w); /* right part */
	for (var i=x+1; i<=room[2]; i++) { 
		this._map[i][y] = 1;
		w.push([i, y]); 
	}

	var w = []; walls.push(w); /* top part */
	for (var j=room[1]; j<y; j++) { 
		this._map[x][j] = 1;
		w.push([x, j]); 
	}
	
	var w = []; walls.push(w); /* bottom part */
	for (var j=y+1; j<=room[3]; j++) { 
		this._map[x][j] = 1;
		w.push([x, j]); 
	}
		
	var solid = walls.random();
	for (var i=0;i<walls.length;i++) {
		var w = walls[i];
		if (w == solid) { continue; }
		
		var hole = w.random();
		this._map[hole[0]][hole[1]] = 0;
	}

	this._stack.push([room[0], room[1], x-1, y-1]); /* left top */
	this._stack.push([x+1, room[1], room[2], y-1]); /* right top */
	this._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */
	this._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */
}
/**
 * @class Icey's Maze generator
 * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation
 * @augments ROT.Map
 */
ROT.Map.IceyMaze = function(width, height, regularity) {
	ROT.Map.call(this, width, height);
	this._regularity = regularity || 0;
}
ROT.Map.IceyMaze.extend(ROT.Map);

ROT.Map.IceyMaze.prototype.create = function(callback) {
	var width = this._width;
	var height = this._height;
	
	var map = this._fillMap(1);
	
	width -= (width % 2 ? 1 : 2);
	height -= (height % 2 ? 1 : 2);

	var cx = 0;
	var cy = 0;
	var nx = 0;
	var ny = 0;

	var done = 0;
	var blocked = false;
	var dirs = [
		[0, 0],
		[0, 0],
		[0, 0],
		[0, 0]
	];
	do {
		cx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);
		cy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);

		if (!done) { map[cx][cy] = 0; }
		
		if (!map[cx][cy]) {
			this._randomize(dirs);
			do {
				if (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }
				blocked = true;
				for (var i=0;i<4;i++) {
					nx = cx + dirs[i][0]*2;
					ny = cy + dirs[i][1]*2;
					if (this._isFree(map, nx, ny, width, height)) {
						map[nx][ny] = 0;
						map[cx + dirs[i][0]][cy + dirs[i][1]] = 0;
						
						cx = nx;
						cy = ny;
						blocked = false;
						done++;
						break;
					}
				}
			} while (!blocked);
		}
	} while (done+1 < width*height/4);
	
	for (var i=0;i<this._width;i++) {
		for (var j=0;j<this._height;j++) {
			callback(i, j, map[i][j]);
		}
	}
	this._map = null;
	return this;
}

ROT.Map.IceyMaze.prototype._randomize = function(dirs) {
	for (var i=0;i<4;i++) {
		dirs[i][0] = 0;
		dirs[i][1] = 0;
	}
	
	switch (Math.floor(ROT.RNG.getUniform()*4)) {
		case 0:
			dirs[0][0] = -1; dirs[1][0] = 1;
			dirs[2][1] = -1; dirs[3][1] = 1;
		break;
		case 1:
			dirs[3][0] = -1; dirs[2][0] = 1;
			dirs[1][1] = -1; dirs[0][1] = 1;
		break;
		case 2:
			dirs[2][0] = -1; dirs[3][0] = 1;
			dirs[0][1] = -1; dirs[1][1] = 1;
		break;
		case 3:
			dirs[1][0] = -1; dirs[0][0] = 1;
			dirs[3][1] = -1; dirs[2][1] = 1;
		break;
	}
}

ROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {
	if (x < 1 || y < 1 || x >= width || y >= height) { return false; }
	return map[x][y];
}
/**
 * @class Maze generator - Eller's algorithm
 * See http://homepages.cwi.nl/~tromp/maze.html for explanation
 * @augments ROT.Map
 */
ROT.Map.EllerMaze = function(width, height) {
	ROT.Map.call(this, width, height);
}
ROT.Map.EllerMaze.extend(ROT.Map);

ROT.Map.EllerMaze.prototype.create = function(callback) {
	var map = this._fillMap(1);
	var w = Math.ceil((this._width-2)/2);
	
	var rand = 9/24;
	
	var L = [];
	var R = [];
	
	for (var i=0;i<w;i++) {
		L.push(i);
		R.push(i);
	}
	L.push(w-1); /* fake stop-block at the right side */

	for (var j=1;j+3<this._height;j+=2) {
		/* one row */
		for (var i=0;i<w;i++) {
			/* cell coords (will be always empty) */
			var x = 2*i+1;
			var y = j;
			map[x][y] = 0;
			
			/* right connection */
			if (i != L[i+1] && ROT.RNG.getUniform() > rand) {
				this._addToList(i, L, R);
				map[x+1][y] = 0;
			}
			
			/* bottom connection */
			if (i != L[i] && ROT.RNG.getUniform() > rand) {
				/* remove connection */
				this._removeFromList(i, L, R);
			} else {
				/* create connection */
				map[x][y+1] = 0;
			}
		}
	}

	/* last row */
	for (var i=0;i<w;i++) {
		/* cell coords (will be always empty) */
		var x = 2*i+1;
		var y = j;
		map[x][y] = 0;
		
		/* right connection */
		if (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {
			/* dig right also if the cell is separated, so it gets connected to the rest of maze */
			this._addToList(i, L, R);
			map[x+1][y] = 0;
		}
		
		this._removeFromList(i, L, R);
	}
	
	for (var i=0;i<this._width;i++) {
		for (var j=0;j<this._height;j++) {
			callback(i, j, map[i][j]);
		}
	}
	
	return this;
}

/**
 * Remove "i" from its list
 */
ROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {
	R[L[i]] = R[i];
	L[R[i]] = L[i];
	R[i] = i;
	L[i] = i;
}

/**
 * Join lists with "i" and "i+1"
 */
ROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {
	R[L[i+1]] = R[i];
	L[R[i]] = L[i+1];
	R[i] = i+1;
	L[i+1] = i;
}
/**
 * @class Cellular automaton map generator
 * @augments ROT.Map
 * @param {int} [width=ROT.DEFAULT_WIDTH]
 * @param {int} [height=ROT.DEFAULT_HEIGHT]
 * @param {object} [options] Options
 * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space
 * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive
 * @param {int} [options.topology] Topology 4 or 6 or 8
 */
ROT.Map.Cellular = function(width, height, options) {
	ROT.Map.call(this, width, height);
	this._options = {
		born: [5, 6, 7, 8],
		survive: [4, 5, 6, 7, 8],
		topology: 8,
		connected: false
	};
	this.setOptions(options);
	
	this._dirs = ROT.DIRS[this._options.topology];
	this._map = this._fillMap(0);
}
ROT.Map.Cellular.extend(ROT.Map);

/**
 * Fill the map with random values
 * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full
 */
ROT.Map.Cellular.prototype.randomize = function(probability) {
	for (var i=0;i<this._width;i++) {
		for (var j=0;j<this._height;j++) {
			this._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);
		}
	}
	return this;
}

/**
 * Change options.
 * @see ROT.Map.Cellular
 */
ROT.Map.Cellular.prototype.setOptions = function(options) {
	for (var p in options) { this._options[p] = options[p]; }
}

ROT.Map.Cellular.prototype.set = function(x, y, value) {
	this._map[x][y] = value;
}

ROT.Map.Cellular.prototype.create = function(callback) {
	var newMap = this._fillMap(0);
	var born = this._options.born;
	var survive = this._options.survive;


	for (var j=0;j<this._height;j++) {
		var widthStep = 1;
		var widthStart = 0;
		if (this._options.topology == 6) { 
			widthStep = 2;
			widthStart = j%2;
		}

		for (var i=widthStart; i<this._width; i+=widthStep) {

			var cur = this._map[i][j];
			var ncount = this._getNeighbors(i, j);
			
			if (cur && survive.indexOf(ncount) != -1) { /* survive */
				newMap[i][j] = 1;
			} else if (!cur && born.indexOf(ncount) != -1) { /* born */
				newMap[i][j] = 1;
			}			
		}
	}
	
	this._map = newMap;

	// optinially connect every space
	if (this._options.connected) {
		this._completeMaze();	
	}

	if (callback) { 
		for (var i = 0; i < this._width; i++) {
			for (var j = 0; j < this._height; j++) {
				callback(i, j, newMap[i][j]);
			}
		}
	}
}

/**
 * Get neighbor count at [i,j] in this._map
 */
ROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {
	var result = 0;
	for (var i=0;i<this._dirs.length;i++) {
		var dir = this._dirs[i];
		var x = cx + dir[0];
		var y = cy + dir[1];
		
		if (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }
		result += (this._map[x][y] == 1 ? 1 : 0);
	}
	
	return result;
}

/**
 * Make sure every non-wall space is accessible.
 */
ROT.Map.Cellular.prototype._completeMaze = function() {
	var allFreeSpace = [];
	var notConnected = {};
	// find all free space
	for (var x = 0; x < this._width; x++) {
		for (var y = 0; y < this._height; y++) {
			if (this._freeSpace(x, y)) {
				var p = [x, y];
				notConnected[this._pointKey(p)] = p;
				allFreeSpace.push([x, y]);
			}
		}
	}
	var start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];

	var key = this._pointKey(start);
	var connected = {};
	connected[key] = start;
	delete notConnected[key]

	// find what's connected to the starting point
	this._findConnected(connected, notConnected, [start]);

	while(Object.keys(notConnected).length > 0) {

		// find two points from notConnected to connected
		var p = this._getFromTo(connected, notConnected);
		var from = p[0]; // notConnected
		var to = p[1]; // connected

		// find everything connected to the starting point
		var local = {};
		local[this._pointKey(from)] = from;
		this._findConnected(local, notConnected, [from], true);

		// connect to a connected square
		this._tunnelToConnected(to, from, connected, notConnected);

		// now all of local is connected
		for (var k in local) {
			var pp = local[k];
			this._map[pp[0]][pp[1]] = 0;
			connected[k] = pp;
			delete notConnected[k];
		}
	}
}

/**
 * Find random points to connect. Search for the closest point in the larger space. 
 * This is to minimize the length of the passage while maintaining good performance.
 */
ROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {
	var from, to, d;
	var connectedKeys = Object.keys(connected);
	var notConnectedKeys = Object.keys(notConnected);
	for (var i = 0; i < 5; i++) {
		if (connectedKeys.length < notConnectedKeys.length) {
			var keys = connectedKeys;
			to = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]
			from = this._getClosest(to, notConnected);
		} else {
			var keys = notConnectedKeys;
			from = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]
			to = this._getClosest(from, connected);
		}
		d = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);
		if (d < 64) {
			break;
		}
	}
	// console.log(">>> connected=" + to + " notConnected=" + from + " dist=" + d);
	return [from, to];
}

ROT.Map.Cellular.prototype._getClosest = function(point, space) {
	var minPoint = null;
	var minDist = null;
	for (k in space) {
		var p = space[k];
		var d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);
		if (minDist == null || d < minDist) {
			minDist = d;
			minPoint = p;
		}
	}
	return minPoint;
}

ROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {
	while(stack.length > 0) {
		var p = stack.splice(0, 1)[0];
		var tests = [
			[p[0] + 1, p[1]],
			[p[0] - 1, p[1]],
			[p[0],     p[1] + 1],
			[p[0],     p[1] - 1]
		];
		for (var i = 0; i < tests.length; i++) {
			var key = this._pointKey(tests[i]);
			if (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {
				connected[key] = tests[i];
				if (!keepNotConnected) {
					delete notConnected[key];
				}
				stack.push(tests[i]);
			}
		}
	}
}

ROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {
	var key = this._pointKey(from);
	var a, b;
	if (from[0] < to[0]) {
		a = from;
		b = to;
	} else {
		a = to;
		b = from;
	}
	for (var xx = a[0]; xx <= b[0]; xx++) {
		this._map[xx][a[1]] = 0;
		var p = [xx, a[1]];
		var pkey = this._pointKey(p);
		connected[pkey] = p;
		delete notConnected[pkey];
	}

	// x is now fixed
	var x = b[0];

	if (from[1] < to[1]) {
		a = from;
		b = to;
	} else {
		a = to;
		b = from;
	}
	for (var yy = a[1]; yy < b[1]; yy++) {
		this._map[x][yy] = 0;
		var p = [x, yy];
		var pkey = this._pointKey(p);
		connected[pkey] = p;
		delete notConnected[pkey];
	}
}

ROT.Map.Cellular.prototype._freeSpace = function(x, y) {
	return x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;
}

ROT.Map.Cellular.prototype._pointKey = function(p) {
	return p[0] + "." + p[1];
}

/**
 * @class Dungeon map: has rooms and corridors
 * @augments ROT.Map
 */
ROT.Map.Dungeon = function(width, height) {
	ROT.Map.call(this, width, height);
	this._rooms = []; /* list of all rooms */
	this._corridors = [];
}
ROT.Map.Dungeon.extend(ROT.Map);

/**
 * Get all generated rooms
 * @returns {ROT.Map.Feature.Room[]}
 */
ROT.Map.Dungeon.prototype.getRooms = function() {
	return this._rooms;
}

/**
 * Get all generated corridors
 * @returns {ROT.Map.Feature.Corridor[]}
 */
ROT.Map.Dungeon.prototype.getCorridors = function() {
	return this._corridors;
}
/**
 * @class Random dungeon generator using human-like digging patterns.
 * Heavily based on Mike Anderson's ideas from the "Tyrant" algo, mentioned at 
 * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.
 * @augments ROT.Map.Dungeon
 */
ROT.Map.Digger = function(width, height, options) {
	ROT.Map.Dungeon.call(this, width, height);
	
	this._options = {
		roomWidth: [3, 9], /* room minimum and maximum width */
		roomHeight: [3, 5], /* room minimum and maximum height */
		corridorLength: [3, 10], /* corridor minimum and maximum length */
		dugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */
		timeLimit: 1000 /* we stop after this much time has passed (msec) */
	}
	for (var p in options) { this._options[p] = options[p]; }
	
	this._features = {
		"Room": 4,
		"Corridor": 4
	}
	this._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */
	this._walls = {}; /* these are available for digging */
	
	this._digCallback = this._digCallback.bind(this);
	this._canBeDugCallback = this._canBeDugCallback.bind(this);
	this._isWallCallback = this._isWallCallback.bind(this);
	this._priorityWallCallback = this._priorityWallCallback.bind(this);
}
ROT.Map.Digger.extend(ROT.Map.Dungeon);

/**
 * Create a map
 * @see ROT.Map#create
 */
ROT.Map.Digger.prototype.create = function(callback) {
	this._rooms = [];
	this._corridors = [];
	this._map = this._fillMap(1);
	this._walls = {};
	this._dug = 0;
	var area = (this._width-2) * (this._height-2);

	this._firstRoom();
	
	var t1 = Date.now();

	do {
		var t2 = Date.now();
		if (t2 - t1 > this._options.timeLimit) { break; }

		/* find a good wall */
		var wall = this._findWall();
		if (!wall) { break; } /* no more walls */
		
		var parts = wall.split(",");
		var x = parseInt(parts[0]);
		var y = parseInt(parts[1]);
		var dir = this._getDiggingDirection(x, y);
		if (!dir) { continue; } /* this wall is not suitable */
		
//		console.log("wall", x, y);

		/* try adding a feature */
		var featureAttempts = 0;
		do {
			featureAttempts++;
			if (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */
				//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */
				this._removeSurroundingWalls(x, y);
				this._removeSurroundingWalls(x-dir[0], y-dir[1]);
				break; 
			}
		} while (featureAttempts < this._featureAttempts);
		
		var priorityWalls = 0;
		for (var id in this._walls) { 
			if (this._walls[id] > 1) { priorityWalls++; }
		}

	} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */

	this._addDoors();

	if (callback) {
		for (var i=0;i<this._width;i++) {
			for (var j=0;j<this._height;j++) {
				callback(i, j, this._map[i][j]);
			}
		}
	}
	
	this._walls = {};
	this._map = null;

	return this;
}

ROT.Map.Digger.prototype._digCallback = function(x, y, value) {
	if (value == 0 || value == 2) { /* empty */
		this._map[x][y] = 0;
		this._dug++;
	} else { /* wall */
		this._walls[x+","+y] = 1;
	}
}

ROT.Map.Digger.prototype._isWallCallback = function(x, y) {
	if (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }
	return (this._map[x][y] == 1);
}

ROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {
	if (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }
	return (this._map[x][y] == 1);
}

ROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {
	this._walls[x+","+y] = 2;
}

ROT.Map.Digger.prototype._firstRoom = function() {
	var cx = Math.floor(this._width/2);
	var cy = Math.floor(this._height/2);
	var room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);
	this._rooms.push(room);
	room.create(this._digCallback);
}

/**
 * Get a suitable wall
 */
ROT.Map.Digger.prototype._findWall = function() {
	var prio1 = [];
	var prio2 = [];
	for (var id in this._walls) {
		var prio = this._walls[id];
		if (prio == 2) { 
			prio2.push(id); 
		} else {
			prio1.push(id);
		}
	}
	
	var arr = (prio2.length ? prio2 : prio1);
	if (!arr.length) { return null; } /* no walls :/ */
	
	var id = arr.random();
	delete this._walls[id];

	return id;
}

/**
 * Tries adding a feature
 * @returns {bool} was this a successful try?
 */
ROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {
	var feature = ROT.RNG.getWeightedValue(this._features);
	feature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);
	
	if (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {
//		console.log("not valid");
//		feature.debug();
		return false;
	}
	
	feature.create(this._digCallback);
//	feature.debug();

	if (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }
	if (feature instanceof ROT.Map.Feature.Corridor) { 
		feature.createPriorityWalls(this._priorityWallCallback);
		this._corridors.push(feature); 
	}
	
	return true;
}

ROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {
	var deltas = ROT.DIRS[4];

	for (var i=0;i<deltas.length;i++) {
		var delta = deltas[i];
		var x = cx + delta[0];
		var y = cy + delta[1];
		delete this._walls[x+","+y];
		var x = cx + 2*delta[0];
		var y = cy + 2*delta[1];
		delete this._walls[x+","+y];
	}
}

/**
 * Returns vector in "digging" direction, or false, if this does not exist (or is not unique)
 */
ROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {
	var result = null;
	var deltas = ROT.DIRS[4];
	
	for (var i=0;i<deltas.length;i++) {
		var delta = deltas[i];
		var x = cx + delta[0];
		var y = cy + delta[1];
		
		if (x < 0 || y < 0 || x >= this._width || y >= this._width) { return null; }
		
		if (!this._map[x][y]) { /* there already is another empty neighbor! */
			if (result) { return null; }
			result = delta;
		}
	}
	
	/* no empty neighbor */
	if (!result) { return null; }
	
	return [-result[0], -result[1]];
}

/**
 * Find empty spaces surrounding rooms, and apply doors.
 */
ROT.Map.Digger.prototype._addDoors = function() {
	var data = this._map;
	var isWallCallback = function(x, y) {
		return (data[x][y] == 1);
	}
	for (var i = 0; i < this._rooms.length; i++ ) {
		var room = this._rooms[i];
		room.clearDoors();
		room.addDoors(isWallCallback);
	}
}
/**
 * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.
 * @augments ROT.Map.Dungeon
 */
ROT.Map.Uniform = function(width, height, options) {
	ROT.Map.Dungeon.call(this, width, height);

	this._options = {
		roomWidth: [3, 9], /* room minimum and maximum width */
		roomHeight: [3, 5], /* room minimum and maximum height */
		roomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */
		timeLimit: 1000 /* we stop after this much time has passed (msec) */
	}
	for (var p in options) { this._options[p] = options[p]; }

	this._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */
	this._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */

	this._connected = []; /* list of already connected rooms */
	this._unconnected = []; /* list of remaining unconnected rooms */
	
	this._digCallback = this._digCallback.bind(this);
	this._canBeDugCallback = this._canBeDugCallback.bind(this);
	this._isWallCallback = this._isWallCallback.bind(this);
}
ROT.Map.Uniform.extend(ROT.Map.Dungeon);

/**
 * Create a map. If the time limit has been hit, returns null.
 * @see ROT.Map#create
 */
ROT.Map.Uniform.prototype.create = function(callback) {
	var t1 = Date.now();
	while (1) {
		var t2 = Date.now();
		if (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */
	
		this._map = this._fillMap(1);
		this._dug = 0;
		this._rooms = [];
		this._unconnected = [];
		this._generateRooms();
		if (this._rooms.length < 2) { continue; }
		if (this._generateCorridors()) { break; }
	}
	
	if (callback) {
		for (var i=0;i<this._width;i++) {
			for (var j=0;j<this._height;j++) {
				callback(i, j, this._map[i][j]);
			}
		}
	}
	
	return this;
}

/**
 * Generates a suitable amount of rooms
 */
ROT.Map.Uniform.prototype._generateRooms = function() {
	var w = this._width-2;
	var h = this._height-2;

	do {
		var room = this._generateRoom();
		if (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */
	} while (room);

	/* either enough rooms, or not able to generate more of them :) */
}

/**
 * Try to generate one room
 */
ROT.Map.Uniform.prototype._generateRoom = function() {
	var count = 0;
	while (count < this._roomAttempts) {
		count++;
		
		var room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);
		if (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }
		
		room.create(this._digCallback);
		this._rooms.push(room);
		return room;
	} 

	/* no room was generated in a given number of attempts */
	return null;
}

/**
 * Generates connectors beween rooms
 * @returns {bool} success Was this attempt successfull?
 */
ROT.Map.Uniform.prototype._generateCorridors = function() {
	var cnt = 0;
	while (cnt < this._corridorAttempts) {
		cnt++;
		this._corridors = [];

		/* dig rooms into a clear map */
		this._map = this._fillMap(1);
		for (var i=0;i<this._rooms.length;i++) { 
			var room = this._rooms[i];
			room.clearDoors();
			room.create(this._digCallback); 
		}

		this._unconnected = this._rooms.slice().randomize();
		this._connected = [];
		if (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */
		
		while (1) {
			/* 1. pick random connected room */
			var connected = this._connected.random();
			
			/* 2. find closest unconnected */
			var room1 = this._closestRoom(this._unconnected, connected);
			
			/* 3. connect it to closest connected */
			var room2 = this._closestRoom(this._connected, room1);
			
			var ok = this._connectRooms(room1, room2);
			if (!ok) { break; } /* stop connecting, re-shuffle */
			
			if (!this._unconnected.length) { return true; } /* done; no rooms remain */
		}
	}
	return false;
}

/**
 * For a given room, find the closest one from the list
 */
ROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {
	var dist = Infinity;
	var center = room.getCenter();
	var result = null;
	
	for (var i=0;i<rooms.length;i++) {
		var r = rooms[i];
		var c = r.getCenter();
		var dx = c[0]-center[0];
		var dy = c[1]-center[1];
		var d = dx*dx+dy*dy;
		
		if (d < dist) {
			dist = d;
			result = r;
		}
	}
	
	return result;
}

ROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {
	/*
		room1.debug();
		room2.debug();
	*/

	var center1 = room1.getCenter();
	var center2 = room2.getCenter();

	var diffX = center2[0] - center1[0];
	var diffY = center2[1] - center1[1];

	if (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */
		var dirIndex1 = (diffY > 0 ? 2 : 0);
		var dirIndex2 = (dirIndex1 + 2) % 4;
		var min = room2.getLeft();
		var max = room2.getRight();
		var index = 0;
	} else { /* first try connecting east-west walls */
		var dirIndex1 = (diffX > 0 ? 1 : 3);
		var dirIndex2 = (dirIndex1 + 2) % 4;
		var min = room2.getTop();
		var max = room2.getBottom();
		var index = 1;
	}

	var start = this._placeInWall(room1, dirIndex1); /* corridor will start here */
	if (!start) { return false; }

	if (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */
		var end = start.slice();
		var value = null;
		switch (dirIndex2) {
			case 0: value = room2.getTop()-1; break;
			case 1: value = room2.getRight()+1; break;
			case 2: value = room2.getBottom()+1; break;
			case 3: value = room2.getLeft()-1; break;
		}
		end[(index+1)%2] = value;
		this._digLine([start, end]);
		
	} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */

		var diff = start[index] - center2[index];
		switch (dirIndex2) {
			case 0:
			case 1:	var rotation = (diff < 0 ? 3 : 1); break;
			case 2:
			case 3:	var rotation = (diff < 0 ? 1 : 3); break;
		}
		dirIndex2 = (dirIndex2 + rotation) % 4;
		
		var end = this._placeInWall(room2, dirIndex2);
		if (!end) { return false; }

		var mid = [0, 0];
		mid[index] = start[index];
		var index2 = (index+1)%2;
		mid[index2] = end[index2];
		this._digLine([start, mid, end]);
		
	} else { /* use current wall pair, but adjust the line in the middle (S-like) */
	
		var index2 = (index+1)%2;
		var end = this._placeInWall(room2, dirIndex2);
		if (!end) { return; }
		var mid = Math.round((end[index2] + start[index2])/2);

		var mid1 = [0, 0];
		var mid2 = [0, 0];
		mid1[index] = start[index];
		mid1[index2] = mid;
		mid2[index] = end[index];
		mid2[index2] = mid;
		this._digLine([start, mid1, mid2, end]);
	}

	room1.addDoor(start[0], start[1]);
	room2.addDoor(end[0], end[1]);
	
	var index = this._unconnected.indexOf(room1);
	if (index != -1) {
		this._unconnected.splice(index, 1);
		this._connected.push(room1);
	}

	var index = this._unconnected.indexOf(room2);
	if (index != -1) {
		this._unconnected.splice(index, 1);
		this._connected.push(room2);
	}
	
	return true;
}

ROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {
	var start = [0, 0];
	var dir = [0, 0];
	var length = 0;
	
	switch (dirIndex) {
		case 0:
			dir = [1, 0];
			start = [room.getLeft(), room.getTop()-1];
			length = room.getRight()-room.getLeft()+1;
		break;
		case 1:
			dir = [0, 1];
			start = [room.getRight()+1, room.getTop()];
			length = room.getBottom()-room.getTop()+1;
		break;
		case 2:
			dir = [1, 0];
			start = [room.getLeft(), room.getBottom()+1];
			length = room.getRight()-room.getLeft()+1;
		break;
		case 3:
			dir = [0, 1];
			start = [room.getLeft()-1, room.getTop()];
			length = room.getBottom()-room.getTop()+1;
		break;
	}
	
	var avail = [];
	var lastBadIndex = -2;

	for (var i=0;i<length;i++) {
		var x = start[0] + i*dir[0];
		var y = start[1] + i*dir[1];
		avail.push(null);
		
		var isWall = (this._map[x][y] == 1);
		if (isWall) {
			if (lastBadIndex != i-1) { avail[i] = [x, y]; }
		} else {
			lastBadIndex = i;
			if (i) { avail[i-1] = null; }
		}
	}
	
	for (var i=avail.length-1; i>=0; i--) {
		if (!avail[i]) { avail.splice(i, 1); }
	}
	return (avail.length ? avail.random() : null);
}

/**
 * Dig a polyline.
 */
ROT.Map.Uniform.prototype._digLine = function(points) {
	for (var i=1;i<points.length;i++) {
		var start = points[i-1];
		var end = points[i];
		var corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);
		corridor.create(this._digCallback);
		this._corridors.push(corridor);
	}
}

ROT.Map.Uniform.prototype._digCallback = function(x, y, value) {
	this._map[x][y] = value;
	if (value == 0) { this._dug++; }
}

ROT.Map.Uniform.prototype._isWallCallback = function(x, y) {
	if (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }
	return (this._map[x][y] == 1);
}

ROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {
	if (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }
	return (this._map[x][y] == 1);
}

/**
 * @author hyakugei
 * @class Dungeon generator which uses the "orginal" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php
 * @augments ROT.Map
 * @param {int} [width=ROT.DEFAULT_WIDTH]
 * @param {int} [height=ROT.DEFAULT_HEIGHT]
 * @param {object} [options] Options
 * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)
 * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) 
 * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.
 * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. 
 */
ROT.Map.Rogue = function(width, height, options) {
	ROT.Map.call(this, width, height);
	
	this._options = {
		cellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values
		cellHeight: 3  //     ie. as an array with min-max values for each direction....
	}
	
	for (var p in options) { this._options[p] = options[p]; }
	
	/*
	Set the room sizes according to the over-all width of the map, 
	and the cell sizes. 
	*/
	
	if (!this._options.hasOwnProperty("roomWidth")) {
		this._options["roomWidth"] = this._calculateRoomSize(this._width, this._options["cellWidth"]);
	}
	if (!this._options.hasOwnProperty["roomHeight"]) {
		this._options["roomHeight"] = this._calculateRoomSize(this._height, this._options["cellHeight"]);
	}
	
}

ROT.Map.Rogue.extend(ROT.Map); 

/**
 * @see ROT.Map#create
 */
ROT.Map.Rogue.prototype.create = function(callback) {
	this.map = this._fillMap(1);
	this.rooms = [];
	this.connectedCells = [];
	
	this._initRooms();
	this._connectRooms();
	this._connectUnconnectedRooms();
	this._createRandomRoomConnections();
	this._createRooms();
	this._createCorridors();
	
	if (callback) {
		for (var i = 0; i < this._width; i++) {
			for (var j = 0; j < this._height; j++) {
				callback(i, j, this.map[i][j]);   
			}
		}
	}
	
	return this;
}

ROT.Map.Rogue.prototype._getRandomInt = function(min, max) {
	return Math.floor(ROT.RNG.getUniform() * (max - min + 1)) + min;
}

ROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {
	var max = Math.floor((size/cell) * 0.8);
	var min = Math.floor((size/cell) * 0.25);
	if (min < 2) min = 2;
	if (max < 2) max = 2;
	return [min, max];
}

ROT.Map.Rogue.prototype._initRooms = function () { 
	// create rooms array. This is the "grid" list from the algo.  
	for (var i = 0; i < this._options.cellWidth; i++) {  
		this.rooms.push([]);
		for(var j = 0; j < this._options.cellHeight; j++) {
			this.rooms[i].push({"x":0, "y":0, "width":0, "height":0, "connections":[], "cellx":i, "celly":j});
		}
	}
}

ROT.Map.Rogue.prototype._connectRooms = function() {
	//pick random starting grid
	var cgx = this._getRandomInt(0, this._options.cellWidth-1);
	var cgy = this._getRandomInt(0, this._options.cellHeight-1);
	
	var idx;
	var ncgx;
	var ncgy;
	
	var found = false;
	var room;
	var otherRoom;
	
	// find  unconnected neighbour cells
	do {
	
		//var dirToCheck = [0,1,2,3,4,5,6,7];
		var dirToCheck = [0,2,4,6];
		dirToCheck = dirToCheck.randomize();
		
		do {
			found = false;
			idx = dirToCheck.pop();
			
			
			ncgx = cgx + ROT.DIRS[8][idx][0];
			ncgy = cgy + ROT.DIRS[8][idx][1];
			
			if(ncgx < 0 || ncgx >= this._options.cellWidth) continue;
			if(ncgy < 0 || ncgy >= this._options.cellHeight) continue;
			
			room = this.rooms[cgx][cgy];
			
			if(room["connections"].length > 0)
			{
				// as long as this room doesn't already coonect to me, we are ok with it. 
				if(room["connections"][0][0] == ncgx &&
				room["connections"][0][1] == ncgy)
				{
					break;
				}
			}
			
			otherRoom = this.rooms[ncgx][ncgy];
			
			if (otherRoom["connections"].length == 0) { 
				otherRoom["connections"].push([cgx,cgy]);
				
				this.connectedCells.push([ncgx, ncgy]);
				cgx = ncgx;
				cgy = ncgy;
				found = true;
			}
					
		} while (dirToCheck.length > 0 && found == false)
		
	} while (dirToCheck.length > 0)

}

ROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {
	//While there are unconnected rooms, try to connect them to a random connected neighbor 
	//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).
	var cw = this._options.cellWidth;
	var ch = this._options.cellHeight;
	
	var randomConnectedCell;
	this.connectedCells = this.connectedCells.randomize();
	var room;
	var otherRoom;
	var validRoom;
	
	for (var i = 0; i < this._options.cellWidth; i++) {
		for (var j = 0; j < this._options.cellHeight; j++)  {
				
			room = this.rooms[i][j];
			
			if (room["connections"].length == 0) {
				var directions = [0,2,4,6];
				directions = directions.randomize();
				
				var validRoom = false;
				
				do {
					
					var dirIdx = directions.pop();
					var newI = i + ROT.DIRS[8][dirIdx][0];
					var newJ = j + ROT.DIRS[8][dirIdx][1];
					
					if (newI < 0 || newI >= cw || 
					newJ < 0 || newJ >= ch) {
						continue;
					}
					
					otherRoom = this.rooms[newI][newJ];
					
					validRoom = true;
					
					if (otherRoom["connections"].length == 0) {
						break;
					}
					
					for (var k = 0; k < otherRoom["connections"].length; k++) {
						if(otherRoom["connections"][k][0] == i && 
						otherRoom["connections"][k][1] == j) {
							validRoom = false;
							break;
						}
					}
					
					if (validRoom) break;
					
				} while (directions.length)
				
				if(validRoom) { 
					room["connections"].push( [otherRoom["cellx"], otherRoom["celly"]] );  
				} else {
					console.log("-- Unable to connect room.");
				}
			}
		}
	}
}

ROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {
	// Empty for now. 
}


ROT.Map.Rogue.prototype._createRooms = function() {
	// Create Rooms 
	
	var w = this._width;
	var h = this._height;
	
	var cw = this._options.cellWidth;
	var ch = this._options.cellHeight;
	
	var cwp = Math.floor(this._width / cw);
	var chp = Math.floor(this._height / ch);
	
	var roomw;
	var roomh;
	var roomWidth = this._options["roomWidth"];
	var roomHeight = this._options["roomHeight"];
	var sx;
	var sy;
	var tx;
	var ty;
	var otherRoom;
	
	for (var i = 0; i < cw; i++) {
		for (var j = 0; j < ch; j++) {
			sx = cwp * i;
			sy = chp * j;
			
			if (sx == 0) sx = 1;
			if (sy == 0) sy = 1;
			
			roomw = this._getRandomInt(roomWidth[0], roomWidth[1]);
			roomh = this._getRandomInt(roomHeight[0], roomHeight[1]);
			
			if (j > 0) {
				otherRoom = this.rooms[i][j-1];
				while (sy - (otherRoom["y"] + otherRoom["height"] ) < 3) {
					sy++;
				}
			}
			
			if (i > 0) {
				otherRoom = this.rooms[i-1][j];
				while(sx - (otherRoom["x"] + otherRoom["width"]) < 3) {
					sx++;
				}
			}
						
			var sxOffset = Math.round(this._getRandomInt(0, cwp-roomw)/2);
			var syOffset = Math.round(this._getRandomInt(0, chp-roomh)/2);
			
			while (sx + sxOffset + roomw >= w) {
				if(sxOffset) {
					sxOffset--;
				} else {
					roomw--; 
				}
			}
			
			while (sy + syOffset + roomh >= h) { 
				if(syOffset) {
					syOffset--;
				} else {
					roomh--; 
				}
			}
			
			sx = sx + sxOffset;
			sy = sy + syOffset;
			
			this.rooms[i][j]["x"] = sx;
			this.rooms[i][j]["y"] = sy;
			this.rooms[i][j]["width"] = roomw;
			this.rooms[i][j]["height"] = roomh;  
			
			for (var ii = sx; ii < sx + roomw; ii++) {
				for (var jj = sy; jj < sy + roomh; jj++) {
					this.map[ii][jj] = 0;
				}
			}  
		}
	}
}

ROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {
	var rx;
	var ry;
	var door;
	
	if (aDirection == 1 || aDirection == 3) {
		rx = this._getRandomInt(aRoom["x"] + 1, aRoom["x"] + aRoom["width"] - 2);
		if (aDirection == 1) {
			ry = aRoom["y"] - 2;
			door = ry + 1;
		} else {
			ry = aRoom["y"] + aRoom["height"] + 1;
			door = ry -1;
		}
		
		this.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. 
		
	} else if (aDirection == 2 || aDirection == 4) {
		ry = this._getRandomInt(aRoom["y"] + 1, aRoom["y"] + aRoom["height"] - 2);
		if(aDirection == 2) {
			rx = aRoom["x"] + aRoom["width"] + 1;
			door = rx - 1;
		} else {
			rx = aRoom["x"] - 2;
			door = rx + 1;
		}
		
		this.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. 
		
	}
	return [rx, ry];
}

/***
* @param startPosition a 2 element array
* @param endPosition a 2 element array
*/
ROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {
	var xOffset = endPosition[0] - startPosition[0];
	var yOffset = endPosition[1] - startPosition[1];
	
	var xpos = startPosition[0];
	var ypos = startPosition[1];
	
	var tempDist;
	var xDir;
	var yDir;
	
	var move; // 2 element array, element 0 is the direction, element 1 is the total value to move. 
	var moves = []; // a list of 2 element arrays
	
	var xAbs = Math.abs(xOffset);
	var yAbs = Math.abs(yOffset);
	
	var percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis
	var firstHalf = percent;
	var secondHalf = 1 - percent;
	
	xDir = xOffset > 0 ? 2 : 6;
	yDir = yOffset > 0 ? 4 : 0;
	
	if (xAbs < yAbs) {
		// move firstHalf of the y offset
		tempDist = Math.ceil(yAbs * firstHalf);
		moves.push([yDir, tempDist]);
		// move all the x offset
		moves.push([xDir, xAbs]);
		// move sendHalf of the  y offset
		tempDist = Math.floor(yAbs * secondHalf);
		moves.push([yDir, tempDist]);
	} else {
		//  move firstHalf of the x offset
		tempDist = Math.ceil(xAbs * firstHalf);
		moves.push([xDir, tempDist]);
		// move all the y offset
		moves.push([yDir, yAbs]);
		// move secondHalf of the x offset.
		tempDist = Math.floor(xAbs * secondHalf);
		moves.push([xDir, tempDist]);  
	}
	
	this.map[xpos][ypos] = 0;
	
	while (moves.length > 0) {
		move = moves.pop();
		while (move[1] > 0) {
			xpos += ROT.DIRS[8][move[0]][0];
			ypos += ROT.DIRS[8][move[0]][1];
			this.map[xpos][ypos] = 0;
			move[1] = move[1] - 1;
		}
	}
}

ROT.Map.Rogue.prototype._createCorridors = function () {
	// Draw Corridors between connected rooms
	
	var cw = this._options.cellWidth;
	var ch = this._options.cellHeight;
	var room;
	var connection;
	var otherRoom;
	var wall;
	var otherWall;
	
	for (var i = 0; i < cw; i++) {
		for (var j = 0; j < ch; j++) {
			room = this.rooms[i][j];
			
			for (var k = 0; k < room["connections"].length; k++) {
					
				connection = room["connections"][k]; 
				
				otherRoom = this.rooms[connection[0]][connection[1]];
				
				// figure out what wall our corridor will start one.
				// figure out what wall our corridor will end on. 
				if (otherRoom["cellx"] > room["cellx"] ) {
					wall = 2;
					otherWall = 4;
				} else if (otherRoom["cellx"] < room["cellx"] ) {
					wall = 4;
					otherWall = 2;
				} else if(otherRoom["celly"] > room["celly"]) {
					wall = 3;
					otherWall = 1;
				} else if(otherRoom["celly"] < room["celly"]) {
					wall = 1;
					otherWall = 3;
				}
				
				this._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));
			}
		}
	}
}
/**
 * @class Dungeon feature; has own .create() method
 */
ROT.Map.Feature = function() {}
ROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}
ROT.Map.Feature.prototype.create = function(digCallback) {}
ROT.Map.Feature.prototype.debug = function() {}
ROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}

/**
 * @class Room
 * @augments ROT.Map.Feature
 * @param {int} x1
 * @param {int} y1
 * @param {int} x2
 * @param {int} y2
 * @param {int} [doorX]
 * @param {int} [doorY]
 */
ROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {
	this._x1 = x1;
	this._y1 = y1;
	this._x2 = x2;
	this._y2 = y2;
	this._doors = {};
	if (arguments.length > 4) { this.addDoor(doorX, doorY); }
}
ROT.Map.Feature.Room.extend(ROT.Map.Feature);

/**
 * Room of random size, with a given doors and direction
 */
ROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {
	var min = options.roomWidth[0];
	var max = options.roomWidth[1];
	var width = min + Math.floor(ROT.RNG.getUniform()*(max-min+1));
	
	var min = options.roomHeight[0];
	var max = options.roomHeight[1];
	var height = min + Math.floor(ROT.RNG.getUniform()*(max-min+1));
	
	if (dx == 1) { /* to the right */
		var y2 = y - Math.floor(ROT.RNG.getUniform() * height);
		return new this(x+1, y2, x+width, y2+height-1, x, y);
	}
	
	if (dx == -1) { /* to the left */
		var y2 = y - Math.floor(ROT.RNG.getUniform() * height);
		return new this(x-width, y2, x-1, y2+height-1, x, y);
	}

	if (dy == 1) { /* to the bottom */
		var x2 = x - Math.floor(ROT.RNG.getUniform() * width);
		return new this(x2, y+1, x2+width-1, y+height, x, y);
	}

	if (dy == -1) { /* to the top */
		var x2 = x - Math.floor(ROT.RNG.getUniform() * width);
		return new this(x2, y-height, x2+width-1, y-1, x, y);
	}
}

/**
 * Room of random size, positioned around center coords
 */
ROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {
	var min = options.roomWidth[0];
	var max = options.roomWidth[1];
	var width = min + Math.floor(ROT.RNG.getUniform()*(max-min+1));
	
	var min = options.roomHeight[0];
	var max = options.roomHeight[1];
	var height = min + Math.floor(ROT.RNG.getUniform()*(max-min+1));

	var x1 = cx - Math.floor(ROT.RNG.getUniform()*width);
	var y1 = cy - Math.floor(ROT.RNG.getUniform()*height);
	var x2 = x1 + width - 1;
	var y2 = y1 + height - 1;

	return new this(x1, y1, x2, y2);
}

/**
 * Room of random size within a given dimensions
 */
ROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {
	var min = options.roomWidth[0];
	var max = options.roomWidth[1];
	var width = min + Math.floor(ROT.RNG.getUniform()*(max-min+1));
	
	var min = options.roomHeight[0];
	var max = options.roomHeight[1];
	var height = min + Math.floor(ROT.RNG.getUniform()*(max-min+1));
	
	var left = availWidth - width - 1;
	var top = availHeight - height - 1;

	var x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);
	var y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);
	var x2 = x1 + width - 1;
	var y2 = y1 + height - 1;

	return new this(x1, y1, x2, y2);
}

ROT.Map.Feature.Room.prototype.addDoor = function(x, y) {
	this._doors[x+","+y] = 1;
	return this;
}

/**
 * @param {function}
 */
ROT.Map.Feature.Room.prototype.getDoors = function(callback) {
	for (var key in this._doors) {
		var parts = key.split(",");
		callback(parseInt(parts[0]), parseInt(parts[1]));
	}
	return this;
}

ROT.Map.Feature.Room.prototype.clearDoors = function() {
	this._doors = {};
	return this;
}

ROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {
	var left = this._x1-1;
	var right = this._x2+1;
	var top = this._y1-1;
	var bottom = this._y2+1;

	for (var x=left; x<=right; x++) {
		for (var y=top; y<=bottom; y++) {
			if (x != left && x != right && y != top && y != bottom) { continue; }
			if (isWallCallback(x, y)) { continue; }

			this.addDoor(x, y);
		}
	}

	return this;
}

ROT.Map.Feature.Room.prototype.debug = function() {
	console.log("room", this._x1, this._y1, this._x2, this._y2);
}

ROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { 
	var left = this._x1-1;
	var right = this._x2+1;
	var top = this._y1-1;
	var bottom = this._y2+1;
	
	for (var x=left; x<=right; x++) {
		for (var y=top; y<=bottom; y++) {
			if (x == left || x == right || y == top || y == bottom) {
				if (!isWallCallback(x, y)) { return false; }
			} else {
				if (!canBeDugCallback(x, y)) { return false; }
			}
		}
	}

	return true;
}

/**
 * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.
 */
ROT.Map.Feature.Room.prototype.create = function(digCallback) { 
	var left = this._x1-1;
	var right = this._x2+1;
	var top = this._y1-1;
	var bottom = this._y2+1;
	
	var value = 0;
	for (var x=left; x<=right; x++) {
		for (var y=top; y<=bottom; y++) {
			if (x+","+y in this._doors) {
				value = 2;
			} else if (x == left || x == right || y == top || y == bottom) {
				value = 1;
			} else {
				value = 0;
			}
			digCallback(x, y, value);
		}
	}
}

ROT.Map.Feature.Room.prototype.getCenter = function() {
	return [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];
}

ROT.Map.Feature.Room.prototype.getLeft = function() {
	return this._x1;
}

ROT.Map.Feature.Room.prototype.getRight = function() {
	return this._x2;
}

ROT.Map.Feature.Room.prototype.getTop = function() {
	return this._y1;
}

ROT.Map.Feature.Room.prototype.getBottom = function() {
	return this._y2;
}

/**
 * @class Corridor
 * @augments ROT.Map.Feature
 * @param {int} startX
 * @param {int} startY
 * @param {int} endX
 * @param {int} endY
 */
ROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {
	this._startX = startX;
	this._startY = startY;
	this._endX = endX; 
	this._endY = endY;
	this._endsWithAWall = true;
}
ROT.Map.Feature.Corridor.extend(ROT.Map.Feature);

ROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {
	var min = options.corridorLength[0];
	var max = options.corridorLength[1];
	var length = min + Math.floor(ROT.RNG.getUniform()*(max-min+1));
	
	return new this(x, y, x + dx*length, y + dy*length);
}

ROT.Map.Feature.Corridor.prototype.debug = function() {
	console.log("corridor", this._startX, this._startY, this._endX, this._endY);
}

ROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ 
	var sx = this._startX;
	var sy = this._startY;
	var dx = this._endX-sx;
	var dy = this._endY-sy;
	var length = 1 + Math.max(Math.abs(dx), Math.abs(dy));
	
	if (dx) { dx = dx/Math.abs(dx); }
	if (dy) { dy = dy/Math.abs(dy); }
	var nx = dy;
	var ny = -dx;
	
	var ok = true;
	for (var i=0; i<length; i++) {
		var x = sx + i*dx;
		var y = sy + i*dy;

		if (!canBeDugCallback(     x,      y)) { ok = false; }
		if (!isWallCallback  (x + nx, y + ny)) { ok = false; }
		if (!isWallCallback  (x - nx, y - ny)) { ok = false; }
		
		if (!ok) {
			length = i;
			this._endX = x-dx;
			this._endY = y-dy;
			break;
		}
	}
	
	/**
	 * If the length degenerated, this corridor might be invalid
	 */
	 
	/* not supported */
	if (length == 0) { return false; } 
	
	 /* length 1 allowed only if the next space is empty */
	if (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }
	
	/**
	 * We do not want the corridor to crash into a corner of a room;
	 * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.
	 * 
	 * Situation:
	 * #######1
	 * .......?
	 * #######2
	 * 
	 * The corridor was dug from left to right.
	 * 1, 2 - problematic corners, ? = N+1th cell (not dug)
	 */
	var firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);
	var secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);
	this._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);
	if ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }

	return true;
}

/**
 * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.
 */
ROT.Map.Feature.Corridor.prototype.create = function(digCallback) { 
	var sx = this._startX;
	var sy = this._startY;
	var dx = this._endX-sx;
	var dy = this._endY-sy;
	var length = 1+Math.max(Math.abs(dx), Math.abs(dy));
	
	if (dx) { dx = dx/Math.abs(dx); }
	if (dy) { dy = dy/Math.abs(dy); }
	var nx = dy;
	var ny = -dx;
	
	for (var i=0; i<length; i++) {
		var x = sx + i*dx;
		var y = sy + i*dy;
		digCallback(x, y, 0);
	}
	
	return true;
}

ROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {
	if (!this._endsWithAWall) { return; }

	var sx = this._startX;
	var sy = this._startY;

	var dx = this._endX-sx;
	var dy = this._endY-sy;
	if (dx) { dx = dx/Math.abs(dx); }
	if (dy) { dy = dy/Math.abs(dy); }
	var nx = dy;
	var ny = -dx;

	priorityWallCallback(this._endX + dx, this._endY + dy);
	priorityWallCallback(this._endX + nx, this._endY + ny);
	priorityWallCallback(this._endX - nx, this._endY - ny);
}/**
 * @class Base noise generator
 */
ROT.Noise = function() {
};

ROT.Noise.prototype.get = function(x, y) {}
/**
 * A simple 2d implementation of simplex noise by Ondrej Zara
 *
 * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
 * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 */

/**
 * @class 2D simplex noise generator
 * @param {int} [gradients=256] Random gradients
 */
ROT.Noise.Simplex = function(gradients) {
	ROT.Noise.call(this);

	this._F2 = 0.5 * (Math.sqrt(3) - 1);
    this._G2 = (3 - Math.sqrt(3)) / 6;

	this._gradients = [
		[ 0, -1],
		[ 1, -1],
		[ 1,  0],
		[ 1,  1],
		[ 0,  1],
		[-1,  1],
		[-1,  0],
		[-1, -1]
	];

	var permutations = [];
	var count = gradients || 256;
	for (var i=0;i<count;i++) { permutations.push(i); }
	permutations = permutations.randomize();

	this._perms = [];
	this._indexes = [];

	for (var i=0;i<2*count;i++) {
		this._perms.push(permutations[i % count]);
		this._indexes.push(this._perms[i] % this._gradients.length);
	}

};
ROT.Noise.Simplex.extend(ROT.Noise);

ROT.Noise.Simplex.prototype.get = function(xin, yin) {
	var perms = this._perms;
	var indexes = this._indexes;
	var count = perms.length/2;
	var G2 = this._G2;

	var n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners

	// Skew the input space to determine which simplex cell we're in
	var s = (xin + yin) * this._F2; // Hairy factor for 2D
	var i = Math.floor(xin + s);
	var j = Math.floor(yin + s);
	var t = (i + j) * G2;
	var X0 = i - t; // Unskew the cell origin back to (x,y) space
	var Y0 = j - t;
	var x0 = xin - X0; // The x,y distances from the cell origin
	var y0 = yin - Y0;

	// For the 2D case, the simplex shape is an equilateral triangle.
	// Determine which simplex we are in.
	var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
	if (x0 > y0) {
		i1 = 1;
		j1 = 0;
	} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
		i1 = 0;
		j1 = 1;
	} // upper triangle, YX order: (0,0)->(0,1)->(1,1)

	// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	// c = (3-sqrt(3))/6
	var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
	var y1 = y0 - j1 + G2;
	var x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords
	var y2 = y0 - 1 + 2*G2;

	// Work out the hashed gradient indices of the three simplex corners
	var ii = i.mod(count);
	var jj = j.mod(count);

	// Calculate the contribution from the three corners
	var t0 = 0.5 - x0*x0 - y0*y0;
	if (t0 >= 0) {
		t0 *= t0;
		gi = indexes[ii+perms[jj]];
		var grad = this._gradients[gi];
		n0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);
	}
	
	var t1 = 0.5 - x1*x1 - y1*y1;
	if (t1 >= 0) {
		t1 *= t1;
		gi = indexes[ii+i1+perms[jj+j1]];
		var grad = this._gradients[gi];
		n1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);
	}
	
	var t2 = 0.5 - x2*x2 - y2*y2;
	if (t2 >= 0) {
		t2 *= t2;
		gi = indexes[ii+1+perms[jj+1]];
		var grad = this._gradients[gi];
		n2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);
	}

	// Add contributions from each corner to get the final noise value.
	// The result is scaled to return values in the interval [-1,1].
	return 70 * (n0 + n1 + n2);
}
/**
 * @class Abstract FOV algorithm
 * @param {function} lightPassesCallback Does the light pass through x,y?
 * @param {object} [options]
 * @param {int} [options.topology=8] 4/6/8
 */
ROT.FOV = function(lightPassesCallback, options) {
	this._lightPasses = lightPassesCallback;
	this._options = {
		topology: 8
	}
	for (var p in options) { this._options[p] = options[p]; }
};

/**
 * Compute visibility for a 360-degree circle
 * @param {int} x
 * @param {int} y
 * @param {int} R Maximum visibility radius
 * @param {function} callback
 */
ROT.FOV.prototype.compute = function(x, y, R, callback) {}

/**
 * Return all neighbors in a concentric ring
 * @param {int} cx center-x
 * @param {int} cy center-y
 * @param {int} r range
 */
ROT.FOV.prototype._getCircle = function(cx, cy, r) {
	var result = [];
	var dirs, countFactor, startOffset;

	switch (this._options.topology) {
		case 4:
			countFactor = 1;
			startOffset = [0, 1];
			dirs = [
				ROT.DIRS[8][7],
				ROT.DIRS[8][1],
				ROT.DIRS[8][3],
				ROT.DIRS[8][5]
			]
		break;

		case 6:
			dirs = ROT.DIRS[6];
			countFactor = 1;
			startOffset = [-1, 1];
		break;

		case 8:
			dirs = ROT.DIRS[4];
			countFactor = 2;
			startOffset = [-1, 1];
		break;
	}

	/* starting neighbor */
	var x = cx + startOffset[0]*r;
	var y = cy + startOffset[1]*r;

	/* circle */
	for (var i=0;i<dirs.length;i++) {
		for (var j=0;j<r*countFactor;j++) {
			result.push([x, y]);
			x += dirs[i][0];
			y += dirs[i][1];

		}
	}

	return result;
}
/**
 * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.
 * @augments ROT.FOV
 */
ROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {
	ROT.FOV.call(this, lightPassesCallback, options);
}
ROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);

/**
 * @see ROT.FOV#compute
 */
ROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {
	var center = this._coords;
	var map = this._map;

	/* this place is always visible */
	callback(x, y, 0);

	/* standing in a dark place. FIXME is this a good idea?  */
	if (!this._lightPasses(x, y)) { return; }
	
	/* start and end angles */
	var DATA = [];
	
	var A, B, cx, cy, blocks;

	/* analyze surrounding cells in concentric rings, starting from the center */
	for (var r=1; r<=R; r++) {
		var neighbors = this._getCircle(x, y, r);
		var angle = 360 / neighbors.length;

		for (var i=0;i<neighbors.length;i++) {
			cx = neighbors[i][0];
			cy = neighbors[i][1];
			A = angle * (i - 0.5);
			B = A + angle;
			
			blocks = !this._lightPasses(cx, cy);
			if (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }
			
			if (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */

		} /* for all cells in this ring */
	} /* for all rings */
}

/**
 * @param {int} A start angle
 * @param {int} B end angle
 * @param {bool} blocks Does current cell block visibility?
 * @param {int[][]} DATA shadowed angle pairs
 */
ROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {
	if (A < 0) { 
		var v1 = arguments.callee(0, B, blocks, DATA);
		var v2 = arguments.callee(360+A, 360, blocks, DATA);
		return v1 || v2;
	}
	
	var index = 0;
	while (index < DATA.length && DATA[index] < A) { index++; }
	
	if (index == DATA.length) { /* completely new shadow */
		if (blocks) { DATA.push(A, B); } 
		return true;
	}
	
	var count = 0;
	
	if (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */
		while (index < DATA.length && DATA[index] < B) {
			index++;
			count++;
		}
		
		if (count == 0) { return false; }
		
		if (blocks) { 
			if (count % 2) {
				DATA.splice(index-count, count, B);
			} else {
				DATA.splice(index-count, count);
			}
		}
		
		return true;

	} else { /* this shadow starts outside an existing shadow, or within a starting boundary */
		while (index < DATA.length && DATA[index] < B) {
			index++;
			count++;
		}
		
		/* visible when outside an existing shadow, or when overlapping */
		if (A == DATA[index-count] && count == 1) { return false; }
		
		if (blocks) { 
			if (count % 2) {
				DATA.splice(index-count, count, A);
			} else {
				DATA.splice(index-count, count, A, B);
			}
		}
			
		return true;
	}
}
/**
 * @class Precise shadowcasting algorithm
 * @augments ROT.FOV
 */
ROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {
	ROT.FOV.call(this, lightPassesCallback, options);
}
ROT.FOV.PreciseShadowcasting.extend(ROT.FOV);

/**
 * @see ROT.FOV#compute
 */
ROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {
	/* this place is always visible */
	callback(x, y, 0, 1);

	/* standing in a dark place. FIXME is this a good idea?  */
	if (!this._lightPasses(x, y)) { return; }
	
	/* list of all shadows */
	var SHADOWS = [];
	
	var cx, cy, blocks, A1, A2, visibility;

	/* analyze surrounding cells in concentric rings, starting from the center */
	for (var r=1; r<=R; r++) {
		var neighbors = this._getCircle(x, y, r);
		var neighborCount = neighbors.length;

		for (var i=0;i<neighborCount;i++) {
			cx = neighbors[i][0];
			cy = neighbors[i][1];
			/* shift half-an-angle backwards to maintain consistency of 0-th cells */
			A1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];
			A2 = [2*i+1, 2*neighborCount]; 
			
			blocks = !this._lightPasses(cx, cy);
			visibility = this._checkVisibility(A1, A2, blocks, SHADOWS);
			if (visibility) { callback(cx, cy, r, visibility); }

			if (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */

		} /* for all cells in this ring */
	} /* for all rings */
}

/**
 * @param {int[2]} A1 arc start
 * @param {int[2]} A2 arc end
 * @param {bool} blocks Does current arc block visibility?
 * @param {int[][]} SHADOWS list of active shadows
 */
ROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {
	if (A1[0] > A2[0]) { /* split into two sub-arcs */
		var v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);
		var v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);
		return (v1+v2)/2;
	}

	/* index1: first shadow >= A1 */
	var index1 = 0, edge1 = false;
	while (index1 < SHADOWS.length) {
		var old = SHADOWS[index1];
		var diff = old[0]*A1[1] - A1[0]*old[1];
		if (diff >= 0) { /* old >= A1 */
			if (diff == 0 && !(index1 % 2)) { edge1 = true; }
			break;
		}
		index1++;
	}

	/* index2: last shadow <= A2 */
	var index2 = SHADOWS.length, edge2 = false;
	while (index2--) {
		var old = SHADOWS[index2];
		var diff = A2[0]*old[1] - old[0]*A2[1];
		if (diff >= 0) { /* old <= A2 */
			if (diff == 0 && (index2 % 2)) { edge2 = true; }
			break;
		}
	}

	var visible = true;
	if (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */
		visible = false; 
	} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */
		visible = false;
	} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */
		visible = false;
	}
	
	if (!visible) { return 0; } /* fast case: not visible */
	
	var visibleLength, P;

	/* compute the length of visible arc, adjust list of shadows (if blocking) */
	var remove = index2-index1+1;
	if (remove % 2) {
		if (index1 % 2) { /* first edge within existing shadow, second outside */
			var P = SHADOWS[index1];
			visibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);
			if (blocks) { SHADOWS.splice(index1, remove, A2); }
		} else { /* second edge within existing shadow, first outside */
			var P = SHADOWS[index2];
			visibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);
			if (blocks) { SHADOWS.splice(index1, remove, A1); }
		}
	} else {
		if (index1 % 2) { /* both edges within existing shadows */
			var P1 = SHADOWS[index1];
			var P2 = SHADOWS[index2];
			visibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);
			if (blocks) { SHADOWS.splice(index1, remove); }
		} else { /* both edges outside existing shadows */
			if (blocks) { SHADOWS.splice(index1, remove, A1, A2); }
			return 1; /* whole arc visible! */
		}
	}

	var arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);

	return visibleLength/arcLength;
}
/**
 * @class Recursive shadowcasting algorithm
 * Currently only supports 4/8 topologies, not hexagonal.
 * Based on Peter Harkins' implementation of Björn Bergström's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting
 * @augments ROT.FOV
 */
ROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {
	ROT.FOV.call(this, lightPassesCallback, options);
}
ROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);

/** Octants used for translating recursive shadowcasting offsets */
ROT.FOV.RecursiveShadowcasting.OCTANTS = [
	[-1,  0,  0,  1],
	[ 0, -1,  1,  0],
	[ 0, -1, -1,  0],
	[-1,  0,  0, -1],
	[ 1,  0,  0, -1],
	[ 0,  1, -1,  0],
	[ 0,  1,  1,  0],
	[ 1,  0,  0,  1]
];

/**
 * Compute visibility for a 360-degree circle
 * @param {int} x
 * @param {int} y
 * @param {int} R Maximum visibility radius
 * @param {function} callback
 */
ROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {
	//You can always see your own tile
	callback(x, y, 0, true);
	for(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {
		this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);
	}
}

/**
 * Compute visibility for a 180-degree arc
 * @param {int} x
 * @param {int} y
 * @param {int} R Maximum visibility radius
 * @param {int} dir Direction to look in (expressed in a ROT.DIR value);
 * @param {function} callback
 */
ROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {
	//You can always see your own tile
	callback(x, y, 0, true);
	var previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees
	var nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees
	var nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees
	this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);
	this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);
	this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);
	this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);
}

/**
 * Compute visibility for a 90-degree arc
 * @param {int} x
 * @param {int} y
 * @param {int} R Maximum visibility radius
 * @param {int} dir Direction to look in (expressed in a ROT.DIR value);
 * @param {function} callback
 */
ROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {
	//You can always see your own tile
	callback(x, y, 0, true);
	var previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees
	this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);
	this._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);
}

/**
 * Render one octant (45-degree arc) of the viewshed
 * @param {int} x
 * @param {int} y
 * @param {int} octant Octant to be rendered
 * @param {int} R Maximum visibility radius
 * @param {function} callback
 */
ROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {
	//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses
	this._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);
}

/**
 * Actually calculates the visibility
 * @param {int} startX The starting X coordinate
 * @param {int} startY The starting Y coordinate
 * @param {int} row The row to render
 * @param {float} visSlopeStart The slope to start at
 * @param {float} visSlopeEnd The slope to end at
 * @param {int} radius The radius to reach out to
 * @param {int} xx 
 * @param {int} xy 
 * @param {int} yx 
 * @param {int} yy 
 * @param {function} callback The callback to use when we hit a block that is visible
 */
ROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {
	if(visSlopeStart < visSlopeEnd) { return; }
	for(var i = row; i <= radius; i++) {
		var dx = -i - 1;
		var dy = -i;
		var blocked = false;
		var newStart = 0;

		//'Row' could be column, names here assume octant 0 and would be flipped for half the octants
		while(dx <= 0) {
			dx += 1;

			//Translate from relative coordinates to map coordinates
			var mapX = startX + dx * xx + dy * xy;
			var mapY = startY + dx * yx + dy * yy;

			//Range of the row
			var slopeStart = (dx - 0.5) / (dy + 0.5);
			var slopeEnd = (dx + 0.5) / (dy - 0.5);
		
			//Ignore if not yet at left edge of Octant
			if(slopeEnd > visSlopeStart) { continue; }
			
			//Done if past right edge
			if(slopeStart < visSlopeEnd) { break; }
				
			//If it's in range, it's visible
			if((dx * dx + dy * dy) < (radius * radius)) {
				callback(mapX, mapY, i, true);
			}
	
			if(!blocked) {
				//If tile is a blocking tile, cast around it
				if(!this._lightPasses(mapX, mapY) && i < radius) {
					blocked = true;
					this._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);
					newStart = slopeEnd;
				}
			} else {
				//Keep narrowing if scanning across a block
				if(!this._lightPasses(mapX, mapY)) {
					newStart = slopeEnd;
					continue;
				}
			
				//Block has ended
				blocked = false;
				visSlopeStart = newStart;
			}
		}
		if(blocked) { break; }
	}
}
/**
 * @namespace Color operations
 */
ROT.Color = {
	fromString: function(str) {
		var cached, r;
		if (str in this._cache) {
			cached = this._cache[str];
		} else {
			if (str.charAt(0) == "#") { /* hex rgb */

				var values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });
				if (values.length == 3) {
					cached = values.map(function(x) { return x*17; });
				} else {
					for (var i=0;i<3;i++) {
						values[i+1] += 16*values[i];
						values.splice(i, 1);
					}
					cached = values;
				}

			} else if (r = str.match(/rgb\(([0-9, ]+)\)/i)) { /* decimal rgb */
				cached = r[1].split(/\s*,\s*/).map(function(x) { return parseInt(x); });
			} else { /* html name */
				cached = [0, 0, 0];
			}

			this._cache[str] = cached;
		}

		return cached.slice();
	},

	/**
	 * Add two or more colors
	 * @param {number[]} color1
	 * @param {number[]} color2
	 * @returns {number[]}
	 */
	add: function(color1, color2) {
		var result = color1.slice();
		for (var i=0;i<3;i++) {
			for (var j=1;j<arguments.length;j++) {
				result[i] += arguments[j][i];
			}
		}
		return result;
	},

	/**
	 * Add two or more colors, MODIFIES FIRST ARGUMENT
	 * @param {number[]} color1
	 * @param {number[]} color2
	 * @returns {number[]}
	 */
	add_: function(color1, color2) {
		for (var i=0;i<3;i++) {
			for (var j=1;j<arguments.length;j++) {
				color1[i] += arguments[j][i];
			}
		}
		return color1;
	},

	/**
	 * Multiply (mix) two or more colors
	 * @param {number[]} color1
	 * @param {number[]} color2
	 * @returns {number[]}
	 */
	multiply: function(color1, color2) {
		var result = color1.slice();
		for (var i=0;i<3;i++) {
			for (var j=1;j<arguments.length;j++) {
				result[i] *= arguments[j][i] / 255;
			}
			result[i] = Math.round(result[i]);
		}
		return result;
	},

	/**
	 * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT
	 * @param {number[]} color1
	 * @param {number[]} color2
	 * @returns {number[]}
	 */
	multiply_: function(color1, color2) {
		for (var i=0;i<3;i++) {
			for (var j=1;j<arguments.length;j++) {
				color1[i] *= arguments[j][i] / 255;
			}
			color1[i] = Math.round(color1[i]);
		}
		return color1;
	},

	/**
	 * Interpolate (blend) two colors with a given factor
	 * @param {number[]} color1
	 * @param {number[]} color2
	 * @param {float} [factor=0.5] 0..1
	 * @returns {number[]}
	 */
	interpolate: function(color1, color2, factor) {
		if (arguments.length < 3) { factor = 0.5; }
		var result = color1.slice();
		for (var i=0;i<3;i++) {
			result[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));
		}
		return result;
	},

	/**
	 * Interpolate (blend) two colors with a given factor in HSL mode
	 * @param {number[]} color1
	 * @param {number[]} color2
	 * @param {float} [factor=0.5] 0..1
	 * @returns {number[]}
	 */
	interpolateHSL: function(color1, color2, factor) {
		if (arguments.length < 3) { factor = 0.5; }
		var hsl1 = this.rgb2hsl(color1);
		var hsl2 = this.rgb2hsl(color2);
		for (var i=0;i<3;i++) {
			hsl1[i] += factor*(hsl2[i]-hsl1[i]);
		}
		return this.hsl2rgb(hsl1);
	},

	/**
	 * Create a new random color based on this one
	 * @param {number[]} color
	 * @param {number[]} diff Set of standard deviations
	 * @returns {number[]}
	 */
	randomize: function(color, diff) {
		if (!(diff instanceof Array)) { diff = ROT.RNG.getNormal(0, diff); }
		var result = color.slice();
		for (var i=0;i<3;i++) {
			result[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);
		}
		return result;
	},

	/**
	 * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.
	 * @param {number[]} color
	 * @returns {number[]}
	 */
	rgb2hsl: function(color) {
		var r = color[0]/255;
		var g = color[1]/255;
		var b = color[2]/255;

		var max = Math.max(r, g, b), min = Math.min(r, g, b);
		var h, s, l = (max + min) / 2;

		if (max == min) {
			h = s = 0; // achromatic
		} else {
			var d = max - min;
			s = (l > 0.5 ? d / (2 - max - min) : d / (max + min));
			switch(max) {
				case r: h = (g - b) / d + (g < b ? 6 : 0); break;
				case g: h = (b - r) / d + 2; break;
				case b: h = (r - g) / d + 4; break;
			}
			h /= 6;
		}

		return [h, s, l];
	},

	/**
	 * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.
	 * @param {number[]} color
	 * @returns {number[]}
	 */
	hsl2rgb: function(color) {
		var l = color[2];

		if (color[1] == 0) {
			l = Math.round(l*255);
			return [l, l, l];
		} else {
			function hue2rgb(p, q, t) {
				if (t < 0) t += 1;
				if (t > 1) t -= 1;
				if (t < 1/6) return p + (q - p) * 6 * t;
				if (t < 1/2) return q;
				if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
				return p;
			}

			var s = color[1];
			var q = (l < 0.5 ? l * (1 + s) : l + s - l * s);
			var p = 2 * l - q;
			var r = hue2rgb(p, q, color[0] + 1/3);
			var g = hue2rgb(p, q, color[0]);
			var b = hue2rgb(p, q, color[0] - 1/3);
			return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
		}
	},

	toRGB: function(color) {
		return "rgb(" + this._clamp(color[0]) + "," + this._clamp(color[1]) + "," + this._clamp(color[2]) + ")";
	},

	toHex: function(color) {
		var parts = [];
		for (var i=0;i<3;i++) {
			parts.push(this._clamp(color[i]).toString(16).lpad("0", 2));
		}
		return "#" + parts.join("");
	},

	_clamp: function(num) {
		if (num < 0) {
			return 0;
		} else if (num > 255) {
			return 255;
		} else {
			return num;
		}
	},

	_cache: {
		"black": [0,0,0],
		"navy": [0,0,128],
		"darkblue": [0,0,139],
		"mediumblue": [0,0,205],
		"blue": [0,0,255],
		"darkgreen": [0,100,0],
		"green": [0,128,0],
		"teal": [0,128,128],
		"darkcyan": [0,139,139],
		"deepskyblue": [0,191,255],
		"darkturquoise": [0,206,209],
		"mediumspringgreen": [0,250,154],
		"lime": [0,255,0],
		"springgreen": [0,255,127],
		"aqua": [0,255,255],
		"cyan": [0,255,255],
		"midnightblue": [25,25,112],
		"dodgerblue": [30,144,255],
		"forestgreen": [34,139,34],
		"seagreen": [46,139,87],
		"darkslategray": [47,79,79],
		"darkslategrey": [47,79,79],
		"limegreen": [50,205,50],
		"mediumseagreen": [60,179,113],
		"turquoise": [64,224,208],
		"royalblue": [65,105,225],
		"steelblue": [70,130,180],
		"darkslateblue": [72,61,139],
		"mediumturquoise": [72,209,204],
		"indigo": [75,0,130],
		"darkolivegreen": [85,107,47],
		"cadetblue": [95,158,160],
		"cornflowerblue": [100,149,237],
		"mediumaquamarine": [102,205,170],
		"dimgray": [105,105,105],
		"dimgrey": [105,105,105],
		"slateblue": [106,90,205],
		"olivedrab": [107,142,35],
		"slategray": [112,128,144],
		"slategrey": [112,128,144],
		"lightslategray": [119,136,153],
		"lightslategrey": [119,136,153],
		"mediumslateblue": [123,104,238],
		"lawngreen": [124,252,0],
		"chartreuse": [127,255,0],
		"aquamarine": [127,255,212],
		"maroon": [128,0,0],
		"purple": [128,0,128],
		"olive": [128,128,0],
		"gray": [128,128,128],
		"grey": [128,128,128],
		"skyblue": [135,206,235],
		"lightskyblue": [135,206,250],
		"blueviolet": [138,43,226],
		"darkred": [139,0,0],
		"darkmagenta": [139,0,139],
		"saddlebrown": [139,69,19],
		"darkseagreen": [143,188,143],
		"lightgreen": [144,238,144],
		"mediumpurple": [147,112,216],
		"darkviolet": [148,0,211],
		"palegreen": [152,251,152],
		"darkorchid": [153,50,204],
		"yellowgreen": [154,205,50],
		"sienna": [160,82,45],
		"brown": [165,42,42],
		"darkgray": [169,169,169],
		"darkgrey": [169,169,169],
		"lightblue": [173,216,230],
		"greenyellow": [173,255,47],
		"paleturquoise": [175,238,238],
		"lightsteelblue": [176,196,222],
		"powderblue": [176,224,230],
		"firebrick": [178,34,34],
		"darkgoldenrod": [184,134,11],
		"mediumorchid": [186,85,211],
		"rosybrown": [188,143,143],
		"darkkhaki": [189,183,107],
		"silver": [192,192,192],
		"mediumvioletred": [199,21,133],
		"indianred": [205,92,92],
		"peru": [205,133,63],
		"chocolate": [210,105,30],
		"tan": [210,180,140],
		"lightgray": [211,211,211],
		"lightgrey": [211,211,211],
		"palevioletred": [216,112,147],
		"thistle": [216,191,216],
		"orchid": [218,112,214],
		"goldenrod": [218,165,32],
		"crimson": [220,20,60],
		"gainsboro": [220,220,220],
		"plum": [221,160,221],
		"burlywood": [222,184,135],
		"lightcyan": [224,255,255],
		"lavender": [230,230,250],
		"darksalmon": [233,150,122],
		"violet": [238,130,238],
		"palegoldenrod": [238,232,170],
		"lightcoral": [240,128,128],
		"khaki": [240,230,140],
		"aliceblue": [240,248,255],
		"honeydew": [240,255,240],
		"azure": [240,255,255],
		"sandybrown": [244,164,96],
		"wheat": [245,222,179],
		"beige": [245,245,220],
		"whitesmoke": [245,245,245],
		"mintcream": [245,255,250],
		"ghostwhite": [248,248,255],
		"salmon": [250,128,114],
		"antiquewhite": [250,235,215],
		"linen": [250,240,230],
		"lightgoldenrodyellow": [250,250,210],
		"oldlace": [253,245,230],
		"red": [255,0,0],
		"fuchsia": [255,0,255],
		"magenta": [255,0,255],
		"deeppink": [255,20,147],
		"orangered": [255,69,0],
		"tomato": [255,99,71],
		"hotpink": [255,105,180],
		"coral": [255,127,80],
		"darkorange": [255,140,0],
		"lightsalmon": [255,160,122],
		"orange": [255,165,0],
		"lightpink": [255,182,193],
		"pink": [255,192,203],
		"gold": [255,215,0],
		"peachpuff": [255,218,185],
		"navajowhite": [255,222,173],
		"moccasin": [255,228,181],
		"bisque": [255,228,196],
		"mistyrose": [255,228,225],
		"blanchedalmond": [255,235,205],
		"papayawhip": [255,239,213],
		"lavenderblush": [255,240,245],
		"seashell": [255,245,238],
		"cornsilk": [255,248,220],
		"lemonchiffon": [255,250,205],
		"floralwhite": [255,250,240],
		"snow": [255,250,250],
		"yellow": [255,255,0],
		"lightyellow": [255,255,224],
		"ivory": [255,255,240],
		"white": [255,255,255]
	}
}
/**
 * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.
 * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)
 * @param {object} [options]
 * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.
 * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.
 * @param {int} [options.range=10] Max light range
 */
ROT.Lighting = function(reflectivityCallback, options) {
	this._reflectivityCallback = reflectivityCallback;
	this._options = {
		passes: 1,
		emissionThreshold: 100,
		range: 10
	};
	this._fov = null;

	this._lights = {};
	this._reflectivityCache = {};
	this._fovCache = {};

	this.setOptions(options);
}

/**
 * Adjust options at runtime
 * @see ROT.Lighting
 * @param {object} [options]
 */
ROT.Lighting.prototype.setOptions = function(options) {
	for (var p in options) { this._options[p] = options[p]; }
	if (options.range) { this.reset(); }
	return this;
}

/**
 * Set the used Field-Of-View algo
 * @param {ROT.FOV} fov
 */
ROT.Lighting.prototype.setFOV = function(fov) {
	this._fov = fov;
	this._fovCache = {};
	return this;
}

/**
 * Set (or remove) a light source
 * @param {int} x
 * @param {int} y
 * @param {null || string || number[3]} color
 */
ROT.Lighting.prototype.setLight = function(x, y, color) {
	var key = x+","+y;

	if (color) {
		this._lights[key] = (typeof(color) == "string" ? ROT.Color.fromString(color) : color);
	} else {
		delete this._lights[key];
	}
	return this;
}

/**
 * Remove all light sources
 */
ROT.Lighting.prototype.clearLights = function() {
    this._lights = {};
}

/**
 * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.
 */
ROT.Lighting.prototype.reset = function() {
	this._reflectivityCache = {};
	this._fovCache = {};

	return this;
}

/**
 * Compute the lighting
 * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell
 */
ROT.Lighting.prototype.compute = function(lightingCallback) {
	var doneCells = {};
	var emittingCells = {};
	var litCells = {};

	for (var key in this._lights) { /* prepare emitters for first pass */
		var light = this._lights[key];
		if (!(key in emittingCells)) { emittingCells[key] = [0, 0, 0]; }

		ROT.Color.add_(emittingCells[key], light);
	}

	for (var i=0;i<this._options.passes;i++) { /* main loop */
		this._emitLight(emittingCells, litCells, doneCells);
		if (i+1 == this._options.passes) { continue; } /* not for the last pass */
		emittingCells = this._computeEmitters(litCells, doneCells);
	}

	for (var litKey in litCells) { /* let the user know what and how is lit */
		var parts = litKey.split(",");
		var x = parseInt(parts[0]);
		var y = parseInt(parts[1]);
		lightingCallback(x, y, litCells[litKey]);
	}

	return this;
}

/**
 * Compute one iteration from all emitting cells
 * @param {object} emittingCells These emit light
 * @param {object} litCells Add projected light to these
 * @param {object} doneCells These already emitted, forbid them from further calculations
 */
ROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {
	for (var key in emittingCells) {
		var parts = key.split(",");
		var x = parseInt(parts[0]);
		var y = parseInt(parts[1]);
		this._emitLightFromCell(x, y, emittingCells[key], litCells);
		doneCells[key] = 1;
	}
	return this;
}

/**
 * Prepare a list of emitters for next pass
 * @param {object} litCells
 * @param {object} doneCells
 * @returns {object}
 */
ROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {
	var result = {};

	for (var key in litCells) {
		if (key in doneCells) { continue; } /* already emitted */

		var color = litCells[key];

		if (key in this._reflectivityCache) {
			var reflectivity = this._reflectivityCache[key];
		} else {
			var parts = key.split(",");
			var x = parseInt(parts[0]);
			var y = parseInt(parts[1]);
			var reflectivity = this._reflectivityCallback(x, y);
			this._reflectivityCache[key] = reflectivity;
		}

		if (reflectivity == 0) { continue; } /* will not reflect at all */

		/* compute emission color */
		var emission = [];
		var intensity = 0;
		for (var i=0;i<3;i++) {
			var part = Math.round(color[i]*reflectivity);
			emission[i] = part;
			intensity += part;
		}
		if (intensity > this._options.emissionThreshold) { result[key] = emission; }
	}

	return result;
}

/**
 * Compute one iteration from one cell
 * @param {int} x
 * @param {int} y
 * @param {number[]} color
 * @param {object} litCells Cell data to by updated
 */
ROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {
	var key = x+","+y;
	if (key in this._fovCache) {
		var fov = this._fovCache[key];
	} else {
		var fov = this._updateFOV(x, y);
	}

	for (var fovKey in fov) {
		var formFactor = fov[fovKey];

		if (fovKey in litCells) { /* already lit */
			var result = litCells[fovKey];
		} else { /* newly lit */
			var result = [0, 0, 0];
			litCells[fovKey] = result;
		}

		for (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */
	}

	return this;
}

/**
 * Compute FOV ("form factor") for a potential light source at [x,y]
 * @param {int} x
 * @param {int} y
 * @returns {object}
 */
ROT.Lighting.prototype._updateFOV = function(x, y) {
	var key1 = x+","+y;
	var cache = {};
	this._fovCache[key1] = cache;
	var range = this._options.range;
	var cb = function(x, y, r, vis) {
		var key2 = x+","+y;
		var formFactor = vis * (1-r/range);
		if (formFactor == 0) { return; }
		cache[key2] = formFactor;
	}
	this._fov.compute(x, y, range, cb.bind(this));

	return cache;
}
/**
 * @class Abstract pathfinder
 * @param {int} toX Target X coord
 * @param {int} toY Target Y coord
 * @param {function} passableCallback Callback to determine map passability
 * @param {object} [options]
 * @param {int} [options.topology=8]
 */
ROT.Path = function(toX, toY, passableCallback, options) {
	this._toX = toX;
	this._toY = toY;
	this._fromX = null;
	this._fromY = null;
	this._passableCallback = passableCallback;
	this._options = {
		topology: 8
	}
	for (var p in options) { this._options[p] = options[p]; }

	this._dirs = ROT.DIRS[this._options.topology];
	if (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */
		this._dirs = [
			this._dirs[0],
			this._dirs[2],
			this._dirs[4],
			this._dirs[6],
			this._dirs[1],
			this._dirs[3],
			this._dirs[5],
			this._dirs[7]
		]
	}
}

/**
 * Compute a path from a given point
 * @param {int} fromX
 * @param {int} fromY
 * @param {function} callback Will be called for every path item with arguments "x" and "y"
 */
ROT.Path.prototype.compute = function(fromX, fromY, callback) {
}

ROT.Path.prototype._getNeighbors = function(cx, cy) {
	var result = [];
	for (var i=0;i<this._dirs.length;i++) {
		var dir = this._dirs[i];
		var x = cx + dir[0];
		var y = cy + dir[1];
		
		if (!this._passableCallback(x, y)) { continue; }
		result.push([x, y]);
	}
	
	return result;
}
/**
 * @class Simplified Dijkstra's algorithm: all edges have a value of 1
 * @augments ROT.Path
 * @see ROT.Path
 */
ROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {
	ROT.Path.call(this, toX, toY, passableCallback, options);

	this._computed = {};
	this._todo = [];
	this._add(toX, toY, null);
}
ROT.Path.Dijkstra.extend(ROT.Path);

/**
 * Compute a path from a given point
 * @see ROT.Path#compute
 */
ROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {
	var key = fromX+","+fromY;
	if (!(key in this._computed)) { this._compute(fromX, fromY); }
	if (!(key in this._computed)) { return; }
	
	var item = this._computed[key];
	while (item) {
		callback(item.x, item.y);
		item = item.prev;
	}
}

/**
 * Compute a non-cached value
 */
ROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {
	while (this._todo.length) {
		var item = this._todo.shift();
		if (item.x == fromX && item.y == fromY) { return; }
		
		var neighbors = this._getNeighbors(item.x, item.y);
		
		for (var i=0;i<neighbors.length;i++) {
			var neighbor = neighbors[i];
			var x = neighbor[0];
			var y = neighbor[1];
			var id = x+","+y;
			if (id in this._computed) { continue; } /* already done */	
			this._add(x, y, item); 
		}
	}
}

ROT.Path.Dijkstra.prototype._add = function(x, y, prev) {
	var obj = {
		x: x,
		y: y,
		prev: prev
	}
	this._computed[x+","+y] = obj;
	this._todo.push(obj);
}
/**
 * @class Simplified A* algorithm: all edges have a value of 1
 * @augments ROT.Path
 * @see ROT.Path
 */
ROT.Path.AStar = function(toX, toY, passableCallback, options) {
	ROT.Path.call(this, toX, toY, passableCallback, options);

	this._todo = [];
	this._done = {};
	this._fromX = null;
	this._fromY = null;
}
ROT.Path.AStar.extend(ROT.Path);

/**
 * Compute a path from a given point
 * @see ROT.Path#compute
 */
ROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {
	this._todo = [];
	this._done = {};
	this._fromX = fromX;
	this._fromY = fromY;
	this._add(this._toX, this._toY, null);

	while (this._todo.length) {
		var item = this._todo.shift();
		if (item.x == fromX && item.y == fromY) { break; }
		var neighbors = this._getNeighbors(item.x, item.y);

		for (var i=0;i<neighbors.length;i++) {
			var neighbor = neighbors[i];
			var x = neighbor[0];
			var y = neighbor[1];
			var id = x+","+y;
			if (id in this._done) { continue; }
			this._add(x, y, item); 
		}
	}
	
	var item = this._done[fromX+","+fromY];
	if (!item) { return; }
	
	while (item) {
		callback(item.x, item.y);
		item = item.prev;
	}
}

ROT.Path.AStar.prototype._add = function(x, y, prev) {
	var obj = {
		x: x,
		y: y,
		prev: prev,
		g: (prev ? prev.g+1 : 0),
		h: this._distance(x, y)
	}
	this._done[x+","+y] = obj;
	
	/* insert into priority queue */
	
	var f = obj.g + obj.h;
	for (var i=0;i<this._todo.length;i++) {
		var item = this._todo[i];
		if (f < item.g + item.h) {
			this._todo.splice(i, 0, obj);
			return;
		}
	}
	
	this._todo.push(obj);
}

ROT.Path.AStar.prototype._distance = function(x, y) {
	switch (this._options.topology) {
		case 4:
			return (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));
		break;

		case 6:
			var dx = Math.abs(x - this._fromX);
			var dy = Math.abs(y - this._fromY);
			return dy + Math.max(0, (dx-dy)/2);
		break;

		case 8: 
			return Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));
		break;
	}
}
/**
 * @class Terminal backend
 * @private
 */
ROT.Display.Term = function(context) {
	ROT.Display.Backend.call(this, context);
	this._cx = -1;
	this._cy = -1;
	this._lastColor = "";
	this._options = {};
	this._ox = 0;
	this._oy = 0;
	this._termcolor = {};
}
ROT.Display.Term.extend(ROT.Display.Backend);

ROT.Display.Term.prototype.compute = function(options) {
	this._options = options;
	this._ox = Math.floor((process.stdout.columns - options.width) / 2);
	this._oy = Math.floor((process.stdout.rows - options.height) / 2);
	this._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);
	this._context._termcolor = this._termcolor;
}

ROT.Display.Term.prototype.draw = function(data, clearBefore) {
	// determine where to draw what with what colors
	var x = data[0];
	var y = data[1];
	var ch = data[2];
	var fg = data[3];
	var bg = data[4];

	// determine if we need to move the terminal cursor
	var dx = this._ox + x;
	var dy = this._oy + y;
	if (dx < 0 || dx >= process.stdout.columns) { return; }
	if (dy < 0 || dy >= process.stdout.rows) { return; }
	if (dx !== this._cx || dy !== this._cy) {
		process.stdout.write(this._termcolor.positionToAnsi(dx,dy));
		this._cx = dx;
		this._cy = dy;
	}

	// terminals automatically clear, but if we're clearing when we're
	// not otherwise provided with a character, just use a space instead
	if (clearBefore) {
		if (!ch) {
			ch = " ";
		}
	}
		
	// if we're not clearing and not provided with a character, do nothing
	if (!ch) { return; }

	// determine if we need to change colors
	var newColor = this._termcolor.colorToAnsi(fg,bg);
	if (newColor !== this._lastColor) {
		process.stdout.write(newColor);
		this._lastColor = newColor;
	}

	// write the provided symbol to the display
	var chars = [].concat(ch);
	process.stdout.write(chars[0]);

	// update our position, given that we wrote a character
	this._cx++;
	if (this._cx >= process.stdout.columns) {
		this._cx = 0;
		this._cy++;
	}
}

ROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {
	return [process.stdout.columns, process.stdout.rows];
}

ROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {
	return 12;
}

ROT.Display.Term.prototype.eventToPosition = function(x, y) {
	return [x,y]
}
/**
 * @class Abstract terminal code module
 * @private
 */
ROT.Display.Term.Color = function(context) {
	this._context = context;
}

ROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {
}

ROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {
}

ROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {
}
/**
 * @class xterm terminal code module
 * @private
 */
ROT.Display.Term.Xterm = function(context) {
	ROT.Display.Term.Color.call(this, context);
}
ROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);

ROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {
	return "\x1b[0;48;5;"
		+ this._termcolor(bg)
		+ "m\x1b[2J";
}

ROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {
	return "\x1b[0;38;5;"
		+ this._termcolor(fg)
		+ ";48;5;"
		+ this._termcolor(bg)
		+ "m";
}

ROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {
	return "\x1b[" + (y+1) + ";" + (x+1) + "H";
}

ROT.Display.Term.Xterm.prototype._termcolor = function(color) {
	var SRC_COLORS = 256.0;
	var DST_COLORS = 6.0;
	var COLOR_RATIO = DST_COLORS / SRC_COLORS;
	var rgb = ROT.Color.fromString(color);
	var r = Math.floor(rgb[0] * COLOR_RATIO);
	var g = Math.floor(rgb[1] * COLOR_RATIO);
	var b = Math.floor(rgb[2] * COLOR_RATIO);
	return r*36 + g*6 + b*1 + 16;
}
/**
 * Export to Node.js module
 */
for (var p in ROT) {
	exports[p] = ROT[p];
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":"/Users/seiyria/GitHub/Roguathia/node_modules/process/browser.js"}],"/Users/seiyria/GitHub/Roguathia/node_modules/util/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/Users/seiyria/GitHub/Roguathia/node_modules/util/util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":"/Users/seiyria/GitHub/Roguathia/node_modules/util/support/isBufferBrowser.js","_process":"/Users/seiyria/GitHub/Roguathia/node_modules/process/browser.js","inherits":"/Users/seiyria/GitHub/Roguathia/node_modules/util/node_modules/inherits/inherits_browser.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Dungeon.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

var _rogueInitGamestate = require('../../rogue/init/gamestate');

var _rogueInitGamestate2 = _interopRequireDefault(_rogueInitGamestate);

_module3['default'].controller('Dungeon', function ($scope) {

  $scope.currentFloor = 0;

  _rogueInitGamestate2['default'].on('start', function () {
    $scope.world = _rogueInitGamestate2['default'].world;
    $scope.victory = _rogueInitGamestate2['default'].winCondition;
    $scope.currentFloor = _rogueInitGamestate2['default'].currentFloor;
  });

  _rogueInitGamestate2['default'].on('descend', function () {
    $scope.currentFloor = _rogueInitGamestate2['default'].currentFloor;
  });
});

},{"../../rogue/init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Log.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _rogueLibLogger = require('../../rogue/lib/logger');

var _rogueLibLogger2 = _interopRequireDefault(_rogueLibLogger);

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

var _rogueInitGamestate = require('../../rogue/init/gamestate');

var _rogueInitGamestate2 = _interopRequireDefault(_rogueInitGamestate);

var _rogueDisplayMessageHandler = require('../../rogue/display/message-handler');

_module3['default'].controller('Log', function ($scope, $localStorage) {

  $localStorage.filters = $localStorage.filters || {
    Meta: true,
    Item: true,
    Combat: true,
    Dungeon: true
  };

  $localStorage.deathLog = $localStorage.deathLog || [];

  $scope.filters = $localStorage.filters;
  $scope.deathLog = $localStorage.deathLog;

  $scope.log = [];

  var addMessage = function addMessage(msgObj) {
    if (!msgObj.type) {
      (0, _rogueLibLogger2['default'])('GameLog', 'Message "' + msgObj.message + '" has no type');
    }

    $scope.log.push(msgObj);

    if ($scope.log.length > 100) {
      $scope.log.shift();
    }
  };

  var addMetaMessage = function addMetaMessage(msg) {
    addMessage({ message: msg, type: _rogueDisplayMessageHandler.MessageTypes.META, turn: $scope.log[$scope.log.length - 1].turn + 1 });
  };

  _rogueInitGamestate2['default'].on('gameend.victory', function () {
    addMetaMessage('You win!');
    addMetaMessage('You earned ' + _rogueInitGamestate2['default'].spEarned + ' SP, ' + _rogueInitGamestate2['default'].kpEarned + ' KP, and ' + _rogueInitGamestate2['default'].vpEarned + ' VP.');
  });

  _rogueInitGamestate2['default'].on('gameend.gameover', function () {
    addMetaMessage('Game over! Everyone died.');
    addMetaMessage('You earned ' + _rogueInitGamestate2['default'].spEarned + ' SP and ' + _rogueInitGamestate2['default'].kpEarned + ' KP.');
  });

  _rogueInitGamestate2['default'].on('log', function (logObj) {
    addMessage(logObj);
  });

  _rogueInitGamestate2['default'].on('die', function (player) {
    $scope.deathLog.unshift({
      name: player.name,
      level: player.level,
      align: player.getAlign(),
      gender: player.gender,
      title: player.professionInst.title,
      race: player.race,
      profession: player.profession,
      floor: _rogueInitGamestate2['default'].currentFloor,
      spEarned: player.getScore(),
      deathTime: Date.now()
    });

    if ($scope.deathLog.length > 25) {
      $scope.deathLog.pop();
    }
  });
});

},{"../../rogue/display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../../rogue/init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../rogue/lib/logger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js","../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Options.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

var _rogueInitGamestate = require('../../rogue/init/gamestate');

var _rogueInitGamestate2 = _interopRequireDefault(_rogueInitGamestate);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

_module3['default'].controller('Options', function ($scope) {

  $scope.seppuku = function () {
    _lodash2['default'].each(_rogueInitGamestate2['default'].players, function (p) {
      if (!p.hp.atMin()) {
        p.die({ name: 'Seppuku' });
      }
    });
  };

  $scope.getCurrentSpKp = function () {
    $scope.spEarned = _rogueInitGamestate2['default'].spEarned;
    $scope.kpEarned = _rogueInitGamestate2['default'].kpEarned;
  };
});

},{"../../rogue/init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Party.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

var _rogueInitGamestate = require('../../rogue/init/gamestate');

var _rogueInitGamestate2 = _interopRequireDefault(_rogueInitGamestate);

_module3['default'].controller('Party', function ($scope, $uibModal, $timeout) {

  $scope.inventoryOffset = function () {
    return 60 + document.getElementsByClassName('player-block')[0].offsetHeight;
  };

  $scope.countSlotsTaken = function (equipment) {
    return _lodash2['default'].reduce(equipment, function (prev, item) {
      return prev + item.slotsTaken;
    }, 0);
  };

  $scope.openEditWindow = function (player, index) {
    $uibModal.open({
      templateUrl: 'player-edit',
      controller: 'PartyMemberEdit',
      keyboard: false,
      backdrop: 'static',
      resolve: { player: player, index: index }
    });
  };

  $scope.isBelow = function (player, stat, threshold) {
    return player[stat].cur / player[stat].max * 100 < threshold;
  };
  $scope.isAbove = function (player, stat, threshold) {
    return player[stat].cur / player[stat].max * 100 > threshold;
  };

  _rogueInitGamestate2['default'].on('redraw', function () {

    $timeout(function () {
      $scope.players = _rogueInitGamestate2['default'].players;
    });
  });
});

_module3['default'].controller('PartyMemberEdit', function ($scope, $uibModalInstance, TemplateDataManager, UpgradeDataManager, player, index) {
  $scope.close = $uibModalInstance.close;

  var upgradesBySplit = function upgradesBySplit(split) {
    var defaultVal = arguments.length <= 1 || arguments[1] === undefined ? 'Random' : arguments[1];

    return [{ key: defaultVal, val: undefined }].concat((0, _lodash2['default'])(UpgradeDataManager.upgrades).filter(function (u) {
      return _lodash2['default'].contains(u, split);
    }).map(function (u) {
      return u.split(split)[1].trim();
    }).map(function (u) {
      return { key: u, val: u };
    }).value());
  };

  $scope.templateDataManager = TemplateDataManager;
  $scope.upgradeDataManager = UpgradeDataManager;
  $scope.index = index;
  $scope.player = player;

  $scope.genders = [{ key: 'Random', val: undefined }, { key: 'Male', val: 'Male' }, { key: 'Female', val: 'Female' }];

  $scope.aligns = [{ key: 'Random', val: undefined }, { key: 'Eviler', val: -200 }, { key: 'Evil', val: -100 }, { key: 'Neutral', val: 0 }, { key: 'Good', val: 100 }, { key: 'Gooder', val: 200 }];

  $scope.professions = upgradesBySplit('Class:');

  $scope.races = upgradesBySplit('Race:');

  $scope.colors = [{ key: 'Default', val: undefined }, { key: 'Red', val: '#f00' }, { key: 'Blue', val: '#00f' }, { key: 'Green', val: '#0f0' }, { key: 'Yellow', val: '#ff0' }, { key: 'Cyan', val: '#0ff' }, { key: 'Magenta', val: '#f0f' }];

  $scope.greater = upgradesBySplit('Trait: G.', 'None');
  $scope.lesser = upgradesBySplit('Trait: L.', 'None');
  $scope.utility = upgradesBySplit('Trait: U.', 'None');
  $scope.buff = upgradesBySplit('Buff:', 'None');

  $scope.ais = [{ key: 'Explore Dungeon', val: undefined }, { key: 'Wander', val: 'Wander' }];
});

},{"../../rogue/init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Root.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

_module3['default'].controller('Root', function ($scope, $http, $interval, $window) {

  // get the current version
  $http.get('version.json').then(function (res) {
    $scope.tag = res.data.tag;
  });

  // title is either the game name or with the version tag if available
  $scope.title = function () {
    if ($scope.tag) {
      return 'Roguathia v' + $scope.tag;
    }

    return 'Roguathia';
  };

  $scope.reload = function () {
    return $window.location.reload();
  };

  // check for an update every 10 minutes
  $interval(function () {
    $http.get('https://api.github.com/repos/seiyria/Roguathia/tags').then(function (res) {
      $scope.latestTag = res.data ? res.data[0].name : null;
      $scope.updateAvailable = $scope.tag != $scope.latestTag;
    });
  }, 600000);
});

},{"../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Upgrades.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

var _rogueInitGamestate = require('../../rogue/init/gamestate');

var _rogueInitGamestate2 = _interopRequireDefault(_rogueInitGamestate);

var _rogueInitInit = require('../../rogue/init/init');

var _rogueInitGameupgrades = require('../../rogue/init/gameupgrades');

var _rogueConstantsUpgrades = require('../../rogue/constants/upgrades');

var _rogueConstantsUpgrades2 = _interopRequireDefault(_rogueConstantsUpgrades);

_module3['default'].filter('visibleUpgrades', function (CurrencyDataManager, UpgradeDataManager) {
  return function (upgrades, type) {
    return _lodash2['default'].filter(upgrades, function (upgrade) {
      return upgrade.cost / 2 < CurrencyDataManager.currency[type] && upgrade.currency === type && UpgradeDataManager.canSeeUpgrade(upgrade);
    });
  };
});

_module3['default'].controller('Upgrades', function ($scope, $localStorage, $timeout, CurrencyDataManager, UpgradeDataManager, TemplateDataManager) {

  $scope.upgrades = _rogueConstantsUpgrades2['default'];
  $scope.upgradeDataManager = UpgradeDataManager;
  $scope.currencyDataManager = CurrencyDataManager;

  var curState = {};

  $scope.buyUpgrade = function (upgrade) {
    if (!UpgradeDataManager.buyUpgrade(upgrade)) return;
    if (upgrade.operate) upgrade.operate(curState);
  };

  var rebuildUpgrades = function rebuildUpgrades() {
    var newState = curState = (0, _rogueInitGameupgrades.NewState)();

    _lodash2['default'].each(newState.unlocked.race.concat(newState.unlocked.profession), function (random) {
      if (_lodash2['default'].contains(UpgradeDataManager.upgrades, 'Random: ' + random)) return;
      UpgradeDataManager.upgrades.push('Random: ' + random);
    });

    _lodash2['default'].each(UpgradeDataManager.upgrades, function (name) {
      var upgrade = _lodash2['default'].findWhere(_rogueConstantsUpgrades2['default'], { name: name });
      if (upgrade && upgrade.operate) upgrade.operate(newState);
    });

    newState.templates = TemplateDataManager.templates;

    (0, _rogueInitGameupgrades.SetState)(newState);
  };

  var getCurrencyFrom = function getCurrencyFrom(store) {
    _lodash2['default'].each(['sp', 'kp', 'vp'], function (key) {
      var add = store[key + 'Earned'] || 0;
      CurrencyDataManager.addCurrency(key, add);
    });
  };

  if ($localStorage.saveStateCache) {
    getCurrencyFrom($localStorage.saveStateCache);
    $localStorage.saveStateCache = null;
  }

  rebuildUpgrades();
  (0, _rogueInitInit.StartGameCycle)();

  _rogueInitGamestate2['default'].on('redraw', function () {
    $localStorage.saveStateCache = {
      spEarned: _rogueInitGamestate2['default'].spEarned,
      kpEarned: _rogueInitGamestate2['default'].kpEarned
    };
  });

  var awardCurrency = function awardCurrency() {

    $timeout(function () {
      getCurrencyFrom(_rogueInitGamestate2['default']);

      $localStorage.saveStateCache = null;

      rebuildUpgrades();
    });
  };

  _rogueInitGamestate2['default'].on('gameend.gameover', awardCurrency);
  _rogueInitGamestate2['default'].on('gameend.victory', awardCurrency);
});

},{"../../rogue/constants/upgrades":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/upgrades.js","../../rogue/init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../rogue/init/gameupgrades":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gameupgrades.js","../../rogue/init/init":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/init.js","../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/directives/fill-height.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

_module3['default'].directive('fillHeight', function ($window, $parse) {
  return {
    scope: {
      scrollBottom: '='
    },
    link: function link(scope, element, attrs) {
      var setSize = function setSize() {
        element[0].style.height = $window.innerHeight - ($parse(attrs.offset)(scope) || 0) + 'px';
      };

      setSize();

      angular.element($window).bind('resize', setSize);

      scope.$watch(function () {
        return attrs.offset;
      }, setSize);

      if (scope.scrollBottom) {
        scope.$watchCollection('scrollBottom', function (newValue) {
          if (!newValue) return;
          element[0].scrollTop = element[0].scrollHeight;
        });
      }
    }
  };
});

},{"../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/directives/tabs/log-tab.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _module2 = require('../../module');

var _module3 = _interopRequireDefault(_module2);

_module3['default'].directive('log', function () {
  return {
    controller: 'Log',
    restrict: 'E',
    templateUrl: 'log-tab'
  };
});

},{"../../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/init.js":[function(require,module,exports){
'use strict';

require('./controllers/Root');

require('./controllers/Party');

require('./controllers/Log');

require('./controllers/Dungeon');

require('./controllers/Options');

require('./controllers/Upgrades');

require('./services/UpgradeDataManager');

require('./services/CurrencyDataManager');

require('./services/TemplateDataManager');

require('./directives/tabs/log-tab');

require('./directives/fill-height');

},{"./controllers/Dungeon":"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Dungeon.js","./controllers/Log":"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Log.js","./controllers/Options":"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Options.js","./controllers/Party":"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Party.js","./controllers/Root":"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Root.js","./controllers/Upgrades":"/Users/seiyria/GitHub/Roguathia/src/js/angular/controllers/Upgrades.js","./directives/fill-height":"/Users/seiyria/GitHub/Roguathia/src/js/angular/directives/fill-height.js","./directives/tabs/log-tab":"/Users/seiyria/GitHub/Roguathia/src/js/angular/directives/tabs/log-tab.js","./services/CurrencyDataManager":"/Users/seiyria/GitHub/Roguathia/src/js/angular/services/CurrencyDataManager.js","./services/TemplateDataManager":"/Users/seiyria/GitHub/Roguathia/src/js/angular/services/TemplateDataManager.js","./services/UpgradeDataManager":"/Users/seiyria/GitHub/Roguathia/src/js/angular/services/UpgradeDataManager.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _module = angular.module('Roguathia', ['ui.bootstrap', 'ngStorage']);

_module.run(["$rootScope", function ($rootScope) {
  return $rootScope._ = _lodash2['default'];
}]);

exports['default'] = _module;
module.exports = exports['default'];

},{"lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/services/CurrencyDataManager.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

_module3['default'].service('CurrencyDataManager', function ($localStorage) {

  if (!$localStorage.currency) {
    $localStorage.currency = { sp: 0, kp: 0, vp: 0 };
  }

  var currency = $localStorage.currency;

  var addCurrency = function addCurrency(key, val) {
    currency[key] += val;
    $localStorage.currency = currency;
  };

  var hasCurrency = function hasCurrency(key, val) {
    return currency[key] >= val;
  };

  var useCurrency = function useCurrency(key, val) {
    if (!hasCurrency(key, val)) return;
    addCurrency(key, -val);
  };

  return {
    addCurrency: addCurrency,
    hasCurrency: hasCurrency,
    useCurrency: useCurrency,
    currency: currency
  };
});

},{"../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/services/TemplateDataManager.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

_module3['default'].service('TemplateDataManager', function ($localStorage) {

  if (!$localStorage.templates) {
    $localStorage.templates = [];
  }

  var templates = $localStorage.templates;

  return {
    templates: templates
  };
});

},{"../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/angular/services/UpgradeDataManager.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _module2 = require('../module');

var _module3 = _interopRequireDefault(_module2);

_module3['default'].service('UpgradeDataManager', function (CurrencyDataManager, $localStorage) {

  if (!$localStorage.upgrades) {
    $localStorage.upgrades = [];
  }

  var upgrades = $localStorage.upgrades;

  var _hasUpgrade = function _hasUpgrade(upgradeName) {
    return _lodash2['default'].contains(upgrades, upgradeName);
  };
  var hasUpgrade = function hasUpgrade(upgrade) {
    return _hasUpgrade(upgrade.name);
  };

  var hasUpgradeReq = function hasUpgradeReq(upgrade) {
    return upgrade.req ? _hasUpgrade(upgrade.req) : true;
  };

  var buyUpgrade = function buyUpgrade(upgrade) {
    if (!CurrencyDataManager.hasCurrency(upgrade.currency, upgrade.cost)) return;
    if (!hasUpgradeReq(upgrade)) return;
    CurrencyDataManager.useCurrency(upgrade.currency, upgrade.cost);
    upgrades.push(upgrade.name);
    $localStorage.upgrades = upgrades;
  };

  var canSeeUpgrade = function canSeeUpgrade(upgrade) {
    return !hasUpgrade(upgrade) && hasUpgradeReq(upgrade);
  };

  return {
    buyUpgrade: buyUpgrade,
    hasUpgrade: hasUpgrade,
    _hasUpgrade: _hasUpgrade,
    canSeeUpgrade: canSeeUpgrade,
    upgrades: upgrades
  };
});

},{"../module":"/Users/seiyria/GitHub/Roguathia/src/js/angular/module.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/init.js":[function(require,module,exports){
'use strict';

require('./angular/init');

},{"./angular/init":"/Users/seiyria/GitHub/Roguathia/src/js/angular/init.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/conducts.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var conducts = [
// breakable conducts
{ check: function check(player) {
    return !player.brokenConduct.stubborn;
  }, affirmMessage: 'You never changed equipment.' }, { check: function check(player) {
    return !player.brokenConduct.wieldedWeapon;
  }, affirmMessage: 'You never hit with a wielded weapon.' }, { check: function check(player) {
    return !player.brokenConduct.pacifist;
  }, affirmMessage: 'You %were a pacifist.' }, { check: function check(player) {
    return !player.brokenConduct.nudist;
  }, affirmMessage: 'You never equipped armor.' }, { check: function check(player) {
    return !player.brokenConduct.celibate;
  }, affirmMessage: 'You %were celibate.' }, { check: function check(player) {
    return player.brokenConduct.lifeSave;
  }, affirmMessage: 'Your life %was saved.' },

// traits
{ check: function check(player) {
    return player.hasTrait('Infravision');
  }, affirmMessage: 'You %had infravision.' }, { check: function check(player) {
    return player.hasTrait('Protection');
  }, affirmMessage: 'You %had protection.' }, { check: function check(player) {
    return player.hasTrait('Clairvoyance');
  }, affirmMessage: 'You %had clairvoyance.' }, { check: function check(player) {
    return player.hasTrait('Warning');
  }, affirmMessage: 'You %were warned.' }, { check: function check(player) {
    return player.hasTrait('Telepathy');
  }, affirmMessage: 'You %were telepathic.' }, { check: function check(player) {
    return player.hasTrait('Stealth');
  }, affirmMessage: 'You %were stealthy.' }, { check: function check(player) {
    return player.hasTrait('Invisible');
  }, affirmMessage: 'You %were invisible.' }, { check: function check(player) {
    return player.hasTrait('SeeInvisible');
  }, affirmMessage: 'You %could see invisible.' }, { check: function check(player) {
    return player.getSpeed() > _settings2['default'].game.baseSpeed;
  }, affirmMessage: 'You %were fast.' }, { check: function check(player) {
    return player.getSpeed() < _settings2['default'].game.baseSpeed;
  }, affirmMessage: 'You %were slow.' }, { check: function check(player) {
    return player.hasTrait('PoisonResistance');
  }, affirmMessage: 'You %were poison resistant.' }, { check: function check(player) {
    return player.hasTrait('ShockResistance');
  }, affirmMessage: 'You %were shock resistant.' }, { check: function check(player) {
    return player.hasTrait('FireResistance');
  }, affirmMessage: 'You %were fire resistant.' }, { check: function check(player) {
    return player.hasTrait('AcidResistance');
  }, affirmMessage: 'You %were acid resistant.' }, { check: function check(player) {
    return player.hasTrait('IceResistance');
  }, affirmMessage: 'You %were ice resistant.' },

// statuses
{ check: function check(player) {
    return player.hasBehavior('Stunned');
  }, affirmMessage: 'You %were stunned.' }, { check: function check(player) {
    return player.hasBehavior('Poisoned');
  }, affirmMessage: 'You %were poisoned.' }, { check: function check(player) {
    return player.hasBehavior('Seduced');
  }, affirmMessage: 'You %were seduced.' },

// alignment
{ check: function check(player) {
    return player.getAlign() === 0;
  }, affirmMessage: 'You %were neutral.' }, { check: function check(player) {
    return player.getAlign() < 0;
  }, affirmMessage: 'You %were evil.' }, { check: function check(player) {
    return player.getAlign() > 0;
  }, affirmMessage: 'You %were good.' },

// you probably always see this
{ check: function check(player) {
    return player.hp.atMin();
  }, affirmMessage: 'You died.' }];

exports['default'] = function (player) {
  var finalConduct = [];

  var tenses = [{ split: '%could', past: 'could', now: 'can' }, { split: '%were', past: 'were', now: 'are' }, { split: '%was', past: 'was', now: 'will be' }, { split: '%had', past: 'had', now: 'have' }];

  var adjustMessage = function adjustMessage(msg) {
    return _lodash2['default'].reduce(tenses, function (prev, obj) {
      return prev.split(obj.split).join(player.hp.atMin() ? obj.past : obj.now);
    }, msg);
  };
  var addMessage = function addMessage(msg) {
    return finalConduct.push(adjustMessage(msg));
  };

  _lodash2['default'].each(conducts, function (conduct) {
    if (conduct.check(player)) {
      addMessage(conduct.affirmMessage);
    } else if (conduct.rejectMessage) {
      addMessage(conduct.rejectMessage);
    }
  });

  return _lodash2['default'].sortBy(finalConduct);
};

module.exports = exports['default'];

},{"./settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var rarity = function rarity(_rarity) {
  return function (target) {
    return target.__defineGetter__('rarity', function () {
      return _rarity;
    }), target;
  };
};
exports.rarity = rarity;
var material = function material(_material) {
  return function (target) {
    return target.prototype.material = _material, target;
  };
};
exports.material = material;
var twoHanded = function twoHanded(target) {
  return target.prototype.slotsTaken = 2, target;
};
exports.twoHanded = twoHanded;
var ranged = function ranged(range) {
  return function (target) {
    return target.prototype.range = _lodash2['default'].extend({ numShots: 1, damageBoost: '0d0', ammo: [] }, range), target;
  };
};
exports.ranged = ranged;

},{"lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/factions.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = {
  MONSTER: 'Monster',
  PLAYER: 'Player',

  MAGIC: 'Magic',

  ALL: 'all'
};
module.exports = exports['default'];

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/faketypes.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var Ring = ['pearl', 'iron', 'twisted', 'steel', 'wire', 'engagement', 'shiny', 'bronze', 'brass', 'copper', 'silver', 'gold', 'wooden', 'granite', 'opal', 'clay', 'coral', 'black onyx', 'moonstone', 'tiger eye', 'jade', 'agate', 'topaz', 'sapphire', 'ruby', 'diamond', 'ivory', 'emerald'];

exports.Ring = Ring;
var Potion = ['ruby', 'dark green', 'purple-red', 'smoky', 'brown', 'pink', 'cyan', 'puce', 'cloudy', 'fizzy', 'orange', 'sky blue', 'milky', 'effervescent', 'dark', 'yellow', 'brilliant blue', 'swirly', 'black', 'white', 'emerald', 'magenta', 'bubbly', 'golden', 'murky'];
exports.Potion = Potion;

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var Entities = {
  Elements: {
    Water: 'blue',
    Fire: 'red',
    Shock: 'green',
    Ice: 'lightblue'
  },
  Tiers: {
    Basic: 'gray',
    Weak: 'brown',
    Inadequate: 'orange',
    Moderate: 'yellow',
    Adequate: 'red',
    Strong: '',
    Powerful: '',
    Difficult: '',
    Nightmarish: ''
  },
  Colors: {
    Black: 'gray', // it would be impossible to see if it were really black
    Yellow: 'yellow',
    Green: 'green',
    Brown: 'brown',
    Red: 'red',
    Blue: 'blue'
  }
};

exports.Entities = Entities;
var Items = {
  Gold: 'gold'
};

exports.Items = Items;
var Tiles = {
  Door: 'gold',
  Fountain: '#00f',
  Sink: '#d3d3ff',
  Throne: 'yellow'
};

exports.Tiles = Tiles;
var Special = {
  Selyk: '#f0f'
};
exports.Special = Special;

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var Entities = {
  Player: '@',

  Ant: 'a',
  Canine: 'd',
  Demon: '&',
  Elemental: 'E',
  Gnome: 'G',
  Humanoid: 'h',
  Jelly: 'j',
  Kobold: 'k',
  Lizard: ':',
  Mystical: 'x',
  Nymph: 'n',
  Orc: 'o',
  Pudding: 'P',
  Rat: 'r',
  Snake: 'S',
  Spore: 'e'
};

exports.Entities = Entities;
var Items = {
  Body: '[',
  Cloak: '[',
  Comestible: '%',
  Feet: '[',
  Gem: '*',
  Gold: '$',
  Hands: ')',
  Head: '[',
  Neck: '"',
  Potion: '!',
  Ring: '=',
  Scroll: '?',
  Spellbook: '+',
  Tool: '(',
  Wand: '/',
  Wrist: '['
};

exports.Items = Items;
var Tiles = {
  Altar: '_',
  Corridor: '#',
  DoorClosed: '+',
  DoorOpenHorizontal: '-',
  DoorOpenVertical: '|',
  Floor: '.',
  Fountain: '{',
  Sink: '#',
  StairsDown: '>',
  StairsUp: '<',
  Throne: '\\',
  WallHorizontal: '-',
  WallVertical: '|'
};
exports.Tiles = Tiles;

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var materials = {
  Unknown: 0,
  Cloth: 1, // can burn, rot
  Leather: 2, // can burn, rot
  Iron: 3, // can rust, corrode
  Mithril: 4,
  Copper: 5, // can corrode
  Glass: 6, // can burn (melt), explode (if potion), shatter
  Dragon: 7,
  Wood: 8, // can burn, rot,
  Food: 9,
  Silver: 10,
  Gold: 11,
  Mineral: 12,
  Plastic: 13, // can burn
  Stone: 14 // can corrode
};

exports['default'] = materials;
var AffectedByFire = function AffectedByFire(item) {
  return _lodash2['default'].contains([materials.Cloth, materials.Leather, materials.Glass, materials.Wood, materials.Plastic], item.material);
};
exports.AffectedByFire = AffectedByFire;
var AffectedByAcid = function AffectedByAcid(item) {
  return _lodash2['default'].contains([materials.Iron, materials.Copper, materials.Stone], item.material);
};
exports.AffectedByAcid = AffectedByAcid;
var AffectedByPoison = function AffectedByPoison(item) {
  return _lodash2['default'].contains([materials.Wood, materials.Cloth, materials.Leather], item.material);
};
exports.AffectedByPoison = AffectedByPoison;
var AffectedByIce = function AffectedByIce(item) {
  return _lodash2['default'].contains([materials.Glass], item.material);
};
exports.AffectedByIce = AffectedByIce;

},{"lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/random.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _contentItemsFoods = require('../content/items/foods');

var Foods = _interopRequireWildcard(_contentItemsFoods);

var _contentItemsFeets = require('../content/items/feets');

var Feets = _interopRequireWildcard(_contentItemsFeets);

var _contentItemsHeads = require('../content/items/heads');

var Heads = _interopRequireWildcard(_contentItemsHeads);

var _contentItemsBodys = require('../content/items/bodys');

var Bodys = _interopRequireWildcard(_contentItemsBodys);

var _contentItemsRings = require('../content/items/rings');

var Rings = _interopRequireWildcard(_contentItemsRings);

var _contentItemsNecks = require('../content/items/necks');

var Necks = _interopRequireWildcard(_contentItemsNecks);

var _contentItemsWands = require('../content/items/wands');

var Wands = _interopRequireWildcard(_contentItemsWands);

var _contentItemsWrists = require('../content/items/wrists');

var Wrists = _interopRequireWildcard(_contentItemsWrists);

var _contentItemsCloaks = require('../content/items/cloaks');

var Cloaks = _interopRequireWildcard(_contentItemsCloaks);

var _contentItems_weapons = require('../content/items/_weapons');

var Weapons = _interopRequireWildcard(_contentItems_weapons);

var _contentItemsPotions = require('../content/items/potions');

var Potions = _interopRequireWildcard(_contentItemsPotions);

var _contentItemsSpellbooks = require('../content/items/spellbooks');

var Spellbooks = _interopRequireWildcard(_contentItemsSpellbooks);

var _contentItemsProjectiles = require('../content/items/projectiles');

var Projectiles = _interopRequireWildcard(_contentItemsProjectiles);

var _contentProfessions_all = require('../content/professions/_all');

var Professions = _interopRequireWildcard(_contentProfessions_all);

var _contentRaces_all = require('../content/races/_all');

var Races = _interopRequireWildcard(_contentRaces_all);

var getRandom = function getRandom(from) {
  var exclude = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  return (0, _lodash2['default'])(from).values().filter(function (type) {
    return !_lodash2['default'].contains(exclude, type.name);
  }).sample();
};

var Food = function Food(opts, exclude) {
  return new (getRandom(Foods, exclude))(opts);
};
exports.Food = Food;
var Feet = function Feet(opts, exclude) {
  return new (getRandom(Feets, exclude))(opts);
};
exports.Feet = Feet;
var Head = function Head(opts, exclude) {
  return new (getRandom(Heads, exclude))(opts);
};
exports.Head = Head;
var Body = function Body(opts, exclude) {
  return new (getRandom(Bodys, exclude))(opts);
};
exports.Body = Body;
var Ring = function Ring(opts, exclude) {
  return new (getRandom(Rings, exclude))(opts);
};
exports.Ring = Ring;
var Neck = function Neck(opts, exclude) {
  return new (getRandom(Necks, exclude))(opts);
};
exports.Neck = Neck;
var Wand = function Wand(opts, exclude) {
  return new (getRandom(Wands, exclude))(opts);
};
exports.Wand = Wand;
var Wrist = function Wrist(opts, exclude) {
  return new (getRandom(Wrists, exclude))(opts);
};
exports.Wrist = Wrist;
var Cloak = function Cloak(opts, exclude) {
  return new (getRandom(Cloaks, exclude))(opts);
};
exports.Cloak = Cloak;
var Weapon = function Weapon(opts, exclude) {
  return new (getRandom(Weapons, exclude))(opts);
};
exports.Weapon = Weapon;
var Potion = function Potion(opts, exclude) {
  return new (getRandom(Potions, exclude))(opts);
};
exports.Potion = Potion;
var Spellbook = function Spellbook(opts, exclude) {
  return new (getRandom(Spellbooks, exclude))(opts);
};
exports.Spellbook = Spellbook;
var Projectile = function Projectile(opts, exclude) {
  return new (getRandom(Projectiles, exclude))(opts);
};
exports.Projectile = Projectile;
var Profession = function Profession(opts) {
  var exclude = arguments.length <= 1 || arguments[1] === undefined ? ['Monster', 'Developer'] : arguments[1];
  return new (getRandom(Professions, exclude))(opts);
};
exports.Profession = Profession;
var Race = function Race(opts) {
  var exclude = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  return new (getRandom(Races, exclude))(opts);
};
exports.Race = Race;

},{"../content/items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../content/items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../content/items/cloaks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/cloaks.js","../content/items/feets":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/feets.js","../content/items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../content/items/heads":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/heads.js","../content/items/necks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/necks.js","../content/items/potions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js","../content/items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js","../content/items/rings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/rings.js","../content/items/spellbooks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/spellbooks.js","../content/items/wands":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/wands.js","../content/items/wrists":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/wrists.js","../content/professions/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/_all.js","../content/races/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = {
  screen: {
    width: 80,
    height: 24
  },
  game: {
    turnDelay: 100,
    killXpDivisor: 5,
    minStatValue: 3,
    alignThreshold: 100,
    baseAC: 10,
    spawnSteps: 20,
    nameLength: 12,

    display: {
      turns: 4,
      log: 50
    },

    defaultStats: {
      monster: {
        str: 8,
        con: 8,
        dex: 8,
        int: 8,
        wis: 8,
        cha: 8
      },

      attributes: {
        ac: 0,
        str: 8,
        con: 8,
        dex: 8,
        int: 8,
        wis: 8,
        cha: 8,
        luk: 0,
        gold: 0,
        level: 1,
        align: 0,
        speed: 100,
        sight: 4,
        sound: 50,
        killXp: '0d0',
        spawnHp: '15d1',
        spawnMp: '0d0',
        regenHp: 20,
        regenMp: 10
      },

      stats: {
        gender: 'Male',
        name: 'Dudley',
        race: 'Human',
        attacks: [],
        behaviors: [],
        profession: 'Developer'
      },

      profession: {
        hp: '0d0',
        mp: '0d0',
        ac: 0,
        str: 0,
        con: 0,
        int: 0,
        dex: 0,
        wis: 0,
        cha: 0,
        luk: 0,
        speed: 0,
        sight: 0,
        spawnSteps: 0,
        addFactions: [],
        addBehaviors: [],
        titles: [],
        attacks: [],
        traits: [],
        skillCaps: {}
      },

      equipmentSlots: {
        hands: 2,
        head: 1,
        body: 1,
        feet: 2,
        wrist: 2,
        cloak: 1,
        neck: 1,
        ring: 2
      },

      race: {
        ac: 0,
        hp: 0,
        mp: 0,
        str: 0,
        con: 0,
        int: 0,
        dex: 0,
        wis: 0,
        cha: 0,
        luk: 0,
        speed: 0,
        sight: 0,
        spawnSteps: 0,
        addFactions: [],
        addBehaviors: [],
        attacks: [],
        traits: [],
        skillBonus: {}
      }
    }
  },
  upgradeParameters: {
    MAX_FEATURE_SPAWN_CHANCE: 10000
  },
  upgrades: {
    itemsInDungeon: 0,
    itemDropChance: 0,
    altarSpawnChance: 0,
    templeSpawnChance: 0,
    throneSpawnChance: 0,
    throneRoomSpawnChance: 0,
    graveSpawnChance: 0,
    graveyardSpawnChance: 0,
    fountainSpawnChance: 0,
    oracleRoomChance: 0,
    sinkSpawnChance: 0,
    bathroomSpawnChance: 0,
    monsterLimit: 10,
    maxDifficulty: 5,
    depth: 0,
    respawnTime: 0
  },
  upgradesMax: {
    itemsInDungeon: 20,
    itemDropChance: 75,
    altarSpawnChance: 1000,
    templeSpawnChance: 100,
    throneSpawnChance: 1000,
    throneRoomSpawnChance: 100,
    graveSpawnChance: 1000,
    graveyardSpawnChance: 100,
    fountainSpawnChance: 1000,
    oracleRoomChance: 100,
    sinkSpawnChance: 1000,
    bathroomSpawnChance: 100,
    monsterLimit: 50,
    maxDifficulty: 55,
    depth: 100,
    respawnTime: 10
  }
};
module.exports = exports['default'];

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var Unskilled = 0;
exports.Unskilled = Unskilled;
var Basic = 1;
exports.Basic = Basic;
var Competent = 2;
exports.Competent = Competent;
var Skilled = 3;
exports.Skilled = Skilled;
var Expert = 4;
exports.Expert = Expert;
var Master = 5;
exports.Master = Master;
var Grandmaster = 6;
exports.Grandmaster = Grandmaster;
var Legendary = 7;

exports.Legendary = Legendary;
exports['default'] = [{ name: 'Unskilled', max: 0 }, { name: 'Basic', max: 20 }, { name: 'Competent', max: 80 }, { name: 'Skilled', max: 180 }, { name: 'Expert', max: 320 }, { name: 'Master', max: 500 }, { name: 'Grandmaster', max: 750 }, { name: 'Legendary', max: 1000 }];

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/upgrades.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _contentProfessions_all = require('../content/professions/_all');

var _contentProfessions_all2 = _interopRequireDefault(_contentProfessions_all);

var _contentRaces_all = require('../content/races/_all');

var _contentRaces_all2 = _interopRequireDefault(_contentRaces_all);

var _contentTraits_all = require('../content/traits/_all');

var Traits = _interopRequireWildcard(_contentTraits_all);

var upgrades = [{ name: 'Rename Tag',
  help: 'Allow for renaming of player characters.',
  cost: 100000,
  currency: 'sp' }, { name: 'Color Tag',
  help: 'Allow for changing of player characters color.',
  cost: 100000,
  currency: 'sp' }];

// SP
_lodash2['default'].each(_lodash2['default'].keys(_contentProfessions_all2['default']), function (profession) {
  upgrades.push({ name: 'Random: ' + profession,
    help: 'This class (' + profession + ') will show up randomly.',
    cost: 10000,
    currency: 'sp',
    operate: function operate(upgradeData) {
      return upgradeData.unlocked.profession.push(profession);
    }
  });

  upgrades.push({ name: 'Class: ' + profession,
    help: 'This class (' + profession + ') can be selected for all party members.',
    req: 'Random: ' + profession,
    unlockedProfession: profession,
    cost: 50000,
    currency: 'sp',
    operate: function operate(upgradeData) {
      return upgradeData.selectable.profession.push(profession);
    }
  });
});

_lodash2['default'].each(_lodash2['default'].keys(_contentRaces_all2['default']), function (race) {
  upgrades.push({ name: 'Random: ' + race,
    help: 'This race (' + race + ') will show up randomly.',
    cost: 20000,
    currency: 'sp',
    operate: function operate(upgradeData) {
      return upgradeData.unlocked.race.push(race);
    }
  });

  upgrades.push({ name: 'Race: ' + race,
    help: 'This race (' + race + ') can be selected for all party members.',
    req: 'Random: ' + race,
    unlockedRace: race,
    cost: 80000,
    currency: 'sp',
    operate: function operate(upgradeData) {
      return upgradeData.selectable.race.push(race);
    }
  });
});

_lodash2['default'].each(['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA', 'LUK'], function (stat) {
  upgrades.push({
    name: 'Trait: L. ' + stat,
    help: 'Lesser ' + stat + ' grants +1 ' + stat + ' when assigned to a character.',
    cost: 5000,
    currency: 'sp'
  });

  upgrades.push({
    name: 'Trait: G. ' + stat,
    help: 'Greater ' + stat + ' grants +3 ' + stat + ' when assigned to a character.',
    cost: 50000,
    currency: 'sp'
  });
});

_lodash2['default'].each(_lodash2['default'].keys(Traits), function (trait) {
  upgrades.push({
    name: 'Trait: U. ' + trait,
    help: 'Grants utility for a basic level of ' + trait + ' when assigned to a character',
    cost: 100000,
    currency: 'sp'
  });
});

upgrades.push({
  name: 'Buff: Proficient',
  help: 'The assigned character is more proficient with every weapon.',
  cost: 100000,
  currency: 'sp'
});

upgrades.push({
  name: 'Buff: Higher Level',
  help: 'The assigned character starts at a higher level.',
  cost: 150000,
  currency: 'sp'
});

upgrades.push({
  name: 'Buff: Enchanted Gear',
  help: 'The assigned character gets an enchantment on all of their gear.',
  cost: 200000,
  currency: 'sp'
});

upgrades.push({
  name: 'Buff: Charged Gear',
  help: 'The assigned character gets more charges on all of their gear.',
  cost: 250000,
  currency: 'sp'
});

for (var i = 0; i < 3; i++) {
  upgrades.push({
    name: 'Bigger Party ' + (i + 1),
    help: 'Add one member to your adventuring party.',
    req: i > 0 ? 'Bigger Party ' + i : null,
    currency: 'sp',
    cost: (i + 2) * 150000,
    operate: function operate(upgradeData) {
      return upgradeData.extra.players++;
    }
  });
}
// no more SP

// KP
for (var i = 0; i < 5; i++) {
  upgrades.push({
    name: 'More Monsters ' + (i + 1),
    help: 'More monsters will be able to spawn in the dungeon.',
    req: i > 0 ? 'More Monsters ' + i : null,
    currency: 'kp',
    cost: (i + 1) * 20000,
    operate: function operate(upgradeData) {
      return upgradeData.dungeon.monsterLimit += 5;
    }
  });
}

for (var i = 0; i < 10; i++) {
  upgrades.push({
    name: 'Darker Monsters ' + (i + 1),
    help: 'More difficult monsters will be able to spawn in the dungeon.',
    req: i > 0 ? 'Darker Monsters ' + i : null,
    currency: 'kp',
    cost: (i + 1) * 10000,
    operate: function operate(upgradeData) {
      return upgradeData.dungeon.maxDifficulty += 5;
    }
  });
}
// no more KP

// VP
_lodash2['default'].each(['throne', 'fountain', 'sink'], function (feat) {
  for (var i = 0; i < 5; i++) {
    upgrades.push({
      name: 'Feature: ' + _lodash2['default'].capitalize(feat) + ' ' + (i + 1),
      help: 'The dungeon will spawn ' + feat + 's more frequently.',
      req: i > 0 ? 'Feature: ' + _lodash2['default'].capitalize(feat) + ' ' + i : null,
      currency: 'vp',
      cost: (i + 1) * 10,
      operate: function operate(upgradeData) {
        return upgradeData.dungeon[feat + 'spawnChance'] += 200;
      } // +2%
    });
  }
});

for (var i = 0; i < 9; i++) {
  upgrades.push({
    name: 'Deeper Dungeon ' + (i + 1),
    help: 'The dungeon will get 10 floors deeper.',
    req: i > 0 ? 'Deeper Dungeon ' + i : null,
    currency: 'vp',
    cost: (i + 1) * 20,
    operate: function operate(upgradeData) {
      return upgradeData.dungeon.depth += 10;
    }
  });
}

for (var i = 0; i < 9; i++) {
  upgrades.push({
    name: 'Squarer Dungeon ' + (i + 1),
    help: 'The dungeon will get wider and taller.',
    req: i > 0 ? 'Squarer Dungeon ' + i : null,
    currency: 'vp',
    cost: (i + 1) * 5,
    operate: function operate(upgradeData) {
      return upgradeData.dungeon.squarity += 10;
    }
  });
}

for (var i = 0; i < 5; i++) {
  upgrades.push({
    name: 'Lost and Found ' + (i + 1),
    help: 'More items got lost by previous adventurers, so you can find them!',
    req: i > 0 ? 'Lost and Found ' + i : null,
    currency: 'vp',
    cost: (i + 1) * 15,
    operate: function operate(upgradeData) {
      return upgradeData.dungeon.itemsInDungeon += 4;
    }
  });
}

for (var i = 0; i < 5; i++) {
  upgrades.push({
    name: 'Perception Boost ' + (i + 1),
    help: 'Lost items are more likely to be out in the open.',
    req: i > 0 ? 'Perception Boost ' + i : null,
    currency: 'vp',
    cost: (i + 1) * 25,
    operate: function operate(upgradeData) {
      return upgradeData.dungeon.itemDropChance += 15;
    }
  });
}

for (var i = 0; i < 10; i++) {
  upgrades.push({
    name: 'Faster Respawn ' + (i + 1),
    help: 'Respawn faster so the dungeon can eat you again faster.',
    req: i > 0 ? 'Faster Respawn ' + i : null,
    currency: 'vp',
    cost: (i + 1) * 25,
    operate: function operate(upgradeData) {
      return upgradeData.extra.respawnTime += 1;
    }
  });
}
// no more VP

exports['default'] = upgrades;
module.exports = exports['default'];

},{"../content/professions/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/_all.js","../content/races/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_all.js","../content/traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/victories.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _worldgenTiles_all = require('../worldgen/tiles/_all');

var Tiles = _interopRequireWildcard(_worldgenTiles_all);

var _contentItems_special = require('../content/items/_special');

var _contentMonsters_special = require('../content/monsters/_special');

var _worldgenMaptypesAltar = require('../worldgen/maptypes/altar');

var _worldgenMaptypesAltar2 = _interopRequireDefault(_worldgenMaptypesAltar);

var _definitionsMonster = require('../definitions/monster');

var _definitionsMonster2 = _interopRequireDefault(_definitionsMonster);

var Victory = (function () {
  function Victory() {
    _classCallCheck(this, Victory);
  }

  _createClass(Victory, null, [{
    key: 'vp',
    value: function vp() {
      return 5;
    }
  }, {
    key: 'check',
    value: function check() {
      return true;
    }
  }, {
    key: 'shouldTrigger',
    value: function shouldTrigger() {
      return false;
    }
  }, {
    key: 'trigger',
    value: function trigger() {}
  }, {
    key: 'mapAdditions',
    value: function mapAdditions() {}
  }, {
    key: 'mapStairs',
    value: function mapStairs(i) {
      return [Tiles.StairsUp, i !== _initGamestate2['default'].world.depth - 1 ? Tiles.StairsDown : null];
    }
  }, {
    key: 'message',
    get: function get() {
      return 'You survived!';
    }
  }, {
    key: 'description',
    get: function get() {
      return 'Survive!';
    }
  }]);

  return Victory;
})();

var Survival = (function (_Victory) {
  _inherits(Survival, _Victory);

  function Survival() {
    _classCallCheck(this, Survival);

    _get(Object.getPrototypeOf(Survival.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Survival, null, [{
    key: 'vp',
    value: function vp() {
      return _initGamestate2['default'].world.depth;
    }
  }, {
    key: 'requiredTurns',
    value: function requiredTurns() {
      return _initGamestate2['default'].world.depth * 1000;
    }
  }, {
    key: 'check',
    value: function check() {
      return _lodash2['default'].max(_initGamestate2['default'].players, 'currentTurn').currentTurn >= this.requiredTurns();
    }
  }, {
    key: 'message',
    get: function get() {
      return 'You survived ' + this.requiredTurns() + ' turns.';
    }
  }, {
    key: 'description',
    get: function get() {
      return 'Survive for ' + this.requiredTurns() + ' turns.';
    }
  }]);

  return Survival;
})(Victory);

exports.Survival = Survival;

var StoneOfSelykFind = (function (_Victory2) {
  _inherits(StoneOfSelykFind, _Victory2);

  function StoneOfSelykFind() {
    _classCallCheck(this, StoneOfSelykFind);

    _get(Object.getPrototypeOf(StoneOfSelykFind.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(StoneOfSelykFind, null, [{
    key: 'vp',
    value: function vp() {
      return 3 * _initGamestate2['default'].world.depth;
    }
  }, {
    key: 'check',
    value: function check() {
      var found = false;
      _lodash2['default'].each(_initGamestate2['default'].players, function (player) {
        if (player.hasInInventory(_contentItems_special.StoneOfSelyk)) found = true;
      });
      return found;
    }
  }, {
    key: 'shouldTrigger',
    value: function shouldTrigger() {
      return _initGamestate2['default'].world.depth === _initGamestate2['default'].currentFloor + 1;
    }
  }, {
    key: 'trigger',
    value: function trigger() {
      _initGamestate2['default'].world.placeItemAtRandomLocation(new _contentItems_special.StoneOfSelyk(), _initGamestate2['default'].currentFloor);
    }
  }, {
    key: 'message',
    get: function get() {
      return 'You found the Stone of Selyk.';
    }
  }, {
    key: 'description',
    get: function get() {
      return 'Find the Stone of Selyk.';
    }
  }]);

  return StoneOfSelykFind;
})(Victory);

exports.StoneOfSelykFind = StoneOfSelykFind;

var SelykAltar = (function (_Victory3) {
  _inherits(SelykAltar, _Victory3);

  function SelykAltar() {
    _classCallCheck(this, SelykAltar);

    _get(Object.getPrototypeOf(SelykAltar.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SelykAltar, null, [{
    key: 'vp',
    value: function vp() {
      return 10 * _initGamestate2['default'].world.depth;
    }
  }, {
    key: 'check',
    value: function check() {
      var found = false;
      _lodash2['default'].each(_initGamestate2['default'].players, function (player) {
        if (player._ascended) found = true;
      });
      return found;
    }
  }, {
    key: 'mapAdditions',
    value: function mapAdditions() {
      var floor = _initGamestate2['default'].world.depth;
      _initGamestate2['default'].world.setMapAt(_worldgenMaptypesAltar2['default'].generate({ z: floor }), floor);
      return true;
    }
  }, {
    key: 'shouldTrigger',
    value: function shouldTrigger() {
      return _initGamestate2['default'].world.depth - 1 === _initGamestate2['default'].currentFloor + 1;
    }
  }, {
    key: 'trigger',
    value: function trigger() {
      _initGamestate2['default'].world.placeItemAtRandomLocation(new _contentItems_special.SelykCellarKey(), _initGamestate2['default'].currentFloor);
    }
  }, {
    key: 'mapStairs',
    value: function mapStairs(i) {
      return [Tiles.StairsUp, i !== _initGamestate2['default'].world.depth - 1 ? Tiles.StairsDown : Tiles.SelykStairsDown];
    }
  }, {
    key: 'message',
    get: function get() {
      return 'You sacrificed yourself at the altar of Selyk.';
    }
  }, {
    key: 'description',
    get: function get() {
      return 'Reach the altar of Selyk.';
    }
  }]);

  return SelykAltar;
})(Victory);

exports.SelykAltar = SelykAltar;

var KillSelyk = (function (_Victory4) {
  _inherits(KillSelyk, _Victory4);

  function KillSelyk() {
    _classCallCheck(this, KillSelyk);

    _get(Object.getPrototypeOf(KillSelyk.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(KillSelyk, null, [{
    key: 'vp',
    value: function vp() {
      return 20 * _initGamestate2['default'].world.depth;
    }
  }, {
    key: 'check',
    value: function check() {
      var found = false;
      _lodash2['default'].each(_initGamestate2['default'].players, function (player) {
        if (player.conquest.Selyk) found = true;
      });
      return found;
    }
  }, {
    key: 'shouldTrigger',
    value: function shouldTrigger() {
      return _initGamestate2['default'].world.depth === _initGamestate2['default'].currentFloor + 1;
    }
  }, {
    key: 'trigger',
    value: function trigger() {
      _initGamestate2['default'].world.placeEntityAtRandomLocation(new _definitionsMonster2['default'](0, 0, 0, _contentMonsters_special.Selyk.init()), _initGamestate2['default'].currentFloor);
    }
  }, {
    key: 'message',
    get: function get() {
      return 'You killed Selyk.';
    }
  }, {
    key: 'description',
    get: function get() {
      return 'Kill Selyk.';
    }
  }]);

  return KillSelyk;
})(Victory);

exports.KillSelyk = KillSelyk;

},{"../content/items/_special":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_special.js","../content/monsters/_special":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/_special.js","../definitions/monster":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/monster.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../worldgen/maptypes/altar":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/maptypes/altar.js","../worldgen/tiles/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _monsterAttacks = require('./monster-attacks');

var MonsterAttacks = _interopRequireWildcard(_monsterAttacks);

var _physicalAttacks = require('./physical-attacks');

var PhysicalAttacks = _interopRequireWildcard(_physicalAttacks);

var _magicAttacks = require('./magic-attacks');

var MagicAttacks = _interopRequireWildcard(_magicAttacks);

var attacks = {};
var theseAttacks = _lodash2['default'].values(MonsterAttacks).concat(_lodash2['default'].values(PhysicalAttacks)).concat(_lodash2['default'].values(MagicAttacks));

_lodash2['default'].each(theseAttacks, function (attack) {
  var attackFunc = function attackFunc(r, h, d) {
    return new attack(r, h, d);
  };
  attackFunc.real = attack;
  attacks[attack.name] = attackFunc;
});

exports['default'] = attacks;
module.exports = exports['default'];

},{"./magic-attacks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/magic-attacks.js","./monster-attacks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/monster-attacks.js","./physical-attacks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/physical-attacks.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/magic-attacks.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsAttack = require('../../definitions/attack');

var Force = (function (_Magic) {
  _inherits(Force, _Magic);

  function Force() {
    _classCallCheck(this, Force);

    _get(Object.getPrototypeOf(Force.prototype), 'constructor', this).apply(this, arguments);
  }

  return Force;
})(_definitionsAttack.Magic);

exports.Force = Force;

},{"../../definitions/attack":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/attack.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/monster-attacks.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _definitionsAttack = require('../../definitions/attack');

var Bite = (function (_Attack) {
  _inherits(Bite, _Attack);

  function Bite() {
    _classCallCheck(this, Bite);

    _get(Object.getPrototypeOf(Bite.prototype), 'constructor', this).apply(this, arguments);
  }

  return Bite;
})(_definitionsAttack.Attack);

exports.Bite = Bite;

var Claw = (function (_Attack2) {
  _inherits(Claw, _Attack2);

  function Claw() {
    _classCallCheck(this, Claw);

    _get(Object.getPrototypeOf(Claw.prototype), 'constructor', this).apply(this, arguments);
  }

  return Claw;
})(_definitionsAttack.Attack);

exports.Claw = Claw;

var Touch = (function (_Attack3) {
  _inherits(Touch, _Attack3);

  function Touch() {
    _classCallCheck(this, Touch);

    _get(Object.getPrototypeOf(Touch.prototype), 'constructor', this).apply(this, arguments);
  }

  return Touch;
})(_definitionsAttack.Attack);

exports.Touch = Touch;

var Bearhug = (function (_Attack4) {
  _inherits(Bearhug, _Attack4);

  function Bearhug() {
    _classCallCheck(this, Bearhug);

    _get(Object.getPrototypeOf(Bearhug.prototype), 'constructor', this).apply(this, arguments);
  }

  return Bearhug;
})(_definitionsAttack.Attack);

exports.Bearhug = Bearhug;

var Poison = (function (_Attack5) {
  _inherits(Poison, _Attack5);

  function Poison() {
    _classCallCheck(this, Poison);

    _get(Object.getPrototypeOf(Poison.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Poison, [{
    key: 'hitString',
    value: function hitString(owner, target, damage, extra) {
      var psn = '';
      if (extra && !target.hasTrait('PoisonResistance')) {
        psn = ' ' + target.name + ' got poisoned!';
        target.addUniqueBehavior(Behaviors.Poisoned());
      }
      return owner.name + ' hit ' + target.name + ' for ' + damage + ' damage!' + psn;
    }
  }, {
    key: 'hitCallback',
    value: function hitCallback() {
      return true;
    }
  }]);

  return Poison;
})(_definitionsAttack.Attack);

exports.Poison = Poison;

var ElectricTouch = (function (_Attack6) {
  _inherits(ElectricTouch, _Attack6);

  function ElectricTouch() {
    _classCallCheck(this, ElectricTouch);

    _get(Object.getPrototypeOf(ElectricTouch.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ElectricTouch, [{
    key: 'hitString',
    value: function hitString(owner, target, damage, extra) {
      var zap = '';
      if (extra) {
        zap = ' ' + target.name + ' got zapped!';
        target.addUniqueBehavior(Behaviors.Stunned());
      }
      return owner.name + ' hit ' + target.name + ' for ' + damage + ' damage!' + zap;
    }
  }, {
    key: 'hitCallback',
    value: function hitCallback() {
      return true;
    }
  }]);

  return ElectricTouch;
})(_definitionsAttack.Attack);

exports.ElectricTouch = ElectricTouch;

var Explode = (function (_Attack7) {
  _inherits(Explode, _Attack7);

  function Explode() {
    _classCallCheck(this, Explode);

    _get(Object.getPrototypeOf(Explode.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Explode, [{
    key: 'hitString',
    value: function hitString(owner, target, damage) {
      return owner.name + ' explodes! ' + target.name + ' took ' + damage + ' damage.';
    }
  }, {
    key: 'canHit',
    value: function canHit() {
      return true;
    }
  }, {
    key: 'afterHitCallback',
    value: function afterHitCallback(owner) {
      owner.die(owner);
    }
  }]);

  return Explode;
})(_definitionsAttack.Attack);

exports.Explode = Explode;

var SeductiveTouch = (function (_Attack8) {
  _inherits(SeductiveTouch, _Attack8);

  function SeductiveTouch() {
    _classCallCheck(this, SeductiveTouch);

    _get(Object.getPrototypeOf(SeductiveTouch.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SeductiveTouch, [{
    key: 'hitString',
    value: function hitString(owner, target, damage, extra) {
      var sed = '';
      if (extra) {
        sed = ' ' + target.name + ' is seduced!';
        target.addUniqueBehavior(Behaviors.Seduced());
      }
      return owner.name + ' hit ' + target.name + ' for ' + damage + ' damage!' + sed;
    }
  }, {
    key: 'hitCallback',
    value: function hitCallback() {
      return true;
    }
  }]);

  return SeductiveTouch;
})(_definitionsAttack.Attack);

exports.SeductiveTouch = SeductiveTouch;

var TelepathicBlast = (function (_Attack9) {
  _inherits(TelepathicBlast, _Attack9);

  function TelepathicBlast() {
    _classCallCheck(this, TelepathicBlast);

    _get(Object.getPrototypeOf(TelepathicBlast.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(TelepathicBlast, [{
    key: 'hitString',
    value: function hitString(owner, target, damage) {
      return owner.name + ' got blasted by ' + target.name + '\'s psychic blast for ' + damage + ' damage!';
    }
  }, {
    key: 'hitCallback',
    value: function hitCallback(owner) {
      return owner.hasTrait('Telepathy');
    }
  }]);

  return TelepathicBlast;
})(_definitionsAttack.Attack);

exports.TelepathicBlast = TelepathicBlast;

},{"../../definitions/attack":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/attack.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/physical-attacks.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsAttack = require('../../definitions/attack');

var _definitionsGlyph = require('../../definitions/glyph');

var _definitionsGlyph2 = _interopRequireDefault(_definitionsGlyph);

var Bash = (function (_SkilledAttack) {
  _inherits(Bash, _SkilledAttack);

  function Bash() {
    _classCallCheck(this, Bash);

    _get(Object.getPrototypeOf(Bash.prototype), 'constructor', this).apply(this, arguments);
  }

  return Bash;
})(_definitionsAttack.SkilledAttack);

exports.Bash = Bash;

var Ranged = (function (_Reagent) {
  _inherits(Ranged, _Reagent);

  function Ranged() {
    _classCallCheck(this, Ranged);

    _get(Object.getPrototypeOf(Ranged.prototype), 'constructor', this).apply(this, arguments);
  }

  return Ranged;
})(_definitionsAttack.Reagent);

exports.Ranged = Ranged;

var Shot = (function (_SkilledAttack2) {
  _inherits(Shot, _SkilledAttack2);

  function Shot() {
    _classCallCheck(this, Shot);

    _get(Object.getPrototypeOf(Shot.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Shot, [{
    key: 'init',
    value: function init() {
      this.glyph = new _definitionsGlyph2['default'](')', '#00f');
    }
  }]);

  return Shot;
})(_definitionsAttack.SkilledAttack);

exports.Shot = Shot;

var Slash = (function (_SkilledAttack3) {
  _inherits(Slash, _SkilledAttack3);

  function Slash() {
    _classCallCheck(this, Slash);

    _get(Object.getPrototypeOf(Slash.prototype), 'constructor', this).apply(this, arguments);
  }

  return Slash;
})(_definitionsAttack.SkilledAttack);

exports.Slash = Slash;

var Smash = (function (_SkilledAttack4) {
  _inherits(Smash, _SkilledAttack4);

  function Smash() {
    _classCallCheck(this, Smash);

    _get(Object.getPrototypeOf(Smash.prototype), 'constructor', this).apply(this, arguments);
  }

  return Smash;
})(_definitionsAttack.SkilledAttack);

exports.Smash = Smash;

var Stab = (function (_SkilledAttack5) {
  _inherits(Stab, _SkilledAttack5);

  function Stab() {
    _classCallCheck(this, Stab);

    _get(Object.getPrototypeOf(Stab.prototype), 'constructor', this).apply(this, arguments);
  }

  return Stab;
})(_definitionsAttack.SkilledAttack);

exports.Stab = Stab;

var Thrust = (function (_SkilledAttack6) {
  _inherits(Thrust, _SkilledAttack6);

  function Thrust() {
    _classCallCheck(this, Thrust);

    _get(Object.getPrototypeOf(Thrust.prototype), 'constructor', this).apply(this, arguments);
  }

  return Thrust;
})(_definitionsAttack.SkilledAttack);

exports.Thrust = Thrust;

var Unarmed = (function (_SkilledAttack7) {
  _inherits(Unarmed, _SkilledAttack7);

  function Unarmed() {
    _classCallCheck(this, Unarmed);

    _get(Object.getPrototypeOf(Unarmed.prototype), 'constructor', this).apply(this, arguments);
  }

  return Unarmed;
})(_definitionsAttack.SkilledAttack);

exports.Unarmed = Unarmed;

},{"../../definitions/attack":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/attack.js","../../definitions/glyph":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/glyph.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _ambient = require('./ambient');

var Ambient = _interopRequireWildcard(_ambient);

var _combat = require('./combat');

var Combat = _interopRequireWildcard(_combat);

var _conditions = require('./conditions');

var Conditions = _interopRequireWildcard(_conditions);

var _death = require('./death');

var Death = _interopRequireWildcard(_death);

var _interactions = require('./interactions');

var Interactions = _interopRequireWildcard(_interactions);

var _regeneration = require('./regeneration');

var Regeneration = _interopRequireWildcard(_regeneration);

var _targetting = require('./targetting');

var Targetting = _interopRequireWildcard(_targetting);

exports['default'] = _lodash2['default'].extend({}, Ambient, Combat, Conditions, Death, Interactions, Regeneration, Targetting);
module.exports = exports['default'];

},{"./ambient":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/ambient.js","./combat":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/combat.js","./conditions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/conditions.js","./death":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/death.js","./interactions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/interactions.js","./regeneration":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/regeneration.js","./targetting":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/targetting.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/ambient.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _definitionsBehavior = require('../../definitions/behavior');

var _definitionsBehavior2 = _interopRequireDefault(_definitionsBehavior);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

/* being stunned sucks */

var EmitsLightBehavior = (function (_Behavior) {
  _inherits(EmitsLightBehavior, _Behavior);

  function EmitsLightBehavior() {
    var color = arguments.length <= 0 || arguments[0] === undefined ? '#fff' : arguments[0];

    _classCallCheck(this, EmitsLightBehavior);

    _get(Object.getPrototypeOf(EmitsLightBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.ALWAYS);
    this.color = _rotJs2['default'].Color.fromString(color);
  }

  _createClass(EmitsLightBehavior, [{
    key: 'spawn',
    value: function spawn(me) {
      me._lightColor = this.color;
      _initGamestate2['default'].world.addLighting(me);
    }
  }, {
    key: 'die',
    value: function die(me) {
      _initGamestate2['default'].world.removeLighting(me);
    }
  }]);

  return EmitsLightBehavior;
})(_definitionsBehavior2['default']);

var EmitsLight = function EmitsLight(color) {
  return new EmitsLightBehavior(color);
};
exports.EmitsLight = EmitsLight;

},{"../../definitions/behavior":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/behavior.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/combat.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _definitionsBehavior = require('../../definitions/behavior');

var _definitionsBehavior2 = _interopRequireDefault(_definitionsBehavior);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _displayMessageHandler = require('../../display/message-handler');

var _displayMessageHandler2 = _interopRequireDefault(_displayMessageHandler);

var _worldgenMonsterSpawner = require('../../worldgen/monster-spawner');

var _worldgenMonsterSpawner2 = _interopRequireDefault(_worldgenMonsterSpawner);

var _conditions = require('./conditions');

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

/* monsters can attack with this */

var AttacksBehavior = (function (_Behavior) {
  _inherits(AttacksBehavior, _Behavior);

  function AttacksBehavior() {
    _classCallCheck(this, AttacksBehavior);

    _get(Object.getPrototypeOf(AttacksBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.DEFENSE);
  }

  _createClass(AttacksBehavior, [{
    key: 'act',
    value: function act(me) {
      return !me.tryAttack();
    }
  }]);

  return AttacksBehavior;
})(_definitionsBehavior2['default']);

var Attacks = function Attacks() {
  return new AttacksBehavior();
};

exports.Attacks = Attacks;

var TeleportsWhenHitBehavior = (function (_Behavior2) {
  _inherits(TeleportsWhenHitBehavior, _Behavior2);

  function TeleportsWhenHitBehavior() {
    var percent = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];

    _classCallCheck(this, TeleportsWhenHitBehavior);

    _get(Object.getPrototypeOf(TeleportsWhenHitBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.DEFER);
    this.percent = percent;
  }

  _createClass(TeleportsWhenHitBehavior, [{
    key: 'takeDamage',
    value: function takeDamage(me) {
      if (_rotJs2['default'].RNG.getPercentage() > this.percent) return;
      _initGamestate2['default'].world.placeEntityAtRandomLocation(me);
    }
  }]);

  return TeleportsWhenHitBehavior;
})(_definitionsBehavior2['default']);

var TeleportsWhenHit = function TeleportsWhenHit(percent) {
  return new TeleportsWhenHitBehavior(percent);
};

exports.TeleportsWhenHit = TeleportsWhenHit;
/* hitting in melee range will stun you */

var ParalyzesWhenHitBehavior = (function (_Behavior3) {
  _inherits(ParalyzesWhenHitBehavior, _Behavior3);

  function ParalyzesWhenHitBehavior() {
    var percent = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];
    var range = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];

    _classCallCheck(this, ParalyzesWhenHitBehavior);

    _get(Object.getPrototypeOf(ParalyzesWhenHitBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.DEFER);
    this.percent = percent;
    this.range = range;
  }

  _createClass(ParalyzesWhenHitBehavior, [{
    key: 'takeDamage',
    value: function takeDamage(me, attacker) {
      if (_rotJs2['default'].RNG.getPercentage() > this.percent || me.distBetween(attacker) > this.range) return;
      var turns = (0, _libDiceRoller2['default'])('1d50 + 50');
      attacker.addUniqueBehavior((0, _conditions.Stunned)(turns));
    }
  }]);

  return ParalyzesWhenHitBehavior;
})(_definitionsBehavior2['default']);

var ParalyzesWhenHit = function ParalyzesWhenHit(percent, range) {
  return new ParalyzesWhenHitBehavior(percent, range);
};

exports.ParalyzesWhenHit = ParalyzesWhenHit;

var StealsBehavior = (function (_Behavior4) {
  _inherits(StealsBehavior, _Behavior4);

  function StealsBehavior() {
    var percent = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];

    _classCallCheck(this, StealsBehavior);

    _get(Object.getPrototypeOf(StealsBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.ALWAYS);
    this.percent = percent;
  }

  _createClass(StealsBehavior, [{
    key: 'act',
    value: function act(me) {
      if (_rotJs2['default'].RNG.getPercentage() > this.percent) return;
      var didSteal = false;
      var item = null;
      var entities = _initGamestate2['default'].world.getValidEntitiesInRange(me.x, me.y, me.z, 1, function (ent) {
        return me.canAttack(ent);
      });
      _lodash2['default'].each(entities, function (ent) {
        item = _lodash2['default'].sample(ent.inventory);
        if (!item) return;
        didSteal = ent;
        return false;
      });

      if (didSteal) {
        _displayMessageHandler2['default'].add({ message: me.name + ' stole ' + item.name + ' from ' + didSteal.name + '!', type: _displayMessageHandler.MessageTypes.COMBAT });
        didSteal.removeFromInventory(item);
        me.addToInventory(item);
      }
    }
  }]);

  return StealsBehavior;
})(_definitionsBehavior2['default']);

var Steals = function Steals() {
  return new StealsBehavior();
};

exports.Steals = Steals;

var SplitsWhenHitBehavior = (function (_Behavior5) {
  _inherits(SplitsWhenHitBehavior, _Behavior5);

  function SplitsWhenHitBehavior() {
    var percent = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];

    _classCallCheck(this, SplitsWhenHitBehavior);

    _get(Object.getPrototypeOf(SplitsWhenHitBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.ALWAYS);
    this.percent = percent;
  }

  _createClass(SplitsWhenHitBehavior, [{
    key: 'takeDamage',
    value: function takeDamage(me) {
      if (_rotJs2['default'].RNG.getPercentage() > this.percent || me.hp.atMin()) return;
      var validTiles = _initGamestate2['default'].world.getValidTilesInRange(me.x, me.y, me.z, 1, function (tile) {
        return _initGamestate2['default'].world.isTileEmpty(tile.x, tile.y, tile.z);
      });
      var chosenTile = _lodash2['default'].sample(validTiles);

      if (!chosenTile) return;

      var newSpawn = _worldgenMonsterSpawner2['default'].spawnSingle(me._name, chosenTile);
      if (!newSpawn) return;
      var newHp = Math.floor(me.hp.cur / 2);
      me.hp._set(newHp);
      newSpawn.hp._set(newHp);
    }
  }]);

  return SplitsWhenHitBehavior;
})(_definitionsBehavior2['default']);

var SplitsWhenHit = function SplitsWhenHit(percent) {
  return new SplitsWhenHitBehavior(percent);
};
exports.SplitsWhenHit = SplitsWhenHit;

},{"../../definitions/behavior":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/behavior.js","../../display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../../worldgen/monster-spawner":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/monster-spawner.js","./conditions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/conditions.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/conditions.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _definitionsBehavior = require('../../definitions/behavior');

var _definitionsBehavior2 = _interopRequireDefault(_definitionsBehavior);

var _displayMessageHandler = require('../../display/message-handler');

var _displayMessageHandler2 = _interopRequireDefault(_displayMessageHandler);

/* being stunned sucks */

var StunnedBehavior = (function (_Behavior) {
  _inherits(StunnedBehavior, _Behavior);

  function StunnedBehavior() {
    var numTurns = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

    _classCallCheck(this, StunnedBehavior);

    _get(Object.getPrototypeOf(StunnedBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.STUN);
    this.stunTurns = numTurns;
  }

  _createClass(StunnedBehavior, [{
    key: 'act',
    value: function act(me) {
      if (this.stunTurns <= 0) {
        me.removeBehavior(this);
        _displayMessageHandler2['default'].add({ message: me.name + ' is no longer stunned.', type: _displayMessageHandler.MessageTypes.COMBAT });
        return true;
      }

      _displayMessageHandler2['default'].add({ message: me.name + ' is stunned!', type: _displayMessageHandler.MessageTypes.COMBAT });
      this.stunTurns--;
      return false;
    }
  }]);

  return StunnedBehavior;
})(_definitionsBehavior2['default']);

var Stunned = function Stunned(numTurns) {
  return new StunnedBehavior(numTurns);
};

exports.Stunned = Stunned;
/* being poisoned also sucks */

var PoisonedBehavior = (function (_Behavior2) {
  _inherits(PoisonedBehavior, _Behavior2);

  function PoisonedBehavior() {
    var numTurns = arguments.length <= 0 || arguments[0] === undefined ? 3 : arguments[0];

    _classCallCheck(this, PoisonedBehavior);

    _get(Object.getPrototypeOf(PoisonedBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.ALWAYS);
    this.poisonTurns = numTurns;
  }

  _createClass(PoisonedBehavior, [{
    key: 'act',
    value: function act(me) {
      if (this.poisonTurns <= 0) {
        me.removeBehavior(this);
        _displayMessageHandler2['default'].add({ message: me.name + ' is no longer poisoned.', type: _displayMessageHandler.MessageTypes.COMBAT });
        return;
      }

      var damage = (0, _libDiceRoller2['default'])('1d4');
      _displayMessageHandler2['default'].add({ message: me.name + ' takes ' + damage + ' poison damage!', type: _displayMessageHandler.MessageTypes.COMBAT });
      this.poisonTurns--;
    }
  }]);

  return PoisonedBehavior;
})(_definitionsBehavior2['default']);

var Poisoned = function Poisoned(numTurns) {
  return new PoisonedBehavior(numTurns);
};

exports.Poisoned = Poisoned;
/* being seduced really sucks */

var SeducedBehavior = (function (_Behavior3) {
  _inherits(SeducedBehavior, _Behavior3);

  function SeducedBehavior() {
    var numTurns = arguments.length <= 0 || arguments[0] === undefined ? 2 : arguments[0];

    _classCallCheck(this, SeducedBehavior);

    _get(Object.getPrototypeOf(SeducedBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.STUN);
    this.stunTurns = numTurns;
  }

  _createClass(SeducedBehavior, [{
    key: 'act',
    value: function act(me) {
      me.breakConduct('celibate');
      if (this.stunTurns <= 0) {
        me.removeBehavior(this);
        _displayMessageHandler2['default'].add({ message: me.name + ' is no longer seduced.', type: _displayMessageHandler.MessageTypes.COMBAT });
        return true;
      }

      this.stunTurns--;
      _displayMessageHandler2['default'].add({ message: me.name + ' is seduced!', type: _displayMessageHandler.MessageTypes.COMBAT });

      var item = (0, _lodash2['default'])(me.equipment).values().flatten().sample();
      if (!item) return false;

      me.unequip(item);
      me.dropItem(item);

      _displayMessageHandler2['default'].add({ message: me.name + ' dropped ' + item.name + '!', type: _displayMessageHandler.MessageTypes.COMBAT });
      return false;
    }
  }]);

  return SeducedBehavior;
})(_definitionsBehavior2['default']);

var Seduced = function Seduced(numTurns) {
  return new SeducedBehavior(numTurns);
};
exports.Seduced = Seduced;

},{"../../definitions/behavior":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/behavior.js","../../display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/death.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x7, _x8, _x9) { var _again = true; _function: while (_again) { var object = _x7, property = _x8, receiver = _x9; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x7 = parent; _x8 = property; _x9 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _definitionsBehavior = require('../../definitions/behavior');

var _definitionsBehavior2 = _interopRequireDefault(_definitionsBehavior);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _displayMessageHandler = require('../../display/message-handler');

var _displayMessageHandler2 = _interopRequireDefault(_displayMessageHandler);

var _items_special = require('../items/_special');

/* die after a period of time */

var KillsSelfAfterPeriodOfTimeBehavior = (function (_Behavior) {
  _inherits(KillsSelfAfterPeriodOfTimeBehavior, _Behavior);

  function KillsSelfAfterPeriodOfTimeBehavior() {
    var turns = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];

    _classCallCheck(this, KillsSelfAfterPeriodOfTimeBehavior);

    _get(Object.getPrototypeOf(KillsSelfAfterPeriodOfTimeBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.DEFER);
    this.turns = turns;
  }

  _createClass(KillsSelfAfterPeriodOfTimeBehavior, [{
    key: 'act',
    value: function act(me) {
      if (this.turns-- > 0) return;
      me.die({ name: 'time' });
    }
  }]);

  return KillsSelfAfterPeriodOfTimeBehavior;
})(_definitionsBehavior2['default']);

var KillsSelfAfterPeriodOfTime = function KillsSelfAfterPeriodOfTime(turns) {
  return new KillsSelfAfterPeriodOfTimeBehavior(turns);
};

exports.KillsSelfAfterPeriodOfTime = KillsSelfAfterPeriodOfTime;
/* drop contents on death */

var DropsItemsBehavior = (function (_Behavior2) {
  _inherits(DropsItemsBehavior, _Behavior2);

  function DropsItemsBehavior() {
    _classCallCheck(this, DropsItemsBehavior);

    _get(Object.getPrototypeOf(DropsItemsBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.DEFER);
  }

  _createClass(DropsItemsBehavior, [{
    key: 'die',
    value: function die(me) {
      var equipped = (0, _lodash2['default'])(me.equipment).values().flatten().value();
      _lodash2['default'].each(equipped, function (item) {
        return me.unequip(item);
      });
      _lodash2['default'].each(me.inventory, function (item) {
        me.dropItem(item);
      });
    }
  }]);

  return DropsItemsBehavior;
})(_definitionsBehavior2['default']);

var DropsItems = function DropsItems() {
  return new DropsItemsBehavior();
};

exports.DropsItems = DropsItems;
/* monsters leave a corpse */

var LeavesCorpseBehavior = (function (_Behavior3) {
  _inherits(LeavesCorpseBehavior, _Behavior3);

  function LeavesCorpseBehavior() {
    var dropPercent = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];

    _classCallCheck(this, LeavesCorpseBehavior);

    _get(Object.getPrototypeOf(LeavesCorpseBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.DEFER);
    this.dropPercent = dropPercent;
  }

  _createClass(LeavesCorpseBehavior, [{
    key: 'die',
    value: function die(me) {
      if (_rotJs2['default'].RNG.getPercentage() > this.dropPercent) return;
      var corpse = new _items_special.Corpse({ monsterName: me.name, glyph: { fg: me.glyph.fg } });
      _initGamestate2['default'].world.moveItem(corpse, me.x, me.y, me.z);
    }
  }]);

  return LeavesCorpseBehavior;
})(_definitionsBehavior2['default']);

var LeavesCorpse = function LeavesCorpse(percent) {
  return new LeavesCorpseBehavior(percent);
};

exports.LeavesCorpse = LeavesCorpse;
/* some things drop gold */

var DropsGoldBehavior = (function (_Behavior4) {
  _inherits(DropsGoldBehavior, _Behavior4);

  function DropsGoldBehavior(gold) {
    _classCallCheck(this, DropsGoldBehavior);

    _get(Object.getPrototypeOf(DropsGoldBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.DEFER);
    this.goldDrop = gold;
  }

  _createClass(DropsGoldBehavior, [{
    key: 'die',
    value: function die(me) {
      var droppedGold = (0, _libDiceRoller2['default'])(this.goldDrop);
      var goldItem = new _items_special.Gold(droppedGold + me.gold);
      if (goldItem.goldValue === 0) return;
      _initGamestate2['default'].world.moveItem(goldItem, me.x, me.y, me.z);
    }
  }]);

  return DropsGoldBehavior;
})(_definitionsBehavior2['default']);

var DropsGold = function DropsGold(gold) {
  return new DropsGoldBehavior(gold);
};

exports.DropsGold = DropsGold;
/* explodes upon death. can be pretty dangerous */

var ExplodesBehavior = (function (_Behavior5) {
  _inherits(ExplodesBehavior, _Behavior5);

  function ExplodesBehavior() {
    var roll = arguments.length <= 0 || arguments[0] === undefined ? '1d4' : arguments[0];
    var range = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
    var percent = arguments.length <= 2 || arguments[2] === undefined ? 100 : arguments[2];

    _classCallCheck(this, ExplodesBehavior);

    _get(Object.getPrototypeOf(ExplodesBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.DEFER);
    this.roll = roll;
    this.percent = percent;
    this.range = range;
  }

  _createClass(ExplodesBehavior, [{
    key: 'die',
    value: function die(me) {
      var _this = this;

      if (_rotJs2['default'].RNG.getPercentage() > this.percent) {
        _displayMessageHandler2['default'].add({ message: me.name + ' explodes a little bit.', type: _displayMessageHandler.MessageTypes.COMBAT });
        return;
      }
      _displayMessageHandler2['default'].add({ message: me.name + ' violently explodes!', type: _displayMessageHandler.MessageTypes.COMBAT });
      _lodash2['default'].each(_initGamestate2['default'].world.getValidEntitiesInRange(me.x, me.y, me.z, this.range), function (entity) {
        if (me === entity || entity.hp.atMin()) return; // infinite loop prevention
        entity.takeDamage((0, _libDiceRoller2['default'])(_this.roll), me);
      });
    }
  }]);

  return ExplodesBehavior;
})(_definitionsBehavior2['default']);

var Explodes = function Explodes(roll, range, percent) {
  return new ExplodesBehavior(roll, range, percent);
};

exports.Explodes = Explodes;
/* drop contents on death */

var LifeSaveBehavior = (function (_Behavior6) {
  _inherits(LifeSaveBehavior, _Behavior6);

  function LifeSaveBehavior(numUses) {
    _classCallCheck(this, LifeSaveBehavior);

    _get(Object.getPrototypeOf(LifeSaveBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.ALWAYS);this.numUses = numUses;
  }

  _createClass(LifeSaveBehavior, [{
    key: 'takeDamage',
    value: function takeDamage(me) {
      if (me.hp.atMin()) {
        me.hp.toMax();
        _displayMessageHandler2['default'].add({ message: me.name + '\'s life was saved!', type: _displayMessageHandler.MessageTypes.COMBAT });
        me.breakConduct('lifeSave');

        if (this.numUses-- <= 0) me.removeBehavior(this);

        if (this._itemRef) {
          this._itemRef.disintegrate(me);
        }
      }
    }
  }]);

  return LifeSaveBehavior;
})(_definitionsBehavior2['default']);

var LifeSave = function LifeSave() {
  var numUses = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
  return new LifeSaveBehavior(numUses);
};
exports.LifeSave = LifeSave;

},{"../../definitions/behavior":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/behavior.js","../../display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../items/_special":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_special.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/interactions.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsBehavior = require('../../definitions/behavior');

var _definitionsBehavior2 = _interopRequireDefault(_definitionsBehavior);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _displayMessageHandler = require('../../display/message-handler');

var _displayMessageHandler2 = _interopRequireDefault(_displayMessageHandler);

/* retrieve items from the ground */

var PickUpItemsBehavior = (function (_Behavior) {
  _inherits(PickUpItemsBehavior, _Behavior);

  function PickUpItemsBehavior() {
    var blacklist = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
    var whitelist = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

    _classCallCheck(this, PickUpItemsBehavior);

    _get(Object.getPrototypeOf(PickUpItemsBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.INTERACT);
    this.blacklist = blacklist;
    this.whitelist = whitelist;
  }

  _createClass(PickUpItemsBehavior, [{
    key: 'act',
    value: function act(me) {
      var _this = this;

      var items = _initGamestate2['default'].world.getItemsAt(me.x, me.y, me.z);
      (0, _lodash2['default'])(items).filter(function (item) {
        return !item._canPickUpTurn || item._canPickUpTurn <= me.currentTurn;
      }).each(function (item) {
        if (_this.whitelist.length && !_lodash2['default'].contains(_this.whitelist, item.getType())) return;
        if (_this.blacklist.length && _lodash2['default'].contains(_this.blacklist, item.getType())) return;
        _initGamestate2['default'].world.removeItem(item);
        me.addToInventory(item);
        _displayMessageHandler2['default'].add({ message: me.name + ' picked up ' + item.name + '.', type: _displayMessageHandler.MessageTypes.ITEM });
      }).value();
    }
  }]);

  return PickUpItemsBehavior;
})(_definitionsBehavior2['default']);

var PickUpItems = function PickUpItems(bl, wl) {
  return new PickUpItemsBehavior(bl, wl);
};

exports.PickUpItems = PickUpItems;
/* interacts with everything */

var InteractsBehavior = (function (_Behavior2) {
  _inherits(InteractsBehavior, _Behavior2);

  function InteractsBehavior() {
    _classCallCheck(this, InteractsBehavior);

    _get(Object.getPrototypeOf(InteractsBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.INTERACT);
  }

  _createClass(InteractsBehavior, [{
    key: 'act',
    value: function act(me) {
      var tiles = _initGamestate2['default'].world.getAllTilesInRange(me.x, me.y, me.z, 1);

      for (var i = 0; i < tiles.length; i++) {
        var tile = tiles[i];

        if (tile.canInteract && tile.interact && tile.canInteract(me)) {
          var msg = tile.interact(me);
          if (msg) _displayMessageHandler2['default'].add({ message: msg, type: _displayMessageHandler.MessageTypes.DUNGEON });
          return false;
        }
      }

      return true;
    }
  }]);

  return InteractsBehavior;
})(_definitionsBehavior2['default']);

var Interacts = function Interacts() {
  return new InteractsBehavior();
};

exports.Interacts = Interacts;
/* breaks down doors that it finds */

var BreaksDoorsBehavior = (function (_Behavior3) {
  _inherits(BreaksDoorsBehavior, _Behavior3);

  function BreaksDoorsBehavior() {
    _classCallCheck(this, BreaksDoorsBehavior);

    _get(Object.getPrototypeOf(BreaksDoorsBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.INTERACT);
  }

  _createClass(BreaksDoorsBehavior, [{
    key: 'act',
    value: function act() {
      return false;
    }
  }]);

  return BreaksDoorsBehavior;
})(_definitionsBehavior2['default']);

var BreaksDoors = function BreaksDoors() {
  return new BreaksDoorsBehavior();
};

exports.BreaksDoors = BreaksDoors;
/* opens doors that it finds */

var OpensDoorsBehavior = (function (_Behavior4) {
  _inherits(OpensDoorsBehavior, _Behavior4);

  function OpensDoorsBehavior() {
    _classCallCheck(this, OpensDoorsBehavior);

    _get(Object.getPrototypeOf(OpensDoorsBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.INTERACT);
  }

  _createClass(OpensDoorsBehavior, [{
    key: 'act',
    value: function act(me) {
      var doors = _initGamestate2['default'].world.getValidTilesInRange(me.x, me.y, me.z, 1, function (tile) {
        return tile.constructor.name === 'Door' && tile.density;
      });
      if (doors.length > 0) {
        var door = doors[0];
        door.interact(me);
        return false;
      }

      return true;
    }
  }]);

  return OpensDoorsBehavior;
})(_definitionsBehavior2['default']);

var OpensDoors = function OpensDoors() {
  return new OpensDoorsBehavior();
};
exports.OpensDoors = OpensDoors;

},{"../../definitions/behavior":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/behavior.js","../../display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/regeneration.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsBehavior = require('../../definitions/behavior');

var _definitionsBehavior2 = _interopRequireDefault(_definitionsBehavior);

var RegeneratesHpBehavior = (function (_Behavior) {
  _inherits(RegeneratesHpBehavior, _Behavior);

  function RegeneratesHpBehavior() {
    var amount = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

    _classCallCheck(this, RegeneratesHpBehavior);

    _get(Object.getPrototypeOf(RegeneratesHpBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.ALWAYS);
    this.amount = amount;
  }

  _createClass(RegeneratesHpBehavior, [{
    key: 'act',
    value: function act(me) {
      if (me.currentTurn % me.getRegenHp() === 0) me.hp.add(this.amount);
    }
  }]);

  return RegeneratesHpBehavior;
})(_definitionsBehavior2['default']);

var RegeneratesHp = function RegeneratesHp() {
  return new RegeneratesHpBehavior();
};

exports.RegeneratesHp = RegeneratesHp;

var RegeneratesMpBehavior = (function (_Behavior2) {
  _inherits(RegeneratesMpBehavior, _Behavior2);

  function RegeneratesMpBehavior() {
    var amount = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

    _classCallCheck(this, RegeneratesMpBehavior);

    _get(Object.getPrototypeOf(RegeneratesMpBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.ALWAYS);
    this.amount = amount;
  }

  _createClass(RegeneratesMpBehavior, [{
    key: 'act',
    value: function act(me) {
      if (me.currentTurn % me.getRegenMp() === 0) me.mp.add(this.amount);
    }
  }]);

  return RegeneratesMpBehavior;
})(_definitionsBehavior2['default']);

var RegeneratesMp = function RegeneratesMp() {
  return new RegeneratesMpBehavior();
};

exports.RegeneratesMp = RegeneratesMp;

var HealsBelowPercentBehavior = (function (_Behavior3) {
  _inherits(HealsBelowPercentBehavior, _Behavior3);

  function HealsBelowPercentBehavior() {
    var percent = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];

    _classCallCheck(this, HealsBelowPercentBehavior);

    _get(Object.getPrototypeOf(HealsBelowPercentBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.HEAL);
    this.healPercent = percent;
  }

  _createClass(HealsBelowPercentBehavior, [{
    key: 'act',
    value: function act(me) {
      if (me.hp.gtPercent(this.healPercent)) return true;
      var healItems = _lodash2['default'].filter(me.inventory, function (item) {
        return item.healRoll && item.canUse(me);
      });
      if (healItems.length === 0) return true;
      var healItem = _lodash2['default'].sample(healItems);
      healItem.use(me);
      return false;
    }
  }]);

  return HealsBelowPercentBehavior;
})(_definitionsBehavior2['default']);

var HealsBelowPercent = function HealsBelowPercent(percent) {
  return new HealsBelowPercentBehavior(percent);
};
exports.HealsBelowPercent = HealsBelowPercent;

},{"../../definitions/behavior":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/behavior.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/targetting.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsBehavior = require('../../definitions/behavior');

var _definitionsBehavior2 = _interopRequireDefault(_definitionsBehavior);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var isTargetBad = function isTargetBad(me) {
  return !me.target || me.target && me.target.hp.atMin() || me.target && me.target.z !== me.z;
};

// retarget and find a new player to attack
var targetNewPlayer = function targetNewPlayer(me) {
  if (isTargetBad(me)) {
    me.setTarget((0, _lodash2['default'])(_initGamestate2['default'].players).reject(function (player) {
      return player.hp.atMin();
    }).sample());
  }

  if (!me.target) return false; // they can wait, you may come back

  return true; // successful retarget
};

/* always seeks a target */

var BloodthirstyBehavior = (function (_Behavior) {
  _inherits(BloodthirstyBehavior, _Behavior);

  function BloodthirstyBehavior() {
    _classCallCheck(this, BloodthirstyBehavior);

    _get(Object.getPrototypeOf(BloodthirstyBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.TARGET);
  }

  _createClass(BloodthirstyBehavior, [{
    key: 'act',
    value: function act(me) {
      if (!targetNewPlayer(me)) return;
      me.stepTowards(me.target);
      return false;
    }
  }]);

  return BloodthirstyBehavior;
})(_definitionsBehavior2['default']);

var Bloodthirsty = function Bloodthirsty() {
  return new BloodthirstyBehavior();
};

exports.Bloodthirsty = Bloodthirsty;
/* seeks a target if they're within vision range */

var SeeksTargetInSightBehavior = (function (_Behavior2) {
  _inherits(SeeksTargetInSightBehavior, _Behavior2);

  function SeeksTargetInSightBehavior() {
    _classCallCheck(this, SeeksTargetInSightBehavior);

    _get(Object.getPrototypeOf(SeeksTargetInSightBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.MOVE);
  }

  _createClass(SeeksTargetInSightBehavior, [{
    key: 'act',
    value: function act(me) {
      var possibleTargets = [];

      _initGamestate2['default'].world.fov[me.z].compute(me.x, me.y, me.getSight(), function (x, y) {
        var entity = _initGamestate2['default'].world.getEntity(x, y, me.z);
        if (!entity || !me.canAttack(entity) || !me.canSee(entity)) return;
        possibleTargets.push(entity);
      });

      if (me.target && _lodash2['default'].contains(possibleTargets, me.target)) {
        me.stepTowards(me.target);
      } else if (possibleTargets.length > 0) {
        me.setTarget(_lodash2['default'].sample(possibleTargets));
        me.stepTowards(me.target);
      } else {
        me.stepRandomly();
      }

      return false;
    }
  }]);

  return SeeksTargetInSightBehavior;
})(_definitionsBehavior2['default']);

var SeeksTargetInSight = function SeeksTargetInSight() {
  return new SeeksTargetInSightBehavior();
};

exports.SeeksTargetInSight = SeeksTargetInSight;

var SeeksTargetViaHearingBehavior = (function (_Behavior3) {
  _inherits(SeeksTargetViaHearingBehavior, _Behavior3);

  function SeeksTargetViaHearingBehavior() {
    var range = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];

    _classCallCheck(this, SeeksTargetViaHearingBehavior);

    _get(Object.getPrototypeOf(SeeksTargetViaHearingBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.MOVE);
    this.range = range;
  }

  _createClass(SeeksTargetViaHearingBehavior, [{
    key: 'act',
    value: function act(me) {
      if (!me.target || isTargetBad(me)) return true;
      me.stepTowards(me.target);
      return false;
    }
  }, {
    key: 'hear',
    value: function hear(me, potentialTarget) {
      var distBetweenTarget = me.distBetween(potentialTarget);
      if (distBetweenTarget > this.range) return;
      if (!me.target) {
        me.setTarget(potentialTarget);
      } else if (distBetweenTarget < me.distBetween(me.target)) {
        me.setTarget(potentialTarget);
      }
    }
  }]);

  return SeeksTargetViaHearingBehavior;
})(_definitionsBehavior2['default']);

var SeeksTargetViaHearing = function SeeksTargetViaHearing(range) {
  return new SeeksTargetViaHearingBehavior(range);
};

exports.SeeksTargetViaHearing = SeeksTargetViaHearing;
/* wanders around aimlessly */

var WandersBehavior = (function (_Behavior4) {
  _inherits(WandersBehavior, _Behavior4);

  function WandersBehavior() {
    _classCallCheck(this, WandersBehavior);

    _get(Object.getPrototypeOf(WandersBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.MOVE);
  }

  _createClass(WandersBehavior, [{
    key: 'act',
    value: function act(me) {
      me.stepRandomly();
      return false;
    }
  }]);

  return WandersBehavior;
})(_definitionsBehavior2['default']);

var Wanders = function Wanders() {
  return new WandersBehavior();
};

exports.Wanders = Wanders;

var ExploresDungeonBehavior = (function (_Behavior5) {
  _inherits(ExploresDungeonBehavior, _Behavior5);

  function ExploresDungeonBehavior() {
    _classCallCheck(this, ExploresDungeonBehavior);

    _get(Object.getPrototypeOf(ExploresDungeonBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.MOVE);
    this.targets = [];
  }

  _createClass(ExploresDungeonBehavior, [{
    key: 'getCentralCoords',
    value: function getCentralCoords(room) {
      return {
        x: room._x1 + ~ ~((room._x2 - room._x1) / 2),
        y: room._y1 + ~ ~((room._y2 - room._y1) / 2)
      };
    }
  }, {
    key: 'checkForRoomActivity',
    value: function checkForRoomActivity(me) {
      var ignoreCurrent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      // mark the current room, if any, as explored
      var currentRoom = _lodash2['default'].find(_initGamestate2['default'].world.tiles[me.z].rooms, function (room) {
        return room._x1 < me.x && room._x2 > me.x && room._y1 < me.y && room._y2 > me.y;
      });

      if (!currentRoom || ignoreCurrent && _lodash2['default'].isEqual(this.target, this.getCentralCoords(currentRoom))) return;
      currentRoom.isExplored = true;
    }
  }, {
    key: 'rebuildPathToTarget',
    value: function rebuildPathToTarget(me) {
      this.pathToTarget = me.simplePathingMap(this.target.x, this.target.y);
    }
  }, {
    key: 'buildListOfTargets',
    value: function buildListOfTargets(me) {
      var _this = this;

      this.targets = _lodash2['default'].map(_initGamestate2['default'].world.tiles[me.z].rooms, function (room) {
        var _getCentralCoords = _this.getCentralCoords(room);

        var x = _getCentralCoords.x;
        var y = _getCentralCoords.y;

        room.x = x;
        room.y = y;
        room.isRoom = true;
        return room;
      });
    }
  }, {
    key: 'findMatchingTarget',
    value: function findMatchingTarget() {
      return _lodash2['default'].findWhere(this.targets, this.target);
    }
  }, {
    key: 'addTarget',
    value: function addTarget(targets) {
      var _targets;

      (_targets = this.targets).unshift.apply(_targets, _toConsumableArray(targets));
      this.targets = _lodash2['default'].uniq(this.targets);
    }
  }, {
    key: 'removeTarget',
    value: function removeTarget(target) {
      this.targets = _lodash2['default'].without(this.targets, target);
    }
  }, {
    key: 'act',
    value: function act(me) {

      if (!me._path) return;

      if (!this.targets.length) {
        this.buildListOfTargets(me);
      }

      // take a random step if you've explored everything
      if (_lodash2['default'].all(this.targets, function (room) {
        return room.isExplored;
      })) {
        me.stepRandomly();
        return;
      }

      var meSight = me.getSight();

      // check for stairs down but only if you're not on the last floor (because those stairs down don't do anything if they're there)
      this.stairsInRange = _initGamestate2['default'].world.getValidTilesInRange(me.x, me.y, me.z, meSight, function (tile) {
        return tile.constructor.name === 'StairsDown';
      })[0];
      if (this.stairsInRange && _initGamestate2['default'].currentFloor !== _initGamestate2['default'].world.depth - 1) this.addTarget([this.stairsInRange]);

      var tilesWithItems = _initGamestate2['default'].world.getValidTilesInRange(me.x, me.y, me.z, meSight, function (tile) {
        var items = _initGamestate2['default'].world.getItemsAt(tile.x, tile.y, me.z);
        return items && items.length > 0;
      });

      this.addTarget(tilesWithItems);

      var nextTarget = _lodash2['default'].find(this.targets, function (t) {
        return !t.isExplored;
      });
      this.target = { x: nextTarget.x, y: nextTarget.y };

      if (!this.lastTarget || this.lastTarget && !_lodash2['default'].isEqual(this.target, this.lastTarget)) {
        this.rebuildPathToTarget(me);
      }

      this.lastTarget = this.target;

      // no valid path to target.. try wandering around?
      if (!me.stepTowards(this.target, this.pathToTarget)) {
        me.stepRandomly();
      }

      // if we hit the spot we're supposed to hit, clear some stuff up.
      if (this.target.x === me.x && this.target.y === me.y) {
        this.checkForRoomActivity(me);
        var targetItem = this.findMatchingTarget();
        if (!targetItem.isRoom) this.removeTarget(targetItem);
      }
    }
  }, {
    key: 'step',
    value: function step(me) {
      this.checkForRoomActivity(me, false);
    }
  }, {
    key: 'descend',
    value: function descend(me) {
      this.buildListOfTargets(me);
    }
  }]);

  return ExploresDungeonBehavior;
})(_definitionsBehavior2['default']);

var ExploresDungeon = function ExploresDungeon() {
  return new ExploresDungeonBehavior();
};

exports.ExploresDungeon = ExploresDungeon;
/* has very loud footsteps. pretty much, only players have or need this */

var AlertsOnStepBehavior = (function (_Behavior6) {
  _inherits(AlertsOnStepBehavior, _Behavior6);

  function AlertsOnStepBehavior() {
    _classCallCheck(this, AlertsOnStepBehavior);

    _get(Object.getPrototypeOf(AlertsOnStepBehavior.prototype), 'constructor', this).call(this, _definitionsBehavior.Priority.ALWAYS);
  }

  _createClass(AlertsOnStepBehavior, [{
    key: 'step',
    value: function step(me) {
      me.alertAllInRange();
    }
  }]);

  return AlertsOnStepBehavior;
})(_definitionsBehavior2['default']);

var AlertsOnStep = function AlertsOnStep() {
  return new AlertsOnStepBehavior();
};
exports.AlertsOnStep = AlertsOnStep;

},{"../../definitions/behavior":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/behavior.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/effects/fountain.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _items_special = require('../items/_special');

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _definitionsEffect = require('../../definitions/effect');

var _definitionsEffect2 = _interopRequireDefault(_definitionsEffect);

var _worldgenMonsterSpawner = require('../../worldgen/monster-spawner');

var _worldgenMonsterSpawner2 = _interopRequireDefault(_worldgenMonsterSpawner);

var FountainEffect = (function (_Effect) {
  _inherits(FountainEffect, _Effect);

  function FountainEffect() {
    _classCallCheck(this, FountainEffect);

    _get(Object.getPrototypeOf(FountainEffect.prototype), 'constructor', this).apply(this, arguments);
  }

  return FountainEffect;
})(_definitionsEffect2['default']);

var NoEffect = (function (_FountainEffect) {
  _inherits(NoEffect, _FountainEffect);

  function NoEffect() {
    _classCallCheck(this, NoEffect);

    _get(Object.getPrototypeOf(NoEffect.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(NoEffect, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' drinks from the fountain, but the tepid water is tasteless.');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 19;
    }
  }]);

  return NoEffect;
})(FountainEffect);

exports.NoEffect = NoEffect;

var DropGold = (function (_FountainEffect2) {
  _inherits(DropGold, _FountainEffect2);

  function DropGold() {
    _classCallCheck(this, DropGold);

    _get(Object.getPrototypeOf(DropGold.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(DropGold, null, [{
    key: 'use',
    value: function use(entity) {
      var gold = new _items_special.Gold((0, _libDiceRoller2['default'])('1d1000'));
      _initGamestate2['default'].world.moveItem(gold, entity.x, entity.y, entity.z);
      this.msg(entity, entity.name + ' hears the sound of gold dropping to the ground.');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 8;
    }
  }]);

  return DropGold;
})(FountainEffect);

exports.DropGold = DropGold;

var Contaminated = (function (_FountainEffect3) {
  _inherits(Contaminated, _FountainEffect3);

  function Contaminated() {
    _classCallCheck(this, Contaminated);

    _get(Object.getPrototypeOf(Contaminated.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Contaminated, null, [{
    key: 'use',
    value: function use(entity) {
      var hasPsnRst = entity.hasTrait('PoisonResistance');
      var damageRoll = hasPsnRst ? '1d4' : '1d10';
      var abusesStats = !hasPsnRst;
      var msg = hasPsnRst ? entity.name + ' drank water from a nearby apple farm runoff stream.' : 'Yuck! ' + entity.name + ' drank contaminated water.';
      if (abusesStats) {
        entity.abuse('str', '1d2+1');
        entity.abuse('con', '1d2');
      }

      entity.takeDamage((0, _libDiceRoller2['default'])(damageRoll), { name: 'fountain' });
      this.msg(entity, msg);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return Contaminated;
})(FountainEffect);

exports.Contaminated = Contaminated;

var BlurredVision = (function (_FountainEffect4) {
  _inherits(BlurredVision, _FountainEffect4);

  function BlurredVision() {
    _classCallCheck(this, BlurredVision);

    _get(Object.getPrototypeOf(BlurredVision.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(BlurredVision, null, [{
    key: 'use',
    value: function use(entity) {
      entity.addTrait(Traits.SeeInvisible({ level: 5 }));
      entity.exercise('wis');
      this.msg(entity, entity.name + ' vision blurs, then returns sharper than before.');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 2;
    }
  }]);

  return BlurredVision;
})(FountainEffect);

exports.BlurredVision = BlurredVision;

var SpawnSnakes = (function (_FountainEffect5) {
  _inherits(SpawnSnakes, _FountainEffect5);

  function SpawnSnakes() {
    _classCallCheck(this, SpawnSnakes);

    _get(Object.getPrototypeOf(SpawnSnakes.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SpawnSnakes, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' drinks from the fountain.');
      this.msg(entity, 'An endless stream of snakes pours out!');
      var spawned = (0, _libDiceRoller2['default'])('1d5 + 1');

      var validTiles = _lodash2['default'].sample(this.getEmptyTilesInRange(entity), spawned);

      for (var i = 0; i < spawned; i++) {
        if (!validTiles[i]) continue;
        _worldgenMonsterSpawner2['default'].spawnSingle('waterMoccasin', validTiles[i]);
      }
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return SpawnSnakes;
})(FountainEffect);

exports.SpawnSnakes = SpawnSnakes;

var StrangeFeeling = (function (_FountainEffect6) {
  _inherits(StrangeFeeling, _FountainEffect6);

  function StrangeFeeling() {
    _classCallCheck(this, StrangeFeeling);

    _get(Object.getPrototypeOf(StrangeFeeling.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(StrangeFeeling, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' momentarily feels strange, then it passes.');
      entity.exercise('wis');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 3;
    }
  }]);

  return StrangeFeeling;
})(FountainEffect);

exports.StrangeFeeling = StrangeFeeling;

var CurseItems = (function (_FountainEffect7) {
  _inherits(CurseItems, _FountainEffect7);

  function CurseItems() {
    _classCallCheck(this, CurseItems);

    _get(Object.getPrototypeOf(CurseItems.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(CurseItems, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' drank some bad water!');
      _lodash2['default'].each(entity.inventory, function (item) {
        if (_rotJs2['default'].RNG.getPercentage() > 20) return;
        item.curse();
      });
    }
  }, {
    key: 'probability',
    get: function get() {
      return 2;
    }
  }]);

  return CurseItems;
})(FountainEffect);

exports.CurseItems = CurseItems;

var SpawnDemon = (function (_FountainEffect8) {
  _inherits(SpawnDemon, _FountainEffect8);

  function SpawnDemon() {
    _classCallCheck(this, SpawnDemon);

    _get(Object.getPrototypeOf(SpawnDemon.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SpawnDemon, null, [{
    key: 'use',
    value: function use(entity) {

      var validTile = _lodash2['default'].sample(this.getEmptyTilesInRange(entity));

      if (!validTile) return;
      this.msg(entity, entity.name + ' summons a demon from the water plane!');
      _worldgenMonsterSpawner2['default'].spawnSingle('waterDemon', validTile);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return SpawnDemon;
})(FountainEffect);

exports.SpawnDemon = SpawnDemon;

var SpawnNymph = (function (_FountainEffect9) {
  _inherits(SpawnNymph, _FountainEffect9);

  function SpawnNymph() {
    _classCallCheck(this, SpawnNymph);

    _get(Object.getPrototypeOf(SpawnNymph.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SpawnNymph, null, [{
    key: 'use',
    value: function use(entity) {

      var validTile = _lodash2['default'].sample(this.getEmptyTilesInRange(entity));
      if (!validTile) return;

      this.msg(entity, entity.name + ' attracts a water nymph!');
      _worldgenMonsterSpawner2['default'].spawnSingle('waterNymph', validTile);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return SpawnNymph;
})(FountainEffect);

exports.SpawnNymph = SpawnNymph;

},{"../../definitions/effect":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/effect.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../../worldgen/monster-spawner":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/monster-spawner.js","../items/_special":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_special.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/effects/sink-drink.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _definitionsEffect = require('../../definitions/effect');

var _definitionsEffect2 = _interopRequireDefault(_definitionsEffect);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _worldgenMonsterSpawner = require('../../worldgen/monster-spawner');

var _worldgenMonsterSpawner2 = _interopRequireDefault(_worldgenMonsterSpawner);

var _constantsRandom = require('../../constants/random');

var SinkDrinkEffect = (function (_Effect) {
  _inherits(SinkDrinkEffect, _Effect);

  function SinkDrinkEffect() {
    _classCallCheck(this, SinkDrinkEffect);

    _get(Object.getPrototypeOf(SinkDrinkEffect.prototype), 'constructor', this).apply(this, arguments);
  }

  return SinkDrinkEffect;
})(_definitionsEffect2['default']);

var NoEffect = (function (_SinkDrinkEffect) {
  _inherits(NoEffect, _SinkDrinkEffect);

  function NoEffect() {
    _classCallCheck(this, NoEffect);

    _get(Object.getPrototypeOf(NoEffect.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(NoEffect, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' takes a sip of water from the sink.');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 25;
    }
  }]);

  return NoEffect;
})(SinkDrinkEffect);

exports.NoEffect = NoEffect;

var HardWater = (function (_SinkDrinkEffect2) {
  _inherits(HardWater, _SinkDrinkEffect2);

  function HardWater() {
    _classCallCheck(this, HardWater);

    _get(Object.getPrototypeOf(HardWater.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(HardWater, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' tastes hard, awful water.');
      entity.gainXp(1);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 20;
    }
  }]);

  return HardWater;
})(SinkDrinkEffect);

exports.HardWater = HardWater;

var HotWater = (function (_SinkDrinkEffect3) {
  _inherits(HotWater, _SinkDrinkEffect3);

  function HotWater() {
    _classCallCheck(this, HotWater);

    _get(Object.getPrototypeOf(HotWater.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(HotWater, null, [{
    key: 'use',
    value: function use(entity) {
      var hasFireRst = entity.hasTrait('FireResistance');
      var msg = entity.name + ' took a sip of scalding hot water.';
      if (hasFireRst) {
        msg += ' It was quite tasty.';
      } else {
        var damage = (0, _libDiceRoller2['default'])('1d6');
        entity.takeDamage(damage, { name: 'sink' });
      }

      this.msg(entity, msg);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 5;
    }
  }]);

  return HotWater;
})(SinkDrinkEffect);

exports.HotWater = HotWater;

var SpawnRat = (function (_SinkDrinkEffect4) {
  _inherits(SpawnRat, _SinkDrinkEffect4);

  function SpawnRat() {
    _classCallCheck(this, SpawnRat);

    _get(Object.getPrototypeOf(SpawnRat.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SpawnRat, null, [{
    key: 'use',
    value: function use(entity, sink) {

      var validTile = _lodash2['default'].sample(this.getEmptyTilesInRange(sink));

      if (!validTile) return;
      this.msg(entity, entity.name + ' found a rat in the sink. Ewww!');
      _worldgenMonsterSpawner2['default'].spawnSingle('sewerRat', validTile);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return SpawnRat;
})(SinkDrinkEffect);

exports.SpawnRat = SpawnRat;

var SpawnElemental = (function (_SinkDrinkEffect5) {
  _inherits(SpawnElemental, _SinkDrinkEffect5);

  function SpawnElemental() {
    _classCallCheck(this, SpawnElemental);

    _get(Object.getPrototypeOf(SpawnElemental.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SpawnElemental, null, [{
    key: 'use',
    value: function use(entity, sink) {

      var validTile = _lodash2['default'].sample(this.getEmptyTilesInRange(sink));

      if (!validTile) return;
      this.msg(entity, entity.name + ' caused the water to think for itself!');
      _worldgenMonsterSpawner2['default'].spawnSingle('waterElemental', validTile);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return SpawnElemental;
})(SinkDrinkEffect);

exports.SpawnElemental = SpawnElemental;

var RingGen = (function (_SinkDrinkEffect6) {
  _inherits(RingGen, _SinkDrinkEffect6);

  function RingGen() {
    _classCallCheck(this, RingGen);

    _get(Object.getPrototypeOf(RingGen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingGen, null, [{
    key: 'use',
    value: function use(entity, sink) {
      if (sink._gotRing) {
        this.msg(entity, entity.name + ' sees murky water in the sink.');
        return;
      }
      sink._gotRing = true;
      entity.exercise('wis');
      var ring = (0, _constantsRandom.Ring)({ bucName: 'uncursed' });
      _initGamestate2['default'].world.moveItem(ring, entity.x, entity.y, entity.z);
      this.msg(entity, entity.name + ' found a ring in the sink!');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return RingGen;
})(SinkDrinkEffect);

exports.RingGen = RingGen;

var PotionDrink = (function (_SinkDrinkEffect7) {
  _inherits(PotionDrink, _SinkDrinkEffect7);

  function PotionDrink() {
    _classCallCheck(this, PotionDrink);

    _get(Object.getPrototypeOf(PotionDrink.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(PotionDrink, null, [{
    key: 'use',
    value: function use(entity) {
      var potion = (0, _constantsRandom.Potion)({ bucName: 'uncursed' });
      this.msg(entity, entity.name + ' sees ' + potion.color + ' water flowing in the sink!');
      potion.use(entity);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return PotionDrink;
})(SinkDrinkEffect);

exports.PotionDrink = PotionDrink;

},{"../../constants/random":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/random.js","../../definitions/effect":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/effect.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../../worldgen/monster-spawner":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/monster-spawner.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/effects/sink-kick.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _definitionsEffect = require('../../definitions/effect');

var _definitionsEffect2 = _interopRequireDefault(_definitionsEffect);

var _constantsRandom = require('../../constants/random');

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _worldgenMonsterSpawner = require('../../worldgen/monster-spawner');

var _worldgenMonsterSpawner2 = _interopRequireDefault(_worldgenMonsterSpawner);

var SinkKickEffect = (function (_Effect) {
  _inherits(SinkKickEffect, _Effect);

  function SinkKickEffect() {
    _classCallCheck(this, SinkKickEffect);

    _get(Object.getPrototypeOf(SinkKickEffect.prototype), 'constructor', this).apply(this, arguments);
  }

  return SinkKickEffect;
})(_definitionsEffect2['default']);

var BasicEffect = (function (_SinkKickEffect) {
  _inherits(BasicEffect, _SinkKickEffect);

  function BasicEffect() {
    _classCallCheck(this, BasicEffect);

    _get(Object.getPrototypeOf(BasicEffect.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(BasicEffect, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' kicks the sink and it vibrates nosily.');
      entity.alertAllInRange(50);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 7;
    }
  }]);

  return BasicEffect;
})(SinkKickEffect);

exports.BasicEffect = BasicEffect;

var RingGen = (function (_SinkKickEffect2) {
  _inherits(RingGen, _SinkKickEffect2);

  function RingGen() {
    _classCallCheck(this, RingGen);

    _get(Object.getPrototypeOf(RingGen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingGen, null, [{
    key: 'use',
    value: function use(entity, sink) {
      if (sink._gotRing) {
        this.msg(entity, entity.name + ' kicked murky water out of the sink.');
        return;
      }
      sink._gotRing = true;
      entity.exercise('wis');
      entity.exercise('dex');
      var ring = (0, _constantsRandom.Ring)({ bucName: 'uncursed' });
      _initGamestate2['default'].world.moveItem(ring, entity.x, entity.y, entity.z);
      this.msg(entity, entity.name + ' found a ring shining in the murky goop!');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 3;
    }
  }]);

  return RingGen;
})(SinkKickEffect);

exports.RingGen = RingGen;

var BadKick = (function (_SinkKickEffect3) {
  _inherits(BadKick, _SinkKickEffect3);

  function BadKick() {
    _classCallCheck(this, BadKick);

    _get(Object.getPrototypeOf(BadKick.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(BadKick, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' fumbled while kicking the sink.');
      entity.alertAllInRange(50);
      entity.abuse('dex');
      entity.abuse('wis');
      var damage = (0, _libDiceRoller2['default'])('1d5');
      entity.takeDamage(damage, { name: 'sink' });
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return BadKick;
})(SinkKickEffect);

exports.BadKick = BadKick;

var SpawnsPudding = (function (_SinkKickEffect4) {
  _inherits(SpawnsPudding, _SinkKickEffect4);

  function SpawnsPudding() {
    _classCallCheck(this, SpawnsPudding);

    _get(Object.getPrototypeOf(SpawnsPudding.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SpawnsPudding, null, [{
    key: 'use',
    value: function use(entity, sink) {
      var validTile = _lodash2['default'].sample(this.getEmptyTilesInRange(sink));

      if (!validTile) return;
      this.msg(entity, entity.name + ' caused black ooze to rise out of the sink!');
      _worldgenMonsterSpawner2['default'].spawnSingle('blackPudding', validTile);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return SpawnsPudding;
})(SinkKickEffect);

exports.SpawnsPudding = SpawnsPudding;

},{"../../constants/random":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/random.js","../../definitions/effect":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/effect.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../../worldgen/monster-spawner":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/monster-spawner.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/effects/throne.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _definitionsEffect = require('../../definitions/effect');

var _definitionsEffect2 = _interopRequireDefault(_definitionsEffect);

var _worldgenMonsterSpawner = require('../../worldgen/monster-spawner');

var _worldgenMonsterSpawner2 = _interopRequireDefault(_worldgenMonsterSpawner);

var ThroneEffect = (function (_Effect) {
  _inherits(ThroneEffect, _Effect);

  function ThroneEffect() {
    _classCallCheck(this, ThroneEffect);

    _get(Object.getPrototypeOf(ThroneEffect.prototype), 'constructor', this).apply(this, arguments);
  }

  return ThroneEffect;
})(_definitionsEffect2['default']);

var Identify = (function (_ThroneEffect) {
  _inherits(Identify, _ThroneEffect);

  function Identify() {
    _classCallCheck(this, Identify);

    _get(Object.getPrototypeOf(Identify.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Identify, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' was granted insight!');
      _lodash2['default'].each(entity.inventory, function (item) {
        if (_rotJs2['default'].RNG.getPercentage() <= 20) return;
        item.identify();
      });
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return Identify;
})(ThroneEffect);

exports.Identify = Identify;

var HealthGainBonus = (function (_ThroneEffect2) {
  _inherits(HealthGainBonus, _ThroneEffect2);

  function HealthGainBonus() {
    _classCallCheck(this, HealthGainBonus);

    _get(Object.getPrototypeOf(HealthGainBonus.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(HealthGainBonus, null, [{
    key: 'use',
    value: function use(entity) {
      var hpGained = (0, _libDiceRoller2['default'])('1d10');
      this.msg(entity, entity.name + ' feels much, much better!');
      entity.hp.max += hpGained;
      entity.hp.toMax();
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return HealthGainBonus;
})(ThroneEffect);

exports.HealthGainBonus = HealthGainBonus;

var Ouch = (function (_ThroneEffect3) {
  _inherits(Ouch, _ThroneEffect3);

  function Ouch() {
    _classCallCheck(this, Ouch);

    _get(Object.getPrototypeOf(Ouch.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Ouch, null, [{
    key: 'use',
    value: function use(entity) {
      var hpLost = (0, _libDiceRoller2['default'])('1d10');
      var statLost = (0, _libDiceRoller2['default'])('1d4 + 2');
      var stat = _lodash2['default'].sample(['con', 'dex', 'int', 'wis', 'str', 'cha', 'luk']);
      this.msg(entity, entity.name + ' feels a painful surge!');
      entity.takeDamage(hpLost, { name: 'throne' });
      entity[stat] -= statLost;
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return Ouch;
})(ThroneEffect);

exports.Ouch = Ouch;

var Shocking = (function (_ThroneEffect4) {
  _inherits(Shocking, _ThroneEffect4);

  function Shocking() {
    _classCallCheck(this, Shocking);

    _get(Object.getPrototypeOf(Shocking.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Shocking, null, [{
    key: 'use',
    value: function use(entity) {
      var hasShkRst = entity.hasTrait('ShockResistance');
      var damageRoll = hasShkRst ? '1d6' : '1d30';

      entity.abuse('con', '1d1');
      entity.takeDamage((0, _libDiceRoller2['default'])(damageRoll), { name: 'throne' });
      this.msg(entity, entity.name + ' was viciously shocked!');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return Shocking;
})(ThroneEffect);

exports.Shocking = Shocking;

var Clarity = (function (_ThroneEffect5) {
  _inherits(Clarity, _ThroneEffect5);

  function Clarity() {
    _classCallCheck(this, Clarity);

    _get(Object.getPrototypeOf(Clarity.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Clarity, null, [{
    key: 'use',
    value: function use(entity) {
      if (entity.hasTrait('SeeInvisible')) {
        this.msg(entity, entity.name + ' has a strange sensation, then it passes.');
        return;
      }
      entity.addTrait(Traits.SeeInvisible({ level: 5 }));
      this.msg(entity, entity.name + ' has a moment of clarity.');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return Clarity;
})(ThroneEffect);

exports.Clarity = Clarity;

var LoseThatGold = (function (_ThroneEffect6) {
  _inherits(LoseThatGold, _ThroneEffect6);

  function LoseThatGold() {
    _classCallCheck(this, LoseThatGold);

    _get(Object.getPrototypeOf(LoseThatGold.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(LoseThatGold, null, [{
    key: 'use',
    value: function use(entity) {
      if (entity.gold === 0) {
        this.msg(entity, entity.name + ' has a strange sensation, then it passes.');
        return;
      }

      entity.gold = 0;
      this.msg(entity, entity.name + ' lost a lotta gold!');
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return LoseThatGold;
})(ThroneEffect);

exports.LoseThatGold = LoseThatGold;

var RandomTeleport = (function (_ThroneEffect7) {
  _inherits(RandomTeleport, _ThroneEffect7);

  function RandomTeleport() {
    _classCallCheck(this, RandomTeleport);

    _get(Object.getPrototypeOf(RandomTeleport.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RandomTeleport, null, [{
    key: 'use',
    value: function use(entity) {
      this.msg(entity, entity.name + ' feels a wrenching sensation!');
      _initGamestate2['default'].world.placeEntityAtRandomLocation(entity);
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return RandomTeleport;
})(ThroneEffect);

exports.RandomTeleport = RandomTeleport;

var SpawnCreatures = (function (_ThroneEffect8) {
  _inherits(SpawnCreatures, _ThroneEffect8);

  function SpawnCreatures() {
    _classCallCheck(this, SpawnCreatures);

    _get(Object.getPrototypeOf(SpawnCreatures.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SpawnCreatures, null, [{
    key: 'use',
    value: function use(entity) {

      var monsters = ['kobold', 'gnome', 'goblin', 'hobgoblin', 'orc'];

      this.msg(entity, entity.name + ' summoned a throne room audience!');
      var spawned = (0, _libDiceRoller2['default'])('1d10');

      var validTiles = _lodash2['default'].sample(this.getEmptyTilesInRange(entity, 5), spawned);

      for (var i = 0; i < spawned; i++) {
        if (!validTiles[i]) continue;
        _worldgenMonsterSpawner2['default'].spawnSingle(_lodash2['default'].sample(monsters), validTiles[i]);
      }
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return SpawnCreatures;
})(ThroneEffect);

exports.SpawnCreatures = SpawnCreatures;

},{"../../definitions/effect":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/effect.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../../worldgen/monster-spawner":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/monster-spawner.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/flavor/names.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = ['Edrix', 'Orfane', 'Odisatije', 'Sefakybeh', 'Erdyinja', 'Eninunagi', 'Efesu', 'Wetef', 'Areyekuwe', 'Uvecusof', 'Veseci', 'Lulalona', 'Ivelet', 'Ucal', 'Wartberg', 'Devew', 'Sose', 'Ophix', 'Talon', 'Nunit', 'Meper', 'Tegavad', 'Sonja', 'Esali', 'Taxire', 'Xanelel', 'Enhailor', 'Sujeb', 'Elahioa', 'Annalie', 'Oivoi', 'Tidiyiwi', 'Elahica', 'Erioalin', 'Fidiv', 'Feropit', 'Nolid', 'Illiwanu', 'Itixas', 'Deverilian', 'Canub', 'Welby', 'Bolmixfon', 'Dextra', 'Vixgen', 'Dutuyaxe', 'Lenazodog', 'Woden', 'Darwin', 'Dontdie', 'Luth', 'Adab', 'Yuped', 'Nediru', 'Gorypegas', 'Anut', 'Eventine', 'Mythe', 'Avojindi', 'Odufin', 'Kiley', 'Irebeq', 'Tegono', 'Azdan', 'Oompha', 'Rokoser', 'Ihoxeqati', 'Ohiwudeh', 'Lexonycor', 'Ecor', 'Ebarad', 'Ritova', 'Nenaty', 'Diptusoroy', 'Dudley', 'Marvin', 'Ben', 'Tenaya', 'Robert', 'Izchak', 'Rab', 'Blizer', 'Raymond', 'Kyle', 'Erich', 'Austin', 'Skralg', 'Rodney'];
module.exports = exports['default'];

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_special.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsEquipment = require('../../definitions/equipment');

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var _constantsDecorators = require('../../constants/decorators');

var _constantsMaterials = require('../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var Gold = (function (_Special) {
  _inherits(Gold, _Special);

  function Gold(num) {
    _classCallCheck(this, _Gold);

    var opts = {
      glyph: { key: _constantsGlyphs.Items.Gold, fg: _constantsGlyphColors.Items.Gold }
    };
    _get(Object.getPrototypeOf(_Gold.prototype), 'constructor', this).call(this, opts);
    this.goldValue = num;
    this.realName = this.goldValue + ' gold';
  }

  var _Gold = Gold;
  Gold = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Gold)(Gold) || Gold;
  return Gold;
})(_definitionsEquipment.Special);

exports.Gold = Gold;

var Corpse = (function (_Comestible) {
  _inherits(Corpse, _Comestible);

  function Corpse() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? { monsterName: 'unknown' } : arguments[0];

    _classCallCheck(this, Corpse);

    _get(Object.getPrototypeOf(Corpse.prototype), 'constructor', this).call(this, opts);
    this.realName = 'corpse of ' + opts.monsterName;
  }

  return Corpse;
})(_definitionsEquipment.Comestible);

exports.Corpse = Corpse;

var StoneOfSelyk = (function (_Gem) {
  _inherits(StoneOfSelyk, _Gem);

  function StoneOfSelyk() {
    _classCallCheck(this, StoneOfSelyk);

    _get(Object.getPrototypeOf(StoneOfSelyk.prototype), 'constructor', this).call(this, { glyph: { fg: _constantsGlyphColors.Special.Selyk } });
    this.realName = 'Stone of Selyk';
  }

  return StoneOfSelyk;
})(_definitionsEquipment.Gem);

exports.StoneOfSelyk = StoneOfSelyk;

var SelykCellarKey = (function (_Tool) {
  _inherits(SelykCellarKey, _Tool);

  function SelykCellarKey() {
    _classCallCheck(this, SelykCellarKey);

    _get(Object.getPrototypeOf(SelykCellarKey.prototype), 'constructor', this).call(this, { glyph: { fg: _constantsGlyphColors.Special.Selyk } });
    this.realName = 'Selyk\'s Cellar Key';
  }

  return SelykCellarKey;
})(_definitionsEquipment.Tool);

exports.SelykCellarKey = SelykCellarKey;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _weaponsAxes = require('./weapons/axes');

var Axes = _interopRequireWildcard(_weaponsAxes);

var _weaponsBows = require('./weapons/bows');

var Bows = _interopRequireWildcard(_weaponsBows);

var _weaponsDaggers = require('./weapons/daggers');

var Daggers = _interopRequireWildcard(_weaponsDaggers);

var _weaponsMaces = require('./weapons/maces');

var Maces = _interopRequireWildcard(_weaponsMaces);

var _weaponsShortswords = require('./weapons/shortswords');

var ShortSwords = _interopRequireWildcard(_weaponsShortswords);

var _weaponsSpears = require('./weapons/spears');

var Spears = _interopRequireWildcard(_weaponsSpears);

var _weaponsStaves = require('./weapons/staves');

var Staves = _interopRequireWildcard(_weaponsStaves);

var _weaponsLongswords = require('./weapons/longswords');

var Swords = _interopRequireWildcard(_weaponsLongswords);

exports['default'] = _lodash2['default'].extend({}, Axes, Bows, Daggers, Maces, ShortSwords, Spears, Staves, Swords);
module.exports = exports['default'];

},{"./weapons/axes":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/axes.js","./weapons/bows":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/bows.js","./weapons/daggers":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/daggers.js","./weapons/longswords":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/longswords.js","./weapons/maces":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/maces.js","./weapons/shortswords":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/shortswords.js","./weapons/spears":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/spears.js","./weapons/staves":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/staves.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsEquipment = require('../../definitions/equipment');

var _libDefaultCalculations = require('../../lib/default-calculations');

var _constantsMaterials = require('../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../constants/decorators');

var TShirt = (function (_Body) {
  _inherits(TShirt, _Body);

  function TShirt() {
    _classCallCheck(this, _TShirt);

    _get(Object.getPrototypeOf(_TShirt.prototype), 'constructor', this).apply(this, arguments);
  }

  var _TShirt = TShirt;
  TShirt = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(TShirt) || TShirt;
  TShirt = (0, _constantsDecorators.rarity)(100)(TShirt) || TShirt;
  return TShirt;
})(_definitionsEquipment.Body);

exports.TShirt = TShirt;

var Robe = (function (_Body2) {
  _inherits(Robe, _Body2);

  function Robe() {
    _classCallCheck(this, _Robe);

    _get(Object.getPrototypeOf(_Robe.prototype), 'constructor', this).apply(this, arguments);
  }

  var _Robe = Robe;
  Robe = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(Robe) || Robe;
  Robe = (0, _constantsDecorators.rarity)(50)(Robe) || Robe;
  return Robe;
})(_definitionsEquipment.Body);

exports.Robe = Robe;

var LeatherJacket = (function (_Body3) {
  _inherits(LeatherJacket, _Body3);

  function LeatherJacket() {
    _classCallCheck(this, _LeatherJacket);

    _get(Object.getPrototypeOf(_LeatherJacket.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(LeatherJacket, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }]);

  var _LeatherJacket = LeatherJacket;
  LeatherJacket = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(LeatherJacket) || LeatherJacket;
  LeatherJacket = (0, _constantsDecorators.rarity)(75)(LeatherJacket) || LeatherJacket;
  return LeatherJacket;
})(_definitionsEquipment.Body);

exports.LeatherJacket = LeatherJacket;

var OrcishRingMail = (function (_Body4) {
  _inherits(OrcishRingMail, _Body4);

  function OrcishRingMail() {
    _classCallCheck(this, _OrcishRingMail);

    _get(Object.getPrototypeOf(_OrcishRingMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(OrcishRingMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 2);
    }
  }]);

  var _OrcishRingMail = OrcishRingMail;
  OrcishRingMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(OrcishRingMail) || OrcishRingMail;
  OrcishRingMail = (0, _constantsDecorators.rarity)(65)(OrcishRingMail) || OrcishRingMail;
  return OrcishRingMail;
})(_definitionsEquipment.Body);

exports.OrcishRingMail = OrcishRingMail;

var StuddedLeatherArmor = (function (_Body5) {
  _inherits(StuddedLeatherArmor, _Body5);

  function StuddedLeatherArmor() {
    _classCallCheck(this, _StuddedLeatherArmor);

    _get(Object.getPrototypeOf(_StuddedLeatherArmor.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(StuddedLeatherArmor, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 3);
    }
  }]);

  var _StuddedLeatherArmor = StuddedLeatherArmor;
  StuddedLeatherArmor = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(StuddedLeatherArmor) || StuddedLeatherArmor;
  StuddedLeatherArmor = (0, _constantsDecorators.rarity)(55)(StuddedLeatherArmor) || StuddedLeatherArmor;
  return StuddedLeatherArmor;
})(_definitionsEquipment.Body);

exports.StuddedLeatherArmor = StuddedLeatherArmor;

var RingMail = (function (_Body6) {
  _inherits(RingMail, _Body6);

  function RingMail() {
    _classCallCheck(this, _RingMail);

    _get(Object.getPrototypeOf(_RingMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 3);
    }
  }]);

  var _RingMail = RingMail;
  RingMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(RingMail) || RingMail;
  RingMail = (0, _constantsDecorators.rarity)(55)(RingMail) || RingMail;
  return RingMail;
})(_definitionsEquipment.Body);

exports.RingMail = RingMail;

var DragonScales = (function (_Body7) {
  _inherits(DragonScales, _Body7);

  function DragonScales() {
    _classCallCheck(this, _DragonScales);

    _get(Object.getPrototypeOf(_DragonScales.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(DragonScales, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 3);
    }
  }]);

  var _DragonScales = DragonScales;
  DragonScales = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Dragon)(DragonScales) || DragonScales;
  DragonScales = (0, _constantsDecorators.rarity)(1)(DragonScales) || DragonScales;
  return DragonScales;
})(_definitionsEquipment.Body);

exports.DragonScales = DragonScales;

var OrcishChainMail = (function (_Body8) {
  _inherits(OrcishChainMail, _Body8);

  function OrcishChainMail() {
    _classCallCheck(this, _OrcishChainMail);

    _get(Object.getPrototypeOf(_OrcishChainMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(OrcishChainMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 4);
    }
  }]);

  var _OrcishChainMail = OrcishChainMail;
  OrcishChainMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(OrcishChainMail) || OrcishChainMail;
  OrcishChainMail = (0, _constantsDecorators.rarity)(45)(OrcishChainMail) || OrcishChainMail;
  return OrcishChainMail;
})(_definitionsEquipment.Body);

exports.OrcishChainMail = OrcishChainMail;

var ScaleMail = (function (_Body9) {
  _inherits(ScaleMail, _Body9);

  function ScaleMail() {
    _classCallCheck(this, _ScaleMail);

    _get(Object.getPrototypeOf(_ScaleMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ScaleMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 4);
    }
  }]);

  var _ScaleMail = ScaleMail;
  ScaleMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(ScaleMail) || ScaleMail;
  ScaleMail = (0, _constantsDecorators.rarity)(45)(ScaleMail) || ScaleMail;
  return ScaleMail;
})(_definitionsEquipment.Body);

exports.ScaleMail = ScaleMail;

var ChainMail = (function (_Body10) {
  _inherits(ChainMail, _Body10);

  function ChainMail() {
    _classCallCheck(this, _ChainMail);

    _get(Object.getPrototypeOf(_ChainMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ChainMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 5);
    }
  }]);

  var _ChainMail = ChainMail;
  ChainMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(ChainMail) || ChainMail;
  ChainMail = (0, _constantsDecorators.rarity)(25)(ChainMail) || ChainMail;
  return ChainMail;
})(_definitionsEquipment.Body);

exports.ChainMail = ChainMail;

var ElvenMithrilCoat = (function (_Body11) {
  _inherits(ElvenMithrilCoat, _Body11);

  function ElvenMithrilCoat() {
    _classCallCheck(this, _ElvenMithrilCoat);

    _get(Object.getPrototypeOf(_ElvenMithrilCoat.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ElvenMithrilCoat, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 5);
    }
  }]);

  var _ElvenMithrilCoat = ElvenMithrilCoat;
  ElvenMithrilCoat = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Mithril)(ElvenMithrilCoat) || ElvenMithrilCoat;
  ElvenMithrilCoat = (0, _constantsDecorators.rarity)(25)(ElvenMithrilCoat) || ElvenMithrilCoat;
  return ElvenMithrilCoat;
})(_definitionsEquipment.Body);

exports.ElvenMithrilCoat = ElvenMithrilCoat;

var SplintMail = (function (_Body12) {
  _inherits(SplintMail, _Body12);

  function SplintMail() {
    _classCallCheck(this, _SplintMail);

    _get(Object.getPrototypeOf(_SplintMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SplintMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 6);
    }
  }]);

  var _SplintMail = SplintMail;
  SplintMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(SplintMail) || SplintMail;
  SplintMail = (0, _constantsDecorators.rarity)(15)(SplintMail) || SplintMail;
  return SplintMail;
})(_definitionsEquipment.Body);

exports.SplintMail = SplintMail;

var BandedMail = (function (_Body13) {
  _inherits(BandedMail, _Body13);

  function BandedMail() {
    _classCallCheck(this, _BandedMail);

    _get(Object.getPrototypeOf(_BandedMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(BandedMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 6);
    }
  }]);

  var _BandedMail = BandedMail;
  BandedMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(BandedMail) || BandedMail;
  BandedMail = (0, _constantsDecorators.rarity)(15)(BandedMail) || BandedMail;
  return BandedMail;
})(_definitionsEquipment.Body);

exports.BandedMail = BandedMail;

var DwarvenMithrilCoat = (function (_Body14) {
  _inherits(DwarvenMithrilCoat, _Body14);

  function DwarvenMithrilCoat() {
    _classCallCheck(this, _DwarvenMithrilCoat);

    _get(Object.getPrototypeOf(_DwarvenMithrilCoat.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(DwarvenMithrilCoat, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 6);
    }
  }]);

  var _DwarvenMithrilCoat = DwarvenMithrilCoat;
  DwarvenMithrilCoat = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Mithril)(DwarvenMithrilCoat) || DwarvenMithrilCoat;
  DwarvenMithrilCoat = (0, _constantsDecorators.rarity)(15)(DwarvenMithrilCoat) || DwarvenMithrilCoat;
  return DwarvenMithrilCoat;
})(_definitionsEquipment.Body);

exports.DwarvenMithrilCoat = DwarvenMithrilCoat;

var BronzePlateMail = (function (_Body15) {
  _inherits(BronzePlateMail, _Body15);

  function BronzePlateMail() {
    _classCallCheck(this, _BronzePlateMail);

    _get(Object.getPrototypeOf(_BronzePlateMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(BronzePlateMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 6);
    }
  }]);

  var _BronzePlateMail = BronzePlateMail;
  BronzePlateMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(BronzePlateMail) || BronzePlateMail;
  BronzePlateMail = (0, _constantsDecorators.rarity)(15)(BronzePlateMail) || BronzePlateMail;
  return BronzePlateMail;
})(_definitionsEquipment.Body);

exports.BronzePlateMail = BronzePlateMail;

var PlateMail = (function (_Body16) {
  _inherits(PlateMail, _Body16);

  function PlateMail() {
    _classCallCheck(this, _PlateMail);

    _get(Object.getPrototypeOf(_PlateMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(PlateMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 7);
    }
  }]);

  var _PlateMail = PlateMail;
  PlateMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(PlateMail) || PlateMail;
  PlateMail = (0, _constantsDecorators.rarity)(5)(PlateMail) || PlateMail;
  return PlateMail;
})(_definitionsEquipment.Body);

exports.PlateMail = PlateMail;

var CrystalPlateMail = (function (_Body17) {
  _inherits(CrystalPlateMail, _Body17);

  function CrystalPlateMail() {
    _classCallCheck(this, _CrystalPlateMail);

    _get(Object.getPrototypeOf(_CrystalPlateMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(CrystalPlateMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 7);
    }
  }]);

  var _CrystalPlateMail = CrystalPlateMail;
  CrystalPlateMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Glass)(CrystalPlateMail) || CrystalPlateMail;
  CrystalPlateMail = (0, _constantsDecorators.rarity)(5)(CrystalPlateMail) || CrystalPlateMail;
  return CrystalPlateMail;
})(_definitionsEquipment.Body);

exports.CrystalPlateMail = CrystalPlateMail;

var DragonScaleMail = (function (_Body18) {
  _inherits(DragonScaleMail, _Body18);

  function DragonScaleMail() {
    _classCallCheck(this, _DragonScaleMail);

    _get(Object.getPrototypeOf(_DragonScaleMail.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(DragonScaleMail, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 9);
    }
  }]);

  var _DragonScaleMail = DragonScaleMail;
  DragonScaleMail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Dragon)(DragonScaleMail) || DragonScaleMail;
  DragonScaleMail = (0, _constantsDecorators.rarity)(1)(DragonScaleMail) || DragonScaleMail;
  return DragonScaleMail;
})(_definitionsEquipment.Body);

exports.DragonScaleMail = DragonScaleMail;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../lib/default-calculations":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/default-calculations.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/cloaks.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsEquipment = require('../../definitions/equipment');

var _libDefaultCalculations = require('../../lib/default-calculations');

var _constantsMaterials = require('../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../constants/decorators');

var OrdinaryCloak = (function (_Cloak) {
  _inherits(OrdinaryCloak, _Cloak);

  function OrdinaryCloak() {
    _classCallCheck(this, _OrdinaryCloak);

    _get(Object.getPrototypeOf(_OrdinaryCloak.prototype), 'constructor', this).apply(this, arguments);
  }

  var _OrdinaryCloak = OrdinaryCloak;
  OrdinaryCloak = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(OrdinaryCloak) || OrdinaryCloak;
  OrdinaryCloak = (0, _constantsDecorators.rarity)(50)(OrdinaryCloak) || OrdinaryCloak;
  return OrdinaryCloak;
})(_definitionsEquipment.Cloak);

exports.OrdinaryCloak = OrdinaryCloak;

var MummyWrapping = (function (_Cloak2) {
  _inherits(MummyWrapping, _Cloak2);

  function MummyWrapping() {
    _classCallCheck(this, _MummyWrapping);

    _get(Object.getPrototypeOf(_MummyWrapping.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(MummyWrapping, [{
    key: 'Invisible',
    value: function Invisible() {
      return -1;
    }
  }]);

  var _MummyWrapping = MummyWrapping;
  MummyWrapping = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(MummyWrapping) || MummyWrapping;
  MummyWrapping = (0, _constantsDecorators.rarity)(10)(MummyWrapping) || MummyWrapping;
  return MummyWrapping;
})(_definitionsEquipment.Cloak);

exports.MummyWrapping = MummyWrapping;

var OrcishCloak = (function (_Cloak3) {
  _inherits(OrcishCloak, _Cloak3);

  function OrcishCloak() {
    _classCallCheck(this, _OrcishCloak);

    _get(Object.getPrototypeOf(_OrcishCloak.prototype), 'constructor', this).apply(this, arguments);
  }

  var _OrcishCloak = OrcishCloak;
  OrcishCloak = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(OrcishCloak) || OrcishCloak;
  OrcishCloak = (0, _constantsDecorators.rarity)(20)(OrcishCloak) || OrcishCloak;
  return OrcishCloak;
})(_definitionsEquipment.Cloak);

exports.OrcishCloak = OrcishCloak;

var DwarvenCloak = (function (_Cloak4) {
  _inherits(DwarvenCloak, _Cloak4);

  function DwarvenCloak() {
    _classCallCheck(this, _DwarvenCloak);

    _get(Object.getPrototypeOf(_DwarvenCloak.prototype), 'constructor', this).apply(this, arguments);
  }

  var _DwarvenCloak = DwarvenCloak;
  DwarvenCloak = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(DwarvenCloak) || DwarvenCloak;
  DwarvenCloak = (0, _constantsDecorators.rarity)(20)(DwarvenCloak) || DwarvenCloak;
  return DwarvenCloak;
})(_definitionsEquipment.Cloak);

exports.DwarvenCloak = DwarvenCloak;

var LeatherCloak = (function (_Cloak5) {
  _inherits(LeatherCloak, _Cloak5);

  function LeatherCloak() {
    _classCallCheck(this, _LeatherCloak);

    _get(Object.getPrototypeOf(_LeatherCloak.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(LeatherCloak, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 1);
    }
  }]);

  var _LeatherCloak = LeatherCloak;
  LeatherCloak = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(LeatherCloak) || LeatherCloak;
  LeatherCloak = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(LeatherCloak) || LeatherCloak;
  LeatherCloak = (0, _constantsDecorators.rarity)(2)(LeatherCloak) || LeatherCloak;
  return LeatherCloak;
})(_definitionsEquipment.Cloak);

exports.LeatherCloak = LeatherCloak;

var AlchemySmock = (function (_Cloak6) {
  _inherits(AlchemySmock, _Cloak6);

  function AlchemySmock() {
    _classCallCheck(this, _AlchemySmock);

    _get(Object.getPrototypeOf(_AlchemySmock.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AlchemySmock, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 1);
    }
  }, {
    key: 'PoisonResistance',
    value: function PoisonResistance() {
      return 1;
    }
  }, {
    key: 'AcidResistance',
    value: function AcidResistance() {
      return 1;
    }
  }]);

  var _AlchemySmock = AlchemySmock;
  AlchemySmock = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(AlchemySmock) || AlchemySmock;
  AlchemySmock = (0, _constantsDecorators.rarity)(1)(AlchemySmock) || AlchemySmock;
  return AlchemySmock;
})(_definitionsEquipment.Cloak);

exports.AlchemySmock = AlchemySmock;

var InvisibilityCloak = (function (_Cloak7) {
  _inherits(InvisibilityCloak, _Cloak7);

  function InvisibilityCloak() {
    _classCallCheck(this, _InvisibilityCloak);

    _get(Object.getPrototypeOf(_InvisibilityCloak.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(InvisibilityCloak, [{
    key: 'Invisible',
    value: function Invisible() {
      return 1;
    }
  }]);

  var _InvisibilityCloak = InvisibilityCloak;
  InvisibilityCloak = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(InvisibilityCloak) || InvisibilityCloak;
  InvisibilityCloak = (0, _constantsDecorators.rarity)(1)(InvisibilityCloak) || InvisibilityCloak;
  return InvisibilityCloak;
})(_definitionsEquipment.Cloak);

exports.InvisibilityCloak = InvisibilityCloak;

var ElvenCloak = (function (_Cloak8) {
  _inherits(ElvenCloak, _Cloak8);

  function ElvenCloak() {
    _classCallCheck(this, _ElvenCloak);

    _get(Object.getPrototypeOf(_ElvenCloak.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ElvenCloak, [{
    key: 'Stealth',
    value: function Stealth() {
      return this.buc * 2;
    }
  }]);

  var _ElvenCloak = ElvenCloak;
  ElvenCloak = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(ElvenCloak) || ElvenCloak;
  ElvenCloak = (0, _constantsDecorators.rarity)(1)(ElvenCloak) || ElvenCloak;
  return ElvenCloak;
})(_definitionsEquipment.Cloak);

exports.ElvenCloak = ElvenCloak;

var Robe = (function (_Cloak9) {
  _inherits(Robe, _Cloak9);

  function Robe() {
    _classCallCheck(this, _Robe);

    _get(Object.getPrototypeOf(_Robe.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Robe, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 2);
    }
  }]);

  var _Robe = Robe;
  Robe = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(Robe) || Robe;
  Robe = (0, _constantsDecorators.rarity)(1)(Robe) || Robe;
  return Robe;
})(_definitionsEquipment.Cloak);

exports.Robe = Robe;

var CloakOfProtection = (function (_Cloak10) {
  _inherits(CloakOfProtection, _Cloak10);

  function CloakOfProtection() {
    _classCallCheck(this, _CloakOfProtection);

    _get(Object.getPrototypeOf(_CloakOfProtection.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(CloakOfProtection, [{
    key: 'Protection',
    value: function Protection() {
      return this.buc * -2;
    }
  }]);

  var _CloakOfProtection = CloakOfProtection;
  CloakOfProtection = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(CloakOfProtection) || CloakOfProtection;
  CloakOfProtection = (0, _constantsDecorators.rarity)(5)(CloakOfProtection) || CloakOfProtection;
  return CloakOfProtection;
})(_definitionsEquipment.Cloak);

exports.CloakOfProtection = CloakOfProtection;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../lib/default-calculations":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/default-calculations.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/feets.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsEquipment = require('../../definitions/equipment');

var _libDefaultCalculations = require('../../lib/default-calculations');

var _constantsMaterials = require('../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../constants/decorators');

var SimpleBoots = (function (_Feet) {
  _inherits(SimpleBoots, _Feet);

  function SimpleBoots() {
    _classCallCheck(this, _SimpleBoots);

    _get(Object.getPrototypeOf(_SimpleBoots.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SimpleBoots, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }]);

  var _SimpleBoots = SimpleBoots;
  SimpleBoots = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(SimpleBoots) || SimpleBoots;
  SimpleBoots = (0, _constantsDecorators.rarity)(50)(SimpleBoots) || SimpleBoots;
  return SimpleBoots;
})(_definitionsEquipment.Feet);

exports.SimpleBoots = SimpleBoots;

var ElvenBoots = (function (_Feet2) {
  _inherits(ElvenBoots, _Feet2);

  function ElvenBoots() {
    _classCallCheck(this, _ElvenBoots);

    _get(Object.getPrototypeOf(_ElvenBoots.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ElvenBoots, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }, {
    key: 'Stealth',
    value: function Stealth() {
      return this.buc * 3;
    }
  }]);

  var _ElvenBoots = ElvenBoots;
  ElvenBoots = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(ElvenBoots) || ElvenBoots;
  ElvenBoots = (0, _constantsDecorators.rarity)(2)(ElvenBoots) || ElvenBoots;
  return ElvenBoots;
})(_definitionsEquipment.Feet);

exports.ElvenBoots = ElvenBoots;

var HermesSandals = (function (_Feet3) {
  _inherits(HermesSandals, _Feet3);

  function HermesSandals() {
    _classCallCheck(this, _HermesSandals);

    _get(Object.getPrototypeOf(_HermesSandals.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(HermesSandals, [{
    key: 'Haste',
    value: function Haste() {
      return this.buc * 2;
    }
  }]);

  var _HermesSandals = HermesSandals;
  HermesSandals = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(HermesSandals) || HermesSandals;
  HermesSandals = (0, _constantsDecorators.rarity)(3)(HermesSandals) || HermesSandals;
  return HermesSandals;
})(_definitionsEquipment.Feet);

exports.HermesSandals = HermesSandals;

var HighBoots = (function (_Feet4) {
  _inherits(HighBoots, _Feet4);

  function HighBoots() {
    _classCallCheck(this, _HighBoots);

    _get(Object.getPrototypeOf(_HighBoots.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(HighBoots, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 2);
    }
  }]);

  var _HighBoots = HighBoots;
  HighBoots = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(HighBoots) || HighBoots;
  HighBoots = (0, _constantsDecorators.rarity)(10)(HighBoots) || HighBoots;
  return HighBoots;
})(_definitionsEquipment.Feet);

exports.HighBoots = HighBoots;

var IronBoots = (function (_Feet5) {
  _inherits(IronBoots, _Feet5);

  function IronBoots() {
    _classCallCheck(this, _IronBoots);

    _get(Object.getPrototypeOf(_IronBoots.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(IronBoots, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 2);
    }
  }]);

  var _IronBoots = IronBoots;
  IronBoots = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(IronBoots) || IronBoots;
  IronBoots = (0, _constantsDecorators.rarity)(5)(IronBoots) || IronBoots;
  return IronBoots;
})(_definitionsEquipment.Feet);

exports.IronBoots = IronBoots;

var BootsOfProtection = (function (_Feet6) {
  _inherits(BootsOfProtection, _Feet6);

  function BootsOfProtection() {
    _classCallCheck(this, _BootsOfProtection);

    _get(Object.getPrototypeOf(_BootsOfProtection.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(BootsOfProtection, [{
    key: 'Protection',
    value: function Protection() {
      return this.buc * -2;
    }
  }]);

  var _BootsOfProtection = BootsOfProtection;
  BootsOfProtection = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(BootsOfProtection) || BootsOfProtection;
  BootsOfProtection = (0, _constantsDecorators.rarity)(5)(BootsOfProtection) || BootsOfProtection;
  return BootsOfProtection;
})(_definitionsEquipment.Feet);

exports.BootsOfProtection = BootsOfProtection;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../lib/default-calculations":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/default-calculations.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsEquipment = require('../../definitions/equipment');

var _constantsDecorators = require('../../constants/decorators');

var Ration = (function (_Comestible) {
  _inherits(Ration, _Comestible);

  function Ration(opts) {
    _classCallCheck(this, _Ration);

    _get(Object.getPrototypeOf(_Ration.prototype), 'constructor', this).call(this, opts);
    this.realName = 'ration';
  }

  var _Ration = Ration;
  Ration = (0, _constantsDecorators.rarity)(50)(Ration) || Ration;
  return Ration;
})(_definitionsEquipment.Comestible);

exports.Ration = Ration;

var Apple = (function (_Comestible2) {
  _inherits(Apple, _Comestible2);

  function Apple(opts) {
    _classCallCheck(this, _Apple);

    _get(Object.getPrototypeOf(_Apple.prototype), 'constructor', this).call(this, opts);
    this.realName = 'apple';
  }

  var _Apple = Apple;
  Apple = (0, _constantsDecorators.rarity)(75)(Apple) || Apple;
  return Apple;
})(_definitionsEquipment.Comestible);

exports.Apple = Apple;

var Carrot = (function (_Comestible3) {
  _inherits(Carrot, _Comestible3);

  function Carrot(opts) {
    _classCallCheck(this, _Carrot);

    _get(Object.getPrototypeOf(_Carrot.prototype), 'constructor', this).call(this, opts);
    this.realName = 'carrot';
  }

  var _Carrot = Carrot;
  Carrot = (0, _constantsDecorators.rarity)(75)(Carrot) || Carrot;
  return Carrot;
})(_definitionsEquipment.Comestible);

exports.Carrot = Carrot;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/heads.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsEquipment = require('../../definitions/equipment');

var _libDefaultCalculations = require('../../lib/default-calculations');

var _constantsMaterials = require('../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../constants/decorators');

var OrdinaryHat = (function (_Head) {
  _inherits(OrdinaryHat, _Head);

  function OrdinaryHat() {
    _classCallCheck(this, _OrdinaryHat);

    _get(Object.getPrototypeOf(_OrdinaryHat.prototype), 'constructor', this).apply(this, arguments);
  }

  var _OrdinaryHat = OrdinaryHat;
  OrdinaryHat = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(OrdinaryHat) || OrdinaryHat;
  OrdinaryHat = (0, _constantsDecorators.rarity)(50)(OrdinaryHat) || OrdinaryHat;
  return OrdinaryHat;
})(_definitionsEquipment.Head);

exports.OrdinaryHat = OrdinaryHat;

var Fedora = (function (_Head2) {
  _inherits(Fedora, _Head2);

  function Fedora() {
    _classCallCheck(this, _Fedora);

    _get(Object.getPrototypeOf(_Fedora.prototype), 'constructor', this).apply(this, arguments);
  }

  var _Fedora = Fedora;
  Fedora = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(Fedora) || Fedora;
  Fedora = (0, _constantsDecorators.rarity)(1)(Fedora) || Fedora;
  return Fedora;
})(_definitionsEquipment.Head);

exports.Fedora = Fedora;

var NightGoggles = (function (_Head3) {
  _inherits(NightGoggles, _Head3);

  function NightGoggles() {
    _classCallCheck(this, _NightGoggles);

    _get(Object.getPrototypeOf(_NightGoggles.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(NightGoggles, [{
    key: 'Infravision',
    value: function Infravision() {
      return this.buc;
    }
  }]);

  var _NightGoggles = NightGoggles;
  NightGoggles = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(NightGoggles) || NightGoggles;
  NightGoggles = (0, _constantsDecorators.rarity)(2)(NightGoggles) || NightGoggles;
  return NightGoggles;
})(_definitionsEquipment.Head);

exports.NightGoggles = NightGoggles;

var DunceCap = (function (_Head4) {
  _inherits(DunceCap, _Head4);

  _createClass(DunceCap, [{
    key: 'int',
    value: function int() {
      return -5;
    }
  }, {
    key: 'wis',
    value: function wis() {
      return -5;
    }
  }]);

  function DunceCap() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _DunceCap);

    opts.bucName = 'cursed'; // always starts cursed
    _get(Object.getPrototypeOf(_DunceCap.prototype), 'constructor', this).call(this, opts);
  }

  var _DunceCap = DunceCap;
  DunceCap = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(DunceCap) || DunceCap;
  DunceCap = (0, _constantsDecorators.rarity)(2)(DunceCap) || DunceCap;
  return DunceCap;
})(_definitionsEquipment.Head);

exports.DunceCap = DunceCap;

var Cornuthaum = (function (_Head5) {
  _inherits(Cornuthaum, _Head5);

  function Cornuthaum() {
    _classCallCheck(this, _Cornuthaum);

    _get(Object.getPrototypeOf(_Cornuthaum.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Cornuthaum, [{
    key: 'Clairvoyance',
    value: function Clairvoyance() {
      return 2;
    }
  }]);

  var _Cornuthaum = Cornuthaum;
  Cornuthaum = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(Cornuthaum) || Cornuthaum;
  Cornuthaum = (0, _constantsDecorators.rarity)(2)(Cornuthaum) || Cornuthaum;
  return Cornuthaum;
})(_definitionsEquipment.Head);

exports.Cornuthaum = Cornuthaum;

var OrcishHelm = (function (_Head6) {
  _inherits(OrcishHelm, _Head6);

  function OrcishHelm() {
    _classCallCheck(this, _OrcishHelm);

    _get(Object.getPrototypeOf(_OrcishHelm.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(OrcishHelm, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }]);

  var _OrcishHelm = OrcishHelm;
  OrcishHelm = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(OrcishHelm) || OrcishHelm;
  OrcishHelm = (0, _constantsDecorators.rarity)(15)(OrcishHelm) || OrcishHelm;
  return OrcishHelm;
})(_definitionsEquipment.Head);

exports.OrcishHelm = OrcishHelm;

var Helm = (function (_Head7) {
  _inherits(Helm, _Head7);

  function Helm() {
    _classCallCheck(this, _Helm);

    _get(Object.getPrototypeOf(_Helm.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Helm, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 2);
    }
  }]);

  var _Helm = Helm;
  Helm = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Helm) || Helm;
  Helm = (0, _constantsDecorators.rarity)(15)(Helm) || Helm;
  return Helm;
})(_definitionsEquipment.Head);

exports.Helm = Helm;

var DentedPot = (function (_Head8) {
  _inherits(DentedPot, _Head8);

  function DentedPot() {
    _classCallCheck(this, _DentedPot);

    _get(Object.getPrototypeOf(_DentedPot.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(DentedPot, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }]);

  var _DentedPot = DentedPot;
  DentedPot = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(DentedPot) || DentedPot;
  DentedPot = (0, _constantsDecorators.rarity)(35)(DentedPot) || DentedPot;
  return DentedPot;
})(_definitionsEquipment.Head);

exports.DentedPot = DentedPot;

var ElvenLeatherHelm = (function (_Head9) {
  _inherits(ElvenLeatherHelm, _Head9);

  function ElvenLeatherHelm() {
    _classCallCheck(this, _ElvenLeatherHelm);

    _get(Object.getPrototypeOf(_ElvenLeatherHelm.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ElvenLeatherHelm, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }]);

  var _ElvenLeatherHelm = ElvenLeatherHelm;
  ElvenLeatherHelm = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(ElvenLeatherHelm) || ElvenLeatherHelm;
  ElvenLeatherHelm = (0, _constantsDecorators.rarity)(15)(ElvenLeatherHelm) || ElvenLeatherHelm;
  return ElvenLeatherHelm;
})(_definitionsEquipment.Head);

exports.ElvenLeatherHelm = ElvenLeatherHelm;

var HelmOfBrilliance = (function (_Head10) {
  _inherits(HelmOfBrilliance, _Head10);

  function HelmOfBrilliance() {
    _classCallCheck(this, _HelmOfBrilliance);

    _get(Object.getPrototypeOf(_HelmOfBrilliance.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(HelmOfBrilliance, [{
    key: 'int',
    value: function int() {
      return 3;
    }
  }, {
    key: 'wis',
    value: function wis() {
      return 3;
    }
  }, {
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }]);

  var _HelmOfBrilliance = HelmOfBrilliance;
  HelmOfBrilliance = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(HelmOfBrilliance) || HelmOfBrilliance;
  HelmOfBrilliance = (0, _constantsDecorators.rarity)(3)(HelmOfBrilliance) || HelmOfBrilliance;
  return HelmOfBrilliance;
})(_definitionsEquipment.Head);

exports.HelmOfBrilliance = HelmOfBrilliance;

var HelmOfTelepathy = (function (_Head11) {
  _inherits(HelmOfTelepathy, _Head11);

  function HelmOfTelepathy() {
    _classCallCheck(this, _HelmOfTelepathy);

    _get(Object.getPrototypeOf(_HelmOfTelepathy.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(HelmOfTelepathy, [{
    key: 'Telepathy',
    value: function Telepathy() {
      return 4;
    }
  }]);

  var _HelmOfTelepathy = HelmOfTelepathy;
  HelmOfTelepathy = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(HelmOfTelepathy) || HelmOfTelepathy;
  HelmOfTelepathy = (0, _constantsDecorators.rarity)(2)(HelmOfTelepathy) || HelmOfTelepathy;
  return HelmOfTelepathy;
})(_definitionsEquipment.Head);

exports.HelmOfTelepathy = HelmOfTelepathy;

var DwarvenIronHelm = (function (_Head12) {
  _inherits(DwarvenIronHelm, _Head12);

  function DwarvenIronHelm() {
    _classCallCheck(this, _DwarvenIronHelm);

    _get(Object.getPrototypeOf(_DwarvenIronHelm.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(DwarvenIronHelm, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this, 2);
    }
  }]);

  var _DwarvenIronHelm = DwarvenIronHelm;
  DwarvenIronHelm = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(DwarvenIronHelm) || DwarvenIronHelm;
  DwarvenIronHelm = (0, _constantsDecorators.rarity)(10)(DwarvenIronHelm) || DwarvenIronHelm;
  return DwarvenIronHelm;
})(_definitionsEquipment.Head);

exports.DwarvenIronHelm = DwarvenIronHelm;

var HelmOfProtection = (function (_Head13) {
  _inherits(HelmOfProtection, _Head13);

  function HelmOfProtection() {
    _classCallCheck(this, _HelmOfProtection);

    _get(Object.getPrototypeOf(_HelmOfProtection.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(HelmOfProtection, [{
    key: 'Protection',
    value: function Protection() {
      return this.buc * -2;
    }
  }]);

  var _HelmOfProtection = HelmOfProtection;
  HelmOfProtection = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(HelmOfProtection) || HelmOfProtection;
  HelmOfProtection = (0, _constantsDecorators.rarity)(5)(HelmOfProtection) || HelmOfProtection;
  return HelmOfProtection;
})(_definitionsEquipment.Head);

exports.HelmOfProtection = HelmOfProtection;
// so hipster

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../lib/default-calculations":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/default-calculations.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/necks.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsEquipment = require('../../definitions/equipment');

var _constantsMaterials = require('../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _constantsDecorators = require('../../constants/decorators');

var Necklace = (function (_Neck) {
  _inherits(Necklace, _Neck);

  function Necklace() {
    _classCallCheck(this, _Necklace);

    _get(Object.getPrototypeOf(_Necklace.prototype), 'constructor', this).apply(this, arguments);
  }

  var _Necklace = Necklace;
  Necklace = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Necklace) || Necklace;
  Necklace = (0, _constantsDecorators.rarity)(50)(Necklace) || Necklace;
  return Necklace;
})(_definitionsEquipment.Neck);

exports.Necklace = Necklace;

var AmuletOfProtection = (function (_Neck2) {
  _inherits(AmuletOfProtection, _Neck2);

  function AmuletOfProtection() {
    _classCallCheck(this, _AmuletOfProtection);

    _get(Object.getPrototypeOf(_AmuletOfProtection.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AmuletOfProtection, [{
    key: 'Protection',
    value: function Protection() {
      return this.buc * -2;
    }
  }]);

  var _AmuletOfProtection = AmuletOfProtection;
  AmuletOfProtection = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(AmuletOfProtection) || AmuletOfProtection;
  AmuletOfProtection = (0, _constantsDecorators.rarity)(5)(AmuletOfProtection) || AmuletOfProtection;
  return AmuletOfProtection;
})(_definitionsEquipment.Neck);

exports.AmuletOfProtection = AmuletOfProtection;

var AmuletOfTelepathy = (function (_Neck3) {
  _inherits(AmuletOfTelepathy, _Neck3);

  function AmuletOfTelepathy() {
    _classCallCheck(this, _AmuletOfTelepathy);

    _get(Object.getPrototypeOf(_AmuletOfTelepathy.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AmuletOfTelepathy, [{
    key: 'Telepathy',
    value: function Telepathy() {
      return 4;
    }
  }]);

  var _AmuletOfTelepathy = AmuletOfTelepathy;
  AmuletOfTelepathy = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(AmuletOfTelepathy) || AmuletOfTelepathy;
  AmuletOfTelepathy = (0, _constantsDecorators.rarity)(1)(AmuletOfTelepathy) || AmuletOfTelepathy;
  return AmuletOfTelepathy;
})(_definitionsEquipment.Neck);

exports.AmuletOfTelepathy = AmuletOfTelepathy;

var AmuletOfStrangulation = (function (_Neck4) {
  _inherits(AmuletOfStrangulation, _Neck4);

  function AmuletOfStrangulation() {
    _classCallCheck(this, _AmuletOfStrangulation);

    _get(Object.getPrototypeOf(_AmuletOfStrangulation.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AmuletOfStrangulation, [{
    key: 'equip',
    value: function equip(player) {
      player.die({ name: 'amulet of strangulation' });
    }
  }]);

  var _AmuletOfStrangulation = AmuletOfStrangulation;
  AmuletOfStrangulation = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(AmuletOfStrangulation) || AmuletOfStrangulation;
  AmuletOfStrangulation = (0, _constantsDecorators.rarity)(1)(AmuletOfStrangulation) || AmuletOfStrangulation;
  return AmuletOfStrangulation;
})(_definitionsEquipment.Neck);

exports.AmuletOfStrangulation = AmuletOfStrangulation;

var AmuletOfLifeSaving = (function (_Neck5) {
  _inherits(AmuletOfLifeSaving, _Neck5);

  function AmuletOfLifeSaving() {
    _classCallCheck(this, _AmuletOfLifeSaving);

    _get(Object.getPrototypeOf(_AmuletOfLifeSaving.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AmuletOfLifeSaving, [{
    key: 'equip',
    value: function equip(player) {
      this._behavior = Behaviors.LifeSave();
      this._behavior._itemRef = this;
      player.addUniqueBehavior(this._behavior);
    }
  }, {
    key: 'unequip',
    value: function unequip(player) {
      player.removeBehavior(this._behavior);
    }
  }]);

  var _AmuletOfLifeSaving = AmuletOfLifeSaving;
  AmuletOfLifeSaving = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(AmuletOfLifeSaving) || AmuletOfLifeSaving;
  AmuletOfLifeSaving = (0, _constantsDecorators.rarity)(1)(AmuletOfLifeSaving) || AmuletOfLifeSaving;
  return AmuletOfLifeSaving;
})(_definitionsEquipment.Neck);

exports.AmuletOfLifeSaving = AmuletOfLifeSaving;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _definitionsEquipment = require('../../definitions/equipment');

var _constantsDecorators = require('../../constants/decorators');

var Healing = (function (_Potion) {
  _inherits(Healing, _Potion);

  function Healing() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Healing);

    _lodash2['default'].extend(opts, { charges: '1d1', healRoll: '4d4', autoRemove: true });
    _get(Object.getPrototypeOf(_Healing.prototype), 'constructor', this).call(this, opts);
  }

  _createClass(Healing, [{
    key: 'use',
    value: function use(entity) {
      var healVal = (0, _libDiceRoller2['default'])(this.healRoll);
      _get(Object.getPrototypeOf(_Healing.prototype), 'use', this).call(this, entity, { healVal: healVal, messageFinish: 'regained ' + healVal + ' health' });
    }
  }]);

  var _Healing = Healing;
  Healing = (0, _constantsDecorators.rarity)(50)(Healing) || Healing;
  return Healing;
})(_definitionsEquipment.Potion);

exports.Healing = Healing;

var ExtraHealing = (function (_Potion2) {
  _inherits(ExtraHealing, _Potion2);

  function ExtraHealing() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _ExtraHealing);

    _lodash2['default'].extend(opts, { charges: '1d1', healRoll: '8d4', autoRemove: true });
    _get(Object.getPrototypeOf(_ExtraHealing.prototype), 'constructor', this).call(this, opts);
  }

  _createClass(ExtraHealing, [{
    key: 'use',
    value: function use(entity) {
      var healVal = (0, _libDiceRoller2['default'])(this.healRoll);
      _get(Object.getPrototypeOf(_ExtraHealing.prototype), 'use', this).call(this, entity, { healVal: healVal, messageFinish: 'regained ' + healVal + ' health' });
    }
  }]);

  var _ExtraHealing = ExtraHealing;
  ExtraHealing = (0, _constantsDecorators.rarity)(5)(ExtraHealing) || ExtraHealing;
  return ExtraHealing;
})(_definitionsEquipment.Potion);

exports.ExtraHealing = ExtraHealing;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x11, _x12, _x13) { var _again = true; _function: while (_again) { var object = _x11, property = _x12, receiver = _x13; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x11 = parent; _x12 = property; _x13 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../definitions/equipment');

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsMaterials = require('../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../constants/decorators');

var Dart = (function (_Weapon) {
  _inherits(Dart, _Weapon);

  function Dart() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Dart);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '2d4',
      glyph: { key: ')', fg: '#00f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d3', toHit: '0d0', range: 3 })]
    });
    _get(Object.getPrototypeOf(_Dart.prototype), 'constructor', this).call(this, opts);
  }

  var _Dart = Dart;
  Dart = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Dart) || Dart;
  Dart = (0, _constantsDecorators.rarity)(50)(Dart) || Dart;
  return Dart;
})(_definitionsEquipment.Weapon);

exports.Dart = Dart;

var Rock = (function (_Weapon2) {
  _inherits(Rock, _Weapon2);

  function Rock() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Rock);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '2d4',
      glyph: { key: ')', fg: '#00f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d3', toHit: '0d0', range: 9 })]
    });
    _get(Object.getPrototypeOf(_Rock.prototype), 'constructor', this).call(this, opts);
  }

  var _Rock = Rock;
  Rock = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Stone)(Rock) || Rock;
  Rock = (0, _constantsDecorators.rarity)(50)(Rock) || Rock;
  return Rock;
})(_definitionsEquipment.Weapon);

exports.Rock = Rock;

var FlintStone = (function (_Weapon3) {
  _inherits(FlintStone, _Weapon3);

  function FlintStone() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _FlintStone);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '2d4',
      glyph: { key: ')', fg: '#00f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d6', toHit: '0d0', range: 4 })]
    });
    _get(Object.getPrototypeOf(_FlintStone.prototype), 'constructor', this).call(this, opts);
  }

  var _FlintStone = FlintStone;
  FlintStone = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Stone)(FlintStone) || FlintStone;
  FlintStone = (0, _constantsDecorators.rarity)(25)(FlintStone) || FlintStone;
  return FlintStone;
})(_definitionsEquipment.Weapon);

exports.FlintStone = FlintStone;

var Javelin = (function (_Weapon4) {
  _inherits(Javelin, _Weapon4);

  function Javelin() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Javelin);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '1d4',
      glyph: { key: ')', fg: '#00f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d6', range: 9 })]
    });
    _get(Object.getPrototypeOf(_Javelin.prototype), 'constructor', this).call(this, opts);
  }

  var _Javelin = Javelin;
  Javelin = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Javelin) || Javelin;
  Javelin = (0, _constantsDecorators.rarity)(10)(Javelin) || Javelin;
  return Javelin;
})(_definitionsEquipment.Weapon);

exports.Javelin = Javelin;

var Shuriken = (function (_Weapon5) {
  _inherits(Shuriken, _Weapon5);

  function Shuriken() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Shuriken);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '5d4',
      glyph: { key: ')', fg: '#00f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d8', range: 15 })]
    });
    _get(Object.getPrototypeOf(_Shuriken.prototype), 'constructor', this).call(this, opts);
  }

  var _Shuriken = Shuriken;
  Shuriken = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Shuriken) || Shuriken;
  Shuriken = (0, _constantsDecorators.rarity)(5)(Shuriken) || Shuriken;
  return Shuriken;
})(_definitionsEquipment.Weapon);

exports.Shuriken = Shuriken;

var Stiletto = (function (_Weapon6) {
  _inherits(Stiletto, _Weapon6);

  function Stiletto() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Stiletto);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '4d4',
      glyph: { key: ')', fg: '#00f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d4', toHit: '0d0', range: 4 })]
    });
    _get(Object.getPrototypeOf(_Stiletto.prototype), 'constructor', this).call(this, opts);
  }

  var _Stiletto = Stiletto;
  Stiletto = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Stiletto) || Stiletto;
  Stiletto = (0, _constantsDecorators.rarity)(5)(Stiletto) || Stiletto;
  return Stiletto;
})(_definitionsEquipment.Weapon);

exports.Stiletto = Stiletto;

var OrcishArrow = (function (_Weapon7) {
  _inherits(OrcishArrow, _Weapon7);

  function OrcishArrow() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _OrcishArrow);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '1d4',
      glyph: { key: ')', fg: '#f0f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d5', toHit: '0d0', range: 5 })]
    });
    _get(Object.getPrototypeOf(_OrcishArrow.prototype), 'constructor', this).call(this, opts);
  }

  var _OrcishArrow = OrcishArrow;
  OrcishArrow = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(OrcishArrow) || OrcishArrow;
  OrcishArrow = (0, _constantsDecorators.rarity)(25)(OrcishArrow) || OrcishArrow;
  return OrcishArrow;
})(_definitionsEquipment.Weapon);

exports.OrcishArrow = OrcishArrow;

var Arrow = (function (_Weapon8) {
  _inherits(Arrow, _Weapon8);

  function Arrow() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Arrow);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '1d4',
      glyph: { key: ')', fg: '#f0f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d6', toHit: '0d0', range: 6 })]
    });
    _get(Object.getPrototypeOf(_Arrow.prototype), 'constructor', this).call(this, opts);
  }

  var _Arrow = Arrow;
  Arrow = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Arrow) || Arrow;
  Arrow = (0, _constantsDecorators.rarity)(20)(Arrow) || Arrow;
  return Arrow;
})(_definitionsEquipment.Weapon);

exports.Arrow = Arrow;

var ElvenArrow = (function (_Weapon9) {
  _inherits(ElvenArrow, _Weapon9);

  function ElvenArrow() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _ElvenArrow);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '2d4',
      glyph: { key: ')', fg: '#f0f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d8', toHit: '1d1', range: 7 })]
    });
    _get(Object.getPrototypeOf(_ElvenArrow.prototype), 'constructor', this).call(this, opts);
  }

  var _ElvenArrow = ElvenArrow;
  ElvenArrow = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(ElvenArrow) || ElvenArrow;
  ElvenArrow = (0, _constantsDecorators.rarity)(15)(ElvenArrow) || ElvenArrow;
  return ElvenArrow;
})(_definitionsEquipment.Weapon);

exports.ElvenArrow = ElvenArrow;

var Bolt = (function (_Weapon10) {
  _inherits(Bolt, _Weapon10);

  function Bolt() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Bolt);

    _lodash2['default'].extend(opts, {
      autoRemove: true,
      charges: '1d4',
      glyph: { key: ')', fg: '#f0f' },
      attacks: [_attacks_all2['default'].Shot({ roll: '1d8', toHit: '0d0', range: 4 })]
    });
    _get(Object.getPrototypeOf(_Bolt.prototype), 'constructor', this).call(this, opts);
  }

  var _Bolt = Bolt;
  Bolt = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Bolt) || Bolt;
  Bolt = (0, _constantsDecorators.rarity)(25)(Bolt) || Bolt;
  return Bolt;
})(_definitionsEquipment.Weapon);

exports.Bolt = Bolt;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/rings.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsEquipment = require('../../definitions/equipment');

var _constantsMaterials = require('../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../constants/decorators');

// region Attribute Rings

var RingOfStrength = (function (_Ring) {
  _inherits(RingOfStrength, _Ring);

  function RingOfStrength() {
    _classCallCheck(this, _RingOfStrength);

    _get(Object.getPrototypeOf(_RingOfStrength.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfStrength, [{
    key: 'str',
    value: function str() {
      return this.buc;
    }
  }]);

  var _RingOfStrength = RingOfStrength;
  RingOfStrength = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(RingOfStrength) || RingOfStrength;
  RingOfStrength = (0, _constantsDecorators.rarity)(15)(RingOfStrength) || RingOfStrength;
  return RingOfStrength;
})(_definitionsEquipment.Ring);

exports.RingOfStrength = RingOfStrength;

var RingOfConstitution = (function (_Ring2) {
  _inherits(RingOfConstitution, _Ring2);

  function RingOfConstitution() {
    _classCallCheck(this, _RingOfConstitution);

    _get(Object.getPrototypeOf(_RingOfConstitution.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfConstitution, [{
    key: 'con',
    value: function con() {
      return this.buc;
    }
  }]);

  var _RingOfConstitution = RingOfConstitution;
  RingOfConstitution = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfConstitution) || RingOfConstitution;
  RingOfConstitution = (0, _constantsDecorators.rarity)(5)(RingOfConstitution) || RingOfConstitution;
  return RingOfConstitution;
})(_definitionsEquipment.Ring);

exports.RingOfConstitution = RingOfConstitution;

var RingOfDexterity = (function (_Ring3) {
  _inherits(RingOfDexterity, _Ring3);

  function RingOfDexterity() {
    _classCallCheck(this, _RingOfDexterity);

    _get(Object.getPrototypeOf(_RingOfDexterity.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfDexterity, [{
    key: 'dex',
    value: function dex() {
      return this.buc;
    }
  }]);

  var _RingOfDexterity = RingOfDexterity;
  RingOfDexterity = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfDexterity) || RingOfDexterity;
  RingOfDexterity = (0, _constantsDecorators.rarity)(15)(RingOfDexterity) || RingOfDexterity;
  return RingOfDexterity;
})(_definitionsEquipment.Ring);

exports.RingOfDexterity = RingOfDexterity;

var RingOfIntelligence = (function (_Ring4) {
  _inherits(RingOfIntelligence, _Ring4);

  function RingOfIntelligence() {
    _classCallCheck(this, _RingOfIntelligence);

    _get(Object.getPrototypeOf(_RingOfIntelligence.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfIntelligence, [{
    key: 'int',
    value: function int() {
      return this.buc;
    }
  }]);

  var _RingOfIntelligence = RingOfIntelligence;
  RingOfIntelligence = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfIntelligence) || RingOfIntelligence;
  RingOfIntelligence = (0, _constantsDecorators.rarity)(20)(RingOfIntelligence) || RingOfIntelligence;
  return RingOfIntelligence;
})(_definitionsEquipment.Ring);

exports.RingOfIntelligence = RingOfIntelligence;

var RingOfWisdom = (function (_Ring5) {
  _inherits(RingOfWisdom, _Ring5);

  function RingOfWisdom() {
    _classCallCheck(this, _RingOfWisdom);

    _get(Object.getPrototypeOf(_RingOfWisdom.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfWisdom, [{
    key: 'wis',
    value: function wis() {
      return this.buc;
    }
  }]);

  var _RingOfWisdom = RingOfWisdom;
  RingOfWisdom = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfWisdom) || RingOfWisdom;
  RingOfWisdom = (0, _constantsDecorators.rarity)(25)(RingOfWisdom) || RingOfWisdom;
  return RingOfWisdom;
})(_definitionsEquipment.Ring);

exports.RingOfWisdom = RingOfWisdom;

var RingOfAdornment = (function (_Ring6) {
  _inherits(RingOfAdornment, _Ring6);

  function RingOfAdornment() {
    _classCallCheck(this, _RingOfAdornment);

    _get(Object.getPrototypeOf(_RingOfAdornment.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfAdornment, [{
    key: 'cha',
    value: function cha() {
      return this.buc;
    }
  }]);

  var _RingOfAdornment = RingOfAdornment;
  RingOfAdornment = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Gold)(RingOfAdornment) || RingOfAdornment;
  RingOfAdornment = (0, _constantsDecorators.rarity)(2)(RingOfAdornment) || RingOfAdornment;
  return RingOfAdornment;
})(_definitionsEquipment.Ring);

exports.RingOfAdornment = RingOfAdornment;

var RingOfLuck = (function (_Ring7) {
  _inherits(RingOfLuck, _Ring7);

  function RingOfLuck() {
    _classCallCheck(this, _RingOfLuck);

    _get(Object.getPrototypeOf(_RingOfLuck.prototype), 'constructor', this).apply(this, arguments);
  }

  // endregion

  // region Trait Rings

  _createClass(RingOfLuck, [{
    key: 'luk',
    value: function luk() {
      return this.buc;
    }
  }]);

  var _RingOfLuck = RingOfLuck;
  RingOfLuck = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfLuck) || RingOfLuck;
  RingOfLuck = (0, _constantsDecorators.rarity)(1)(RingOfLuck) || RingOfLuck;
  return RingOfLuck;
})(_definitionsEquipment.Ring);

exports.RingOfLuck = RingOfLuck;

var RingOfProtection = (function (_Ring8) {
  _inherits(RingOfProtection, _Ring8);

  function RingOfProtection() {
    _classCallCheck(this, _RingOfProtection);

    _get(Object.getPrototypeOf(_RingOfProtection.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfProtection, [{
    key: 'Protection',
    value: function Protection() {
      return this.buc;
    }
  }]);

  var _RingOfProtection = RingOfProtection;
  RingOfProtection = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfProtection) || RingOfProtection;
  RingOfProtection = (0, _constantsDecorators.rarity)(5)(RingOfProtection) || RingOfProtection;
  return RingOfProtection;
})(_definitionsEquipment.Ring);

exports.RingOfProtection = RingOfProtection;

var RingOfHaste = (function (_Ring9) {
  _inherits(RingOfHaste, _Ring9);

  function RingOfHaste() {
    _classCallCheck(this, _RingOfHaste);

    _get(Object.getPrototypeOf(_RingOfHaste.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfHaste, [{
    key: 'Haste',
    value: function Haste() {
      return this.buc * 25;
    }
  }]);

  var _RingOfHaste = RingOfHaste;
  RingOfHaste = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfHaste) || RingOfHaste;
  RingOfHaste = (0, _constantsDecorators.rarity)(4)(RingOfHaste) || RingOfHaste;
  return RingOfHaste;
})(_definitionsEquipment.Ring);

exports.RingOfHaste = RingOfHaste;

var RingOfSight = (function (_Ring10) {
  _inherits(RingOfSight, _Ring10);

  function RingOfSight() {
    _classCallCheck(this, _RingOfSight);

    _get(Object.getPrototypeOf(_RingOfSight.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfSight, [{
    key: 'Infravision',
    value: function Infravision() {
      return this.buc;
    }
  }]);

  var _RingOfSight = RingOfSight;
  RingOfSight = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfSight) || RingOfSight;
  RingOfSight = (0, _constantsDecorators.rarity)(1)(RingOfSight) || RingOfSight;
  return RingOfSight;
})(_definitionsEquipment.Ring);

exports.RingOfSight = RingOfSight;

var RingOfAccuracy = (function (_Ring11) {
  _inherits(RingOfAccuracy, _Ring11);

  function RingOfAccuracy() {
    _classCallCheck(this, _RingOfAccuracy);

    _get(Object.getPrototypeOf(_RingOfAccuracy.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfAccuracy, [{
    key: 'toHit',
    value: function toHit() {
      return '0d0 +' + this.buc;
    }
  }]);

  var _RingOfAccuracy = RingOfAccuracy;
  RingOfAccuracy = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfAccuracy) || RingOfAccuracy;
  RingOfAccuracy = (0, _constantsDecorators.rarity)(25)(RingOfAccuracy) || RingOfAccuracy;
  return RingOfAccuracy;
})(_definitionsEquipment.Ring);

exports.RingOfAccuracy = RingOfAccuracy;

var RingOfBonusDamage = (function (_Ring12) {
  _inherits(RingOfBonusDamage, _Ring12);

  function RingOfBonusDamage() {
    _classCallCheck(this, _RingOfBonusDamage);

    _get(Object.getPrototypeOf(_RingOfBonusDamage.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfBonusDamage, [{
    key: 'bonusDamage',
    value: function bonusDamage() {
      return '0d0 +' + this.buc;
    }
  }]);

  var _RingOfBonusDamage = RingOfBonusDamage;
  RingOfBonusDamage = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfBonusDamage) || RingOfBonusDamage;
  RingOfBonusDamage = (0, _constantsDecorators.rarity)(15)(RingOfBonusDamage) || RingOfBonusDamage;
  return RingOfBonusDamage;
})(_definitionsEquipment.Ring);

exports.RingOfBonusDamage = RingOfBonusDamage;

var RingOfStealth = (function (_Ring13) {
  _inherits(RingOfStealth, _Ring13);

  function RingOfStealth() {
    _classCallCheck(this, _RingOfStealth);

    _get(Object.getPrototypeOf(_RingOfStealth.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfStealth, [{
    key: 'Stealth',
    value: function Stealth() {
      return this.buc * 2;
    }
  }]);

  var _RingOfStealth = RingOfStealth;
  RingOfStealth = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(RingOfStealth) || RingOfStealth;
  RingOfStealth = (0, _constantsDecorators.rarity)(1)(RingOfStealth) || RingOfStealth;
  return RingOfStealth;
})(_definitionsEquipment.Ring);

exports.RingOfStealth = RingOfStealth;

var RingOfInvisibility = (function (_Ring14) {
  _inherits(RingOfInvisibility, _Ring14);

  function RingOfInvisibility() {
    _classCallCheck(this, _RingOfInvisibility);

    _get(Object.getPrototypeOf(_RingOfInvisibility.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfInvisibility, [{
    key: 'Invisible',
    value: function Invisible() {
      return this.buc;
    }
  }]);

  var _RingOfInvisibility = RingOfInvisibility;
  RingOfInvisibility = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(RingOfInvisibility) || RingOfInvisibility;
  RingOfInvisibility = (0, _constantsDecorators.rarity)(1)(RingOfInvisibility) || RingOfInvisibility;
  return RingOfInvisibility;
})(_definitionsEquipment.Ring);

exports.RingOfInvisibility = RingOfInvisibility;

var RingOfSeeInvisible = (function (_Ring15) {
  _inherits(RingOfSeeInvisible, _Ring15);

  function RingOfSeeInvisible() {
    _classCallCheck(this, _RingOfSeeInvisible);

    _get(Object.getPrototypeOf(_RingOfSeeInvisible.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfSeeInvisible, [{
    key: 'SeeInvisible',
    value: function SeeInvisible() {
      return this.buc;
    }
  }]);

  var _RingOfSeeInvisible = RingOfSeeInvisible;
  RingOfSeeInvisible = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(RingOfSeeInvisible) || RingOfSeeInvisible;
  RingOfSeeInvisible = (0, _constantsDecorators.rarity)(1)(RingOfSeeInvisible) || RingOfSeeInvisible;
  return RingOfSeeInvisible;
})(_definitionsEquipment.Ring);

exports.RingOfSeeInvisible = RingOfSeeInvisible;

var RingOfWarning = (function (_Ring16) {
  _inherits(RingOfWarning, _Ring16);

  function RingOfWarning() {
    _classCallCheck(this, _RingOfWarning);

    _get(Object.getPrototypeOf(_RingOfWarning.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfWarning, [{
    key: 'Warning',
    value: function Warning() {
      return this.buc * 2;
    }
  }]);

  var _RingOfWarning = RingOfWarning;
  RingOfWarning = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(RingOfWarning) || RingOfWarning;
  RingOfWarning = (0, _constantsDecorators.rarity)(1)(RingOfWarning) || RingOfWarning;
  return RingOfWarning;
})(_definitionsEquipment.Ring);

exports.RingOfWarning = RingOfWarning;

var RingOfRegeneration = (function (_Ring17) {
  _inherits(RingOfRegeneration, _Ring17);

  function RingOfRegeneration() {
    _classCallCheck(this, _RingOfRegeneration);

    _get(Object.getPrototypeOf(_RingOfRegeneration.prototype), 'constructor', this).apply(this, arguments);
  }

  // endregion

  // region Resistance Rings

  _createClass(RingOfRegeneration, [{
    key: 'hpRegen',
    value: function hpRegen() {
      return -3 * this.buc;
    }
  }, {
    key: 'mpRegen',
    value: function mpRegen() {
      return -3 * this.buc;
    }
  }]);

  var _RingOfRegeneration = RingOfRegeneration;
  RingOfRegeneration = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(RingOfRegeneration) || RingOfRegeneration;
  RingOfRegeneration = (0, _constantsDecorators.rarity)(1)(RingOfRegeneration) || RingOfRegeneration;
  return RingOfRegeneration;
})(_definitionsEquipment.Ring);

exports.RingOfRegeneration = RingOfRegeneration;

var RingOfPoisonResistance = (function (_Ring18) {
  _inherits(RingOfPoisonResistance, _Ring18);

  function RingOfPoisonResistance() {
    _classCallCheck(this, _RingOfPoisonResistance);

    _get(Object.getPrototypeOf(_RingOfPoisonResistance.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfPoisonResistance, [{
    key: 'PoisonResistance',
    value: function PoisonResistance() {
      return this.buc;
    }
  }]);

  var _RingOfPoisonResistance = RingOfPoisonResistance;
  RingOfPoisonResistance = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(RingOfPoisonResistance) || RingOfPoisonResistance;
  RingOfPoisonResistance = (0, _constantsDecorators.rarity)(5)(RingOfPoisonResistance) || RingOfPoisonResistance;
  return RingOfPoisonResistance;
})(_definitionsEquipment.Ring);

exports.RingOfPoisonResistance = RingOfPoisonResistance;

var RingOfShockResistance = (function (_Ring19) {
  _inherits(RingOfShockResistance, _Ring19);

  function RingOfShockResistance() {
    _classCallCheck(this, _RingOfShockResistance);

    _get(Object.getPrototypeOf(_RingOfShockResistance.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfShockResistance, [{
    key: 'ShockResistance',
    value: function ShockResistance() {
      return this.buc;
    }
  }]);

  var _RingOfShockResistance = RingOfShockResistance;
  RingOfShockResistance = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(RingOfShockResistance) || RingOfShockResistance;
  RingOfShockResistance = (0, _constantsDecorators.rarity)(5)(RingOfShockResistance) || RingOfShockResistance;
  return RingOfShockResistance;
})(_definitionsEquipment.Ring);

exports.RingOfShockResistance = RingOfShockResistance;

var RingOfAcidResistance = (function (_Ring20) {
  _inherits(RingOfAcidResistance, _Ring20);

  function RingOfAcidResistance() {
    _classCallCheck(this, _RingOfAcidResistance);

    _get(Object.getPrototypeOf(_RingOfAcidResistance.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfAcidResistance, [{
    key: 'AcidResistance',
    value: function AcidResistance() {
      return this.buc;
    }
  }]);

  var _RingOfAcidResistance = RingOfAcidResistance;
  RingOfAcidResistance = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(RingOfAcidResistance) || RingOfAcidResistance;
  RingOfAcidResistance = (0, _constantsDecorators.rarity)(5)(RingOfAcidResistance) || RingOfAcidResistance;
  return RingOfAcidResistance;
})(_definitionsEquipment.Ring);

exports.RingOfAcidResistance = RingOfAcidResistance;

var RingOfFireResistance = (function (_Ring21) {
  _inherits(RingOfFireResistance, _Ring21);

  function RingOfFireResistance() {
    _classCallCheck(this, _RingOfFireResistance);

    _get(Object.getPrototypeOf(_RingOfFireResistance.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RingOfFireResistance, [{
    key: 'FireResistance',
    value: function FireResistance() {
      return this.buc;
    }
  }]);

  var _RingOfFireResistance = RingOfFireResistance;
  RingOfFireResistance = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(RingOfFireResistance) || RingOfFireResistance;
  RingOfFireResistance = (0, _constantsDecorators.rarity)(5)(RingOfFireResistance) || RingOfFireResistance;
  return RingOfFireResistance;
})(_definitionsEquipment.Ring);

exports.RingOfFireResistance = RingOfFireResistance;

var RingOfIceResistance = (function (_Ring22) {
  _inherits(RingOfIceResistance, _Ring22);

  function RingOfIceResistance() {
    _classCallCheck(this, _RingOfIceResistance);

    _get(Object.getPrototypeOf(_RingOfIceResistance.prototype), 'constructor', this).apply(this, arguments);
  }

  // endregion

  _createClass(RingOfIceResistance, [{
    key: 'IceResistance',
    value: function IceResistance() {
      return this.buc;
    }
  }]);

  var _RingOfIceResistance = RingOfIceResistance;
  RingOfIceResistance = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Glass)(RingOfIceResistance) || RingOfIceResistance;
  RingOfIceResistance = (0, _constantsDecorators.rarity)(5)(RingOfIceResistance) || RingOfIceResistance;
  return RingOfIceResistance;
})(_definitionsEquipment.Ring);

exports.RingOfIceResistance = RingOfIceResistance;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/spellbooks.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../definitions/equipment');

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsDecorators = require('../../constants/decorators');

var ForceBolt = (function (_Spellbook) {
  _inherits(ForceBolt, _Spellbook);

  function ForceBolt() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _ForceBolt);

    _lodash2['default'].extend(opts, {
      manaCost: 2,
      attacks: [_attacks_all2['default'].Force({ roll: '2d6', range: 4 })]
    });
    _get(Object.getPrototypeOf(_ForceBolt.prototype), 'constructor', this).call(this, opts);
  }

  var _ForceBolt = ForceBolt;
  ForceBolt = (0, _constantsDecorators.rarity)(25)(ForceBolt) || ForceBolt;
  return ForceBolt;
})(_definitionsEquipment.Spellbook);

exports.ForceBolt = ForceBolt;

var CureSelf = (function (_Spellbook2) {
  _inherits(CureSelf, _Spellbook2);

  function CureSelf() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _CureSelf);

    _lodash2['default'].extend(opts, {
      manaCost: 10,
      healRoll: '3d6'
    });
    _get(Object.getPrototypeOf(_CureSelf.prototype), 'constructor', this).call(this, opts);
  }

  var _CureSelf = CureSelf;
  CureSelf = (0, _constantsDecorators.rarity)(0)(CureSelf) || CureSelf;
  return CureSelf;
})(_definitionsEquipment.Spellbook);

exports.CureSelf = CureSelf;

var ExtraCureSelf = (function (_Spellbook3) {
  _inherits(ExtraCureSelf, _Spellbook3);

  function ExtraCureSelf() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _ExtraCureSelf);

    _lodash2['default'].extend(opts, {
      manaCost: 25,
      healRoll: '6d6'
    });
    _get(Object.getPrototypeOf(_ExtraCureSelf.prototype), 'constructor', this).call(this, opts);
  }

  var _ExtraCureSelf = ExtraCureSelf;
  ExtraCureSelf = (0, _constantsDecorators.rarity)(0)(ExtraCureSelf) || ExtraCureSelf;
  return ExtraCureSelf;
})(_definitionsEquipment.Spellbook);

exports.ExtraCureSelf = ExtraCureSelf;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/wands.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../definitions/equipment');

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsDecorators = require('../../constants/decorators');

var WandOfStriking = (function (_Wand) {
  _inherits(WandOfStriking, _Wand);

  function WandOfStriking() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _WandOfStriking);

    _lodash2['default'].extend(opts, {
      charges: '2d5',
      attacks: [_attacks_all2['default'].Force({ roll: '2d6', range: 4 })]
    });
    _get(Object.getPrototypeOf(_WandOfStriking.prototype), 'constructor', this).call(this, opts);
  }

  var _WandOfStriking = WandOfStriking;
  WandOfStriking = (0, _constantsDecorators.rarity)(25)(WandOfStriking) || WandOfStriking;
  return WandOfStriking;
})(_definitionsEquipment.Wand);

exports.WandOfStriking = WandOfStriking;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/axes.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../../definitions/equipment');

var _attacks_all = require('../../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsMaterials = require('../../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../../constants/decorators');

var Axe = (function (_Hands) {
  _inherits(Axe, _Hands);

  function Axe() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Axe);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#ccc' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d6' })]
    });
    _get(Object.getPrototypeOf(_Axe.prototype), 'constructor', this).call(this, opts);
  }

  var _Axe = Axe;
  Axe = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Axe) || Axe;
  Axe = (0, _constantsDecorators.rarity)(10)(Axe) || Axe;
  return Axe;
})(_definitionsEquipment.Hands);

exports.Axe = Axe;

var BattleAxe = (function (_Hands2) {
  _inherits(BattleAxe, _Hands2);

  function BattleAxe() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _BattleAxe);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#ccc' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d8 + 1d4' })]
    });
    _get(Object.getPrototypeOf(_BattleAxe.prototype), 'constructor', this).call(this, opts);
  }

  var _BattleAxe = BattleAxe;
  BattleAxe = (0, _constantsDecorators.twoHanded)(BattleAxe) || BattleAxe;
  BattleAxe = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(BattleAxe) || BattleAxe;
  BattleAxe = (0, _constantsDecorators.rarity)(3)(BattleAxe) || BattleAxe;
  return BattleAxe;
})(_definitionsEquipment.Hands);

exports.BattleAxe = BattleAxe;

var DwarvishMattock = (function (_Hands3) {
  _inherits(DwarvishMattock, _Hands3);

  function DwarvishMattock() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _DwarvishMattock);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#ccc' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d12 + 1d4' })]
    });
    _get(Object.getPrototypeOf(_DwarvishMattock.prototype), 'constructor', this).call(this, opts);
  }

  var _DwarvishMattock = DwarvishMattock;
  DwarvishMattock = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(DwarvishMattock) || DwarvishMattock;
  DwarvishMattock = (0, _constantsDecorators.rarity)(1)(DwarvishMattock) || DwarvishMattock;
  return DwarvishMattock;
})(_definitionsEquipment.Hands);

exports.DwarvishMattock = DwarvishMattock;

},{"../../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/bows.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../../definitions/equipment');

var _attacks_all = require('../../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsMaterials = require('../../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../../constants/decorators');

var allArrows = ['orcisharrow', 'arrow', 'elvenarrow'];

var OrcishBow = (function (_Hands) {
  _inherits(OrcishBow, _Hands);

  function OrcishBow() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _OrcishBow);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#f00' },
      attacks: [_attacks_all2['default'].Ranged({ roll: '1d1' })] // if it can't shoot arrows, it'll bash for 1d1
    });
    _get(Object.getPrototypeOf(_OrcishBow.prototype), 'constructor', this).call(this, opts);
  }

  var _OrcishBow = OrcishBow;
  OrcishBow = (0, _constantsDecorators.ranged)({ ammo: allArrows, damageBoost: '1d1' })(OrcishBow) || OrcishBow;
  OrcishBow = (0, _constantsDecorators.twoHanded)(OrcishBow) || OrcishBow;
  OrcishBow = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(OrcishBow) || OrcishBow;
  OrcishBow = (0, _constantsDecorators.rarity)(35)(OrcishBow) || OrcishBow;
  return OrcishBow;
})(_definitionsEquipment.Hands);

exports.OrcishBow = OrcishBow;

var Sling = (function (_Hands2) {
  _inherits(Sling, _Hands2);

  function Sling() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Sling);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#f00' },
      attacks: [_attacks_all2['default'].Ranged({ roll: '1d1' })] // if it can't shoot arrows, it'll bash for 1d2
    });
    _get(Object.getPrototypeOf(_Sling.prototype), 'constructor', this).call(this, opts);
  }

  var _Sling = Sling;
  Sling = (0, _constantsDecorators.ranged)({ ammo: ['rock', 'flint stone'], damageBoost: '1d2' })(Sling) || Sling;
  Sling = (0, _constantsDecorators.twoHanded)(Sling) || Sling;
  Sling = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Sling) || Sling;
  Sling = (0, _constantsDecorators.rarity)(25)(Sling) || Sling;
  return Sling;
})(_definitionsEquipment.Hands);

exports.Sling = Sling;

var Bow = (function (_Hands3) {
  _inherits(Bow, _Hands3);

  function Bow() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Bow);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#f00' },
      attacks: [_attacks_all2['default'].Ranged({ roll: '1d2' })] // if it can't shoot arrows, it'll bash for 1d2
    });
    _get(Object.getPrototypeOf(_Bow.prototype), 'constructor', this).call(this, opts);
  }

  var _Bow = Bow;
  Bow = (0, _constantsDecorators.ranged)({ ammo: allArrows, damageBoost: '1d2' })(Bow) || Bow;
  Bow = (0, _constantsDecorators.twoHanded)(Bow) || Bow;
  Bow = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Bow) || Bow;
  Bow = (0, _constantsDecorators.rarity)(25)(Bow) || Bow;
  return Bow;
})(_definitionsEquipment.Hands);

exports.Bow = Bow;

var ElvenBow = (function (_Hands4) {
  _inherits(ElvenBow, _Hands4);

  function ElvenBow() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _ElvenBow);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#f00' },
      attacks: [_attacks_all2['default'].Ranged({ roll: '1d3' })] // if it can't shoot arrows, it'll bash for 1d3
    });
    _get(Object.getPrototypeOf(_ElvenBow.prototype), 'constructor', this).call(this, opts);
  }

  var _ElvenBow = ElvenBow;
  ElvenBow = (0, _constantsDecorators.ranged)({ ammo: allArrows, damageBoost: '1d3' })(ElvenBow) || ElvenBow;
  ElvenBow = (0, _constantsDecorators.twoHanded)(ElvenBow) || ElvenBow;
  ElvenBow = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(ElvenBow) || ElvenBow;
  ElvenBow = (0, _constantsDecorators.rarity)(15)(ElvenBow) || ElvenBow;
  return ElvenBow;
})(_definitionsEquipment.Hands);

exports.ElvenBow = ElvenBow;

var Crossbow = (function (_Hands5) {
  _inherits(Crossbow, _Hands5);

  function Crossbow() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Crossbow);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#f00' },
      attacks: [_attacks_all2['default'].Ranged({ roll: '1d2' })] // if it can't shoot arrows, it'll bash for 1d2
    });
    _get(Object.getPrototypeOf(_Crossbow.prototype), 'constructor', this).call(this, opts);
  }

  var _Crossbow = Crossbow;
  Crossbow = (0, _constantsDecorators.ranged)({ ammo: ['bolt'], damageBoost: '1d3' })(Crossbow) || Crossbow;
  Crossbow = (0, _constantsDecorators.twoHanded)(Crossbow) || Crossbow;
  Crossbow = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Crossbow) || Crossbow;
  Crossbow = (0, _constantsDecorators.rarity)(25)(Crossbow) || Crossbow;
  return Crossbow;
})(_definitionsEquipment.Hands);

exports.Crossbow = Crossbow;

},{"../../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/daggers.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x7, _x8, _x9) { var _again = true; _function: while (_again) { var object = _x7, property = _x8, receiver = _x9; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x7 = parent; _x8 = property; _x9 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../../definitions/equipment');

var _attacks_all = require('../../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsMaterials = require('../../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../../constants/decorators');

var OrcishDagger = (function (_Hands) {
  _inherits(OrcishDagger, _Hands);

  function OrcishDagger() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _OrcishDagger);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#ccc' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d3' })]
    });
    _get(Object.getPrototypeOf(_OrcishDagger.prototype), 'constructor', this).call(this, opts);
  }

  var _OrcishDagger = OrcishDagger;
  OrcishDagger = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(OrcishDagger) || OrcishDagger;
  OrcishDagger = (0, _constantsDecorators.rarity)(35)(OrcishDagger) || OrcishDagger;
  return OrcishDagger;
})(_definitionsEquipment.Hands);

exports.OrcishDagger = OrcishDagger;

var Dagger = (function (_Hands2) {
  _inherits(Dagger, _Hands2);

  function Dagger() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Dagger);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d4' })]
    });
    _get(Object.getPrototypeOf(_Dagger.prototype), 'constructor', this).call(this, opts);
  }

  var _Dagger = Dagger;
  Dagger = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Dagger) || Dagger;
  Dagger = (0, _constantsDecorators.rarity)(25)(Dagger) || Dagger;
  return Dagger;
})(_definitionsEquipment.Hands);

exports.Dagger = Dagger;

var Scalpel = (function (_Hands3) {
  _inherits(Scalpel, _Hands3);

  function Scalpel() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Scalpel);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d3' })]
    });
    _get(Object.getPrototypeOf(_Scalpel.prototype), 'constructor', this).call(this, opts);
  }

  var _Scalpel = Scalpel;
  Scalpel = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Scalpel) || Scalpel;
  Scalpel = (0, _constantsDecorators.rarity)(25)(Scalpel) || Scalpel;
  return Scalpel;
})(_definitionsEquipment.Hands);

exports.Scalpel = Scalpel;

var SilverDagger = (function (_Hands4) {
  _inherits(SilverDagger, _Hands4);

  function SilverDagger() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _SilverDagger);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d5' })]
    });
    _get(Object.getPrototypeOf(_SilverDagger.prototype), 'constructor', this).call(this, opts);
  }

  var _SilverDagger = SilverDagger;
  SilverDagger = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Silver)(SilverDagger) || SilverDagger;
  SilverDagger = (0, _constantsDecorators.rarity)(15)(SilverDagger) || SilverDagger;
  return SilverDagger;
})(_definitionsEquipment.Hands);

exports.SilverDagger = SilverDagger;

var ElvenDagger = (function (_Hands5) {
  _inherits(ElvenDagger, _Hands5);

  function ElvenDagger() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _ElvenDagger);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d7' })]
    });
    _get(Object.getPrototypeOf(_ElvenDagger.prototype), 'constructor', this).call(this, opts);
  }

  var _ElvenDagger = ElvenDagger;
  ElvenDagger = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(ElvenDagger) || ElvenDagger;
  ElvenDagger = (0, _constantsDecorators.rarity)(15)(ElvenDagger) || ElvenDagger;
  return ElvenDagger;
})(_definitionsEquipment.Hands);

exports.ElvenDagger = ElvenDagger;

var Crysknife = (function (_Hands6) {
  _inherits(Crysknife, _Hands6);

  function Crysknife() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Crysknife);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d10' })]
    });
    _get(Object.getPrototypeOf(_Crysknife.prototype), 'constructor', this).call(this, opts);
  }

  var _Crysknife = Crysknife;
  Crysknife = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Mineral)(Crysknife) || Crysknife;
  Crysknife = (0, _constantsDecorators.rarity)(5)(Crysknife) || Crysknife;
  return Crysknife;
})(_definitionsEquipment.Hands);

exports.Crysknife = Crysknife;

},{"../../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/longswords.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x9, _x10, _x11) { var _again = true; _function: while (_again) { var object = _x9, property = _x10, receiver = _x11; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x9 = parent; _x10 = property; _x11 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../../definitions/equipment');

var _attacks_all = require('../../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsMaterials = require('../../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../../constants/decorators');

var Longsword = (function (_Hands) {
  _inherits(Longsword, _Hands);

  function Longsword() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Longsword);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d8' })]
    });
    _get(Object.getPrototypeOf(_Longsword.prototype), 'constructor', this).call(this, opts);
  }

  var _Longsword = Longsword;
  Longsword = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Longsword) || Longsword;
  Longsword = (0, _constantsDecorators.rarity)(25)(Longsword) || Longsword;
  return Longsword;
})(_definitionsEquipment.Hands);

exports.Longsword = Longsword;

var Katana = (function (_Hands2) {
  _inherits(Katana, _Hands2);

  function Katana() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Katana);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d10' })]
    });
    _get(Object.getPrototypeOf(_Katana.prototype), 'constructor', this).call(this, opts);
  }

  var _Katana = Katana;
  Katana = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Katana) || Katana;
  Katana = (0, _constantsDecorators.rarity)(15)(Katana) || Katana;
  return Katana;
})(_definitionsEquipment.Hands);

exports.Katana = Katana;

var Broadsword = (function (_Hands3) {
  _inherits(Broadsword, _Hands3);

  function Broadsword() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Broadsword);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '2d4' })]
    });
    _get(Object.getPrototypeOf(_Broadsword.prototype), 'constructor', this).call(this, opts);
  }

  var _Broadsword = Broadsword;
  Broadsword = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Broadsword) || Broadsword;
  Broadsword = (0, _constantsDecorators.rarity)(20)(Broadsword) || Broadsword;
  return Broadsword;
})(_definitionsEquipment.Hands);

exports.Broadsword = Broadsword;

var ElvenBroadsword = (function (_Hands4) {
  _inherits(ElvenBroadsword, _Hands4);

  function ElvenBroadsword() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _ElvenBroadsword);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d6 + 1d4' })]
    });
    _get(Object.getPrototypeOf(_ElvenBroadsword.prototype), 'constructor', this).call(this, opts);
  }

  var _ElvenBroadsword = ElvenBroadsword;
  ElvenBroadsword = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(ElvenBroadsword) || ElvenBroadsword;
  ElvenBroadsword = (0, _constantsDecorators.rarity)(5)(ElvenBroadsword) || ElvenBroadsword;
  return ElvenBroadsword;
})(_definitionsEquipment.Hands);

exports.ElvenBroadsword = ElvenBroadsword;

var SilverSaber = (function (_Hands5) {
  _inherits(SilverSaber, _Hands5);

  function SilverSaber() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _SilverSaber);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d8', toHit: '1d4' })]
    });
    _get(Object.getPrototypeOf(_SilverSaber.prototype), 'constructor', this).call(this, opts);
  }

  var _SilverSaber = SilverSaber;
  SilverSaber = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Silver)(SilverSaber) || SilverSaber;
  SilverSaber = (0, _constantsDecorators.rarity)(1)(SilverSaber) || SilverSaber;
  return SilverSaber;
})(_definitionsEquipment.Hands);

exports.SilverSaber = SilverSaber;

var Scimitar = (function (_Hands6) {
  _inherits(Scimitar, _Hands6);

  function Scimitar() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Scimitar);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d8', toHit: '1d4' })]
    });
    _get(Object.getPrototypeOf(_Scimitar.prototype), 'constructor', this).call(this, opts);
  }

  var _Scimitar = Scimitar;
  Scimitar = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Scimitar) || Scimitar;
  Scimitar = (0, _constantsDecorators.rarity)(5)(Scimitar) || Scimitar;
  return Scimitar;
})(_definitionsEquipment.Hands);

exports.Scimitar = Scimitar;

var Greatsword = (function (_Hands7) {
  _inherits(Greatsword, _Hands7);

  function Greatsword() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Greatsword);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d12' })]
    });
    _get(Object.getPrototypeOf(_Greatsword.prototype), 'constructor', this).call(this, opts);
  }

  var _Greatsword = Greatsword;
  Greatsword = (0, _constantsDecorators.twoHanded)(Greatsword) || Greatsword;
  Greatsword = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Greatsword) || Greatsword;
  Greatsword = (0, _constantsDecorators.rarity)(15)(Greatsword) || Greatsword;
  return Greatsword;
})(_definitionsEquipment.Hands);

exports.Greatsword = Greatsword;

var Tsurugi = (function (_Hands8) {
  _inherits(Tsurugi, _Hands8);

  function Tsurugi() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Tsurugi);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d16' })]
    });
    _get(Object.getPrototypeOf(_Tsurugi.prototype), 'constructor', this).call(this, opts);
  }

  var _Tsurugi = Tsurugi;
  Tsurugi = (0, _constantsDecorators.twoHanded)(Tsurugi) || Tsurugi;
  Tsurugi = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Tsurugi) || Tsurugi;
  Tsurugi = (0, _constantsDecorators.rarity)(1)(Tsurugi) || Tsurugi;
  return Tsurugi;
})(_definitionsEquipment.Hands);

exports.Tsurugi = Tsurugi;

},{"../../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/maces.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x9, _x10, _x11) { var _again = true; _function: while (_again) { var object = _x9, property = _x10, receiver = _x11; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x9 = parent; _x10 = property; _x11 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../../definitions/equipment');

var _attacks_all = require('../../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsMaterials = require('../../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../../constants/decorators');

var Bullwhip = (function (_Hands) {
  _inherits(Bullwhip, _Hands);

  function Bullwhip() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Bullwhip);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Smash({ roll: '1d3' })]
    });
    _get(Object.getPrototypeOf(_Bullwhip.prototype), 'constructor', this).call(this, opts);
  }

  var _Bullwhip = Bullwhip;
  Bullwhip = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(Bullwhip) || Bullwhip;
  Bullwhip = (0, _constantsDecorators.rarity)(25)(Bullwhip) || Bullwhip;
  return Bullwhip;
})(_definitionsEquipment.Hands);

exports.Bullwhip = Bullwhip;

var GardenHose = (function (_Hands2) {
  _inherits(GardenHose, _Hands2);

  function GardenHose() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _GardenHose);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Smash({ roll: '1d2' })]
    });
    _get(Object.getPrototypeOf(_GardenHose.prototype), 'constructor', this).call(this, opts);
  }

  var _GardenHose = GardenHose;
  GardenHose = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Plastic)(GardenHose) || GardenHose;
  GardenHose = (0, _constantsDecorators.rarity)(15)(GardenHose) || GardenHose;
  return GardenHose;
})(_definitionsEquipment.Hands);

exports.GardenHose = GardenHose;

var Club = (function (_Hands3) {
  _inherits(Club, _Hands3);

  function Club() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Club);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Smash({ roll: '1d6' })]
    });
    _get(Object.getPrototypeOf(_Club.prototype), 'constructor', this).call(this, opts);
  }

  var _Club = Club;
  Club = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Club) || Club;
  Club = (0, _constantsDecorators.rarity)(25)(Club) || Club;
  return Club;
})(_definitionsEquipment.Hands);

exports.Club = Club;

var Aklys = (function (_Hands4) {
  _inherits(Aklys, _Hands4);

  function Aklys() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Aklys);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Smash({ roll: '1d6' })]
    });
    _get(Object.getPrototypeOf(_Aklys.prototype), 'constructor', this).call(this, opts);
  }

  var _Aklys = Aklys;
  Aklys = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Aklys) || Aklys;
  Aklys = (0, _constantsDecorators.rarity)(25)(Aklys) || Aklys;
  return Aklys;
})(_definitionsEquipment.Hands);

exports.Aklys = Aklys;

var Mace = (function (_Hands5) {
  _inherits(Mace, _Hands5);

  function Mace() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Mace);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Smash({ roll: '1d6 + 1' })]
    });
    _get(Object.getPrototypeOf(_Mace.prototype), 'constructor', this).call(this, opts);
  }

  var _Mace = Mace;
  Mace = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Mace) || Mace;
  Mace = (0, _constantsDecorators.rarity)(20)(Mace) || Mace;
  return Mace;
})(_definitionsEquipment.Hands);

exports.Mace = Mace;

var Flail = (function (_Hands6) {
  _inherits(Flail, _Hands6);

  function Flail() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Flail);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Smash({ roll: '1d6 + 2', toHit: '1d2' }), _attacks_all2['default'].Stab({ roll: '1d2' })]
    });
    _get(Object.getPrototypeOf(_Flail.prototype), 'constructor', this).call(this, opts);
  }

  var _Flail = Flail;
  Flail = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Flail) || Flail;
  Flail = (0, _constantsDecorators.rarity)(5)(Flail) || Flail;
  return Flail;
})(_definitionsEquipment.Hands);

exports.Flail = Flail;

var Morningstar = (function (_Hands7) {
  _inherits(Morningstar, _Hands7);

  function Morningstar() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Morningstar);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Smash({ roll: '2d4' })]
    });
    _get(Object.getPrototypeOf(_Morningstar.prototype), 'constructor', this).call(this, opts);
  }

  var _Morningstar = Morningstar;
  Morningstar = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Morningstar) || Morningstar;
  Morningstar = (0, _constantsDecorators.rarity)(15)(Morningstar) || Morningstar;
  return Morningstar;
})(_definitionsEquipment.Hands);

exports.Morningstar = Morningstar;

var Warhammer = (function (_Hands8) {
  _inherits(Warhammer, _Hands8);

  function Warhammer() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Warhammer);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Smash({ roll: '2d14' })]
    });
    _get(Object.getPrototypeOf(_Warhammer.prototype), 'constructor', this).call(this, opts);
  }

  var _Warhammer = Warhammer;
  Warhammer = (0, _constantsDecorators.twoHanded)(Warhammer) || Warhammer;
  Warhammer = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Warhammer) || Warhammer;
  Warhammer = (0, _constantsDecorators.rarity)(1)(Warhammer) || Warhammer;
  return Warhammer;
})(_definitionsEquipment.Hands);

exports.Warhammer = Warhammer;

},{"../../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/shortswords.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x5, _x6, _x7) { var _again = true; _function: while (_again) { var object = _x5, property = _x6, receiver = _x7; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x5 = parent; _x6 = property; _x7 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../../definitions/equipment');

var _attacks_all = require('../../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsMaterials = require('../../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../../constants/decorators');

var OrcishShortSword = (function (_Hands) {
  _inherits(OrcishShortSword, _Hands);

  function OrcishShortSword() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _OrcishShortSword);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#ccc' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d5' })]
    });
    _get(Object.getPrototypeOf(_OrcishShortSword.prototype), 'constructor', this).call(this, opts);
  }

  var _OrcishShortSword = OrcishShortSword;
  OrcishShortSword = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Copper)(OrcishShortSword) || OrcishShortSword;
  OrcishShortSword = (0, _constantsDecorators.rarity)(25)(OrcishShortSword) || OrcishShortSword;
  return OrcishShortSword;
})(_definitionsEquipment.Hands);

exports.OrcishShortSword = OrcishShortSword;

var Shortsword = (function (_Hands2) {
  _inherits(Shortsword, _Hands2);

  function Shortsword() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Shortsword);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d6' })]
    });
    _get(Object.getPrototypeOf(_Shortsword.prototype), 'constructor', this).call(this, opts);
  }

  var _Shortsword = Shortsword;
  Shortsword = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Shortsword) || Shortsword;
  Shortsword = (0, _constantsDecorators.rarity)(25)(Shortsword) || Shortsword;
  return Shortsword;
})(_definitionsEquipment.Hands);

exports.Shortsword = Shortsword;

var DwarvenShortsword = (function (_Hands3) {
  _inherits(DwarvenShortsword, _Hands3);

  function DwarvenShortsword() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _DwarvenShortsword);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d7' })]
    });
    _get(Object.getPrototypeOf(_DwarvenShortsword.prototype), 'constructor', this).call(this, opts);
  }

  var _DwarvenShortsword = DwarvenShortsword;
  DwarvenShortsword = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(DwarvenShortsword) || DwarvenShortsword;
  DwarvenShortsword = (0, _constantsDecorators.rarity)(15)(DwarvenShortsword) || DwarvenShortsword;
  return DwarvenShortsword;
})(_definitionsEquipment.Hands);

exports.DwarvenShortsword = DwarvenShortsword;

var ElvishShortsword = (function (_Hands4) {
  _inherits(ElvishShortsword, _Hands4);

  function ElvishShortsword() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _ElvishShortsword);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Slash({ roll: '1d8' })]
    });
    _get(Object.getPrototypeOf(_ElvishShortsword.prototype), 'constructor', this).call(this, opts);
  }

  var _ElvishShortsword = ElvishShortsword;
  ElvishShortsword = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(ElvishShortsword) || ElvishShortsword;
  ElvishShortsword = (0, _constantsDecorators.rarity)(5)(ElvishShortsword) || ElvishShortsword;
  return ElvishShortsword;
})(_definitionsEquipment.Hands);

exports.ElvishShortsword = ElvishShortsword;

},{"../../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/spears.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../../definitions/equipment');

var _attacks_all = require('../../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsMaterials = require('../../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../../constants/decorators');

var OrcishSpear = (function (_Hands) {
  _inherits(OrcishSpear, _Hands);

  function OrcishSpear() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _OrcishSpear);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#ccc' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d5' })]
    });
    _get(Object.getPrototypeOf(_OrcishSpear.prototype), 'constructor', this).call(this, opts);
  }

  var _OrcishSpear = OrcishSpear;
  OrcishSpear = (0, _constantsDecorators.twoHanded)(OrcishSpear) || OrcishSpear;
  OrcishSpear = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(OrcishSpear) || OrcishSpear;
  OrcishSpear = (0, _constantsDecorators.rarity)(35)(OrcishSpear) || OrcishSpear;
  return OrcishSpear;
})(_definitionsEquipment.Hands);

exports.OrcishSpear = OrcishSpear;

var Spear = (function (_Hands2) {
  _inherits(Spear, _Hands2);

  function Spear() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Spear);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d6' })]
    });
    _get(Object.getPrototypeOf(_Spear.prototype), 'constructor', this).call(this, opts);
  }

  var _Spear = Spear;
  Spear = (0, _constantsDecorators.twoHanded)(Spear) || Spear;
  Spear = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Spear) || Spear;
  Spear = (0, _constantsDecorators.rarity)(25)(Spear) || Spear;
  return Spear;
})(_definitionsEquipment.Hands);

exports.Spear = Spear;

var DwarvenSpear = (function (_Hands3) {
  _inherits(DwarvenSpear, _Hands3);

  function DwarvenSpear() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _DwarvenSpear);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d7' })]
    });
    _get(Object.getPrototypeOf(_DwarvenSpear.prototype), 'constructor', this).call(this, opts);
  }

  var _DwarvenSpear = DwarvenSpear;
  DwarvenSpear = (0, _constantsDecorators.twoHanded)(DwarvenSpear) || DwarvenSpear;
  DwarvenSpear = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(DwarvenSpear) || DwarvenSpear;
  DwarvenSpear = (0, _constantsDecorators.rarity)(15)(DwarvenSpear) || DwarvenSpear;
  return DwarvenSpear;
})(_definitionsEquipment.Hands);

exports.DwarvenSpear = DwarvenSpear;

var ElvishSpear = (function (_Hands4) {
  _inherits(ElvishSpear, _Hands4);

  function ElvishSpear() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _ElvishSpear);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Stab({ roll: '1d8' })]
    });
    _get(Object.getPrototypeOf(_ElvishSpear.prototype), 'constructor', this).call(this, opts);
  }

  var _ElvishSpear = ElvishSpear;
  ElvishSpear = (0, _constantsDecorators.twoHanded)(ElvishSpear) || ElvishSpear;
  ElvishSpear = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(ElvishSpear) || ElvishSpear;
  ElvishSpear = (0, _constantsDecorators.rarity)(5)(ElvishSpear) || ElvishSpear;
  return ElvishSpear;
})(_definitionsEquipment.Hands);

exports.ElvishSpear = ElvishSpear;

var Trident = (function (_Hands5) {
  _inherits(Trident, _Hands5);

  function Trident() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Trident);

    _lodash2['default'].extend(opts, {
      glyph: { fg: 'teal' },
      attacks: [_attacks_all2['default'].Stab({ roll: '2d6 + 1' })]
    });
    _get(Object.getPrototypeOf(_Trident.prototype), 'constructor', this).call(this, opts);
  }

  _createClass(Trident, [{
    key: 'LizardBane',
    value: function LizardBane() {
      return 2;
    }
  }, {
    key: 'LizardFury',
    value: function LizardFury() {
      return 1;
    }
  }]);

  var _Trident = Trident;
  Trident = (0, _constantsDecorators.twoHanded)(Trident) || Trident;
  Trident = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Trident) || Trident;
  Trident = (0, _constantsDecorators.rarity)(1)(Trident) || Trident;
  return Trident;
})(_definitionsEquipment.Hands);

exports.Trident = Trident;

},{"../../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/weapons/staves.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _definitionsEquipment = require('../../../definitions/equipment');

var _attacks_all = require('../../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsMaterials = require('../../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../../constants/decorators');

var Quarterstaff = (function (_Hands) {
  _inherits(Quarterstaff, _Hands);

  function Quarterstaff() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Quarterstaff);

    _lodash2['default'].extend(opts, {
      glyph: { fg: '#49311c' },
      attacks: [_attacks_all2['default'].Bash({ roll: '1d6' })]
    });
    _get(Object.getPrototypeOf(_Quarterstaff.prototype), 'constructor', this).call(this, opts);
  }

  var _Quarterstaff = Quarterstaff;
  Quarterstaff = (0, _constantsDecorators.twoHanded)(Quarterstaff) || Quarterstaff;
  Quarterstaff = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Quarterstaff) || Quarterstaff;
  Quarterstaff = (0, _constantsDecorators.rarity)(25)(Quarterstaff) || Quarterstaff;
  return Quarterstaff;
})(_definitionsEquipment.Hands);

exports.Quarterstaff = Quarterstaff;

},{"../../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/wrists.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsEquipment = require('../../definitions/equipment');

var _libDefaultCalculations = require('../../lib/default-calculations');

var _constantsMaterials = require('../../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../../constants/decorators');

var LeatherGloves = (function (_Wrist) {
  _inherits(LeatherGloves, _Wrist);

  function LeatherGloves() {
    _classCallCheck(this, _LeatherGloves);

    _get(Object.getPrototypeOf(_LeatherGloves.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(LeatherGloves, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }]);

  var _LeatherGloves = LeatherGloves;
  LeatherGloves = (0, _constantsDecorators.twoHanded)(LeatherGloves) || LeatherGloves;
  LeatherGloves = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(LeatherGloves) || LeatherGloves;
  LeatherGloves = (0, _constantsDecorators.rarity)(45)(LeatherGloves) || LeatherGloves;
  return LeatherGloves;
})(_definitionsEquipment.Wrist);

exports.LeatherGloves = LeatherGloves;

var Bracer = (function (_Wrist2) {
  _inherits(Bracer, _Wrist2);

  function Bracer() {
    _classCallCheck(this, _Bracer);

    _get(Object.getPrototypeOf(_Bracer.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Bracer, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }]);

  var _Bracer = Bracer;
  Bracer = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(Bracer) || Bracer;
  Bracer = (0, _constantsDecorators.rarity)(45)(Bracer) || Bracer;
  return Bracer;
})(_definitionsEquipment.Wrist);

exports.Bracer = Bracer;

var GauntletsOfDexterity = (function (_Wrist3) {
  _inherits(GauntletsOfDexterity, _Wrist3);

  function GauntletsOfDexterity() {
    _classCallCheck(this, _GauntletsOfDexterity);

    _get(Object.getPrototypeOf(_GauntletsOfDexterity.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(GauntletsOfDexterity, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }, {
    key: 'dex',
    value: function dex() {
      return this.buc * -2;
    }
  }]);

  var _GauntletsOfDexterity = GauntletsOfDexterity;
  GauntletsOfDexterity = (0, _constantsDecorators.twoHanded)(GauntletsOfDexterity) || GauntletsOfDexterity;
  GauntletsOfDexterity = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(GauntletsOfDexterity) || GauntletsOfDexterity;
  GauntletsOfDexterity = (0, _constantsDecorators.rarity)(10)(GauntletsOfDexterity) || GauntletsOfDexterity;
  return GauntletsOfDexterity;
})(_definitionsEquipment.Wrist);

exports.GauntletsOfDexterity = GauntletsOfDexterity;

var GauntletsOfStrength = (function (_Wrist4) {
  _inherits(GauntletsOfStrength, _Wrist4);

  function GauntletsOfStrength() {
    _classCallCheck(this, _GauntletsOfStrength);

    _get(Object.getPrototypeOf(_GauntletsOfStrength.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(GauntletsOfStrength, [{
    key: 'ac',
    value: function ac() {
      return (0, _libDefaultCalculations.AC)(this);
    }
  }, {
    key: 'str',
    value: function str() {
      return this.buc * -2;
    }
  }]);

  var _GauntletsOfStrength = GauntletsOfStrength;
  GauntletsOfStrength = (0, _constantsDecorators.twoHanded)(GauntletsOfStrength) || GauntletsOfStrength;
  GauntletsOfStrength = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Leather)(GauntletsOfStrength) || GauntletsOfStrength;
  GauntletsOfStrength = (0, _constantsDecorators.rarity)(10)(GauntletsOfStrength) || GauntletsOfStrength;
  return GauntletsOfStrength;
})(_definitionsEquipment.Wrist);

exports.GauntletsOfStrength = GauntletsOfStrength;

},{"../../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","../../lib/default-calculations":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/default-calculations.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/_all.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _canines = require('./canines');

var Canines = _interopRequireWildcard(_canines);

var _elementals = require('./elementals');

var Elementals = _interopRequireWildcard(_elementals);

var _gnomes = require('./gnomes');

var Gnomes = _interopRequireWildcard(_gnomes);

var _insects = require('./insects');

var Insects = _interopRequireWildcard(_insects);

var _jellies = require('./jellies');

var Jellies = _interopRequireWildcard(_jellies);

var _kobolds = require('./kobolds');

var Kobolds = _interopRequireWildcard(_kobolds);

var _nymphs = require('./nymphs');

var Nymphs = _interopRequireWildcard(_nymphs);

var _orcs = require('./orcs');

var Orcs = _interopRequireWildcard(_orcs);

var _puddings = require('./puddings');

var Puddings = _interopRequireWildcard(_puddings);

var _rats = require('./rats');

var Rats = _interopRequireWildcard(_rats);

var _lizards = require('./lizards');

var Lizards = _interopRequireWildcard(_lizards);

var _spores = require('./spores');

var Spores = _interopRequireWildcard(_spores);

var _summoned = require('./_summoned');

var Summoned = _interopRequireWildcard(_summoned);

exports['default'] = _lodash2['default'].extend({}, Canines, Elementals, Gnomes, Insects, Jellies, Kobolds, Lizards, Nymphs, Orcs, Puddings, Rats, Spores, Summoned);
module.exports = exports['default'];

},{"./_summoned":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/_summoned.js","./canines":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/canines.js","./elementals":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/elementals.js","./gnomes":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/gnomes.js","./insects":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/insects.js","./jellies":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/jellies.js","./kobolds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/kobolds.js","./lizards":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/lizards.js","./nymphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/nymphs.js","./orcs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/orcs.js","./puddings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/puddings.js","./rats":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/rats.js","./spores":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/spores.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/_special.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _constantsRandom = require('../../constants/random');

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var Selyk = { difficulty: 10, spawnPattern: '1d1', frequency: 0, init: function init() {
    return { important: true, glyph: { key: _constantsGlyphs.Entities.Humanoid, fg: _constantsGlyphColors.Special.Selyk },
      attributes: { ac: -10, speed: 200, level: 20, str: '2d10', con: '2d10', int: '3d10', mp: '5d10', killXp: '50d10', spawnHp: '5d10 + 25' },
      stats: { name: 'Selyk', race: 'Human', profession: 'Wizard',
        startingEquipment: [{ init: function init() {
            return (0, _constantsRandom.Wand)({ bucName: 'blessed', charges: '5d5' });
          } }],
        behaviors: [Behaviors.Bloodthirsty(), Behaviors.Attacks(), Behaviors.TeleportsWhenHit(), Behaviors.OpensDoors()],
        attacks: [_attacks_all2['default'].ElectricTouch({ roll: '1d1', toHit: '1d5' })]
      } };
  } };
exports.Selyk = Selyk;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../../constants/random":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/random.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/_summoned.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var Attacks = _interopRequireWildcard(_attacks_all);

var _constantsFactions = require('../../constants/factions');

var _constantsFactions2 = _interopRequireDefault(_constantsFactions);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var waterMoccasin = { difficulty: 7, spawnPattern: '1d1', frequency: 0, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Snake, fg: _constantsGlyphColors.Entities.Elements.Water },
      addAntiFactions: [_constantsFactions2['default'].ALL],
      attributes: { ac: -7, speed: 200, level: 4, killXp: '6d10', spawnHp: '2d4' },
      stats: { name: 'water moccasin', race: 'Snake',
        behaviors: [Behaviors.LeavesCorpse(10), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [Attacks.Poison({ roll: '1d6' })]
      } };
  } };

exports.waterMoccasin = waterMoccasin;
var waterDemon = { difficulty: 11, spawnPattern: '1d1', frequency: 0, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Demon, fg: _constantsGlyphColors.Entities.Elements.Water },
      attributes: { ac: -14, speed: 175, level: 8, killXp: '18d10', spawnHp: '5d10' },
      stats: { name: 'water demon', race: 'Demon',
        behaviors: [Behaviors.SeeksTargetInSight(), Behaviors.Attacks(), Behaviors.DropsItems()]
      } };
  } };
exports.waterDemon = waterDemon;

},{"../../constants/factions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/factions.js","../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/canines.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var jackal = { difficulty: 2, spawnPattern: '1d3 + 1', frequency: 25, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Canine, fg: _constantsGlyphColors.Entities.Tiers.Basic },
      startingEquipment: [{ probability: 20, init: function init() {
          return new Foods.Ration({ charges: '1d2' });
        } }],
      attributes: { ac: -3, speed: 125, level: 1, str: '1d4 + 2', dex: '2d3 + 4', con: 4, killXp: '2d3 + 3', spawnHp: '3d3 + 5' },
      stats: { name: 'jackal', race: 'Canine',
        behaviors: [Behaviors.LeavesCorpse(5), Behaviors.DropsGold('1d10'), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks(), Behaviors.DropsItems()],
        attacks: [_attacks_all2['default'].Bite({ roll: '1d2 + 1', toHit: '1d2' })]
      } };
  } };

exports.jackal = jackal;
var fox = { difficulty: 1, spawnPattern: '1d3 + 1', frequency: 30, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Canine, fg: _constantsGlyphColors.Entities.Tiers.Weak },
      attributes: { ac: -1, speed: 150, level: 1, str: '1d3', dex: '1d3 + 4', con: 4, killXp: '2d3 + 3', spawnHp: '1d3 + 5' },
      stats: { name: 'fox', race: 'Canine',
        behaviors: [Behaviors.LeavesCorpse(40), Behaviors.DropsGold('1d10'), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks(), Behaviors.DropsItems()],
        attacks: [_attacks_all2['default'].Bite({ roll: '1d2 + 1' })]
      } };
  } };
exports.fox = fox;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/elementals.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var waterElemental = { difficulty: 10, spawnPattern: '1d2 + 1', frequency: 1, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Elemental, fg: _constantsGlyphColors.Entities.Elements.Water },
      attributes: { ac: -8, speed: 50, level: 8, killXp: '13d10', spawnHp: '7d7' },
      stats: { name: 'water elemental', race: 'Elemental',
        behaviors: [Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Claw({ roll: '5d6' })]
      } };
  } };
exports.waterElemental = waterElemental;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/gnomes.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsProjectiles = require('../items/projectiles');

var Projectiles = _interopRequireWildcard(_itemsProjectiles);

var _itemsFeets = require('../items/feets');

var Feets = _interopRequireWildcard(_itemsFeets);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var gnome = { difficulty: 3, spawnPattern: '1d2', frequency: 3, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Gnome, fg: _constantsGlyphColors.Entities.Tiers.Weak },
      startingEquipment: [{ choices: { bow: 1, crossbow: 1, darts: 1 },
        choicesInit: {
          bow: function bow() {
            return [new Weapons.Bow(), new Projectiles.Arrow({ charges: '1d14 + 3' })];
          },
          crossbow: function crossbow() {
            return [new Weapons.Crossbow(), new Projectiles.Bolt({ charges: '1d14 + 3' })];
          },
          darts: function darts() {
            return new Projectiles.Dart({ charges: '1d14 + 3' });
          }
        }
      }, { probability: 25, init: function init() {
          return new Feets.SimpleBoots();
        } }],
      attributes: { speed: 50, level: 1, killXp: '2d10', spawnHp: '6d2' },
      stats: { name: 'gnome', race: 'Gnome',
        behaviors: [Behaviors.LeavesCorpse(75), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()]
      } };
  } };
exports.gnome = gnome;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/feets":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/feets.js","../items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/insects.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var gridBug = { difficulty: 1, spawnPattern: '1d2', frequency: 40, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Mystical, fg: _constantsGlyphColors.Entities.Tiers.Basic },
      attributes: { ac: -1, speed: 150, level: 1, str: 5, dex: 3, con: 0, killXp: '4d1', spawnHp: '1d4 + 2' },
      stats: { name: 'grid bug', race: 'Insect',
        behaviors: [Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].ElectricTouch({ roll: '1d3 + 1' })]
      } };
  } };

exports.gridBug = gridBug;
var giantAnt = { difficulty: 4, spawnPattern: '1d4 + 2', frequency: 7, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Ant, fg: _constantsGlyphColors.Entities.Tiers.Weak },
      attributes: { ac: -2, speed: 150, level: 3, str: '1d3 + 3', dex: '1d3 + 2', con: 4, killXp: '2d4 + 5', spawnHp: '1d8 + 5' },
      stats: { name: 'giant ant', race: 'Insect',
        behaviors: [Behaviors.LeavesCorpse(10), Behaviors.DropsGold('2d4'), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '1d4 + 1' })]
      } };
  } };

exports.giantAnt = giantAnt;
var killerBee = { difficulty: 12, spawnPattern: '3d4', frequency: 2, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Ant, fg: _constantsGlyphColors.Entities.Tiers.Inadequate },
      attributes: { ac: -11, speed: 150, level: 7, killXp: '7d4 + 5', spawnHp: '3d4' },
      stats: { name: 'killer bee', race: 'Insect',
        behaviors: [Behaviors.LeavesCorpse(1), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Poison({ roll: '1d3', percent: 33 })]
      } };
  } };

exports.killerBee = killerBee;
var soldierAnt = { difficulty: 13, spawnPattern: '2d4 + 3', frequency: 2, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Ant, fg: _constantsGlyphColors.Entities.Tiers.Inadequate },
      attributes: { ac: -7, speed: 150, level: 6, killXp: '10d4', spawnHp: '4d4' },
      stats: { name: 'soldier ant', race: 'Insect',
        behaviors: [Behaviors.LeavesCorpse(5), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '2d4' }), _attacks_all2['default'].Poison({ roll: '3d4', percent: 33 })]
      } };
  } };

exports.soldierAnt = soldierAnt;
var fireAnt = { difficulty: 11, spawnPattern: '2d4 + 3', frequency: 2, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Ant, fg: _constantsGlyphColors.Entities.Elements.Fire },
      attributes: { ac: -7, speed: 150, level: 5, killXp: '10d4', spawnHp: '3d6' },
      stats: { name: 'fire ant', race: 'Insect',
        behaviors: [Behaviors.LeavesCorpse(1), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '2d4' }), _attacks_all2['default'].Bite({ roll: '2d4', element: 'Fire' })]
      } };
  } };

exports.fireAnt = fireAnt;
var giantBeetle = { difficulty: 7, spawnPattern: '1d3', frequency: 5, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Ant, fg: _constantsGlyphColors.Entities.Elements.Fire },
      attributes: { ac: -6, speed: 50, level: 5, killXp: '10d4', spawnHp: '3d6' },
      stats: { name: 'giant beetle', race: 'Insect',
        behaviors: [Behaviors.LeavesCorpse(5), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '3d6' })]
      } };
  } };
exports.giantBeetle = giantBeetle;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/jellies.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var blueJelly = { difficulty: 9, spawnPattern: '1d1', frequency: 2, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Jelly, fg: _constantsGlyphColors.Entities.Colors.Blue },
      attributes: { ac: -6, speed: 50, level: 4, killXp: '10d5', spawnHp: '5d5' },
      stats: { name: 'blue jelly', race: 'Jelly',
        behaviors: [Behaviors.Attacks(), Behaviors.KillsSelfAfterPeriodOfTime()],
        attacks: [_attacks_all2['default'].Bite({ roll: '4d6', element: 'Ice' })]
      } };
  } };
exports.blueJelly = blueJelly;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/kobolds.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var Attacks = _interopRequireWildcard(_attacks_all);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsFeets = require('../items/feets');

var Feets = _interopRequireWildcard(_itemsFeets);

var _itemsSpellbooks = require('../items/spellbooks');

var Spellbooks = _interopRequireWildcard(_itemsSpellbooks);

var _itemsProjectiles = require('../items/projectiles');

var Projectiles = _interopRequireWildcard(_itemsProjectiles);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var koboldStartingEquipment = [{ choices: { dagger: 2, spear: 1, shortsword: 1 },
  choicesInit: {
    dagger: function dagger() {
      return new Weapons.OrcishDagger();
    },
    spear: function spear() {
      return new Weapons.OrcishSpear();
    },
    shortsword: function shortsword() {
      return new Weapons.OrcishShortSword();
    }
  }
}, { probability: 25, init: function init() {
    return new Projectiles.Dart({ charges: '1d14 + 3' });
  } }, { probability: 25, init: function init() {
    return new Feets.SimpleBoots();
  } }];

var kobold = { difficulty: 1, spawnPattern: '1d1', frequency: 3, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Kobold, fg: _constantsGlyphColors.Entities.Tiers.Weak },
      startingEquipment: koboldStartingEquipment,
      attributes: { speed: 50, level: 1, killXp: '1d10', spawnHp: '3d2' },
      stats: { name: 'kobold', race: 'Kobold',
        behaviors: [Behaviors.LeavesCorpse(55), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()]
      } };
  } };

exports.kobold = kobold;
var largeKobold = { difficulty: 2, spawnPattern: '1d1', frequency: 3, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Kobold, fg: _constantsGlyphColors.Entities.Tiers.Inadequate },
      startingEquipment: koboldStartingEquipment,
      attributes: { speed: 50, level: 2, killXp: '2d10', spawnHp: '6d2' },
      stats: { name: 'large kobold', race: 'Kobold',
        behaviors: [Behaviors.LeavesCorpse(55), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()]
      } };
  } };

exports.largeKobold = largeKobold;
var koboldLord = { difficulty: 3, spawnPattern: '1d1', frequency: 3, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Kobold, fg: _constantsGlyphColors.Entities.Tiers.Moderate },
      startingEquipment: koboldStartingEquipment,
      attributes: { speed: 50, level: 3, killXp: '3d10', spawnHp: '12d2' },
      stats: { name: 'kobold lord', race: 'Kobold',
        behaviors: [Behaviors.LeavesCorpse(45), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [Attacks.Bite({ roll: '1d4' })]
      } };
  } };

exports.koboldLord = koboldLord;
var koboldShaman = { difficulty: 2, spawnPattern: '1d1', frequency: 3, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Kobold, fg: _constantsGlyphColors.Entities.Colors.Blue },
      startingEquipment: [{ init: function init() {
          return new Spellbooks.CureSelf();
        } }, { init: function init() {
          return new Spellbooks.ForceBolt();
        } }],
      attributes: { speed: 50, level: 2, ac: -4, int: 5, mp: '3d4', killXp: '3d10', spawnHp: '12d3' },
      stats: { name: 'kobold shaman', race: 'Kobold',
        behaviors: [Behaviors.LeavesCorpse(35), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()]
      } };
  } };
exports.koboldShaman = koboldShaman;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/feets":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/feets.js","../items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js","../items/spellbooks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/spellbooks.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/lizards.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _itemsFeets = require('../items/feets');

var Feets = _interopRequireWildcard(_itemsFeets);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsProjectiles = require('../items/projectiles');

var Projectiles = _interopRequireWildcard(_itemsProjectiles);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var newt = { difficulty: 1, spawnPattern: '1d1', frequency: 50, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Lizard, fg: _constantsGlyphColors.Entities.Colors.Yellow },
      attributes: { ac: -2, speed: 50, level: 1, killXp: '1d1', spawnHp: '1d4' },
      stats: { name: 'newt', race: 'Lizard',
        behaviors: [Behaviors.LeavesCorpse(25), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '1d2' })]
      } };
  } };

exports.newt = newt;
var gecko = { difficulty: 2, spawnPattern: '1d1', frequency: 35, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Lizard, fg: _constantsGlyphColors.Entities.Colors.Green },
      attributes: { ac: -2, speed: 50, level: 2, killXp: '1d8', spawnHp: '2d4' },
      stats: { name: 'gecko', race: 'Lizard',
        behaviors: [Behaviors.LeavesCorpse(25), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '1d3' })]
      } };
  } };

exports.gecko = gecko;
var iguana = { difficulty: 3, spawnPattern: '1d1', frequency: 25, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Lizard, fg: _constantsGlyphColors.Entities.Colors.Brown },
      attributes: { ac: -3, speed: 50, level: 3, killXp: '3d8', spawnHp: '4d4' },
      stats: { name: 'iguana', race: 'Lizard',
        behaviors: [Behaviors.LeavesCorpse(25), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '1d4' })]
      } };
  } };

exports.iguana = iguana;
var babyCrocodile = { difficulty: 3, spawnPattern: '1d2', frequency: 1, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Lizard, fg: _constantsGlyphColors.Entities.Colors.Brown },
      attributes: { ac: -3, speed: 25, level: 3, killXp: '3d8', spawnHp: '3d7' },
      stats: { name: 'baby crocodile', race: 'Lizard',
        behaviors: [Behaviors.LeavesCorpse(25), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '1d4' })]
      } };
  } };

exports.babyCrocodile = babyCrocodile;
var crocodile = { difficulty: 7, spawnPattern: '1d1', frequency: 1, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Lizard, fg: _constantsGlyphColors.Entities.Colors.Brown },
      attributes: { ac: -5, speed: 50, level: 6, killXp: '7d12', spawnHp: '4d10' },
      stats: { name: 'crocodile', race: 'Lizard',
        behaviors: [Behaviors.LeavesCorpse(25), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '4d2' }), _attacks_all2['default'].Claw({ roll: '1d12' })]
      } };
  } };

exports.crocodile = crocodile;
var chameleon = { difficulty: 7, spawnPattern: '1d1', frequency: 5, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Lizard, fg: _constantsGlyphColors.Entities.Colors.Brown },
      attributes: { ac: -5, speed: 75, level: 6, killXp: '7d12', spawnHp: '3d10' },
      stats: { name: 'chameleon', race: 'Lizard',
        behaviors: [Behaviors.LeavesCorpse(5), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '4d2' })]
      } };
  } };

exports.chameleon = chameleon;
var salamander = { difficulty: 17, spawnPattern: '1d1', frequency: 1, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Lizard, fg: _constantsGlyphColors.Entities.Colors.Red },
      addFactions: ['Lizard'],
      startingEquipment: [{ choices: { spear: 18, trident: 2, stiletto: 1 },
        choicesInit: {
          spear: function spear() {
            return new Weapons.Spear();
          },
          trident: function trident() {
            return new Weapons.Trident();
          },
          stiletto: function stiletto() {
            return new Projectiles.Stiletto();
          }
        }
      }, { probability: 25, init: function init() {
          return new Feets.SimpleBoots();
        } }],
      attributes: { ac: -11, speed: 100, level: 10, killXp: '20d10', spawnHp: '4d20' },
      stats: { name: 'salamander', race: 'Lizardman',
        behaviors: [Behaviors.LeavesCorpse(5), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        traits: [Traits.FireResistance()],
        attacks: [_attacks_all2['default'].Bearhug({ roll: '2d6' }), _attacks_all2['default'].Bearhug({ roll: '3d6', element: 'Fire' }), _attacks_all2['default'].Touch({ roll: '1d6', element: 'Fire' })]
      } };
  } };
exports.salamander = salamander;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/feets":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/feets.js","../items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/nymphs.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var waterNymph = { difficulty: 5, spawnPattern: '1d3 + 1', frequency: 0, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Nymph, fg: _constantsGlyphColors.Entities.Elements.Water },
      attributes: { ac: -1, speed: 100, level: 3, killXp: '7d7', spawnHp: '5d5 + 5' },
      stats: { name: 'water nymph', race: 'Elf',
        behaviors: [Behaviors.LeavesCorpse(15), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Steals(), Behaviors.Attacks(), Behaviors.DropsItems()],
        attacks: [_attacks_all2['default'].Claw({ roll: '1d2 + 1' }), _attacks_all2['default'].SeductiveTouch({ roll: '1d2', chance: 20 })]
      } };
  } };

exports.waterNymph = waterNymph;
var forestNymph = { difficulty: 5, spawnPattern: '1d1', frequency: 1, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Nymph, fg: _constantsGlyphColors.Entities.Colors.Green },
      attributes: { ac: -1, speed: 100, level: 3, killXp: '7d7', spawnHp: '5d5 + 5' },
      stats: { name: 'forest nymph', race: 'Elf',
        behaviors: [Behaviors.LeavesCorpse(15), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Steals(), Behaviors.Attacks(), Behaviors.DropsItems()],
        attacks: [_attacks_all2['default'].Claw({ roll: '1d3 + 1' }), _attacks_all2['default'].SeductiveTouch({ roll: '1d3', chance: 30 })]
      } };
  } };

exports.forestNymph = forestNymph;
var mountainNymph = { difficulty: 25, spawnPattern: '1d1', frequency: 1, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Nymph, fg: _constantsGlyphColors.Entities.Colors.Brown },
      attributes: { ac: -8, speed: 150, level: 3, killXp: '20d7', spawnHp: '20d5' },
      stats: { name: 'mountain nymph', race: 'Elf',
        behaviors: [Behaviors.LeavesCorpse(15), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Steals(), Behaviors.Attacks(), Behaviors.DropsItems()],
        attacks: [_attacks_all2['default'].Claw({ roll: '2d4' }), _attacks_all2['default'].SeductiveTouch({ roll: '2d3', chance: 40 })]
      } };
  } };
exports.mountainNymph = mountainNymph;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/orcs.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsHeads = require('../items/heads');

var Heads = _interopRequireWildcard(_itemsHeads);

var _itemsBodys = require('../items/bodys');

var Bodys = _interopRequireWildcard(_itemsBodys);

var _itemsFeets = require('../items/feets');

var Feets = _interopRequireWildcard(_itemsFeets);

var _itemsProjectiles = require('../items/projectiles');

var Projectiles = _interopRequireWildcard(_itemsProjectiles);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var goblin = { difficulty: 1, spawnPattern: '1d1', frequency: 6, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Orc, fg: _constantsGlyphColors.Entities.Tiers.Basic },
      startingEquipment: [{ probability: 50, init: function init() {
          return new Weapons.OrcishDagger();
        } }, { probability: 50, init: function init() {
          return new Heads.OrcishHelm();
        } }, { probability: 25, init: function init() {
          return new Feets.SimpleBoots();
        } }],
      attributes: { speed: 75, level: 1, killXp: '1d15', spawnHp: '6d2' },
      stats: { name: 'goblin', race: 'Orc',
        behaviors: [Behaviors.LeavesCorpse(75), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()]
      } };
  } };

exports.goblin = goblin;
var hobgoblin = { difficulty: 3, spawnPattern: '1d1', frequency: 6, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Orc, fg: _constantsGlyphColors.Entities.Tiers.Weak },
      startingEquipment: [{ choices: { dagger: 1, shortsword: 1 },
        choicesInit: {
          dagger: function dagger() {
            return new Weapons.OrcishDagger();
          },
          shortsword: function shortsword() {
            return new Weapons.OrcishShortSword();
          }
        }
      }, { probability: 50, init: function init() {
          return new Heads.OrcishHelm();
        } }, { probability: 25, init: function init() {
          return new Feets.SimpleBoots();
        } }],
      attributes: { speed: 75, level: 1, killXp: '1d15', spawnHp: '6d2' },
      stats: { name: 'hobgoblin', race: 'Orc',
        behaviors: [Behaviors.LeavesCorpse(75), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()]
      } };
  } };

exports.hobgoblin = hobgoblin;
var orc = { difficulty: 3, spawnPattern: '1d1', frequency: 0, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Orc, fg: _constantsGlyphColors.Entities.Tiers.Inadequate },
      startingEquipment: [{ choices: { sword: 1, bow: 1 },
        choicesInit: {
          sword: function sword() {
            return new Weapons.Scimitar();
          },
          bow: function bow() {
            return [new Weapons.OrcishBow(), new Projectiles.OrcishArrow({ charges: '1d14 + 3' })];
          }
        }
      }, { probability: 50, init: function init() {
          return new Heads.OrcishHelm();
        } }, { probability: 50, init: function init() {
          return new Bodys.OrcishRingMail();
        } }, { probability: 25, init: function init() {
          return new Feets.SimpleBoots();
        } }],
      attributes: { speed: 75, level: 1, killXp: '1d15', spawnHp: '6d2' },
      stats: { name: 'orc', race: 'Orc',
        behaviors: [Behaviors.LeavesCorpse(75), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()]
      } };
  } };
exports.orc = orc;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../items/feets":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/feets.js","../items/heads":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/heads.js","../items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/puddings.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var blackPudding = { difficulty: 12, spawnPattern: '1d1', frequency: 1, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Pudding, fg: _constantsGlyphColors.Entities.Colors.Black },
      attributes: { ac: -4, speed: 30, level: 10, killXp: '20d10', spawnHp: '5d5' },
      stats: { name: 'black pudding', race: 'Pudding',
        behaviors: [Behaviors.LeavesCorpse(5), Behaviors.SplitsWhenHit(), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Claw({ roll: '3d8' })]
      } };
  } };
exports.blackPudding = blackPudding;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/rats.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var _attacks_all2 = _interopRequireDefault(_attacks_all);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var sewerRat = { difficulty: 1, spawnPattern: '1d2 + 1', frequency: 45, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Rat, fg: _constantsGlyphColors.Entities.Tiers.Weak },
      attributes: { ac: -3, speed: 100, level: 1, killXp: '1d4', spawnHp: '1d2' },
      stats: { name: 'sewer rat', race: 'Rat',
        behaviors: [Behaviors.LeavesCorpse(5), Behaviors.SeeksTargetViaHearing(), Behaviors.SeeksTargetInSight(), Behaviors.Attacks()],
        attacks: [_attacks_all2['default'].Bite({ roll: '1d3' })]
      } };
  } };
exports.sewerRat = sewerRat;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/spores.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var _attacks_all = require('../attacks/_all');

var Attacks = _interopRequireWildcard(_attacks_all);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var gasSpore = { difficulty: 2, spawnPattern: '1d1', frequency: 15, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Spore, fg: _constantsGlyphColors.Entities.Tiers.Basic },
      attributes: { ac: 0, speed: 25, level: 2, killXp: '12d1', spawnHp: '2d4' },
      stats: { name: 'gas spore', race: 'Spore',
        behaviors: [Behaviors.Explodes('4d8', 3), Behaviors.Wanders()]
      } };
  } };

exports.gasSpore = gasSpore;
var floatingEye = { difficulty: 3, spawnPattern: '1d1', frequency: 3, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Spore, fg: _constantsGlyphColors.Entities.Tiers.Weak },
      attributes: { ac: -1, speed: 10, level: 2, killXp: '2d10', spawnHp: '1d5' },
      stats: { name: 'floating eye', race: 'Spore',
        behaviors: [Behaviors.ParalyzesWhenHit(50), Behaviors.Wanders()]
      } };
  } };

exports.floatingEye = floatingEye;
var electricSphere = { difficulty: 8, spawnPattern: '1d1', frequency: 3, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Spore, fg: _constantsGlyphColors.Entities.Elements.Shock },
      attributes: { ac: -6, speed: 110, level: 6, killXp: '15d10', spawnHp: '5d4' },
      stats: { name: 'shocking sphere', race: 'Spore',
        behaviors: [Behaviors.SeeksTargetInSight(), Behaviors.Attacks(), Behaviors.EmitsLight(_constantsGlyphColors.Entities.Elements.Shock)],
        traits: [Traits.ShockResistance()],
        attacks: [Attacks.Explode({ roll: '4d6', element: 'Shock' })]
      } };
  } };

exports.electricSphere = electricSphere;
var fireSphere = { difficulty: 8, spawnPattern: '1d1', frequency: 3, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Spore, fg: _constantsGlyphColors.Entities.Elements.Fire },
      attributes: { ac: -6, speed: 110, level: 6, killXp: '15d10', spawnHp: '5d4' },
      stats: { name: 'burning sphere', race: 'Spore',
        behaviors: [Behaviors.SeeksTargetInSight(), Behaviors.Attacks(), Behaviors.EmitsLight(_constantsGlyphColors.Entities.Elements.Fire)],
        traits: [Traits.FireResistance()],
        attacks: [Attacks.Explode({ roll: '4d6', element: 'Fire' })]
      } };
  } };

exports.fireSphere = fireSphere;
var iceSphere = { difficulty: 8, spawnPattern: '1d1', frequency: 3, init: function init() {
    return { glyph: { key: _constantsGlyphs.Entities.Spore, fg: _constantsGlyphColors.Entities.Elements.Ice },
      attributes: { ac: -6, speed: 110, level: 6, killXp: '15d10', spawnHp: '5d4' },
      stats: { name: 'freezing sphere', race: 'Spore',
        behaviors: [Behaviors.SeeksTargetInSight(), Behaviors.Attacks(), Behaviors.EmitsLight(_constantsGlyphColors.Entities.Elements.Ice)],
        traits: [Traits.IceResistance()],
        attacks: [Attacks.Explode({ roll: '4d6', element: 'Ice' })]
      } };
  } };
exports.iceSphere = iceSphere;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/_all.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _archaeologist = require('./archaeologist');

var _archaeologist2 = _interopRequireDefault(_archaeologist);

var _barbarian = require('./barbarian');

var _barbarian2 = _interopRequireDefault(_barbarian);

var _caveman = require('./caveman');

var _caveman2 = _interopRequireDefault(_caveman);

var _developer = require('./developer');

var _developer2 = _interopRequireDefault(_developer);

var _healer = require('./healer');

var _healer2 = _interopRequireDefault(_healer);

var _knight = require('./knight');

var _knight2 = _interopRequireDefault(_knight);

var _monk = require('./monk');

var _monk2 = _interopRequireDefault(_monk);

var _monster = require('./monster');

var _monster2 = _interopRequireDefault(_monster);

var _priest = require('./priest');

var _priest2 = _interopRequireDefault(_priest);

var _ranger = require('./ranger');

var _ranger2 = _interopRequireDefault(_ranger);

var _rogue = require('./rogue');

var _rogue2 = _interopRequireDefault(_rogue);

var _tourist = require('./tourist');

var _tourist2 = _interopRequireDefault(_tourist);

var _valkyrie = require('./valkyrie');

var _valkyrie2 = _interopRequireDefault(_valkyrie);

var _wizard = require('./wizard');

var _wizard2 = _interopRequireDefault(_wizard);

exports['default'] = {
  Archaeologist: _archaeologist2['default'], Barbarian: _barbarian2['default'], Caveman: _caveman2['default'], Developer: _developer2['default'], Healer: _healer2['default'], Knight: _knight2['default'],
  Monk: _monk2['default'], Monster: _monster2['default'], Priest: _priest2['default'], Ranger: _ranger2['default'], Rogue: _rogue2['default'], Tourist: _tourist2['default'], Valkyrie: _valkyrie2['default'], Wizard: _wizard2['default']
};
module.exports = exports['default'];

},{"./archaeologist":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/archaeologist.js","./barbarian":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/barbarian.js","./caveman":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/caveman.js","./developer":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/developer.js","./healer":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/healer.js","./knight":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/knight.js","./monk":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/monk.js","./monster":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/monster.js","./priest":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/priest.js","./ranger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/ranger.js","./rogue":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/rogue.js","./tourist":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/tourist.js","./valkyrie":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/valkyrie.js","./wizard":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/wizard.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/archaeologist.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsBodys = require('../items/bodys');

var Bodys = _interopRequireWildcard(_itemsBodys);

var _itemsHeads = require('../items/heads');

var Heads = _interopRequireWildcard(_itemsHeads);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var archaeologistConfig = {
  hp: '6d3',
  mp: '0d0',
  str: '2d2',
  con: '1d4',
  int: '1d2',
  dex: '3d3',
  wis: '1d2',
  cha: '1d1',
  levelUp: {
    hp: '1d3',
    mp: '0d0',
    str: '1d2',
    con: '1d2',
    int: '1d1',
    dex: '1d3',
    wis: '1d2',
    cha: '1d2 - 1'
  },
  titles: ['Digger',, 'Field Worker',,, 'Investigator',,, 'Exhumer',,, 'Excavator',,, 'Spelunker',,, 'Speleologist',,, 'Collector',,, 'Curator'],
  traits: [Traits.Stealth({ level: 2 }), Traits.Haste({ level: 2 })],
  skillCaps: { bash: Thresholds.Skilled, stab: Thresholds.Basic, slash: Thresholds.Skilled, unarmed: Thresholds.Expert },
  startingItems: [{ init: function init() {
      return new Weapons.Bullwhip({ bucName: 'uncursed', enchantment: 2 });
    } }, { init: function init() {
      return new Foods.Ration({ charges: '3d2', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Bodys.LeatherJacket({ bucName: 'uncursed', startIdentified: true });
    } }, { init: function init() {
      return new Heads.Fedora({ bucName: 'uncursed', startIdentified: true });
    } }]
};

var Archaeologist = (function (_Profession) {
  _inherits(Archaeologist, _Profession);

  function Archaeologist() {
    _classCallCheck(this, Archaeologist);

    _get(Object.getPrototypeOf(Archaeologist.prototype), 'constructor', this).call(this, archaeologistConfig);
  }

  return Archaeologist;
})(_definitionsProfession2['default']);

exports['default'] = Archaeologist;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../items/heads":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/heads.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/barbarian.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsBodys = require('../items/bodys');

var Bodys = _interopRequireWildcard(_itemsBodys);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var barbarianConfig = {
  hp: '2d3',
  mp: '0d0',
  str: '4d3',
  con: '3d2',
  int: '1d1',
  dex: '2d2',
  wis: '1d1',
  cha: '1d1',
  levelUp: {
    hp: '1d2',
    mp: '0d0',
    str: '1d3',
    con: '1d2',
    int: '1d1',
    dex: '1d2',
    wis: '1d1',
    cha: '1d2 - 1'
  },
  titles: ['Plunderex',, 'Pillager',,, 'Bandit',,, 'Brigand',,, 'Raider',,, 'Reaver',,, 'Slayer',,, 'Chiefterex',,, 'Conquerex'],
  traits: [Traits.Stealth({ level: 3, req: 15 }), Traits.Haste({ level: 2, req: 7 }), Traits.PoisonResistance()],
  skillCaps: { bash: Thresholds.Skilled, stab: Thresholds.Skilled, ranged: Thresholds.Basic, shot: Thresholds.Basic, slash: Thresholds.Skilled, unarmed: Thresholds.Master },
  startingItems: [{ choices: { swordaxe: 1, axesword: 1 },
    choicesInit: {
      swordaxe: function swordaxe() {
        return [new Weapons.Broadsword({ bucName: 'uncursed' }), new Weapons.Axe({ bucName: 'uncursed' })];
      },
      axesword: function axesword() {
        return [new Weapons.BattleAxe({ bucName: 'uncursed' }), new Weapons.Shortsword({ bucName: 'uncursed' })];
      }
    }
  }, { init: function init() {
      return new Foods.Ration({ charges: '1d2', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Bodys.RingMail({ bucName: 'uncursed', startIdentified: true });
    } }]
};

var Barbarian = (function (_Profession) {
  _inherits(Barbarian, _Profession);

  function Barbarian() {
    _classCallCheck(this, Barbarian);

    _get(Object.getPrototypeOf(Barbarian.prototype), 'constructor', this).call(this, barbarianConfig);
  }

  return Barbarian;
})(_definitionsProfession2['default']);

exports['default'] = Barbarian;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/caveman.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsBodys = require('../items/bodys');

var Bodys = _interopRequireWildcard(_itemsBodys);

var _itemsProjectiles = require('../items/projectiles');

var Projectiles = _interopRequireWildcard(_itemsProjectiles);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var cavemanConfig = {
  hp: '4d4',
  mp: '0d0',
  str: '6d2',
  con: '1d2',
  int: '1d1',
  dex: '1d2',
  wis: '1d1',
  cha: '1d1',
  levelUp: {
    hp: '1d4',
    mp: '0d0',
    str: '2d2',
    con: '1d2',
    int: '1d1',
    dex: '1d2',
    wis: '1d1',
    cha: '0d0'
  },
  titles: ['Troglodyte',, 'Aborigine',,, 'Wanderer',,, 'Vagrant',,, 'Wayfarer',,, 'Roamer',,, 'Nomad',,, 'Rover',,, 'Pioneer'],
  traits: [Traits.Warning({ level: 3, req: 15 }), Traits.Haste({ level: 2, req: 7 })],
  skillCaps: { bash: Thresholds.Expert, stab: Thresholds.Basic, ranged: Thresholds.Basic, shot: Thresholds.Basic, unarmed: Thresholds.Master },
  startingItems: [{ init: function init() {
      return new Weapons.Club({ bucName: 'uncursed', enchantment: 1 });
    } }, { init: function init() {
      return new Weapons.Sling({ bucName: 'uncursed', enchantment: 2 });
    } }, { init: function init() {
      return new Projectiles.FlintStone({ charges: '1d12 + 10', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Projectiles.Rock({ charges: '1d15 + 18', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Bodys.StuddedLeatherArmor({ bucName: 'uncursed', startIdentified: true });
    } }]
};

var Caveman = (function (_Profession) {
  _inherits(Caveman, _Profession);

  function Caveman() {
    _classCallCheck(this, Caveman);

    _get(Object.getPrototypeOf(Caveman.prototype), 'constructor', this).call(this, cavemanConfig);
  }

  return Caveman;
})(_definitionsProfession2['default']);

exports['default'] = Caveman;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/developer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _itemsHeads = require('../items/heads');

var Heads = _interopRequireWildcard(_itemsHeads);

var _itemsNecks = require('../items/necks');

var Necks = _interopRequireWildcard(_itemsNecks);

var _itemsPotions = require('../items/potions');

var Potions = _interopRequireWildcard(_itemsPotions);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsProjectiles = require('../items/projectiles');

var Projectiles = _interopRequireWildcard(_itemsProjectiles);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var devCfg = {
  hp: '1d1',
  mp: '9d5',
  str: '1d1',
  con: '1d1',
  int: '4d5',
  dex: '1d1',
  wis: '4d5',
  cha: '4d5',
  levelUp: {
    hp: '1d3',
    mp: '0d0',
    str: '1d2',
    con: '1d2',
    int: '1d1',
    dex: '1d3',
    wis: '1d2',
    cha: '1d1'
  },
  titles: ['Developer'],
  traits: [Traits.Infravision({ level: 3 }), Traits.Telepathy({ level: 10 }), Traits.Clairvoyance({ level: 1, req: 2 }), Traits.Stealth({ level: 8 })],
  skillCaps: { shot: Thresholds.Expert, stab: Thresholds.Skilled },
  startingItems: [{ init: function init() {
      return new Weapons.Bow({ bucName: 'uncursed' });
    } }, { init: function init() {
      return new Projectiles.Arrow({ charges: '1d1', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Heads.NightGoggles({ bucName: 'uncursed' });
    } }, { init: function init() {
      return new Necks.AmuletOfLifeSaving({ bucName: 'uncursed' });
    } }, { init: function init() {
      return new Foods.Ration({ charges: '1d3', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Potions.Healing({ charges: '1d1', bucName: 'uncursed', startIdentified: true });
    } }]
};

var Developer = (function (_Profession) {
  _inherits(Developer, _Profession);

  function Developer() {
    _classCallCheck(this, Developer);

    _get(Object.getPrototypeOf(Developer.prototype), 'constructor', this).call(this, devCfg);
  }

  return Developer;
})(_definitionsProfession2['default']);

exports['default'] = Developer;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../items/heads":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/heads.js","../items/necks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/necks.js","../items/potions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js","../items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/healer.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _items_special = require('../items/_special');

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _itemsPotions = require('../items/potions');

var Potions = _interopRequireWildcard(_itemsPotions);

var _itemsSpellbooks = require('../items/spellbooks');

var Spellbooks = _interopRequireWildcard(_itemsSpellbooks);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsWrists = require('../items/wrists');

var Wrists = _interopRequireWildcard(_itemsWrists);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var healerConfig = {
  hp: '2d5',
  mp: '3d3',
  str: '1d2',
  con: '1d2',
  int: '2d2',
  dex: '1d2',
  wis: '2d3',
  cha: '1d1',
  levelUp: {
    hp: '1d5',
    mp: '2d2',
    str: '1d1',
    con: '1d2',
    int: '1d2',
    dex: '1d2',
    wis: '1d3',
    cha: '1d2 - 1'
  },
  titles: ['Rhizotomist',, 'Empiric',,, 'Embalmer',,, 'Dresser',,, 'Medicus ossium',,, 'Herbalist',,, 'Magisterex',,, 'Physician',,, 'Chirurgeon'],
  traits: [Traits.Warning({ level: 3, req: 15 }), Traits.PoisonResistance()],
  skillCaps: { bash: Thresholds.Expert, stab: Thresholds.Skilled, ranged: Thresholds.Basic, slash: Thresholds.Basic, unarmed: Thresholds.Basic },
  startingItems: [{ init: function init() {
      return new _items_special.Gold((0, _libDiceRoller2['default'])('1d1000 + 1000'));
    } }, { init: function init() {
      return new Weapons.Scalpel({ bucName: 'uncursed' });
    } }, { init: function init() {
      return new Wrists.LeatherGloves({ enchantment: 2, bucName: 'uncursed', startIdentified: true });
    } }, { init: function init() {
      return new Spellbooks.CureSelf({ bucName: 'blessed', startIdentified: true });
    } }, { init: function init() {
      return new Spellbooks.ExtraCureSelf({ bucName: 'blessed', startIdentified: true });
    } }, { init: function init() {
      return new Foods.Apple({ charges: '1d4 + 4', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Potions.Healing({ charges: '4d1', bucName: 'uncursed', startIdentified: true });
    } }, { init: function init() {
      return new Potions.ExtraHealing({ charges: '4d1', bucName: 'uncursed', startIdentified: true });
    } }]
};

var Healer = (function (_Profession) {
  _inherits(Healer, _Profession);

  function Healer() {
    _classCallCheck(this, Healer);

    _get(Object.getPrototypeOf(Healer.prototype), 'constructor', this).call(this, healerConfig);
  }

  return Healer;
})(_definitionsProfession2['default']);

exports['default'] = Healer;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../items/_special":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_special.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../items/potions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js","../items/spellbooks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/spellbooks.js","../items/wrists":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/wrists.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/knight.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _itemsBodys = require('../items/bodys');

var Bodys = _interopRequireWildcard(_itemsBodys);

var _itemsHeads = require('../items/heads');

var Heads = _interopRequireWildcard(_itemsHeads);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsWrists = require('../items/wrists');

var Wrists = _interopRequireWildcard(_itemsWrists);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var knightConfig = {
  hp: '2d7',
  mp: '0d0',
  str: '3d2',
  con: '3d2',
  int: '3d2',
  dex: '3d2',
  wis: '3d2',
  cha: '3d2',
  levelUp: {
    hp: '1d6',
    mp: '0d0',
    str: '1d3',
    con: '1d3',
    int: '1d2',
    dex: '1d3',
    wis: '1d1',
    cha: '1d2 - 1'
  },
  titles: ['Gallant',, 'Esquire',,, 'Bachelor',,, 'Sergeant',,, 'Knight',,, 'Banneret',,, 'Chevalierex',,, 'Seignieur',,, 'Paladin'],
  traits: [Traits.Haste({ level: 2, req: 7 })],
  skillCaps: { bash: Thresholds.Expert, stab: Thresholds.Basic, ranged: Thresholds.Basic, slash: Thresholds.Expert, unarmed: Thresholds.Expert, force: Thresholds.Basic },
  startingItems: [{ init: function init() {
      return new Weapons.Longsword({ bucName: 'uncursed', enchantment: 1 });
    } }, { init: function init() {
      return new Weapons.Spear({ bucName: 'uncursed', enchantment: 1 });
    } }, { init: function init() {
      return new Bodys.RingMail({ bucName: 'uncursed', enchantment: 1 });
    } }, { init: function init() {
      return new Wrists.LeatherGloves({ bucName: 'uncursed', startIdentified: true });
    } }, { init: function init() {
      return new Heads.Helm({ bucName: 'uncursed', startIdentified: true });
    } }, { init: function init() {
      return new Foods.Apple({ charges: '1d10 + 10', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Foods.Carrot({ charges: '1d10 + 10', bucName: 'uncursed' });
    } }]
};

var Knight = (function (_Profession) {
  _inherits(Knight, _Profession);

  function Knight() {
    _classCallCheck(this, Knight);

    _get(Object.getPrototypeOf(Knight.prototype), 'constructor', this).call(this, knightConfig);
  }

  return Knight;
})(_definitionsProfession2['default']);

exports['default'] = Knight;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../items/heads":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/heads.js","../items/wrists":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/wrists.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/monk.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _itemsPotions = require('../items/potions');

var Potions = _interopRequireWildcard(_itemsPotions);

var _itemsBodys = require('../items/bodys');

var Bodys = _interopRequireWildcard(_itemsBodys);

var _itemsWrists = require('../items/wrists');

var Wrists = _interopRequireWildcard(_itemsWrists);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var monkConfig = {
  hp: '2d5',
  mp: '1d7',
  str: '4d2',
  con: '2d2',
  int: '1d2',
  dex: '4d2',
  wis: '1d2',
  cha: '1d1',
  levelUp: {
    hp: '1d4',
    mp: '1d3',
    str: '2d2',
    con: '1d2',
    int: '1d2',
    dex: '2d2',
    wis: '1d1',
    cha: '1d2 - 1'
  },
  titles: ['Candidate',, 'Novice',,, 'Initiate',,, 'Student of Stones',,, 'Student of Waters',,, 'Student of Metals',,, 'Student of Winds',,, 'Student of Fire',,, 'Master'],
  traits: [Traits.PoisonResistance({ req: 3 }), Traits.Stealth({ level: 3, req: 5 }), Traits.Warning({ level: 2, req: 7 }), Traits.Haste({ level: 4, req: 9 }), Traits.FireResistance({ req: 11 }), Traits.IceResistance({ req: 13 }), Traits.ShockResistance({ req: 15 }), Traits.Infravision({ level: 3, req: 17 }), Traits.Protection({ level: 1, req: 19 })],
  skillCaps: { bash: Thresholds.Basic, unarmed: Thresholds.Grandmaster, force: Thresholds.Basic },
  startingItems: [{ init: function init() {
      return new Bodys.Robe({ bucName: 'uncursed', enchantment: 2 });
    } }, { init: function init() {
      return new Wrists.LeatherGloves({ bucName: 'uncursed', enchantment: 2, startIdentified: true });
    } }, { init: function init() {
      return new Potions.Healing({ charges: '1d1', bucName: 'uncursed', startIdentified: true });
    } }, { init: function init() {
      return new Foods.Ration({ charges: '1d3 + 3', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Foods.Apple({ charges: '1d5 + 5', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Foods.Carrot({ charges: '1d5 + 5', bucName: 'uncursed' });
    } }]
};

var Monk = (function (_Profession) {
  _inherits(Monk, _Profession);

  function Monk() {
    _classCallCheck(this, Monk);

    _get(Object.getPrototypeOf(Monk.prototype), 'constructor', this).call(this, monkConfig);
  }

  return Monk;
})(_definitionsProfession2['default']);

exports['default'] = Monk;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../items/potions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js","../items/wrists":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/wrists.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/monster.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var monsterCfg = {
  hp: '1d1',
  str: '1d1',
  con: '1d1',
  int: '1d1',
  dex: '1d1',
  wis: '1d1',
  cha: '1d1',
  levelUp: {
    hp: '2d1',
    str: '2d1',
    con: '2d1',
    int: '2d1',
    dex: '2d1',
    wis: '2d1',
    cha: '2d1'
  },
  titles: ['Monster'],
  traits: [Traits.Infravision({ level: 7 })]
};

var Monster = (function (_Profession) {
  _inherits(Monster, _Profession);

  function Monster() {
    _classCallCheck(this, Monster);

    _get(Object.getPrototypeOf(Monster.prototype), 'constructor', this).call(this, monsterCfg);
  }

  return Monster;
})(_definitionsProfession2['default']);

exports['default'] = Monster;
module.exports = exports['default'];

},{"../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/priest.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _itemsPotions = require('../items/potions');

var Potions = _interopRequireWildcard(_itemsPotions);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsBodys = require('../items/bodys');

var Bodys = _interopRequireWildcard(_itemsBodys);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var priestConfig = {
  hp: '1d5',
  mp: '3d5',
  str: '1d2',
  con: '1d2',
  int: '2d2',
  dex: '1d2',
  wis: '3d2',
  cha: '1d2',
  levelUp: {
    hp: '1d3',
    mp: '1d5',
    str: '1d2 - 1',
    con: '1d1',
    int: '1d2',
    dex: '1d2 - 1',
    wis: '1d2',
    cha: '1d2 - 1'
  },
  titles: ['Aspirant',, 'Acolyte',,, 'Adept',,, 'Priest',,, 'Curate',,, 'Canon',,, 'Lama',,, 'Patriarch',,, 'High Priest'],
  traits: [Traits.Warning({ level: 3, req: 15 }), Traits.FireResistance({ req: 20 })],
  skillCaps: { bash: Thresholds.Expert, unarmed: Thresholds.Basic, stab: Thresholds.Skilled, ranged: Thresholds.Basic, smash: Thresholds.Skilled, thrust: Thresholds.Skilled },
  startingItems: [{ init: function init() {
      return new Weapons.Mace({ bucName: 'uncursed', enchantment: 1 });
    } }, { init: function init() {
      return new Bodys.Robe({ bucName: 'uncursed', enchantment: 1 });
    } }, { init: function init() {
      return new Potions.Healing({ charges: '1d1', bucName: 'uncursed', startIdentified: true });
    } }]
};

var Priest = (function (_Profession) {
  _inherits(Priest, _Profession);

  function Priest() {
    _classCallCheck(this, Priest);

    _get(Object.getPrototypeOf(Priest.prototype), 'constructor', this).call(this, priestConfig);
  }

  return Priest;
})(_definitionsProfession2['default']);

exports['default'] = Priest;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../items/potions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/ranger.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsPotions = require('../items/potions');

var Potions = _interopRequireWildcard(_itemsPotions);

var _itemsProjectiles = require('../items/projectiles');

var Projectiles = _interopRequireWildcard(_itemsProjectiles);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var rangerCfg = {
  hp: '3d4',
  mp: '0d0',
  str: '2d3',
  con: '1d5',
  int: '1d3',
  dex: '2d5',
  wis: '0d0',
  cha: '1d1',
  levelUp: {
    hp: '1d4',
    mp: '0d0',
    str: '1d2',
    con: '1d2',
    int: '1d2',
    dex: '1d4',
    wis: '0d0',
    cha: '1d2 - 1'
  },
  titles: ['Tenderfoot',, 'Lookout',,, 'Trailblazer',,, 'Reconnoiterex',,, 'Scout',,, 'Arbalester',,, 'Archer',,, 'Sharpshooter',,, 'Marksrex'],
  skillCaps: { ranged: Thresholds.Expert, shot: Thresholds.Expert, stab: Thresholds.Skilled },
  startingItems: [{ choices: { less: 5, more: 1 },
    choicesInit: {
      less: function less() {
        return new Projectiles.Arrow({ charges: '1d10 + 5', bucName: 'uncursed' });
      },
      more: function more() {
        return new Projectiles.Arrow({ charges: '2d10 + 10', bucName: 'uncursed' });
      }
    }
  }, { init: function init() {
      return new Weapons.Bow({ bucName: 'uncursed' });
    } }, { init: function init() {
      return new Foods.Ration({ charges: '1d3', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Potions.Healing({ charges: '1d2', bucName: 'uncursed', startIdentified: true });
    } }]
};

var Ranger = (function (_Profession) {
  _inherits(Ranger, _Profession);

  function Ranger() {
    _classCallCheck(this, Ranger);

    _get(Object.getPrototypeOf(Ranger.prototype), 'constructor', this).call(this, rangerCfg);
  }

  return Ranger;
})(_definitionsProfession2['default']);

exports['default'] = Ranger;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../items/potions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js","../items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/rogue.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _itemsBodys = require('../items/bodys');

var Bodys = _interopRequireWildcard(_itemsBodys);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsProjectiles = require('../items/projectiles');

var Projectiles = _interopRequireWildcard(_itemsProjectiles);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var rogueConfig = {
  hp: '2d6',
  mp: '0d0',
  str: '3d3',
  con: '1d4',
  int: '1d2',
  dex: '2d5',
  wis: '1d2',
  cha: '1d2',
  levelUp: {
    hp: '1d4',
    mp: '0d0',
    str: '1d3',
    con: '1d2',
    int: '1d2 - 1',
    dex: '1d3',
    wis: '1d2 - 1',
    cha: '1d2 - 1'
  },
  titles: ['Footpad',, 'Cutpurse',,, 'Rogue',,, 'Pilferer',,, 'Robber',,, 'Burglar',,, 'Filcher',,, 'Magsrex',,, 'Thief'],
  traits: [Traits.Stealth({ level: 4 })],
  skillCaps: { bash: Thresholds.Expert, stab: Thresholds.Basic, ranged: Thresholds.Basic, slash: Thresholds.Expert, unarmed: Thresholds.Expert, force: Thresholds.Basic },
  startingItems: [{ init: function init() {
      return new Weapons.Shortsword({ bucName: 'uncursed', enchantment: 1 });
    } }, { init: function init() {
      return new Projectiles.Stiletto({ charges: '1d10 + 5', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Weapons.Spear({ bucName: 'uncursed', enchantment: 1 });
    } }, { init: function init() {
      return new Bodys.LeatherJacket({ bucName: 'uncursed', enchantment: 1 });
    } }]
};

var Rogue = (function (_Profession) {
  _inherits(Rogue, _Profession);

  function Rogue() {
    _classCallCheck(this, Rogue);

    _get(Object.getPrototypeOf(Rogue.prototype), 'constructor', this).call(this, rogueConfig);
  }

  return Rogue;
})(_definitionsProfession2['default']);

exports['default'] = Rogue;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/tourist.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _libDiceRoller = require('../../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _items_special = require('../items/_special');

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _itemsPotions = require('../items/potions');

var Potions = _interopRequireWildcard(_itemsPotions);

var _itemsProjectiles = require('../items/projectiles');

var Projectiles = _interopRequireWildcard(_itemsProjectiles);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var touristCfg = {
  hp: '1d5',
  mp: '1d2 + 1',
  str: '1d3',
  con: '1d2',
  int: '1d3',
  dex: '1d2',
  wis: '1d2',
  cha: '1d3 + 1',
  luk: '1d3',
  levelUp: {
    hp: '1d5',
    mp: '1d2',
    str: '1d2 - 1',
    con: '1d2',
    int: '1d2 - 1',
    dex: '1d1',
    wis: '1d2 - 1',
    cha: '1d2',
    luk: '1d2 - 1'
  },
  titles: ['Rambler',, 'Sightseer',,, 'Excursionist',,, 'Perigrinator',,, 'Traveler',,, 'Journeyer',,, 'Voyager',,, 'Explorer',,, 'Adventurer'],
  skillCaps: { bash: Thresholds.Competent, slash: Thresholds.Competent, smash: Thresholds.Competent, stab: Thresholds.Competent, thrust: Thresholds.Competent, unarmed: Thresholds.Competent },
  startingItems: [{ init: function init() {
      return new _items_special.Gold((0, _libDiceRoller2['default'])('1d1000'));
    } }, { choices: { less: 5, more: 1 },
    choicesInit: {
      less: function less() {
        return new Projectiles.Dart({ charges: '1d5 + 5', bucName: 'uncursed' });
      },
      more: function more() {
        return new Projectiles.Dart({ charges: '5d10 + 10', bucName: 'uncursed' });
      }
    }
  }, { init: function init() {
      return new Foods.Ration({ charges: '1d5 + 5', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Potions.Healing({ charges: '1d3 + 1', bucName: 'blessed', startIdentified: true });
    } }]
};

var Tourist = (function (_Profession) {
  _inherits(Tourist, _Profession);

  function Tourist() {
    _classCallCheck(this, Tourist);

    _get(Object.getPrototypeOf(Tourist.prototype), 'constructor', this).call(this, touristCfg);
  }

  return Tourist;
})(_definitionsProfession2['default']);

exports['default'] = Tourist;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../items/_special":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_special.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../items/potions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js","../items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/valkyrie.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var valkyrieConfig = {
  hp: '2d5',
  mp: '0d0',
  str: '2d3',
  con: '1d5',
  int: '1d3',
  dex: '3d2',
  wis: '1d2',
  cha: '1d2',
  levelUp: {
    hp: '1d4',
    mp: '0d0',
    str: '1d2',
    con: '1d2',
    int: '1d2 - 1',
    dex: '1d2',
    wis: '1d1',
    cha: '1d2 - 1'
  },
  titles: ['Stripling',, 'Skirmisher',,, 'Fighter',,, 'Man-at-arms',,, 'Warrior',,, 'Swashbuckler',,, 'Hero',,, 'Champion',,, 'Lord'],
  traits: [Traits.IceResistance(), Traits.Stealth({ level: 2 }), Traits.Haste({ level: 3, req: 7 })],
  skillCaps: { bash: Thresholds.Expert, stab: Thresholds.Skilled, ranged: Thresholds.Expert, smash: Thresholds.Expert, thrust: Thresholds.Expert, slash: Thresholds.Expert, unarmed: Thresholds.Expert },
  startingItems: [{ init: function init() {
      return new Weapons.Spear({ bucName: 'uncursed', enchantment: 3 });
    } }, { init: function init() {
      return new Weapons.Dagger({ bucName: 'uncursed', enchantment: 1 });
    } }, { init: function init() {
      return new Foods.Ration({ charges: '1d3', bucName: 'uncursed' });
    } }]
};

var Valkyrie = (function (_Profession) {
  _inherits(Valkyrie, _Profession);

  function Valkyrie() {
    _classCallCheck(this, Valkyrie);

    _get(Object.getPrototypeOf(Valkyrie.prototype), 'constructor', this).call(this, valkyrieConfig);
  }

  return Valkyrie;
})(_definitionsProfession2['default']);

exports['default'] = Valkyrie;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/wizard.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsProfession = require('../../definitions/profession');

var _definitionsProfession2 = _interopRequireDefault(_definitionsProfession);

var _constantsFactions = require('../../constants/factions');

var _constantsFactions2 = _interopRequireDefault(_constantsFactions);

var _itemsFoods = require('../items/foods');

var Foods = _interopRequireWildcard(_itemsFoods);

var _items_weapons = require('../items/_weapons');

var Weapons = _interopRequireWildcard(_items_weapons);

var _itemsPotions = require('../items/potions');

var Potions = _interopRequireWildcard(_itemsPotions);

var _itemsSpellbooks = require('../items/spellbooks');

var Spellbooks = _interopRequireWildcard(_itemsSpellbooks);

var _constantsRandom = require('../../constants/random');

var Random = _interopRequireWildcard(_constantsRandom);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var wizardCfg = {
  hp: '1d2 + 1',
  mp: '1d5 + 5',
  str: '1d2',
  con: '1d2',
  int: '2d3 + 1',
  dex: '1d2 - 1',
  wis: '1d2',
  cha: '1d3 - 1',
  levelUp: {
    hp: '1d2 - 1',
    mp: '1d4 + 1',
    str: '1d2 - 1',
    con: '1d2 - 1',
    int: '1d2',
    dex: '1d2 - 1',
    wis: '1d1',
    cha: '1d2 - 1'
  },
  regenHp: 20,
  regenMp: -3,
  titles: ['Evoker',, 'Conjurer',,, 'Thaumaturge',,, 'Magician',,, 'Enchantrex',,, 'Sorcerex',,, 'Necromancer',,, 'Wizard',,, 'Mage'],
  skillCaps: { bash: Thresholds.Skilled, stab: Thresholds.Skilled, force: Thresholds.Expert },
  addFactions: [_constantsFactions2['default'].MAGIC],
  startingItems: [{ init: function init() {
      return Random.Ring({ bucName: 'uncursed' });
    } }, { init: function init() {
      return Random.Wand({ bucName: 'uncursed' });
    } }, { init: function init() {
      return new Spellbooks.ForceBolt({ bucName: 'blessed' });
    } }, { init: function init() {
      return new Weapons.Quarterstaff({ bucName: 'uncursed' });
    } }, { init: function init() {
      return new Foods.Ration({ charges: '1d2', bucName: 'uncursed' });
    } }, { init: function init() {
      return new Potions.Healing({ charges: '1d2', bucName: 'uncursed' });
    } }]
};

var Wizard = (function (_Profession) {
  _inherits(Wizard, _Profession);

  function Wizard() {
    _classCallCheck(this, Wizard);

    _get(Object.getPrototypeOf(Wizard.prototype), 'constructor', this).call(this, wizardCfg);
  }

  return Wizard;
})(_definitionsProfession2['default']);

exports['default'] = Wizard;
module.exports = exports['default'];

},{"../../constants/factions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/factions.js","../../constants/random":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/random.js","../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../../definitions/profession":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js","../items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../items/potions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js","../items/spellbooks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/spellbooks.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_all.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _canine = require('./canine');

var _canine2 = _interopRequireDefault(_canine);

var _demon = require('./demon');

var _demon2 = _interopRequireDefault(_demon);

var _elemental = require('./elemental');

var _elemental2 = _interopRequireDefault(_elemental);

var _elf = require('./elf');

var _elf2 = _interopRequireDefault(_elf);

var _gnome = require('./gnome');

var _gnome2 = _interopRequireDefault(_gnome);

var _human = require('./human');

var _human2 = _interopRequireDefault(_human);

var _insect = require('./insect');

var _insect2 = _interopRequireDefault(_insect);

var _jelly = require('./jelly');

var _jelly2 = _interopRequireDefault(_jelly);

var _kobold = require('./kobold');

var _kobold2 = _interopRequireDefault(_kobold);

var _manticore = require('./manticore');

var _manticore2 = _interopRequireDefault(_manticore);

var _orc = require('./orc');

var _orc2 = _interopRequireDefault(_orc);

var _psionic = require('./psionic');

var _psionic2 = _interopRequireDefault(_psionic);

var _pudding = require('./pudding');

var _pudding2 = _interopRequireDefault(_pudding);

var _rat = require('./rat');

var _rat2 = _interopRequireDefault(_rat);

var _lizard = require('./lizard');

var _lizard2 = _interopRequireDefault(_lizard);

var _lizardman = require('./lizardman');

var _lizardman2 = _interopRequireDefault(_lizardman);

var _snake = require('./snake');

var _snake2 = _interopRequireDefault(_snake);

var _spider = require('./spider');

var _spider2 = _interopRequireDefault(_spider);

var _spore = require('./spore');

var _spore2 = _interopRequireDefault(_spore);

exports['default'] = { Canine: _canine2['default'], Demon: _demon2['default'], Elemental: _elemental2['default'], Elf: _elf2['default'], Gnome: _gnome2['default'],
  Human: _human2['default'], Insect: _insect2['default'], Jelly: _jelly2['default'], Kobold: _kobold2['default'], Lizard: _lizard2['default'], Lizardman: _lizardman2['default'], Manticore: _manticore2['default'], Orc: _orc2['default'], Pudding: _pudding2['default'], Psionic: _psionic2['default'], Rat: _rat2['default'],
  Snake: _snake2['default'], Spider: _spider2['default'], Spore: _spore2['default'] };
module.exports = exports['default'];

},{"./canine":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/canine.js","./demon":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/demon.js","./elemental":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/elemental.js","./elf":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/elf.js","./gnome":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/gnome.js","./human":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/human.js","./insect":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/insect.js","./jelly":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/jelly.js","./kobold":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/kobold.js","./lizard":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/lizard.js","./lizardman":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/lizardman.js","./manticore":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/manticore.js","./orc":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/orc.js","./psionic":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/psionic.js","./pudding":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/pudding.js","./rat":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/rat.js","./snake":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/snake.js","./spider":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/spider.js","./spore":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/spore.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_humanoid.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var _behaviors_all = require('../behaviors/_all');

var Behaviors = _interopRequireWildcard(_behaviors_all);

var Humanoid = (function (_Race) {
  _inherits(Humanoid, _Race);

  function Humanoid(opts) {
    _classCallCheck(this, Humanoid);

    opts.stats = opts.stats || {};
    opts.stats.addBehaviors = [Behaviors.Interacts(), Behaviors.PickUpItems(), Behaviors.DropsItems()];
    _get(Object.getPrototypeOf(Humanoid.prototype), 'constructor', this).call(this, opts);
  }

  return Humanoid;
})(_definitionsRace2['default']);

exports['default'] = Humanoid;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js","../behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/canine.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = { stats: { dex: 2, str: 2, con: 1, int: -1, wis: -1 } };

var Canine = (function (_Race) {
  _inherits(Canine, _Race);

  function Canine() {
    _classCallCheck(this, Canine);

    _get(Object.getPrototypeOf(Canine.prototype), 'constructor', this).call(this, opts);
  }

  return Canine;
})(_definitionsRace2['default']);

exports['default'] = Canine;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/demon.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _humanoid = require('./_humanoid');

var _humanoid2 = _interopRequireDefault(_humanoid);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var _attacks_all = require('../attacks/_all');

var Attacks = _interopRequireWildcard(_attacks_all);

var attackProps = {
  roll: '1d3',
  spawnChance: 1,
  spawn: {
    waterDemon: 100
  }
};

var opts = { stats: {
    str: -2, con: -2, dex: -2, int: -2, wis: -2, cha: -2, luk: -2,
    traits: [Traits.PoisonResistance(), Traits.Infravision({ level: 10 }), Traits.Protection({ level: 1 })],
    attacks: [Attacks.Unarmed(attackProps), Attacks.Bite(attackProps), Attacks.Claw(attackProps)]
  } };

var Demon = (function (_Humanoid) {
  _inherits(Demon, _Humanoid);

  function Demon() {
    _classCallCheck(this, Demon);

    _get(Object.getPrototypeOf(Demon.prototype), 'constructor', this).call(this, opts);
  }

  return Demon;
})(_humanoid2['default']);

exports['default'] = Demon;
module.exports = exports['default'];

},{"../attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js","./_humanoid":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_humanoid.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/elemental.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = {};

var Elemental = (function (_Race) {
  _inherits(Elemental, _Race);

  function Elemental() {
    _classCallCheck(this, Elemental);

    _get(Object.getPrototypeOf(Elemental.prototype), 'constructor', this).call(this, opts);
  }

  return Elemental;
})(_definitionsRace2['default']);

exports['default'] = Elemental;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/elf.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _humanoid = require('./_humanoid');

var _humanoid2 = _interopRequireDefault(_humanoid);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var opts = { stats: { int: 2, dex: 2, wis: 1, sight: 1,
    skillBonus: { shot: Thresholds.Basic, stab: Thresholds.Basic },
    traits: [Traits.Infravision({ level: 3 })]
  } };

var Elf = (function (_Humanoid) {
  _inherits(Elf, _Humanoid);

  function Elf() {
    _classCallCheck(this, Elf);

    _get(Object.getPrototypeOf(Elf.prototype), 'constructor', this).call(this, opts);
  }

  return Elf;
})(_humanoid2['default']);

exports['default'] = Elf;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js","./_humanoid":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_humanoid.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/gnome.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _humanoid = require('./_humanoid');

var _humanoid2 = _interopRequireDefault(_humanoid);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var opts = { stats: { str: -2, con: -2, dex: -1, int: 3, wis: 3, cha: -1, sight: 1,
    skillBonus: { bash: Thresholds.Basic, smash: Thresholds.Basic },
    traits: [Traits.Infravision({ level: 2 })]
  } };

var Gnome = (function (_Humanoid) {
  _inherits(Gnome, _Humanoid);

  function Gnome() {
    _classCallCheck(this, Gnome);

    _get(Object.getPrototypeOf(Gnome.prototype), 'constructor', this).call(this, opts);
  }

  return Gnome;
})(_humanoid2['default']);

exports['default'] = Gnome;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js","./_humanoid":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_humanoid.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/human.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _humanoid = require('./_humanoid');

var _humanoid2 = _interopRequireDefault(_humanoid);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var opts = { stats: { str: 1, con: 1, dex: 1, int: 1, wis: 1, cha: 1, luk: 1, sight: -1,
    skillBonus: { basic: Thresholds.Basic, slash: Thresholds.Basic, smash: Thresholds.Basic, stab: Thresholds.Basic, thrust: Thresholds.Basic, unarmed: Thresholds.Basic }
  } };

var Human = (function (_Humanoid) {
  _inherits(Human, _Humanoid);

  function Human() {
    _classCallCheck(this, Human);

    _get(Object.getPrototypeOf(Human.prototype), 'constructor', this).call(this, opts);
  }

  return Human;
})(_humanoid2['default']);

exports['default'] = Human;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","./_humanoid":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_humanoid.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/insect.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = { stats: { dex: -2, str: -2, con: -2 } };

var Insect = (function (_Race) {
  _inherits(Insect, _Race);

  function Insect() {
    _classCallCheck(this, Insect);

    _get(Object.getPrototypeOf(Insect.prototype), 'constructor', this).call(this, opts);
  }

  return Insect;
})(_definitionsRace2['default']);

exports['default'] = Insect;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/jelly.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = {};

var Jelly = (function (_Race) {
  _inherits(Jelly, _Race);

  function Jelly() {
    _classCallCheck(this, Jelly);

    _get(Object.getPrototypeOf(Jelly.prototype), 'constructor', this).call(this, opts);
  }

  return Jelly;
})(_definitionsRace2['default']);

exports['default'] = Jelly;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/kobold.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _humanoid = require('./_humanoid');

var _humanoid2 = _interopRequireDefault(_humanoid);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var opts = { stats: { dex: 1, str: 1, con: 1, int: -4, wis: -2, sight: 1,
    skillBonus: { smash: Thresholds.Basic, stab: Thresholds.Basic, thrust: Thresholds.Basic },
    traits: [Traits.Infravision({ level: 2 })]
  } };

var Kobold = (function (_Humanoid) {
  _inherits(Kobold, _Humanoid);

  function Kobold() {
    _classCallCheck(this, Kobold);

    _get(Object.getPrototypeOf(Kobold.prototype), 'constructor', this).call(this, opts);
  }

  return Kobold;
})(_humanoid2['default']);

exports['default'] = Kobold;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js","./_humanoid":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_humanoid.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/lizard.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = { slots: { hands: 0, body: 1, feet: 4, heads: 1, neck: 0, ring: 0, cloak: 0, wrist: 0 }, stats: { con: 1, int: 1 } };

var Lizard = (function (_Race) {
  _inherits(Lizard, _Race);

  function Lizard() {
    _classCallCheck(this, Lizard);

    _get(Object.getPrototypeOf(Lizard.prototype), 'constructor', this).call(this, opts);
  }

  return Lizard;
})(_definitionsRace2['default']);

exports['default'] = Lizard;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/lizardman.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _humanoid = require('./_humanoid');

var _humanoid2 = _interopRequireDefault(_humanoid);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var opts = { slots: { hands: 3 }, stats: { dex: 2,
    skillBonus: { slash: Thresholds.Basic, stab: Thresholds.Basic, thrust: Thresholds.Basic }
  } };

var Lizardman = (function (_Humanoid) {
  _inherits(Lizardman, _Humanoid);

  function Lizardman() {
    _classCallCheck(this, Lizardman);

    _get(Object.getPrototypeOf(Lizardman.prototype), 'constructor', this).call(this, opts);
  }

  return Lizardman;
})(_humanoid2['default']);

exports['default'] = Lizardman;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","./_humanoid":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_humanoid.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/manticore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = { slots: { hands: 0, body: 3, feet: 0, head: 3, neck: 3, ring: 0, cloak: 0, wrist: 0 } };

var Manticore = (function (_Race) {
  _inherits(Manticore, _Race);

  function Manticore() {
    _classCallCheck(this, Manticore);

    _get(Object.getPrototypeOf(Manticore.prototype), 'constructor', this).call(this, opts);
  }

  return Manticore;
})(_definitionsRace2['default']);

exports['default'] = Manticore;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/orc.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _humanoid = require('./_humanoid');

var _humanoid2 = _interopRequireDefault(_humanoid);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _traits_all = require('../traits/_all');

var Traits = _interopRequireWildcard(_traits_all);

var opts = { stats: { dex: -1, str: 3, con: 3, int: -3, wis: -2, sight: 1,
    skillBonus: { smash: Thresholds.Competent, unarmed: Thresholds.Basic },
    traits: [Traits.Infravision({ level: 2 })]
  } };

var Orc = (function (_Humanoid) {
  _inherits(Orc, _Humanoid);

  function Orc() {
    _classCallCheck(this, Orc);

    _get(Object.getPrototypeOf(Orc.prototype), 'constructor', this).call(this, opts);
  }

  return Orc;
})(_humanoid2['default']);

exports['default'] = Orc;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js","./_humanoid":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_humanoid.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/psionic.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _humanoid = require('./_humanoid');

var _humanoid2 = _interopRequireDefault(_humanoid);

var _constantsSkillThresholds = require('../../constants/skill-thresholds');

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var opts = { stats: { dex: -5, str: -5, con: -3, int: 5, wis: 5 },
  skillBonus: { force: Thresholds.Competent }
};

var Psionic = (function (_Humanoid) {
  _inherits(Psionic, _Humanoid);

  function Psionic() {
    _classCallCheck(this, Psionic);

    _get(Object.getPrototypeOf(Psionic.prototype), 'constructor', this).call(this, opts);
  }

  _createClass(Psionic, [{
    key: 'canEquip',
    value: function canEquip(owner, item) {
      return item && !_lodash2['default'].contains(['weapon', 'hands'], item.getParentType()) && _get(Object.getPrototypeOf(Psionic.prototype), 'canEquip', this).call(this, owner, item);
    }
  }]);

  return Psionic;
})(_humanoid2['default']);

exports['default'] = Psionic;
module.exports = exports['default'];

},{"../../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","./_humanoid":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_humanoid.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/pudding.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = { stats: { con: 5, int: -5, wis: -5, dex: -5, str: -1, sight: -1 } };

var Pudding = (function (_Race) {
  _inherits(Pudding, _Race);

  function Pudding() {
    _classCallCheck(this, Pudding);

    _get(Object.getPrototypeOf(Pudding.prototype), 'constructor', this).call(this, opts);
  }

  return Pudding;
})(_definitionsRace2['default']);

exports['default'] = Pudding;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/rat.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = { stats: { con: -3, int: -3, wis: -3, dex: -3, str: -3, cha: -3, luk: -3, sight: -1 } };

var Rat = (function (_Race) {
  _inherits(Rat, _Race);

  function Rat() {
    _classCallCheck(this, Rat);

    _get(Object.getPrototypeOf(Rat.prototype), 'constructor', this).call(this, opts);
  }

  return Rat;
})(_definitionsRace2['default']);

exports['default'] = Rat;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/snake.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = { slots: { hands: 0, body: 1, feet: 0, heads: 1, neck: 1, ring: 1, cloak: 0, wrist: 0 } };

var Snake = (function (_Race) {
  _inherits(Snake, _Race);

  function Snake() {
    _classCallCheck(this, Snake);

    _get(Object.getPrototypeOf(Snake.prototype), 'constructor', this).call(this, opts);
  }

  return Snake;
})(_definitionsRace2['default']);

exports['default'] = Snake;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/spider.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = { slots: { hands: 0, body: 1, feet: 8, heads: 1, neck: 1, ring: 0, cloak: 0, wrist: 0 } };

var Spider = (function (_Race) {
  _inherits(Spider, _Race);

  function Spider() {
    _classCallCheck(this, Spider);

    _get(Object.getPrototypeOf(Spider.prototype), 'constructor', this).call(this, opts);
  }

  return Spider;
})(_definitionsRace2['default']);

exports['default'] = Spider;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/spore.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsRace = require('../../definitions/race');

var _definitionsRace2 = _interopRequireDefault(_definitionsRace);

var opts = {};

var Spore = (function (_Race) {
  _inherits(Spore, _Race);

  function Spore() {
    _classCallCheck(this, Spore);

    _get(Object.getPrototypeOf(Spore.prototype), 'constructor', this).call(this, opts);
  }

  return Spore;
})(_definitionsRace2['default']);

exports['default'] = Spore;
module.exports = exports['default'];

},{"../../definitions/race":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsTrait = require('../../definitions/trait');

var _definitionsTrait2 = _interopRequireDefault(_definitionsTrait);

var InfravisionTrait = (function (_Trait) {
  _inherits(InfravisionTrait, _Trait);

  function InfravisionTrait() {
    _classCallCheck(this, InfravisionTrait);

    _get(Object.getPrototypeOf(InfravisionTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(InfravisionTrait, [{
    key: 'Infravision',
    value: function Infravision() {
      return this.level;
    }
  }]);

  return InfravisionTrait;
})(_definitionsTrait2['default']);

var Infravision = function Infravision(opts) {
  return new InfravisionTrait(opts);
};

exports.Infravision = Infravision;

var ProtectionTrait = (function (_Trait2) {
  _inherits(ProtectionTrait, _Trait2);

  function ProtectionTrait() {
    _classCallCheck(this, ProtectionTrait);

    _get(Object.getPrototypeOf(ProtectionTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ProtectionTrait, [{
    key: 'Protection',
    value: function Protection() {
      return this.level;
    }
  }]);

  return ProtectionTrait;
})(_definitionsTrait2['default']);

var Protection = function Protection(opts) {
  return new ProtectionTrait(opts);
};

exports.Protection = Protection;

var HasteTrait = (function (_Trait3) {
  _inherits(HasteTrait, _Trait3);

  function HasteTrait() {
    _classCallCheck(this, HasteTrait);

    _get(Object.getPrototypeOf(HasteTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(HasteTrait, [{
    key: 'Haste',
    value: function Haste() {
      return this.level * 25;
    }
  }]);

  return HasteTrait;
})(_definitionsTrait2['default']);

var Haste = function Haste(opts) {
  return new HasteTrait(opts);
};

exports.Haste = Haste;

var TelepathyTrait = (function (_Trait4) {
  _inherits(TelepathyTrait, _Trait4);

  function TelepathyTrait() {
    _classCallCheck(this, TelepathyTrait);

    _get(Object.getPrototypeOf(TelepathyTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(TelepathyTrait, [{
    key: 'Telepathy',
    value: function Telepathy() {
      return this.level * 5;
    }
  }]);

  return TelepathyTrait;
})(_definitionsTrait2['default']);

var Telepathy = function Telepathy(opts) {
  return new TelepathyTrait(opts);
};

exports.Telepathy = Telepathy;

var ClairvoyanceTrait = (function (_Trait5) {
  _inherits(ClairvoyanceTrait, _Trait5);

  function ClairvoyanceTrait() {
    _classCallCheck(this, ClairvoyanceTrait);

    _get(Object.getPrototypeOf(ClairvoyanceTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ClairvoyanceTrait, [{
    key: 'Clairvoyance',
    value: function Clairvoyance() {
      return this.level * 5;
    }
  }]);

  return ClairvoyanceTrait;
})(_definitionsTrait2['default']);

var Clairvoyance = function Clairvoyance(opts) {
  return new ClairvoyanceTrait(opts);
};

exports.Clairvoyance = Clairvoyance;

var WarningTrait = (function (_Trait6) {
  _inherits(WarningTrait, _Trait6);

  function WarningTrait() {
    _classCallCheck(this, WarningTrait);

    _get(Object.getPrototypeOf(WarningTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(WarningTrait, [{
    key: 'Warning',
    value: function Warning() {
      return this.level * 5;
    }
  }]);

  return WarningTrait;
})(_definitionsTrait2['default']);

var Warning = function Warning(opts) {
  return new WarningTrait(opts);
};

exports.Warning = Warning;

var InvisibleTrait = (function (_Trait7) {
  _inherits(InvisibleTrait, _Trait7);

  function InvisibleTrait() {
    _classCallCheck(this, InvisibleTrait);

    _get(Object.getPrototypeOf(InvisibleTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(InvisibleTrait, [{
    key: 'Invisible',
    value: function Invisible() {
      return this.level;
    }
  }]);

  return InvisibleTrait;
})(_definitionsTrait2['default']);

var Invisible = function Invisible(opts) {
  return new InvisibleTrait(opts);
};

exports.Invisible = Invisible;

var SeeInvisibleTrait = (function (_Trait8) {
  _inherits(SeeInvisibleTrait, _Trait8);

  function SeeInvisibleTrait() {
    _classCallCheck(this, SeeInvisibleTrait);

    _get(Object.getPrototypeOf(SeeInvisibleTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SeeInvisibleTrait, [{
    key: 'SeeInvisible',
    value: function SeeInvisible() {
      return this.level;
    }
  }]);

  return SeeInvisibleTrait;
})(_definitionsTrait2['default']);

var SeeInvisible = function SeeInvisible(opts) {
  return new SeeInvisibleTrait(opts);
};

exports.SeeInvisible = SeeInvisible;

var StealthTrait = (function (_Trait9) {
  _inherits(StealthTrait, _Trait9);

  function StealthTrait() {
    _classCallCheck(this, StealthTrait);

    _get(Object.getPrototypeOf(StealthTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(StealthTrait, [{
    key: 'Stealth',
    value: function Stealth() {
      return this.level * 5;
    }
  }]);

  return StealthTrait;
})(_definitionsTrait2['default']);

var Stealth = function Stealth(opts) {
  return new StealthTrait(opts);
};

exports.Stealth = Stealth;

var PoisonResistanceTrait = (function (_Trait10) {
  _inherits(PoisonResistanceTrait, _Trait10);

  function PoisonResistanceTrait() {
    _classCallCheck(this, PoisonResistanceTrait);

    _get(Object.getPrototypeOf(PoisonResistanceTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(PoisonResistanceTrait, [{
    key: 'PoisonResistance',
    value: function PoisonResistance() {
      return 1;
    }
  }]);

  return PoisonResistanceTrait;
})(_definitionsTrait2['default']);

var PoisonResistance = function PoisonResistance() {
  return new PoisonResistanceTrait();
};

exports.PoisonResistance = PoisonResistance;

var FireResistanceTrait = (function (_Trait11) {
  _inherits(FireResistanceTrait, _Trait11);

  function FireResistanceTrait() {
    _classCallCheck(this, FireResistanceTrait);

    _get(Object.getPrototypeOf(FireResistanceTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(FireResistanceTrait, [{
    key: 'FireResistance',
    value: function FireResistance() {
      return 1;
    }
  }]);

  return FireResistanceTrait;
})(_definitionsTrait2['default']);

var FireResistance = function FireResistance() {
  return new FireResistanceTrait();
};

exports.FireResistance = FireResistance;

var ShockResistanceTrait = (function (_Trait12) {
  _inherits(ShockResistanceTrait, _Trait12);

  function ShockResistanceTrait() {
    _classCallCheck(this, ShockResistanceTrait);

    _get(Object.getPrototypeOf(ShockResistanceTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(ShockResistanceTrait, [{
    key: 'ShockResistance',
    value: function ShockResistance() {
      return 1;
    }
  }]);

  return ShockResistanceTrait;
})(_definitionsTrait2['default']);

var ShockResistance = function ShockResistance() {
  return new ShockResistanceTrait();
};

exports.ShockResistance = ShockResistance;

var IceResistanceTrait = (function (_Trait13) {
  _inherits(IceResistanceTrait, _Trait13);

  function IceResistanceTrait() {
    _classCallCheck(this, IceResistanceTrait);

    _get(Object.getPrototypeOf(IceResistanceTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(IceResistanceTrait, [{
    key: 'IceResistance',
    value: function IceResistance() {
      return 1;
    }
  }]);

  return IceResistanceTrait;
})(_definitionsTrait2['default']);

var IceResistance = function IceResistance() {
  return new IceResistanceTrait();
};

exports.IceResistance = IceResistance;

var AcidResistanceTrait = (function (_Trait14) {
  _inherits(AcidResistanceTrait, _Trait14);

  function AcidResistanceTrait() {
    _classCallCheck(this, AcidResistanceTrait);

    _get(Object.getPrototypeOf(AcidResistanceTrait.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AcidResistanceTrait, [{
    key: 'AcidResistance',
    value: function AcidResistance() {
      return 1;
    }
  }]);

  return AcidResistanceTrait;
})(_definitionsTrait2['default']);

var AcidResistance = function AcidResistance() {
  return new AcidResistanceTrait();
};
exports.AcidResistance = AcidResistance;

},{"../../definitions/trait":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/trait.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/abstract.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var Abstract = (function () {
  function Abstract() {
    _classCallCheck(this, Abstract);
  }

  _createClass(Abstract, [{
    key: 'distBetween',
    value: function distBetween(target) {
      var a = target.x - this.x;
      var b = target.y - this.y;
      return Math.sqrt(a * a + b * b);
    }
  }, {
    key: 'distBetweenXY',
    value: function distBetweenXY(x, y) {
      return this.distBetween({ x: x, y: y });
    }
  }, {
    key: 'getCanonName',
    value: function getCanonName() {
      return _lodash2['default'].startCase(this.constructor.name).toLowerCase();
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.constructor.name.toLowerCase();
    }
  }, {
    key: 'getParentType',
    value: function getParentType() {
      return Object.getPrototypeOf(Object.getPrototypeOf(this)).constructor.name.toLowerCase();
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {}
  }]);

  return Abstract;
})();

exports['default'] = Abstract;
module.exports = exports['default'];

},{"lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/attack.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _diceJs = require('dice.js');

var _diceJs2 = _interopRequireDefault(_diceJs);

var _libDiceRoller = require('../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _displayMessageHandler = require('../display/message-handler');

var _displayMessageHandler2 = _interopRequireDefault(_displayMessageHandler);

var _abstract = require('./abstract');

var _abstract2 = _interopRequireDefault(_abstract);

var _glyph = require('./glyph');

var _glyph2 = _interopRequireDefault(_glyph);

var _libLogger = require('../lib/logger');

var _libLogger2 = _interopRequireDefault(_libLogger);

var _libRotExtensions = require('../lib/rot-extensions');

var _worldgenMonsterSpawner = require('../worldgen/monster-spawner');

var _worldgenMonsterSpawner2 = _interopRequireDefault(_worldgenMonsterSpawner);

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var Projectile = function Projectile(glyph) {
  _classCallCheck(this, Projectile);

  this.glyph = glyph;
};

exports.Projectile = Projectile;

var Attack = (function (_Abstract) {
  _inherits(Attack, _Abstract);

  function Attack(opts) {
    _classCallCheck(this, Attack);

    _get(Object.getPrototypeOf(Attack.prototype), 'constructor', this).call(this);
    _lodash2['default'].extend(this, { roll: '1d4', toHit: '0d0', range: 1, chance: 100 }, opts);
    if (this.init) this.init();
  }

  _createClass(Attack, [{
    key: 'value',
    value: function value() {
      return _diceJs2['default'].statistics(this.roll).mean + _diceJs2['default'].statistics(this.toHit) + this.range * 3;
    }
  }, {
    key: 'inRange',
    value: function inRange(owner, target) {
      return owner.distBetween(target) <= this.range;
    }
  }, {
    key: 'possibleTargets',
    value: function possibleTargets(owner) {
      var possibleTargets = [];
      _initGamestate2['default'].world.fov[owner.z].compute(owner.x, owner.y, this.range, function (x, y) {
        var entity = _initGamestate2['default'].world.getEntity(x, y, owner.z);
        if (!entity) return;
        // no target, can't attack target, or the target is invisible and hasn't attacked you yet
        var canOwnerSee = owner.canSee(entity);
        var sightCheck = canOwnerSee || !canOwnerSee && owner._attackedBy !== entity;
        if (!owner.canAttack(entity) || !sightCheck) return;
        possibleTargets.push(entity);
      });
      return possibleTargets;
    }
  }, {
    key: 'canUse',
    value: function canUse(owner) {
      if (_rotJs2['default'].RNG.getPercentage() > this.chance) return;
      return this.possibleTargets(owner).length > 0;
    }
  }, {
    key: 'canHit',
    value: function canHit(owner, target, attackNum) {
      if (owner.hp.atMin()) return false;
      var hitRoll = (0, _libDiceRoller2['default'])('1d' + (20 + attackNum)); // subsequent attacks are less likely to hit
      var targetAC = target.getAC();
      var myToHitBonus = (0, _libDiceRoller2['default'])(this.toHit) - owner.getToHit(target) - owner.getSkillLevelValue(this.getType()) - (this._itemRef ? this._itemRef.buc - 1 : 0); // cursed: -2, uncursed: 0, blessed: +1
      var targetACRoll = 0;

      if (targetAC >= 0) {
        targetACRoll = targetAC + owner.level - myToHitBonus;
      } else {
        targetACRoll = _constantsSettings2['default'].game.baseAC + _rotJs2['default'].RNG.getUniformInt(targetAC, -1) + owner.level - myToHitBonus;
      }
      return hitRoll < targetACRoll;
    }
  }, {
    key: 'animate',
    value: function animate(owner, target, callback) {
      if (!this.glyph) return callback();

      var engine = _initGamestate2['default'].game.engine;
      engine.lock();

      var canPass = function canPass(x, y) {
        var entity = _initGamestate2['default'].world.getEntity(x, y, owner.z);
        var isAttackable = entity && owner.canAttack(entity);
        var isMe = owner.x === x && owner.y === y;
        return _initGamestate2['default'].world.isTilePassable(x, y, owner.z, false) || isMe || isAttackable;
      };
      var astar = new _rotJs2['default'].Path.AStar(target.x, target.y, canPass, { topology: 8 });

      var path = [];
      var pathCallback = function pathCallback(x, y) {
        path.push({ x: x, y: y });
      };

      astar.compute(owner.x, owner.y, pathCallback);

      path.shift();

      if (!path.length) path = [{ x: owner.x, y: owner.y }];

      var projectile = new Projectile(this.glyph);

      projectile.z = owner.z;
      projectile.x = path[0].x;
      projectile.y = path[0].y;

      _initGamestate2['default'].projectiles.push(projectile);

      var moveTo = function moveTo(x, y) {
        projectile.x = x;
        projectile.y = y;
        _initGamestate2['default'].game.refresh();
      };

      var finalize = function finalize() {
        _initGamestate2['default'].projectiles = _lodash2['default'].without(_initGamestate2['default'].projectiles, projectile);
        _initGamestate2['default'].game.refresh();
        callback(); // this has to be called first to prevent race conditions with unlocking the engine and double-dying
        engine.unlock();
      };

      moveTo(projectile.x, projectile.y);

      _lodash2['default'].each(path, function (step, i) {
        var curStep = step;
        setTimeout(function () {
          moveTo(curStep.x, curStep.y);
          if (i === path.length - 1) finalize();
        }, i * (_constantsSettings2['default'].game.turnDelay / 5));
      });
    }
  }, {
    key: 'use',
    value: function use(owner, target, attackNum) {
      target._attackedBy = owner;
      this.tryHit(owner, target, attackNum);
    }
  }, {
    key: 'tryHit',
    value: function tryHit(owner, target, attackNum) {
      var _this = this;

      if (!target) return;
      if (this._itemRef) this._itemRef.use(owner);
      if (!this.canHit(owner, target, attackNum)) {
        var extra = this.missCallback(owner, target);
        _displayMessageHandler2['default'].add({ message: this.missString(owner, target, extra), type: _displayMessageHandler.MessageTypes.COMBAT });
        return false;
      }
      this.animate(owner, target, function () {
        return _this.hit(owner, target);
      });
    }
  }, {
    key: 'calcDamage',
    value: function calcDamage(owner, target) {

      // you can resist some elemental damage!
      if (this.element && target.hasTrait(this.element + 'Resistance')) {
        return 0;
      }

      var damageBoost = 0;
      if (this._itemRef) {
        damageBoost += this._itemRef.enchantment;
        if (this._itemRef._tempAttackBoost) damageBoost += (0, _libDiceRoller2['default'])(this._itemRef._tempAttackBoost);
      }
      var val = (0, _libDiceRoller2['default'])(this.roll) + owner.calcStatBonus('str') + damageBoost + owner.getBonusDamage(target);

      if (!_lodash2['default'].isNumber(val)) {
        (0, _libLogger2['default'])('Attack', 'Invalid attack roll\n      Roll: ' + this.roll + '\n      STR: ' + owner.calcStatBonus('str') + '\n      Boost: ' + damageBoost + '\n      Ref: ' + JSON.stringify(this._itemRef) + '\n      Bonus: ' + owner.getBonusDamage(target) + '\n      MyBonusDamage: ' + owner.bonusDamage + ' (' + typeof owner.bonusDamage + ') ' + owner.rollOrAdd(owner.bonusDamage) + '\n      MyProfessionBonusDamage: ' + owner.professionInst.bonusDamage + ' (' + typeof owner.professionInst.bonusDamage + ') ' + owner.rollOrAdd(owner.professionInst.bonusDamage) + '\n      MyRaceBonusDamage: ' + owner.raceInst.bonusDamage + ' (' + typeof owner.raceInst.bonusDamage + ') ' + owner.rollOrAdd(owner.raceInst.bonusDamage) + '\n      MyTraitValue: ' + owner.getTraitValue('bonusDamage') + '\n      MyFury: ' + owner.getTraitVsOpponent(target, 'Fury') + ' (' + typeof owner.getTraitVsOpponent(target, 'Fury') + ')\n      ');
      }

      return val;
    }
  }, {
    key: 'hit',
    value: function hit(owner, target) {
      var damage = this.calcDamage(owner, target);
      if (damage <= 0) {
        var extraBlockData = this.blockCallback(owner, target);
        _displayMessageHandler2['default'].add({ message: this.blockString(owner, target, extraBlockData), type: _displayMessageHandler.MessageTypes.COMBAT });
        return false;
      }
      var extra = this.hitCallback(owner, target, damage);
      _displayMessageHandler2['default'].add({ message: this.hitString(owner, target, damage, extra), type: _displayMessageHandler.MessageTypes.COMBAT });
      target.takeDamage(damage, owner);
      this.afterHitCallback(owner, target);
    }
  }, {
    key: 'hitString',
    value: function hitString(owner, target, damage) {
      return owner.name + ' hit ' + target.name + ' for ' + damage + ' damage!';
    }
  }, {
    key: 'hitCallback',
    value: function hitCallback(owner) {
      owner.breakConduct('pacifist');

      // TODO this should probably be a behavior
      if (this.spawn && _rotJs2['default'].RNG.getPercentage() <= this.spawnChance) {
        var spawnMe = (0, _libRotExtensions.WeightedExtension)(this.spawn).key;
        var validTile = _lodash2['default'].sample(_initGamestate2['default'].world.getValidTilesInRange(owner.x, owner.y, owner.z, 1, function (tile) {
          return _initGamestate2['default'].world.isTileEmpty(tile.x, tile.y, tile.z);
        }));
        if (!validTile) return;
        _worldgenMonsterSpawner2['default'].spawnSingle(spawnMe, validTile);
      }

      return _rotJs2['default'].RNG.getPercentage() <= this.percent;
    }
  }, {
    key: 'blockString',
    value: function blockString(owner, target) {
      return target.name + ' blocked ' + owner.name + '\'s attack!';
    }
  }, {
    key: 'blockCallback',
    value: function blockCallback() {}
  }, {
    key: 'missString',
    value: function missString(owner, target) {
      return owner.name + ' missed ' + target.name + '!';
    }
  }, {
    key: 'missCallback',
    value: function missCallback() {}
  }, {
    key: 'afterHitCallback',
    value: function afterHitCallback() {}
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      this._itemRef = null;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var me = _lodash2['default'].omit(this, ['_itemRef']);
      return JSON.stringify(me);
    }
  }]);

  return Attack;
})(_abstract2['default']);

exports.Attack = Attack;

var SkilledAttack = (function (_Attack) {
  _inherits(SkilledAttack, _Attack);

  function SkilledAttack() {
    _classCallCheck(this, SkilledAttack);

    _get(Object.getPrototypeOf(SkilledAttack.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SkilledAttack, [{
    key: 'hitCallback',
    value: function hitCallback(owner) {
      _get(Object.getPrototypeOf(SkilledAttack.prototype), 'hitCallback', this).call(this, owner);
      if (this.getType() !== 'Unarmed') {
        owner.breakConduct('wieldedWeapon');
      }
      owner.increaseSkill(this.getType());
    }
  }]);

  return SkilledAttack;
})(Attack);

exports.SkilledAttack = SkilledAttack;

var Reagent = (function (_SkilledAttack) {
  _inherits(Reagent, _SkilledAttack);

  function Reagent() {
    _classCallCheck(this, Reagent);

    _get(Object.getPrototypeOf(Reagent.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Reagent, [{
    key: 'isValidRangedAttack',
    value: function isValidRangedAttack(owner) {
      return this._itemRef && this._itemRef.canUse(owner) && this._itemRef.hasValidAmmo(owner);
    }
  }, {
    key: 'use',
    value: function use(owner, target, attackNum) {
      if (this.isValidRangedAttack(owner)) return this._itemRef.use(owner);
      return _get(Object.getPrototypeOf(Reagent.prototype), 'use', this).call(this, owner, target, attackNum);
    }
  }]);

  return Reagent;
})(SkilledAttack);

exports.Reagent = Reagent;

var Magic = (function (_SkilledAttack2) {
  _inherits(Magic, _SkilledAttack2);

  function Magic() {
    _classCallCheck(this, Magic);

    _get(Object.getPrototypeOf(Magic.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Magic, [{
    key: 'init',
    value: function init() {
      this.glyph = new _glyph2['default'](')', '#f00');
    }
  }]);

  return Magic;
})(SkilledAttack);

exports.Magic = Magic;

},{"../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../lib/logger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js","../lib/rot-extensions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/rot-extensions.js","../worldgen/monster-spawner":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/monster-spawner.js","./abstract":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/abstract.js","./glyph":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/glyph.js","dice.js":"/Users/seiyria/GitHub/Roguathia/node_modules/dice.js/src/dice.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/behavior.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

// behaviors are functionality that cascade, ie, a monster could have 10 behaviors that override die()

var Behavior = function Behavior(priority) {
  _classCallCheck(this, Behavior);

  if (!_lodash2['default'].isNumber(priority)) {
    throw new Error(this.constructor.name + ' should be instantiated with a priority.');
  }
  this.priority = priority;
}

// priorities determine the ordering of behavior execution
;

exports['default'] = Behavior;
var Priority = {
  ALWAYS: 0,
  STUN: 1,
  HEAL: 2,
  DEFENSE: 3,
  INTERACT: 4,
  TARGET: 5,
  MOVE: 6,
  DEFER: 10
};
exports.Priority = Priority;

},{"lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/character.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x12, _x13, _x14) { var _again = true; _function: while (_again) { var object = _x12, property = _x13, receiver = _x14; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x12 = parent; _x13 = property; _x14 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _libDiceRoller = require('../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _entity = require('./entity');

var _entity2 = _interopRequireDefault(_entity);

var _libNumberRange = require('../lib/number-range');

var _libNumberRange2 = _interopRequireDefault(_libNumberRange);

var _contentProfessions_all = require('../content/professions/_all');

var _contentProfessions_all2 = _interopRequireDefault(_contentProfessions_all);

var _contentRaces_all = require('../content/races/_all');

var _contentRaces_all2 = _interopRequireDefault(_contentRaces_all);

var _contentBehaviors_all = require('../content/behaviors/_all');

var Behaviors = _interopRequireWildcard(_contentBehaviors_all);

var _contentTraits_all = require('../content/traits/_all');

var Traits = _interopRequireWildcard(_contentTraits_all);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _contentAttacks_all = require('../content/attacks/_all');

var _contentAttacks_all2 = _interopRequireDefault(_contentAttacks_all);

var _displayMessageHandler = require('../display/message-handler');

var _displayMessageHandler2 = _interopRequireDefault(_displayMessageHandler);

var _libValueAssign = require('../lib/value-assign');

var _libValueAssign2 = _interopRequireDefault(_libValueAssign);

var _libDirectionalProbability = require('../lib/directional-probability');

var _libDirectionalProbability2 = _interopRequireDefault(_libDirectionalProbability);

var _libLogger = require('../lib/logger');

var _libLogger2 = _interopRequireDefault(_libLogger);

var _libGenId = require('../lib/gen-id');

var _libGenId2 = _interopRequireDefault(_libGenId);

var _constantsSkillThresholds = require('../constants/skill-thresholds');

var _constantsSkillThresholds2 = _interopRequireDefault(_constantsSkillThresholds);

var Thresholds = _interopRequireWildcard(_constantsSkillThresholds);

var _definitionsAttack = require('../definitions/attack');

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var _contentFlavorNames = require('../content/flavor/names');

var _contentFlavorNames2 = _interopRequireDefault(_contentFlavorNames);

var defaultBehaviors = [Behaviors.RegeneratesHp(), Behaviors.RegeneratesMp()];

var Character = (function (_Entity) {
  _inherits(Character, _Entity);

  function Character(glyph, x, y, z) {
    var _behaviors, _factions, _behaviors2, _factions2, _behaviors3, _factions3, _antiFactions;

    var opts = arguments.length <= 4 || arguments[4] === undefined ? { stats: {}, attributes: {}, template: {} } : arguments[4];

    _classCallCheck(this, Character);

    _get(Object.getPrototypeOf(Character.prototype), 'constructor', this).call(this, glyph, x, y, z);

    this.__id = (0, _libGenId2['default'])();

    this.factions = [];
    this.antiFactions = [];
    this.traits = [];
    this.traitHash = {};
    this.skills = {};
    this.brokenConduct = {};

    this.currentTurn = 0;

    _lodash2['default'].extend(this, _constantsSettings2['default'].game.defaultStats.attributes, opts.attributes, _libValueAssign2['default']);
    _lodash2['default'].extend(this, _constantsSettings2['default'].game.defaultStats.stats, opts.stats);

    (_behaviors = this.behaviors).push.apply(_behaviors, defaultBehaviors);

    this.loadFromTemplate(opts.template);

    this.professionInst = new _contentProfessions_all2['default'][this.profession]();
    var profHp = this.professionInst.hp;
    var profMp = this.professionInst.mp;

    this.hp = new _libNumberRange2['default'](0, this.spawnHp + profHp, this.spawnHp + profHp);
    this.mp = new _libNumberRange2['default'](0, this.spawnMp + profMp, this.spawnMp + profMp);
    this.xp = new _libNumberRange2['default'](0, 0, this.calcLevelXp(this.level));
    (_factions = this.factions).push.apply(_factions, _toConsumableArray(this.professionInst.addFactions));
    (_behaviors2 = this.behaviors).push.apply(_behaviors2, _toConsumableArray(this.professionInst.addBehaviors));

    this.raceInst = new _contentRaces_all2['default'][this.race]();
    (_factions2 = this.factions).push.apply(_factions2, _toConsumableArray(this.raceInst.addFactions));
    (_behaviors3 = this.behaviors).push.apply(_behaviors3, _toConsumableArray(this.raceInst.addBehaviors));

    if (opts.addFactions) (_factions3 = this.factions).push.apply(_factions3, _toConsumableArray(opts.addFactions));
    if (opts.addAntiFactions) (_antiFactions = this.antiFactions).push.apply(_antiFactions, _toConsumableArray(opts.addAntiFactions));

    this.sortBehaviors();

    this.inventory = [];
    this.equipment = {};

    _initGamestate2['default'].world.moveEntity(this, this.x, this.y, this.z);

    _initGamestate2['default'].game.scheduler.add(this, true);

    this.doBehavior('spawn');

    this.behaviors = _lodash2['default'].uniq(this.behaviors, function (b) {
      return b.constructor.name;
    });

    this.loadStartingEquipment();
    this.loadStartingTraits(opts.template);
    this.loadStartingSkills();

    // calculate levelup bonuses
    for (var i = 1; i < this.level; i++) {
      this.levelupStatBoost();
    }
  }

  // region Static functions

  _createClass(Character, [{
    key: 'calcLevelXp',
    value: function calcLevelXp(level) {
      return 20 * Math.pow(2, level);
    }
  }, {
    key: 'rollOrAdd',
    value: function rollOrAdd(val) {
      val = _lodash2['default'].isString(val) ? (0, _libDiceRoller2['default'])(val) : val;
      return !val || _lodash2['default'].isNaN(val) || !_lodash2['default'].isNumber(val) ? 0 : val;
    }

    // endregion

    // region Trait functions
  }, {
    key: 'getTraits',
    value: function getTraits() {
      return this.traits.concat(this.raceInst.traits).concat(this.professionInst.traits).concat(_lodash2['default'].flatten(_lodash2['default'].values(this.equipment)));
    }
  }, {
    key: 'hasTrait',
    value: function hasTrait(propertyName) {
      if (this.traitHash[propertyName]) return this.traitHash[propertyName];
      return _lodash2['default'].contains(_lodash2['default'].pluck(this.getTraits(), 'constructor.name'), propertyName + 'Trait');
    }
  }, {
    key: 'getTraitValue',
    value: function getTraitValue(property) {
      var _this = this;

      var defaultVal = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

      if (this.traitHash[property]) return this.traitHash[property];
      var properties = this.getTraits();
      var value = _lodash2['default'].reduce(properties, function (prev, prop) {
        return prev + (prop[property] && prop.canUse(_this) ? _this.rollOrAdd(prop[property]()) : defaultVal);
      }, defaultVal);
      this.traitHash[property] = value;
      return value;
    }
  }, {
    key: 'addTrait',
    value: function addTrait(property) {
      this.traits.push(property);
      this.flushTraits(property.constructor.name);
    }
  }, {
    key: 'removeTrait',
    value: function removeTrait(property) {
      this.traits = _lodash2['default'].without(this.traits, property);
      this.flushTraits(property.constructor.name);
    }
  }, {
    key: 'flushTraits',
    value: function flushTraits(key) {
      if (key) return delete this.traitHash[key];
      this.traitHash = {};
    }

    // endregion

    // region Skill-related functions
  }, {
    key: 'increaseSkill',
    value: function increaseSkill(type) {
      if (!this.skills[type]) return;
      this.skills[type].add(1);
    }
  }, {
    key: 'getSkillLevel',
    value: function getSkillLevel(type) {
      if (!this.skills[type]) return;
      var curNum = this.skills[type].cur;
      var level = _lodash2['default'].reject(_constantsSkillThresholds2['default'], function (threshold) {
        return threshold.max < curNum;
      })[0];
      return level;
    }
  }, {
    key: 'getSkillLevelValue',
    value: function getSkillLevelValue(type) {
      var level = this.getSkillLevel(type);
      return level ? Thresholds[level.name] : 0;
    }

    // endregion

    // region Loading functions (skills, equipment)
  }, {
    key: 'loadFromTemplate',
    value: function loadFromTemplate(template) {
      if (!template) return;
      template = _lodash2['default'].clone(template);
      if (!template.profession) template.profession = _lodash2['default'].sample(_initGamestate2['default'].unlocked.profession) || 'Tourist';
      if (!template.race) template.race = _lodash2['default'].sample(_initGamestate2['default'].unlocked.race) || 'Human';
      if (!template.align) template.align = _lodash2['default'].random(-200, 200);
      if (!template.gender) template.gender = _lodash2['default'].sample(['Male', 'Female']);
      if (!template.name) template.name = _lodash2['default'].sample(_contentFlavorNames2['default']);
      if (!template.color) template.color = '#fff';
      if (!template.ai) template.ai = 'Wander';

      this.glyph.fg = template.color;

      _lodash2['default'].extend(this, template);
    }
  }, {
    key: 'loadStartingTraits',
    value: function loadStartingTraits(template) {
      if (!template || !template.trait) return;
      var _template$trait = template.trait;
      var utility = _template$trait.utility;
      var buff = _template$trait.buff;
      var _template$trait2 = template.trait;
      var greater = _template$trait2.greater;
      var lesser = _template$trait2.lesser;

      if (greater) {
        greater = greater.toLowerCase();
        this[greater] += 3;
      }
      if (lesser) {
        lesser = lesser.toLowerCase();
        this[lesser] += 1;
      }
      if (utility) this.addTrait(Traits[utility]({ level: 1 }));
      if (buff) this.handleStartingBuff(buff);
    }
  }, {
    key: 'handleStartingBuff',
    value: function handleStartingBuff(buff) {
      var _this2 = this;

      var acts = {
        'Charged Gear': function ChargedGear() {
          return _lodash2['default'].each(_this2.inventory, function (item) {
            return item.charges ? item.charges += 3 : null;
          });
        },
        'Enchanted Gear': function EnchantedGear() {
          return _lodash2['default'].each(_lodash2['default'].flatten(_lodash2['default'].values(_this2.equipment)), function (item) {
            return item.enchantment ? item.enchantment += 1 : item.enchantment = 1;
          });
        },
        'Higher Level': function HigherLevel() {
          return _this2.level += 2;
        }
      };
      if (acts[buff]) acts[buff]();
    }
  }, {
    key: 'loadStartingSkills',
    value: function loadStartingSkills() {
      var _this3 = this;

      var skillCaps = this.professionInst.skillCaps;
      var skillBonus = this.raceInst.skillBonus;
      var defaultLevel = Thresholds.Basic;
      _lodash2['default'].each(_lodash2['default'].values(_contentAttacks_all2['default']), function (atk) {
        if (!(atk.real.prototype instanceof _definitionsAttack.SkilledAttack)) return;
        var atkName = atk.real.name.toLowerCase();
        var maxLevel = defaultLevel + (skillCaps[atkName] || 0);
        maxLevel = Math.min(maxLevel, Thresholds.Legendary);
        var level = skillBonus[atkName] || 0;
        if (_this3.trait && _this3.trait.buff === 'Proficient') {
          level += 2;
        }
        _this3.skills[atkName] = new _libNumberRange2['default'](0, _constantsSkillThresholds2['default'][level].max, _constantsSkillThresholds2['default'][maxLevel].max);
      });
    }
  }, {
    key: 'loadStartingEquipment',
    value: function loadStartingEquipment() {
      var _this4 = this;

      var list = arguments.length <= 0 || arguments[0] === undefined ? this.professionInst.startingItems : arguments[0];

      if (!list) return;
      _lodash2['default'].each(list, function (item) {
        if (item.probability && _rotJs2['default'].RNG.getPercentage() > item.probability) return;

        var inst = null;
        if (item.choices) {
          var choice = _rotJs2['default'].RNG.getWeightedValue(item.choices);
          inst = item.choicesInit[choice]();
        } else {
          inst = item.init();
        }

        if (!_lodash2['default'].isArray(inst)) {
          inst = [inst];
        }

        _lodash2['default'].each(inst, function (item) {
          return _this4.addToInventory(item);
        });
      });
    }

    // endregion

    // region Inventory functions (stacking, add, remove, etc)
  }, {
    key: 'tryToStack',
    value: function tryToStack(item) {
      if (!item.canStack) return;
      var didStack = false;
      _lodash2['default'].each(this.inventory, function (testItem) {
        if (didStack) return;

        if (testItem.name !== item.name || testItem.buc !== item.buc || testItem.enchantment !== item.enchantment) return;

        if (!testItem.charges) testItem.charges = 1;

        testItem.charges += item.charges ? item.charges : 1;
        didStack = true;
      });
      return didStack;
    }
  }, {
    key: 'hasInInventory',
    value: function hasInInventory(itemProto) {
      return _lodash2['default'].find(this.inventory, function (item) {
        return item.getType() === itemProto.name.toLowerCase();
      });
    }
  }, {
    key: 'dropItem',
    value: function dropItem(item) {
      if (this.isEquipped(item)) {
        this.unequip(item);
      }
      item._canPickUpTurn = this.currentTurn + 5;
      this.removeFromInventory(item);
      _initGamestate2['default'].world.moveItem(item, this.x, this.y, this.z);
    }
  }, {
    key: 'addToInventory',
    value: function addToInventory(item) {
      if (item.goldValue) {
        this.gold += item.goldValue;
        return;
      }
      if (this.tryToStack(item)) return;
      if (this.tryEquip(item)) return;
      this.inventory.push(item);
    }
  }, {
    key: 'removeFromInventory',
    value: function removeFromInventory(item) {
      this.inventory = _lodash2['default'].without(this.inventory, item);
    }

    // endregion

    // region Equip-related (slot-checking, equip, unequip, etc)
  }, {
    key: 'isEquipped',
    value: function isEquipped(item) {
      var slot = item.getParentType();
      return _lodash2['default'].contains(this.equipment[slot], item);
    }
  }, {
    key: 'slotsTaken',
    value: function slotsTaken(slot) {
      if (!this.equipment[slot]) return 0;
      return _lodash2['default'].reduce(this.equipment[slot], function (prev, item) {
        return prev + item.slotsTaken;
      }, 0);
    }
  }, {
    key: 'canEquip',
    value: function canEquip(item) {
      return this.raceInst.canEquip(this, item);
    }
  }, {
    key: 'equip',
    value: function equip(item) {
      var slot = item.getParentType();
      if (!this.equipment[slot]) this.equipment[slot] = [];
      this.equipment[slot].push(item);
      this.breakConduct('stubborn');
      if (this.getParentType() !== 'hands') {
        this.breakConduct('nudist');
      }
      if (item.equip) item.equip(this);
      this.flushTraits();
    }
  }, {
    key: 'getWorseItemsThan',
    value: function getWorseItemsThan(item) {
      var slot = item.getParentType();
      return (0, _lodash2['default'])(this.equipment[slot]).filter(function (equip) {
        return equip.value() < item.value() && item.bucName !== 'cursed';
      });
    }
  }, {
    key: 'shouldEquip',
    value: function shouldEquip(item) {
      var slot = item.getParentType();
      if (this.raceInst.slots[slot] > 0 && this.canEquip(item)) return true;
      var lowerItems = this.getWorseItemsThan(item);
      return lowerItems.length < item.slotsTaken;
    }
  }, {
    key: 'tryEquip',
    value: function tryEquip(item) {
      if (!this.canEquip(item) || !this.shouldEquip(item)) return false;
      var worseItems = this.getWorseItemsThan(item);
      if (worseItems.length < item.slotsTaken) return false; // cursed items

      if (worseItems.length > 0) {
        for (var i = 0; i < item.slotsTaken; i++) {
          this.unequip(worseItems[i]);
        }
      }
      this.equip(item);
      return true;
    }
  }, {
    key: 'unequip',
    value: function unequip(item) {
      if (item.isCursed()) return;
      var slot = item.getParentType();
      this.equipment[slot] = _lodash2['default'].without(this.equipment[slot], item);
      this.inventory.push(item);
      if (item.unequip) item.unequip(this);
    }

    // endregion

    // region Behavior-related functions
  }, {
    key: 'doBehavior',
    value: function doBehavior(action) {
      var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

      args.unshift(this);
      _lodash2['default'].each(this.behaviors, function (behavior) {
        if (behavior[action]) return behavior[action].apply(behavior, args);
      }); // returning false from any behavior will cancel subsequent ones
    }
  }, {
    key: 'sortBehaviors',
    value: function sortBehaviors() {
      this.behaviors = _lodash2['default'].sortBy(this.behaviors, 'priority');
    }
  }, {
    key: 'addBehavior',
    value: function addBehavior(behavior) {
      this.behaviors.push(behavior);
      this.sortBehaviors();
    }
  }, {
    key: 'hasBehavior',
    value: function hasBehavior(behavior) {
      if (!_lodash2['default'].contains(behavior, 'Behavior')) behavior = behavior + 'Behavior';
      return _lodash2['default'].contains(_lodash2['default'].pluck(this.behaviors, 'constructor.name'), behavior);
    }
  }, {
    key: 'addUniqueBehavior',
    value: function addUniqueBehavior(behavior) {
      if (this.hasBehavior(behavior.constructor.name)) return;
      this.addBehavior(behavior);
    }
  }, {
    key: 'removeBehavior',
    value: function removeBehavior(behavior) {
      this.behaviors = _lodash2['default'].without(this.behaviors, behavior);
    }

    // endregion

    // region Damage / dying / targetting
  }, {
    key: 'takeDamage',
    value: function takeDamage(damage, attacker) {
      this.hp.sub(damage);
      this.doBehavior('takeDamage', [attacker]);
      if (this.hp.atMin()) {
        this.die(attacker);
      }
    }
  }, {
    key: 'die',
    value: function die(killer) {
      this.hp.toMin();
      if (this.killerName) {
        (0, _libLogger2['default'])('Player', 'Error: Attempting to die twice. Previous killer: ' + this.killerName + ' (' + this.__killerId + '), Usurper: ' + killer.name + ' (' + killer.__id + ')', true);
        return;
      }
      this.doBehavior('die');
      _displayMessageHandler2['default'].add({ message: this.name + ' was killed by ' + killer.name + '!', type: _displayMessageHandler.MessageTypes.COMBAT });
      if (killer.kill) killer.kill(this);

      this.__killerId = killer.__id;
      this.killerName = killer.name;
      this.removeSelf();
    }
  }, {
    key: 'removeSelf',
    value: function removeSelf() {
      _initGamestate2['default'].world.removeEntity(this);
      _initGamestate2['default'].game.scheduler.remove(this);
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      _lodash2['default'].each(this.attacks, function (a) {
        return a.cleanUp();
      });
      this.behaviors = null;
      this.inventory = null;
      this.equipment = null;
      this.attacks = null;
      this._path = null;
      this._attackedBy = null;

      this.professionInst = null;
      this.raceInst = null;

      this.conquest = null;
      this.traits = null;
      this.traitHash = null;
      this.skills = null;
    }
  }, {
    key: 'kill',
    value: function kill(dead) {
      this.gainXp(dead.killXp);
      this.doBehavior('kill');
    }
  }, {
    key: 'setTarget',
    value: function setTarget(newTarget) {
      this.target = newTarget;
    }

    // endregion

    // region Movement (pathfinding, stepping)
  }, {
    key: 'stepRandomly',
    value: function stepRandomly() {
      var _this5 = this;

      var tiles = _initGamestate2['default'].world.getAllTilesInRange(this.x, this.y, this.z, 1);
      var validTiles = _lodash2['default'].map(tiles, function (tile, i) {
        return _initGamestate2['default'].world.isTileEmpty(tile.x, tile.y, tile.z) ? i + 1 : null;
      }); // 1-9 instead of 0-8
      var direction = (0, _lodash2['default'])(validTiles).compact().sample() - 1; // adjustment for array
      var newTile = tiles[direction]; // default to a random tile

      if (this.lastDirection) {
        (function () {
          var probs = (0, _libDirectionalProbability2['default'])(_this5.lastDirection + 1); // adjust for array
          var choices = (0, _lodash2['default'])(validTiles).map(function (tileIndex) {
            return tileIndex ? [tileIndex, probs[tileIndex]] : null;
          }).compact().zipObject().value();
          direction = parseInt(_rotJs2['default'].RNG.getWeightedValue(choices)) - 1;
          newTile = tiles[direction];
        })();
      }

      if (!newTile) return; // surrounded
      this.move(newTile);
      this.lastDirection = direction;
      this.doBehavior('step');
    }
  }, {
    key: 'stepTowards',
    value: function stepTowards(target) {
      var basePath = arguments.length <= 1 || arguments[1] === undefined ? target._path : arguments[1];
      return (function () {
        var _this6 = this;

        // first check if it's just a coordinate pair
        if (_lodash2['default'].keys(target).length > 2 && !this.canSee(target)) {
          return this.stepRandomly();
        }

        var path = [];
        var addPath = function addPath(x, y) {
          return path.push({ x: x, y: y });
        };
        basePath.compute(this.x, this.y, addPath);

        path.shift();
        var step = path.shift();
        if (!step) return false;

        var blockingEntityInfo = function blockingEntityInfo(path) {
          var entity = null;
          var step = null;
          _lodash2['default'].each(path, function (newStep, i) {
            var testEntity = _initGamestate2['default'].world.getEntity(newStep.x, newStep.y, _this6.z);
            if (testEntity && !_this6.canAttack(testEntity)) {
              entity = testEntity;
              step = i;
              return false;
            }
          });
          return { entity: entity, step: step };
        };

        var mainBlockingInfo = blockingEntityInfo(path);

        // the main path is blocked
        if (mainBlockingInfo.entity) {
          var altPath = this.getAlternatePathTo(target);

          // no alternate path could be generated
          if (!altPath) {
            this.moveTo(step.x, step.y);
            return true;
          }

          var altBlockingInfo = blockingEntityInfo(altPath);

          // both are blocked, take the shortest path
          if (mainBlockingInfo.entity && altBlockingInfo.entity) {
            var newPath = _lodash2['default'].min([path, altPath], function (testPath) {
              return testPath.length;
            });
            var newStep = newPath.shift();
            this.moveTo(newStep.x, newStep.y);

            // the alt path isn't blocked, take that
          } else {
              var newStep = altPath.shift();
              this.moveTo(newStep.x, newStep.y);
            }

          // no blockers, keep moving on
        } else {
            this.moveTo(step.x, step.y);
          }

        this.doBehavior('step');
        return true;
      }).apply(this, arguments);
    }
  }, {
    key: 'getAlternatePathTo',
    value: function getAlternatePathTo(target) {
      var _this7 = this;

      var canPass = function canPass(x, y) {
        var entity = _initGamestate2['default'].world.getEntity(x, y, _this7.z);
        var isAttackable = entity && _this7.canAttack(entity);
        var isMe = _this7.x === x && _this7.y === y;
        return _initGamestate2['default'].world.isTilePassable(x, y, _this7.z) || isMe || isAttackable;
      };
      var astar = new _rotJs2['default'].Path.AStar(target.x, target.y, canPass);

      var path = [];
      astar.compute(this.x, this.y, function (x, y) {
        return path.push({ x: x, y: y });
      });

      path.shift();
      var step = path.shift();
      if (!step) return null;
      return path;
    }
  }, {
    key: 'moveTo',
    value: function moveTo(x, y) {
      return _initGamestate2['default'].world.moveEntity(this, x, y, this.z);
    }
  }, {
    key: 'move',
    value: function move(newTile) {
      return _initGamestate2['default'].world.moveEntity(this, newTile.x, newTile.y, newTile.z);
    }
  }, {
    key: 'alertAllInRange',
    value: function alertAllInRange() {
      var _this8 = this;

      var soundRange = arguments.length <= 0 || arguments[0] === undefined ? this.getSoundEmission() : arguments[0];

      var entities = _initGamestate2['default'].world.getValidEntitiesInRange(this.x, this.y, this.z, soundRange, function (entity) {
        return entity.canAttack(_this8);
      });
      _lodash2['default'].each(entities, function (entity) {
        entity.doBehavior('hear', [_this8]);
      });
    }

    // endregion

    // region Attack-related (vision, attacking, etc)
  }, {
    key: 'getAttacks',
    value: function getAttacks() {
      var _this9 = this;

      var baseAttacks = this.attacks || [];
      var racialAttacks = baseAttacks.concat(this.raceInst.attacks);
      var attacks = racialAttacks.concat((0, _lodash2['default'])(this.equipment).values().flatten().filter(function (item) {
        return item.canUse(_this9) && item.attacks;
      }).pluck('attacks').flatten().value());
      if (attacks.length === 0) attacks = [_contentAttacks_all2['default'].Unarmed()];
      var inventoryAttacks = (0, _lodash2['default'])(this.inventory).filter(function (item) {
        return item.canUse(_this9) && item.attacks;
      }).pluck('attacks').flatten().value();

      // all melee attacks are valid, but only one ranged inventory attack can be used
      if (_lodash2['default'].some(attacks, function (atk) {
        return atk.canUse(_this9);
      })) return attacks;
      return _lodash2['default'].compact([(0, _lodash2['default'])(inventoryAttacks).filter(function (atk) {
        return atk.canUse(_this9);
      }).sample()]);
    }
  }, {
    key: 'canSee',
    value: function canSee(entity) {
      return this.getTraitValue('SeeInvisible') >= entity.getTraitValue('Invisible');
    }
  }, {
    key: 'canAttack',
    value: function canAttack(entity) {
      if (entity.hp.atMin()) return false;
      if (_lodash2['default'].contains(this.factions, 'Player') && _lodash2['default'].contains(entity.factions, 'Player')) return false;
      // they have a faction that you are against
      return _lodash2['default'].intersection(entity.factions, this.antiFactions).length > 0 ||

      // or you attack everything but your own faction
      _lodash2['default'].contains(this.antiFactions, 'all') && _lodash2['default'].intersection(entity.factions, this.factions).length === 0;
    }
  }, {
    key: 'doAttack',
    value: function doAttack(attack, hitNum) {
      var target = attack.possibleTargets(this)[0];
      if (!target) return; // possibly a multi-shot attack that has killed early
      attack.use(this, target, hitNum);
    }
  }, {
    key: 'tryAttack',
    value: function tryAttack() {
      var _this10 = this;

      var attacks = this.getAttacks();
      if (attacks.length === 0) return false;

      _lodash2['default'].each(attacks, function (atk, i) {
        return _this10.doAttack(atk, i);
      });
      return true;
    }

    // endregion

    // region Levelup/XP functions
  }, {
    key: 'calcLevelHpBonus',
    value: function calcLevelHpBonus() {
      return (0, _libDiceRoller2['default'])(this.professionInst.config.hp) + this.calcStatBonus('con');
    }
  }, {
    key: 'calcLevelMpBonus',
    value: function calcLevelMpBonus() {
      return (0, _libDiceRoller2['default'])(this.professionInst.config.mp) + this.calcStatBonus('int');
    }
  }, {
    key: 'gainXp',
    value: function gainXp(number) {
      if (this.hp.atMin()) return;
      this.xp.add(number);
      if (this.xp.atMax()) {
        this.levelup();
      }
    }
  }, {
    key: 'levelup',
    value: function levelup() {
      this.level += 1;
      this.xp.max = this.calcLevelXp(this.level);
      this.levelupStatBoost();

      // resets
      this.xp.toMin();
      this.hp.toMax();
      this.mp.toMax();

      this.flushTraits();
      _displayMessageHandler2['default'].add({ message: this.name + ' has reached experience level ' + this.level + '!', type: _displayMessageHandler.MessageTypes.CHARACTER });
    }
  }, {
    key: 'levelupStatBoost',
    value: function levelupStatBoost() {
      this.professionInst.levelup();
      this.hp.max += this.calcLevelHpBonus();
      this.mp.max += this.calcLevelMpBonus();
    }

    // endregion

    // region Stat manipulation
  }, {
    key: 'abuse',
    value: function abuse(stat) {
      var loss = arguments.length <= 1 || arguments[1] === undefined ? '1d1' : arguments[1];

      this[stat] = Math.max(this[stat] - (0, _libDiceRoller2['default'])(loss), _constantsSettings2['default'].game.minStatValue);
    }
  }, {
    key: 'exercise',
    value: function exercise(stat) {
      var gain = arguments.length <= 1 || arguments[1] === undefined ? '1d1' : arguments[1];

      this[stat] += (0, _libDiceRoller2['default'])(gain);
    }

    // endregion

    // region Getters (Stats, etc)
  }, {
    key: 'getTraitVsOpponent',
    value: function getTraitVsOpponent(target, trait) {
      var _this11 = this;

      if (!target) return 0;
      return _lodash2['default'].reduce(target.factions, function (prev, cur) {
        return prev + _this11.getTraitValue('' + cur + trait);
      }, 0);
    }
  }, {
    key: 'getAlign',
    value: function getAlign() {
      if (this.align <= -_constantsSettings2['default'].game.alignThreshold) return 'Evil';
      if (this.align >= _constantsSettings2['default'].game.alignThreshold) return 'Good';
      return 'Neutral';
    }
  }, {
    key: 'getStat',
    value: function getStat(stat) {
      return this.rollOrAdd(this[stat]) + this.rollOrAdd(this.professionInst[stat]) + this.rollOrAdd(this.raceInst[stat]) + this.getTraitValue(stat);
    }
  }, {
    key: 'getStatWithMin',
    value: function getStatWithMin(stat) {
      var min = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

      return Math.max(min, this.getStat(stat));
    }
  }, {
    key: 'getRegenHp',
    value: function getRegenHp() {
      return this.getStatWithMin('regenHp', 1);
    }
  }, {
    key: 'getRegenMp',
    value: function getRegenMp() {
      return this.getStatWithMin('regenMp', 1);
    }
  }, {
    key: 'getBonusDamage',
    value: function getBonusDamage() {
      var target = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      return this.getStat('bonusDamage') + this.getTraitVsOpponent(target, 'Fury');
    }
  }, {
    key: 'getToHit',
    value: function getToHit() {
      var target = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      return this.getStat('toHit') + this.getTraitVsOpponent(target, 'Bane');
    }
  }, {
    key: 'getSight',
    value: function getSight() {
      return this.getStatWithMin('sight') + this.getTraitValue('Infravision');
    }
  }, {
    key: 'getSpeed',
    value: function getSpeed() {
      return this.getStatWithMin('speed') + this.getTraitValue('Haste');
    }
  }, {
    key: 'getSoundEmission',
    value: function getSoundEmission() {
      return this.getStatWithMin('sound') - this.getTraitValue('Stealth');
    }
  }, {
    key: 'getAC',
    value: function getAC() {
      return _constantsSettings2['default'].game.baseAC + this.getStat('ac') - this.calcStatBonus('dex') - this.getTraitValue('Protection');
    }
  }, {
    key: 'getStr',
    value: function getStr() {
      return this.getStatWithMin('str');
    }
  }, {
    key: 'getDex',
    value: function getDex() {
      return this.getStatWithMin('dex');
    }
  }, {
    key: 'getCon',
    value: function getCon() {
      return this.getStatWithMin('con');
    }
  }, {
    key: 'getInt',
    value: function getInt() {
      return this.getStatWithMin('int');
    }
  }, {
    key: 'getWis',
    value: function getWis() {
      return this.getStatWithMin('wis');
    }
  }, {
    key: 'getCha',
    value: function getCha() {
      return this.getStatWithMin('cha');
    }
  }, {
    key: 'getLuk',
    value: function getLuk() {
      return this.getStatWithMin('luk');
    }
  }, {
    key: 'hasFaction',
    value: function hasFaction(faction) {
      return _lodash2['default'].contains(this.factions, faction);
    }

    // endregion (Stats, etc)

  }, {
    key: 'act',
    value: function act() {
      this.currentTurn++;
      this.doBehavior('act');
    }
  }, {
    key: 'breakConduct',
    value: function breakConduct(conduct) {
      this.brokenConduct[conduct] = true;
    }
  }, {
    key: 'calcDifficulty',
    value: function calcDifficulty(entity) {
      return Math.max(1, Math.min(5, Math.floor((entity.level - this.level) / 2)));
    }
  }, {
    key: 'heal',
    value: function heal(value) {
      if (!value || !_lodash2['default'].isNumber(value) || _lodash2['default'].isNaN(value)) {
        (0, _libLogger2['default'])('Character', 'Value given to heal was not well formed: ' + value);
      }
      this.hp.add(value);
    }

    // -2 = 4/5, -1 = 6/7, 0 = 8, +1 = 9/10, +2 = 10/11 (etc)
  }, {
    key: 'calcStatBonus',
    value: function calcStatBonus(stat) {
      return Math.floor(this['get' + _lodash2['default'].capitalize(stat)]() / 2) - 4;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var me = _lodash2['default'].omit(this, ['game', '_path', 'traitHash', '_attackedBy', '__id', '__killerId']);
      return JSON.stringify(me);
    }
  }]);

  return Character;
})(_entity2['default']);

exports['default'] = Character;
module.exports = exports['default'];

},{"../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../constants/skill-thresholds":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/skill-thresholds.js","../content/attacks/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/attacks/_all.js","../content/behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js","../content/flavor/names":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/flavor/names.js","../content/professions/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/professions/_all.js","../content/races/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/races/_all.js","../content/traits/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/traits/_all.js","../definitions/attack":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/attack.js","../display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../lib/directional-probability":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/directional-probability.js","../lib/gen-id":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/gen-id.js","../lib/logger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js","../lib/number-range":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/number-range.js","../lib/value-assign":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/value-assign.js","./entity":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/entity.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/effect.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _displayMessageHandler = require('../display/message-handler');

var _displayMessageHandler2 = _interopRequireDefault(_displayMessageHandler);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var Effect = (function () {
  function Effect() {
    _classCallCheck(this, Effect);
  }

  _createClass(Effect, null, [{
    key: 'use',
    value: function use() {}
  }, {
    key: 'msg',
    value: function msg(entity, message) {
      _displayMessageHandler2['default'].add({ entity: entity, message: message, type: _displayMessageHandler.MessageTypes.DUNGEON });
    }
  }, {
    key: 'getEmptyTilesInRange',
    value: function getEmptyTilesInRange(entity) {
      var range = arguments.length <= 1 || arguments[1] === undefined ? 3 : arguments[1];

      return _initGamestate2['default'].world.getValidTilesInRange(entity.x, entity.y, entity.z, range, function (tile) {
        return _initGamestate2['default'].world.isTileEmpty(tile.x, tile.y, tile.z);
      });
    }
  }, {
    key: 'probability',
    get: function get() {
      return 1;
    }
  }]);

  return Effect;
})();

exports['default'] = Effect;
module.exports = exports['default'];

},{"../display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/entity.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _glyph = require('./glyph');

var _glyph2 = _interopRequireDefault(_glyph);

var _abstract = require('./abstract');

var _abstract2 = _interopRequireDefault(_abstract);

var Entity = (function (_Abstract) {
  _inherits(Entity, _Abstract);

  function Entity(glyphOpts) {
    var x = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
    var y = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
    var z = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

    _classCallCheck(this, Entity);

    _get(Object.getPrototypeOf(Entity.prototype), 'constructor', this).call(this);
    this.density = 1;
    this.opacity = 0;
    this.x = x;
    this.y = y;
    this.z = z;
    this.setGlyph(glyphOpts);
  }

  _createClass(Entity, [{
    key: 'setGlyph',
    value: function setGlyph(glyphOpts) {
      this.glyph = new _glyph2['default'](glyphOpts.key, glyphOpts.fg, glyphOpts.bg);
    }
  }, {
    key: 'isDense',
    value: function isDense() {
      return !!this.density;
    }
  }, {
    key: 'isBlockingLight',
    value: function isBlockingLight() {
      return !!this.opacity;
    }
  }]);

  return Entity;
})(_abstract2['default']);

exports['default'] = Entity;
module.exports = exports['default'];

},{"./abstract":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/abstract.js","./glyph":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/glyph.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x16, _x17, _x18) { var _again = true; _function: while (_again) { var object = _x16, property = _x17, receiver = _x18; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x16 = parent; _x17 = property; _x18 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _item = require('./item');

var _constantsFaketypes = require('../constants/faketypes');

var Fakes = _interopRequireWildcard(_constantsFaketypes);

var _displayMessageHandler = require('../display/message-handler');

var _displayMessageHandler2 = _interopRequireDefault(_displayMessageHandler);

var _constantsGlyphs = require('../constants/glyphs');

var _constantsMaterials = require('../constants/materials');

var _constantsMaterials2 = _interopRequireDefault(_constantsMaterials);

var _constantsDecorators = require('../constants/decorators');

var Equipment = (function (_Item) {
  _inherits(Equipment, _Item);

  function Equipment() {
    _classCallCheck(this, Equipment);

    _get(Object.getPrototypeOf(Equipment.prototype), 'constructor', this).apply(this, arguments);
  }

  return Equipment;
})(_item.Item);

var Special = (function (_Item2) {
  _inherits(Special, _Item2);

  function Special() {
    _classCallCheck(this, Special);

    _get(Object.getPrototypeOf(Special.prototype), 'constructor', this).apply(this, arguments);
  }

  return Special;
})(_item.Item);

exports.Special = Special;

var Comestible = (function (_Item3) {
  _inherits(Comestible, _Item3);

  function Comestible() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Comestible);

    opts.autoRemove = true;
    opts.symbol = _constantsGlyphs.Items.Comestible;
    _get(Object.getPrototypeOf(_Comestible.prototype), 'constructor', this).call(this, opts);
    this.canStack = true;
  }

  var _Comestible = Comestible;
  Comestible = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Food)(Comestible) || Comestible;
  return Comestible;
})(_item.Item);

exports.Comestible = Comestible;

var Armor = (function (_Equipment) {
  _inherits(Armor, _Equipment);

  function Armor() {
    _classCallCheck(this, Armor);

    _get(Object.getPrototypeOf(Armor.prototype), 'constructor', this).apply(this, arguments);
  }

  return Armor;
})(Equipment);

exports.Armor = Armor;

var Weapon = (function (_Equipment2) {
  _inherits(Weapon, _Equipment2);

  function Weapon(opts) {
    _classCallCheck(this, Weapon);

    _get(Object.getPrototypeOf(Weapon.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = this.getCanonName();
  }

  return Weapon;
})(Equipment);

exports.Weapon = Weapon;

var Body = (function (_Armor) {
  _inherits(Body, _Armor);

  function Body() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Body);

    opts.symbol = _constantsGlyphs.Items.Body;
    _get(Object.getPrototypeOf(_Body.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = this.getCanonName();
  }

  var _Body = Body;
  Body = (0, _constantsDecorators.rarity)(25)(Body) || Body;
  return Body;
})(Armor);

exports.Body = Body;

var Ring = (function (_Armor2) {
  _inherits(Ring, _Armor2);

  function Ring() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Ring);

    opts.bucProb = { cursed: 7, blessed: 2, uncursed: 91 };
    opts.symbol = _constantsGlyphs.Items.Ring;
    _get(Object.getPrototypeOf(_Ring.prototype), 'constructor', this).call(this, opts);
    this.realName = '' + this.getCanonName();
    this.fakeName = this.pickFakeName(Fakes.Ring) + ' ring';
  }

  var _Ring = Ring;
  Ring = (0, _constantsDecorators.rarity)(3)(Ring) || Ring;
  return Ring;
})(Armor);

exports.Ring = Ring;

var Hands = (function (_Weapon) {
  _inherits(Hands, _Weapon);

  function Hands() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Hands);

    opts.symbol = _constantsGlyphs.Items.Hands;
    _get(Object.getPrototypeOf(_Hands.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = this.getCanonName();
  }

  var _Hands = Hands;
  Hands = (0, _constantsDecorators.rarity)(25)(Hands) || Hands;
  return Hands;
})(Weapon);

exports.Hands = Hands;

var Wrist = (function (_Armor3) {
  _inherits(Wrist, _Armor3);

  function Wrist() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Wrist);

    opts.symbol = _constantsGlyphs.Items.Wrist;
    _get(Object.getPrototypeOf(_Wrist.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = this.getCanonName();
  }

  var _Wrist = Wrist;
  Wrist = (0, _constantsDecorators.rarity)(5)(Wrist) || Wrist;
  return Wrist;
})(Armor);

exports.Wrist = Wrist;

var Feet = (function (_Armor4) {
  _inherits(Feet, _Armor4);

  function Feet() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Feet);

    opts.symbol = _constantsGlyphs.Items.Feet;
    _get(Object.getPrototypeOf(_Feet.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = this.getCanonName();
    this.slotsTaken = 2;
  }

  var _Feet = Feet;
  Feet = (0, _constantsDecorators.rarity)(5)(Feet) || Feet;
  return Feet;
})(Armor);

exports.Feet = Feet;

var Head = (function (_Armor5) {
  _inherits(Head, _Armor5);

  function Head() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Head);

    opts.symbol = _constantsGlyphs.Items.Head;
    _get(Object.getPrototypeOf(_Head.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = this.getCanonName();
  }

  var _Head = Head;
  Head = (0, _constantsDecorators.rarity)(5)(Head) || Head;
  return Head;
})(Armor);

exports.Head = Head;

var Cloak = (function (_Armor6) {
  _inherits(Cloak, _Armor6);

  function Cloak() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Cloak);

    opts.symbol = _constantsGlyphs.Items.Cloak;
    _get(Object.getPrototypeOf(_Cloak.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = this.getCanonName();
  }

  var _Cloak = Cloak;
  Cloak = (0, _constantsDecorators.rarity)(3)(Cloak) || Cloak;
  return Cloak;
})(Armor);

exports.Cloak = Cloak;

var Neck = (function (_Armor7) {
  _inherits(Neck, _Armor7);

  function Neck() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Neck);

    opts.symbol = _constantsGlyphs.Items.Neck;
    _get(Object.getPrototypeOf(_Neck.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = this.getCanonName();
  }

  var _Neck = Neck;
  Neck = (0, _constantsDecorators.rarity)(1)(Neck) || Neck;
  return Neck;
})(Armor);

exports.Neck = Neck;

var Gem = (function (_Item4) {
  _inherits(Gem, _Item4);

  function Gem() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Gem);

    opts.symbol = _constantsGlyphs.Items.Gem;
    _get(Object.getPrototypeOf(_Gem.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = '' + this.getCanonName();
    this.canStack = true;
  }

  var _Gem = Gem;
  Gem = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Glass)(Gem) || Gem;
  Gem = (0, _constantsDecorators.rarity)(0)(Gem) || Gem;
  return Gem;
})(_item.Item);

exports.Gem = Gem;

var Scroll = (function (_Item5) {
  _inherits(Scroll, _Item5);

  function Scroll() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Scroll);

    opts.symbol = _constantsGlyphs.Items.Scroll;
    _get(Object.getPrototypeOf(_Scroll.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = '' + this.getCanonName();
    this.canStack = true;
  }

  var _Scroll = Scroll;
  Scroll = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(Scroll) || Scroll;
  Scroll = (0, _constantsDecorators.rarity)(0)(Scroll) || Scroll;
  return Scroll;
})(_item.Item);

exports.Scroll = Scroll;

var Wand = (function (_Weapon2) {
  _inherits(Wand, _Weapon2);

  function Wand() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Wand);

    opts.symbol = _constantsGlyphs.Items.Wand;
    _get(Object.getPrototypeOf(_Wand.prototype), 'constructor', this).call(this, opts);
    this.realName = this.fakeName = this.getCanonName();
  }

  var _Wand = Wand;
  Wand = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Wood)(Wand) || Wand;
  Wand = (0, _constantsDecorators.rarity)(2)(Wand) || Wand;
  return Wand;
})(Weapon);

exports.Wand = Wand;

var Spellbook = (function (_Weapon3) {
  _inherits(Spellbook, _Weapon3);

  function Spellbook() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Spellbook);

    opts.manaCost = opts.manaCost || 3;
    opts.symbol = _constantsGlyphs.Items.Spellbook;
    _get(Object.getPrototypeOf(_Spellbook.prototype), 'constructor', this).call(this, opts);
  }

  var _Spellbook = Spellbook;
  Spellbook = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Cloth)(Spellbook) || Spellbook;
  Spellbook = (0, _constantsDecorators.rarity)(1)(Spellbook) || Spellbook;
  return Spellbook;
})(Weapon);

exports.Spellbook = Spellbook;

var Potion = (function (_Equipment3) {
  _inherits(Potion, _Equipment3);

  function Potion() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Potion);

    opts.symbol = _constantsGlyphs.Items.Potion;
    _get(Object.getPrototypeOf(_Potion.prototype), 'constructor', this).call(this, opts);
    this.realName = 'potion of ' + this.getCanonName();
    var fake = this.pickFakeName(Fakes.Potion);
    this.color = fake;
    this.fakeName = fake + ' potion';
    this.canStack = true;
  }

  _createClass(Potion, [{
    key: 'use',
    value: function use(entity, extra) {
      _get(Object.getPrototypeOf(_Potion.prototype), 'use', this).call(this, entity, extra);
      _displayMessageHandler2['default'].add({ message: entity.name + ' drank ' + this.color + ' liquid and ' + extra.messageFinish + '!', type: _displayMessageHandler.MessageTypes.DUNGEON });
    }
  }]);

  var _Potion = Potion;
  Potion = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Glass)(Potion) || Potion;
  Potion = (0, _constantsDecorators.rarity)(20)(Potion) || Potion;
  return Potion;
})(Equipment);

exports.Potion = Potion;

var Tool = (function (_Item6) {
  _inherits(Tool, _Item6);

  function Tool() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, _Tool);

    opts.symbol = _constantsGlyphs.Items.Tool;
    _get(Object.getPrototypeOf(_Tool.prototype), 'constructor', this).call(this, opts);
  }

  var _Tool = Tool;
  Tool = (0, _constantsDecorators.material)(_constantsMaterials2['default'].Iron)(Tool) || Tool;
  Tool = (0, _constantsDecorators.rarity)(0)(Tool) || Tool;
  return Tool;
})(_item.Item);

exports.Tool = Tool;
// actually a value of 8 but they're not implemented yet
// actually a value of 15 but they're not implemented yet

},{"../constants/decorators":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/decorators.js","../constants/faketypes":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/faketypes.js","../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../constants/materials":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/materials.js","../display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","./item":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/item.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/glyph.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Glyph = function Glyph(key, fg, bg) {
  _classCallCheck(this, Glyph);

  this.key = key ? key.substring(0, 1) : '';
  this.fg = fg;
  this.bg = bg;
};

exports['default'] = Glyph;
module.exports = exports['default'];

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/item.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _libDiceRoller = require('../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _glyph = require('./glyph');

var _glyph2 = _interopRequireDefault(_glyph);

var _libValidColors = require('../lib/valid-colors');

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _abstract = require('./abstract');

var _abstract2 = _interopRequireDefault(_abstract);

var _libLogger = require('../lib/logger');

var _libLogger2 = _interopRequireDefault(_libLogger);

var _displayMessageHandler = require('../display/message-handler');

var _displayMessageHandler2 = _interopRequireDefault(_displayMessageHandler);

var Item = (function (_Abstract) {
  _inherits(Item, _Abstract);

  _createClass(Item, [{
    key: 'name',
    get: function get() {
      var name = !this.isIdentified() && this.fakeName ? this.fakeName : this.realName;
      if (!name) name = this.getCanonName();
      var enchant = this.enchantment ? '+' + this.enchantment + ' ' + name : name;
      var buc = this.bucName !== 'uncursed' ? this.bucName + ' ' + enchant : enchant;
      return buc;
    }
  }]);

  function Item(opts) {
    var _this = this;

    _classCallCheck(this, Item);

    _get(Object.getPrototypeOf(Item.prototype), 'constructor', this).call(this, opts);
    opts.glyph = _lodash2['default'].extend({ fg: (0, _libValidColors.GetColor)(), key: opts.symbol }, opts.glyph);
    _lodash2['default'].extend(this, opts);
    this.enchantment = this.enchantment || 0;
    this.slotsTaken = this.slotsTaken || 1;
    if (this.attacks) {
      _lodash2['default'].each(this.attacks, function (attack) {
        return attack._itemRef = _this;
      });
    }
    if (this.range) {
      this.range = _lodash2['default'].extend({ numShots: 1, damageBoost: '0d0', ammo: [] }, this.range);
    }
    if (this.charges) this.charges = (0, _libDiceRoller2['default'])(this.charges);
    if (this.startIdentified) this.identify();
    this.glyph = new _glyph2['default'](opts.glyph.key, opts.glyph.fg);
    this.generateBUC(opts.bucProb);
    if (!this.material) {
      (0, _libLogger2['default'])('Item', this.getType() + ' has no material set.');
    }
  }

  _createClass(Item, [{
    key: 'isIdentified',
    value: function isIdentified() {
      var myType = this.getParentType();
      return _initGamestate2['default'].identification[myType];
    }
  }, {
    key: 'identify',
    value: function identify() {
      var myType = this.getParentType();
      _initGamestate2['default'].identification[myType] = this.realName;
    }
  }, {
    key: 'pickFakeName',
    value: function pickFakeName(choices) {
      var myType = this.getParentType();
      if (_initGamestate2['default']._idMap[this.realName]) {
        return _initGamestate2['default']._idMap[this.realName]; // this item has already been generated
      }
      var currentTypes = _lodash2['default'].keys(_initGamestate2['default'].identification[myType]);
      var validTypes = _lodash2['default'].difference(choices, currentTypes);
      var name = _lodash2['default'].sample(validTypes);
      _initGamestate2['default']._idMap[this.realName] = name;
      return name;
    }
  }, {
    key: 'canUse',
    value: function canUse(owner) {
      if (this.manaCost) return owner.mp.gte(this.manaCost);
      if (this.charges) return this.charges > 0;
      return owner.isEquipped(this);
    }
  }, {
    key: 'hasValidAmmo',
    value: function hasValidAmmo(owner) {
      return this.getValidAmmo(owner).length > 0;
    }
  }, {
    key: 'getValidAmmo',
    value: function getValidAmmo(owner) {
      var _this2 = this;

      return _lodash2['default'].filter(owner.inventory, function (item) {
        return item.canUse(owner) && _lodash2['default'].contains(_this2.range.ammo, item.getType());
      });
    }
  }, {
    key: 'use',
    value: function use(owner) {
      var extra = arguments.length <= 1 || arguments[1] === undefined ? { healVal: 1 } : arguments[1];

      if (this.manaCost) owner.mp.sub(this.manaCost);
      if (this.healRoll) owner.heal(extra.healVal);
      if (this.charges) {
        this.charges--;
        if (this.charges <= 0 && this.autoRemove) this.disintegrate(owner);
      }
      if (this.range && this.hasValidAmmo(owner)) {
        this.pewpew(owner);
      }
    }
  }, {
    key: 'pewpew',
    value: function pewpew(owner) {
      for (var i = 0; i < this.range.numShots; i++) {
        var chosenAmmo = _lodash2['default'].sample(this.getValidAmmo(owner));
        chosenAmmo._tempAttackBoost = this.range.damageBoost;
        var attack = _lodash2['default'].sample(chosenAmmo.attacks);
        owner.doAttack(attack, i);
        delete chosenAmmo._tempAttackBoost;
      }
    }
  }, {
    key: 'disintegrate',
    value: function disintegrate(owner) {
      owner.unequip(this);
      owner.dropItem(this);
      _initGamestate2['default'].world.removeItem(this);
      _displayMessageHandler2['default'].add({ message: this.name + ' crumbled to dust.', type: _displayMessageHandler.MessageTypes.ITEM });
    }
  }, {
    key: 'isCursed',
    value: function isCursed() {
      return this.bucName === 'cursed';
    }
  }, {
    key: 'curse',
    value: function curse() {
      this.bucName = 'cursed';
      this.setBUC();
    }
  }, {
    key: 'uncurse',
    value: function uncurse() {
      this.bucName = 'uncursed';
      this.setBUC();
    }
  }, {
    key: 'bless',
    value: function bless() {
      this.bucName = 'blessed';
      this.setBUC();
    }
  }, {
    key: 'setBUC',
    value: function setBUC() {
      var hash = { cursed: -1, uncursed: 1, blessed: 2 };
      this.buc = hash[this.bucName];
    }
  }, {
    key: 'generateBUC',
    value: function generateBUC() {
      var opts = arguments.length <= 0 || arguments[0] === undefined ? { cursed: 5, blessed: 5, uncursed: 90 } : arguments[0];

      if (!this.bucName) {
        var _status = _rotJs2['default'].RNG.getWeightedValue(opts);
        this.bucName = _status;
      }
      this.setBUC();
    }
  }, {
    key: 'value',
    value: function value() {
      var atkValue = _lodash2['default'].reduce(this.attacks, function (prev, cur) {
        return prev + cur.value();
      }, 0);
      return this.buc * (100 - this.rarity) + this.enchantment * 5 + atkValue;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var me = _lodash2['default'].omit(this, ['bucProb', 'startIdentified', '_tempAttackBoost', 'symbol']);
      return JSON.stringify(me);
    }
  }]);

  return Item;
})(_abstract2['default']);

exports.Item = Item;

},{"../display/message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../lib/logger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js","../lib/valid-colors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/valid-colors.js","./abstract":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/abstract.js","./glyph":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/glyph.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/monster.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _character = require('./character');

var _character2 = _interopRequireDefault(_character);

var _constantsFactions = require('../constants/factions');

var _constantsFactions2 = _interopRequireDefault(_constantsFactions);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var Monster = (function (_Character) {
  _inherits(Monster, _Character);

  function Monster(x, y, z, opts) {
    var _factions;

    _classCallCheck(this, Monster);

    opts.stats.profession = 'Monster';
    opts.attributes = _lodash2['default'].extend({}, _constantsSettings2['default'].game.defaultStats.monster, opts.attributes);
    _get(Object.getPrototypeOf(Monster.prototype), 'constructor', this).call(this, opts.glyph, x, y, z, opts);
    this.difficulty = opts.difficulty;
    this.antiFactions.push(_constantsFactions2['default'].PLAYER);
    if (opts.addFactions) (_factions = this.factions).push.apply(_factions, _toConsumableArray(opts.addFactions));
    if (opts.startingEquipment) this.loadStartingEquipment(opts.startingEquipment);
    if (opts.important) this.important = true;

    _initGamestate2['default'].monsters.push(this);
  }

  _createClass(Monster, [{
    key: 'arePlayersAPossibility',
    value: function arePlayersAPossibility() {
      var minZ = _lodash2['default'].min(_initGamestate2['default'].players, 'z').z;
      return minZ <= this.z;
    }
  }, {
    key: 'act',
    value: function act() {
      if (!this.arePlayersAPossibility()) {
        return this.removeSelf() && this.cleanUp();
      }
      _get(Object.getPrototypeOf(Monster.prototype), 'act', this).call(this);
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      _get(Object.getPrototypeOf(Monster.prototype), 'cleanUp', this).call(this);
      this._attackedBy = null;
      this.target = null;
      this._current = null;
    }
  }, {
    key: 'removeSelf',
    value: function removeSelf() {
      _get(Object.getPrototypeOf(Monster.prototype), 'removeSelf', this).call(this);
      _initGamestate2['default'].monsters = _lodash2['default'].without(_initGamestate2['default'].monsters, this);
      this.cleanUp();
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var base = JSON.parse(_get(Object.getPrototypeOf(Monster.prototype), 'toJSON', this).call(this));
      var me = _lodash2['default'].omit(base, 'target');
      return JSON.stringify(me);
    }
  }]);

  return Monster;
})(_character2['default']);

exports['default'] = Monster;
module.exports = exports['default'];

},{"../constants/factions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/factions.js","../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","./character":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/character.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/player.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _character = require('./character');

var _character2 = _interopRequireDefault(_character);

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _worldgenMonsterSpawner = require('../worldgen/monster-spawner');

var _worldgenMonsterSpawner2 = _interopRequireDefault(_worldgenMonsterSpawner);

var _contentBehaviors_all = require('../content/behaviors/_all');

var Behaviors = _interopRequireWildcard(_contentBehaviors_all);

var _constantsFactions = require('../constants/factions');

var _constantsFactions2 = _interopRequireDefault(_constantsFactions);

var _constantsGlyphs = require('../constants/glyphs');

var Player = (function (_Character) {
  _inherits(Player, _Character);

  function Player(x, y, z) {
    var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

    _classCallCheck(this, Player);

    opts.stats = { behaviors: [Behaviors.Attacks(), Behaviors.Interacts(), Behaviors.PickUpItems(), Behaviors.DropsGold('0d0'), Behaviors.HealsBelowPercent(50), Behaviors.AlertsOnStep(), Behaviors.DropsItems()] };
    _get(Object.getPrototypeOf(Player.prototype), 'constructor', this).call(this, { key: _constantsGlyphs.Entities.Player }, x, y, z, opts);
    this.factions.push(_constantsFactions2['default'].PLAYER);
    this.antiFactions.push(_constantsFactions2['default'].MONSTER);
    this.spawnSteps = _constantsSettings2['default'].game.spawnSteps; // spawn creatures every 100 steps
    this.totalXpEarned = 0;
    this.totalKpEarned = 0;
    this.conquest = {};

    this.name = _lodash2['default'].trunc(this.name, { length: _constantsSettings2['default'].game.nameLength, omission: '' });
    this.brokenConduct.stubborn = false;
    this.getDefaultExploreBehavior(opts.template);
  }

  _createClass(Player, [{
    key: 'getDefaultExploreBehavior',
    value: function getDefaultExploreBehavior(template) {
      var behaviors = {
        Wander: Behaviors.Wanders,
        Explore: Behaviors.ExploresDungeon
      };
      this.behaviors.push(behaviors[template.ai || 'Explore']());
    }
  }, {
    key: 'getSpawnSteps',
    value: function getSpawnSteps() {
      return this.getStat('spawnSteps');
    }
  }, {
    key: 'gainXp',
    value: function gainXp(xp) {
      _get(Object.getPrototypeOf(Player.prototype), 'gainXp', this).call(this, xp);
      this.totalXpEarned += xp;
    }
  }, {
    key: 'kill',
    value: function kill(dead) {
      _get(Object.getPrototypeOf(Player.prototype), 'kill', this).call(this, dead);
      this.totalKpEarned += ~ ~(dead.difficulty * Math.min(dead.killXp / _constantsSettings2['default'].game.killXpDivisor, 1));
      if (!this.conquest[dead.name]) this.conquest[dead.name] = 0;
      this.conquest[dead.name]++;

      // probably refactor this into a lose/gainAlign and some constants for common occurrences
      if (dead.hasFaction(_constantsFactions2['default'].PLAYER)) {
        this.align -= 50;
      }
    }
  }, {
    key: 'act',
    value: function act() {
      if (_initGamestate2['default'].game.checkWin()) return;

      var engine = _initGamestate2['default'].game.engine;
      engine.lock();

      var livingPlayers = _lodash2['default'].reject(_initGamestate2['default'].players, function (player) {
        return player.hp.atMin();
      });

      if (!_initGamestate2['default'].manualMove) {
        _get(Object.getPrototypeOf(Player.prototype), 'act', this).call(this);
        setTimeout(function () {
          engine.unlock();
        }, _constantsSettings2['default'].game.turnDelay / livingPlayers.length);
      }

      this._path = this.rebuildPathingMap();

      if (this.currentTurn % this.getSpawnSteps() === 0) {
        this.spawnMonster();
      }

      // redraw counter, so we don't redraw once per player turn, just once for every player turn
      _initGamestate2['default'].playerTurnsTaken++;

      if (_initGamestate2['default'].playerTurnsTaken >= _initGamestate2['default'].livingPlayers) {
        _initGamestate2['default'].game.refresh();
        _initGamestate2['default'].emit('redraw');

        _initGamestate2['default'].playerTurnsTaken = 0;
      }
    }
  }, {
    key: 'rebuildPathingMap',
    value: function rebuildPathingMap() {
      var _this = this;

      var targetX = arguments.length <= 0 || arguments[0] === undefined ? this.x : arguments[0];
      var targetY = arguments.length <= 1 || arguments[1] === undefined ? this.y : arguments[1];

      var canPass = function canPass(x, y) {
        var entity = _initGamestate2['default'].world.getEntity(x, y, _this.z);
        var isAttackable = entity && _this.canAttack(entity);
        var isMe = _this.x === x && _this.y === y;
        var isPlayer = entity && entity.constructor.name === 'Player';
        return _initGamestate2['default'].world.isTilePassable(x, y, _this.z) || isPlayer || isMe || isAttackable;
      };

      return new _rotJs2['default'].Path.Dijkstra(targetX, targetY, canPass, { topology: 8 });
    }
  }, {
    key: 'simplePathingMap',
    value: function simplePathingMap() {
      var _this2 = this;

      var targetX = arguments.length <= 0 || arguments[0] === undefined ? this.x : arguments[0];
      var targetY = arguments.length <= 1 || arguments[1] === undefined ? this.y : arguments[1];

      var canPass = function canPass(x, y) {
        return _initGamestate2['default'].world.isTilePassable(x, y, _this2.z);
      };
      return new _rotJs2['default'].Path.Dijkstra(targetX, targetY, canPass, { topology: 8 });
    }
  }, {
    key: 'die',
    value: function die(killer) {
      _get(Object.getPrototypeOf(Player.prototype), 'die', this).call(this, killer);

      _initGamestate2['default'].emit('redraw');
      _initGamestate2['default'].emit('die', this);
      _initGamestate2['default'].livingPlayers--;

      if (_lodash2['default'].every(_initGamestate2['default'].players, function (player) {
        return player.hp.atMin();
      })) {
        _initGamestate2['default'].game.gameOver();
        _initGamestate2['default'].game.engine.lock();
      }
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      _get(Object.getPrototypeOf(Player.prototype), 'cleanUp', this).call(this);
      this._path = null;
    }
  }, {
    key: 'spawnMonster',
    value: function spawnMonster() {
      _worldgenMonsterSpawner2['default'].spawn(this);
    }
  }, {
    key: 'descend',
    value: function descend() {
      if (_initGamestate2['default'].currentFloor + 1 === _initGamestate2['default'].world.depth) return;
      var newFloor = _initGamestate2['default'].currentFloor = _initGamestate2['default'].currentFloor + 1;
      var stairs = _initGamestate2['default'].world.stairs[newFloor].up;

      _lodash2['default'].each(_initGamestate2['default'].players, function (player) {
        if (player.hp.atMin()) return;
        _initGamestate2['default'].world.moveEntity(player, stairs[0], stairs[1], newFloor);
        player.stepRandomly();
        player.doBehavior('descend');
      });

      _initGamestate2['default'].world.descend();
      _initGamestate2['default'].emit('descend');
    }
  }, {
    key: 'ascend',
    value: function ascend() {
      _initGamestate2['default'].currentFloor--;
    }
  }, {
    key: 'getScore',
    value: function getScore() {
      return this.currentTurn + this.gold + this.totalXpEarned;
    }
  }]);

  return Player;
})(_character2['default']);

exports['default'] = Player;
module.exports = exports['default'];

},{"../constants/factions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/factions.js","../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../content/behaviors/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/behaviors/_all.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../worldgen/monster-spawner":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/monster-spawner.js","./character":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/character.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/profession.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _libValueAssign = require('../lib/value-assign');

var _libValueAssign2 = _interopRequireDefault(_libValueAssign);

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var Profession = (function () {
  function Profession() {
    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Profession);

    config = _lodash2['default'].extend({}, _lodash2['default'].cloneDeep(_constantsSettings2['default'].game.defaultStats.profession), config);
    this.config = config;
    _lodash2['default'].extend(this, config, _libValueAssign2['default']);
    config.addFactions.push(this.constructor.name);
    this.level = 1;
    this.title = this.titles[0];
  }

  _createClass(Profession, [{
    key: 'levelup',
    value: function levelup() {
      var _this = this;

      this.level++;
      if (this.titles[this.level - 1]) {
        this.title = this.titles[this.level - 1];
      }
      (0, _lodash2['default'])(this.config.levelUp).keys().value().forEach(function (key) {
        var val = (0, _libValueAssign2['default'])(null, _this.config[key]);
        _this[key] += val;
      });
    }
  }]);

  return Profession;
})();

exports['default'] = Profession;
module.exports = exports['default'];

},{"../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../lib/value-assign":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/value-assign.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/race.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _libValueAssign = require('../lib/value-assign');

var _libValueAssign2 = _interopRequireDefault(_libValueAssign);

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var _libLogger = require('../lib/logger');

var _libLogger2 = _interopRequireDefault(_libLogger);

var Race = (function () {
  function Race() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Race);

    this.slots = _lodash2['default'].extend({}, _constantsSettings2['default'].game.defaultStats.equipmentSlots, opts.slots);
    _lodash2['default'].extend(this, _lodash2['default'].cloneDeep(_constantsSettings2['default'].game.defaultStats.race), opts.stats, _libValueAssign2['default']);
    this.addFactions.push(this.constructor.name);
  }

  _createClass(Race, [{
    key: 'canEquip',
    value: function canEquip(owner, item) {
      if (!item) {
        (0, _libLogger2['default'])('Race', 'Invalid item');
      }
      var slot = item.getParentType();
      var slotsTaken = owner.slotsTaken(slot);
      var totalSlots = this.slots[slot];
      var itemSlots = item.slotsTaken;
      return itemSlots <= totalSlots - slotsTaken;
    }
  }]);

  return Race;
})();

exports['default'] = Race;
module.exports = exports['default'];

},{"../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../lib/logger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js","../lib/value-assign":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/value-assign.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/tile.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _entity = require('./entity');

var _entity2 = _interopRequireDefault(_entity);

var _libRotExtensions = require('../lib/rot-extensions');

var Tile = (function (_Entity) {
  _inherits(Tile, _Entity);

  function Tile(key, fg, bg) {
    _classCallCheck(this, Tile);

    _get(Object.getPrototypeOf(Tile.prototype), 'constructor', this).call(this, { key: key, fg: fg, bg: bg });
    this.density = 0;
    this.opacity = 0;
    this.reflect = 0.3;
  }

  _createClass(Tile, [{
    key: 'ceaseExisting',
    value: function ceaseExisting() {
      this.glyph.key = '.';
      this.glyph.fg = '';
      this.glyph.bg = '';
      this.canInteract = undefined;
    }
  }, {
    key: 'getRandomEffect',
    value: function getRandomEffect(effects) {
      return (0, _libRotExtensions.WeightedExtension)(effects).value;
    }
  }]);

  return Tile;
})(_entity2['default']);

exports['default'] = Tile;
module.exports = exports['default'];

},{"../lib/rot-extensions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/rot-extensions.js","./entity":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/entity.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/trait.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var Trait = (function () {
  function Trait(opts) {
    _classCallCheck(this, Trait);

    _lodash2['default'].extend(this, { level: 1, req: 0 }, opts);
  }

  _createClass(Trait, [{
    key: 'canUse',
    value: function canUse(entity) {
      return entity.level >= this.req;
    }
  }]);

  return Trait;
})();

exports['default'] = Trait;
module.exports = exports['default'];

},{"lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var MessageQueue = (function () {
  function MessageQueue() {
    _classCallCheck(this, MessageQueue);
  }

  _createClass(MessageQueue, null, [{
    key: 'add',
    value: function add(messageObj) {

      // attempt to hide messages from enemies that are too far away that interact with stuff, if applicable
      if (messageObj.entity) {
        var isInRange = false;
        _lodash2['default'].each(_initGamestate2['default'].players, function (player) {
          if (player.distBetween(messageObj.entity) <= player.getSight()) isInRange = true;
        });
        if (!isInRange) return;
      }
      _initGamestate2['default'].messages.unshift({ turnsLeft: _constantsSettings2['default'].game.display.turns, message: messageObj.message });
      _initGamestate2['default'].messages.length = _constantsSettings2['default'].game.display.log; // cap the messages off at the last 50
      messageObj.turn = _lodash2['default'].max(_lodash2['default'].pluck(_initGamestate2['default'].players, 'currentTurn'));
      _initGamestate2['default'].emit('log', messageObj);
    }
  }, {
    key: 'viewAllMessages',
    value: function viewAllMessages() {
      _initGamestate2['default'].messages = (0, _lodash2['default'])(_initGamestate2['default'].messages).compact().each(function (msg) {
        return msg.turnsLeft--;
      }).reject(function (msg) {
        return msg.turnsLeft <= 0;
      }).value();
    }
  }]);

  return MessageQueue;
})();

exports['default'] = MessageQueue;
var MessageTypes = {
  COMBAT: 'Combat',
  CHARACTER: 'Character',
  DUNGEON: 'Dungeon',
  META: 'Meta',
  ITEM: 'Item'
};
exports.MessageTypes = MessageTypes;

},{"../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screen.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var Screen = (function () {
  function Screen() {
    _classCallCheck(this, Screen);
  }

  _createClass(Screen, null, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {}
  }, {
    key: 'render',
    value: function render() {}
  }, {
    key: 'handleInput',
    value: function handleInput() {}
  }, {
    key: 'drawCenterText',
    value: function drawCenterText(display, y, text) {
      var divisor = arguments.length <= 3 || arguments[3] === undefined ? 2 : arguments[3];
      var xOffset = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];

      var x = xOffset + Math.floor(_constantsSettings2['default'].screen.width / divisor) - Math.floor(text.length / 2);
      display.drawText(x, y, text);
      return { x: x, y: y };
    }
  }, {
    key: 'drawLeftCenterText',
    value: function drawLeftCenterText(display, y, text) {
      return this.drawCenterText(display, y, text, 4);
    }
  }, {
    key: 'drawRightCenterText',
    value: function drawRightCenterText(display, y, text) {
      return this.drawCenterText(display, y, text, 4, _constantsSettings2['default'].screen.width / 2);
    }
  }, {
    key: 'drawLeftText',
    value: function drawLeftText(display, y, text) {
      var xOffset = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

      display.drawText(xOffset, y, text);
    }
  }, {
    key: 'drawLeftTextNoTrim',
    value: function drawLeftTextNoTrim(display, y) {
      var text = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
      var xOffset = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

      for (var i = 0; i < text.length; i++) {
        display.draw(i + xOffset, y, text[i]);
      }
    }
  }, {
    key: 'padText',
    value: function padText(text, width) {
      return _lodash2['default'].pad(text, width);
    }
  }, {
    key: 'getMainPlayer',
    value: function getMainPlayer() {
      return _lodash2['default'].max(_initGamestate2['default'].players, 'currentTurn');
    }
  }, {
    key: 'changeScreenWithDelay',
    value: function changeScreenWithDelay(newScreen, delay) {
      setTimeout(function () {
        var multiChoice = _initGamestate2['default'].splitScreen ? newScreen.multi : newScreen.single;
        var screen = newScreen.single && newScreen.multi ? multiChoice : newScreen;
        _initGamestate2['default'].game.switchScreen(screen);
      }, delay);
    }
  }]);

  return Screen;
})();

exports.Screen = Screen;

var ScrollingScreen = (function (_Screen) {
  _inherits(ScrollingScreen, _Screen);

  function ScrollingScreen() {
    _classCallCheck(this, ScrollingScreen);

    _get(Object.getPrototypeOf(ScrollingScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  return ScrollingScreen;
})(Screen);

var SingleScrollingScreen = (function (_ScrollingScreen) {
  _inherits(SingleScrollingScreen, _ScrollingScreen);

  function SingleScrollingScreen() {
    _classCallCheck(this, SingleScrollingScreen);

    _get(Object.getPrototypeOf(SingleScrollingScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SingleScrollingScreen, null, [{
    key: 'enter',
    value: function enter() {
      this.currentIndex = 0;
    }
  }, {
    key: 'render',
    value: function render(display) {
      var _this = this;

      display.clear();
      this.drawLeftText(display, 0, this.title);
      this.drawLeftText(display, 1, _lodash2['default'].repeat('-', this.title.length));

      var remainingHeight = _constantsSettings2['default'].screen.height - 3;
      var slice = this.scrollContent.slice(this.currentIndex, remainingHeight + this.currentIndex);
      for (var i = 0; i < remainingHeight; i++) {
        this.drawLeftTextNoTrim(display, i + 2, slice[i]);
      }

      setTimeout(function () {
        if (slice.length < remainingHeight) {
          _this.changeScreenWithDelay(_this.nextScreen, 4000);
        } else {
          _this.currentIndex++;
          _this.render(display);
        }
      }, 2000);
    }
  }]);

  return SingleScrollingScreen;
})(ScrollingScreen);

exports.SingleScrollingScreen = SingleScrollingScreen;

var SplitScrollingScreen = (function (_ScrollingScreen2) {
  _inherits(SplitScrollingScreen, _ScrollingScreen2);

  function SplitScrollingScreen() {
    _classCallCheck(this, SplitScrollingScreen);

    _get(Object.getPrototypeOf(SplitScrollingScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SplitScrollingScreen, null, [{
    key: 'enter',
    value: function enter() {
      this.currentIndices = _lodash2['default'].map(_initGamestate2['default'].players, function () {
        return 0;
      });

      var width = _constantsSettings2['default'].screen.width / 2;
      var height = _initGamestate2['default'].players.length > 2 ? _constantsSettings2['default'].screen.height / 2 : _constantsSettings2['default'].screen.height;

      this.tlCoords = [{ x: 0, y: 0 }, { x: width + 1, y: 0 }, { x: 0, y: height + 1 }, { x: width + 1, y: height + 1 }];
    }
  }, {
    key: 'isDone',
    value: function isDone() {
      return _lodash2['default'].every(this.currentIndices, function (index) {
        return index === true;
      });
    }
  }, {
    key: 'drawBorder',
    value: function drawBorder(display) {

      var middleX = _constantsSettings2['default'].screen.width / 2;
      for (var i = 0; i < _constantsSettings2['default'].screen.height; i++) {
        display.draw(middleX, i, '‖');
      }

      if (_initGamestate2['default'].players.length > 2) {
        var middleY = _constantsSettings2['default'].screen.height / 2;
        for (var i = 0; i < _constantsSettings2['default'].screen.width; i++) {
          display.draw(i, middleY, '=');
        }
      }
    }
  }, {
    key: 'drawList',
    value: function drawList(display, playerIndex) {

      var offset = this.tlCoords[playerIndex];

      this.drawLeftText(display, offset.y, this.title[playerIndex], offset.x);
      this.drawLeftText(display, offset.y + 1, _lodash2['default'].repeat('-', this.title[playerIndex].length), offset.x);

      var remainingHeight = (_initGamestate2['default'].players.length > 2 ? _constantsSettings2['default'].screen.height / 2 : _constantsSettings2['default'].screen.height) - 3;
      var slice = this.scrollContent[playerIndex].slice(this.currentIndices[playerIndex], remainingHeight + this.currentIndices[playerIndex]);
      for (var i = 0; i < remainingHeight; i++) {
        this.drawLeftTextNoTrim(display, offset.y + i + 2, slice[i], offset.x);
      }

      if (slice.length < remainingHeight) this.currentIndices[playerIndex] = true;
    }
  }, {
    key: 'render',
    value: function render(display) {
      var _this2 = this;

      display.clear();

      _lodash2['default'].each(this.currentIndices, function (value, i) {
        _this2.drawList(display, i);
      });

      this.drawBorder(display);

      setTimeout(function () {
        if (_this2.isDone()) {
          _this2.changeScreenWithDelay(_this2.nextScreen, 6000);
        } else {
          _this2.currentIndices = _lodash2['default'].map(_this2.currentIndices, function (index) {
            return index === true ? true : index + 1;
          });
          _this2.render(display);
        }
      }, 2000);
    }
  }]);

  return SplitScrollingScreen;
})(ScrollingScreen);

exports.SplitScrollingScreen = SplitScrollingScreen;

},{"../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/conduct.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _screen = require('../screen');

var _respawn = require('./respawn');

var _respawn2 = _interopRequireDefault(_respawn);

var _constantsConducts = require('../../constants/conducts');

var _constantsConducts2 = _interopRequireDefault(_constantsConducts);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var SingleConductScreen = (function (_SingleScrollingScreen) {
  _inherits(SingleConductScreen, _SingleScrollingScreen);

  function SingleConductScreen() {
    _classCallCheck(this, SingleConductScreen);

    _get(Object.getPrototypeOf(SingleConductScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SingleConductScreen, null, [{
    key: 'enter',
    value: function enter() {
      _get(Object.getPrototypeOf(SingleConductScreen), 'enter', this).call(this);
      var target = this.getMainPlayer();
      var sortedConduct = (0, _constantsConducts2['default'])(target);
      this.scrollContent = sortedConduct;
      this.title = target.name + '\'s Traits (' + sortedConduct.length + ')'; // shorten this for splitscreen
      this.nextScreen = _respawn2['default'];
    }

    // static get split() { return SplitConductScreen; }
  }]);

  return SingleConductScreen;
})(_screen.SingleScrollingScreen);

exports.SingleConductScreen = SingleConductScreen;

var SplitConductScreen = (function (_SplitScrollingScreen) {
  _inherits(SplitConductScreen, _SplitScrollingScreen);

  function SplitConductScreen() {
    _classCallCheck(this, SplitConductScreen);

    _get(Object.getPrototypeOf(SplitConductScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SplitConductScreen, null, [{
    key: 'enter',
    value: function enter() {
      var _this = this;

      _get(Object.getPrototypeOf(SplitConductScreen), 'enter', this).call(this);
      this.scrollContent = [];
      this.title = [];

      _lodash2['default'].each(_initGamestate2['default'].players, function (target, i) {
        var sortedConduct = (0, _constantsConducts2['default'])(target);
        _this.scrollContent[i] = sortedConduct;
        _this.title[i] = target.name + '\'s Traits (' + sortedConduct.length + ')'; // shorten this for splitscreen
      });

      this.nextScreen = _respawn2['default'];
    }

    // static get split() { return SingleConductScreen; }
  }]);

  return SplitConductScreen;
})(_screen.SplitScrollingScreen);

exports.SplitConductScreen = SplitConductScreen;

},{"../../constants/conducts":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/conducts.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../screen":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screen.js","./respawn":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/respawn.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/dead.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _screen = require('../screen');

var _vanquished = require('./vanquished');

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _libPageTitle = require('../../lib/page-title');

var _libPageTitle2 = _interopRequireDefault(_libPageTitle);

var DeadScreen = (function (_Screen) {
  _inherits(DeadScreen, _Screen);

  function DeadScreen() {
    _classCallCheck(this, DeadScreen);

    _get(Object.getPrototypeOf(DeadScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(DeadScreen, null, [{
    key: 'enter',
    value: function enter() {
      _initGamestate2['default'].game.engine.lock();
      this.changeScreenWithDelay({ single: _vanquished.SingleVanquishedScreen, multi: _vanquished.SplitVanquishedScreen }, 5000);
    }
  }, {
    key: 'render',
    value: function render(display) {
      var TOMBSTONE_WIDTH = 26;
      var goodbyes = ['Goodbye', 'Sayonara', 'Ciao', 'Adios', 'Toodles', 'Ta ta', 'Farewell', 'Bye-bye', 'Bye', 'So long', 'RIP'];

      var latestDeath = this.getMainPlayer();
      var score = latestDeath.getScore();
      var floor = _initGamestate2['default'].currentFloor + 1;
      var paddedName = this.padText(latestDeath.name, TOMBSTONE_WIDTH);
      var paddedScore = this.padText('Score: ' + score, TOMBSTONE_WIDTH);
      var paddedKiller = this.padText(latestDeath.killerName, TOMBSTONE_WIDTH);

      var goodbye = _lodash2['default'].sample(goodbyes);
      var mapName = _initGamestate2['default'].world.tiles[_initGamestate2['default'].currentFloor].mapName;
      var i = 3;

      this.drawCenterText(display, i++, '------------------');
      this.drawCenterText(display, i++, '/                  \\');
      this.drawCenterText(display, i++, '/        REST        \\');
      this.drawCenterText(display, i++, '/          IN          \\');
      this.drawCenterText(display, i++, '/         POINTS         \\');
      this.drawCenterText(display, i++, '/                          \\');
      this.drawCenterText(display, i++, '|' + paddedName + '|');
      this.drawCenterText(display, i++, '|' + paddedScore + '|');
      this.drawCenterText(display, i++, '|                          |');
      this.drawCenterText(display, i++, '|         slain by         |');
      this.drawCenterText(display, i++, '|' + paddedKiller + '|');
      this.drawCenterText(display, i++, '|                          |');
      this.drawCenterText(display, i++, '&  * |      *                   $     *');
      this.drawCenterText(display, i++, '__\\\\)/_]_|____\\\\(\\\\_____//\\/_______\\{/____|____');

      i++;

      this.drawLeftText(display, i++, goodbye + ', ' + latestDeath.name + ' the ' + latestDeath.getAlign() + ' ' + latestDeath.gender + ' ' + latestDeath.race + ' ' + latestDeath.profession + '...');
      this.drawLeftText(display, i++, 'You were level ' + latestDeath.level + ' after earning ' + latestDeath.totalXpEarned + ' experience.');
      this.drawLeftText(display, i++, 'You died in ' + mapName + ' on dungeon level ' + floor + '.');
      this.drawLeftText(display, i++, 'You scored ' + score + ' points and ' + latestDeath.gold + ' gold over ' + latestDeath.currentTurn + ' steps.');
      this.drawLeftText(display, i++, 'You earned ' + _initGamestate2['default'].spEarned + ' SP and ' + _initGamestate2['default'].kpEarned + ' KP.');

      (0, _libPageTitle2['default'])('Dead');
    }
  }]);

  return DeadScreen;
})(_screen.Screen);

exports['default'] = DeadScreen;
module.exports = exports['default'];

},{"../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/page-title":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/page-title.js","../screen":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screen.js","./vanquished":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/vanquished.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/game.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x7, _x8, _x9) { var _again = true; _function: while (_again) { var object = _x7, property = _x8, receiver = _x9; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x7 = parent; _x8 = property; _x9 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _screen = require('../screen');

var _messageHandler = require('../message-handler');

var _messageHandler2 = _interopRequireDefault(_messageHandler);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _constantsSettings = require('../../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var _libPageTitle = require('../../lib/page-title');

var _libPageTitle2 = _interopRequireDefault(_libPageTitle);

var GameScreen = (function (_Screen) {
  _inherits(GameScreen, _Screen);

  function GameScreen() {
    _classCallCheck(this, GameScreen);

    _get(Object.getPrototypeOf(GameScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(GameScreen, null, [{
    key: 'getScreenOffsets',
    value: function getScreenOffsets() {
      var centerPoint = arguments.length <= 0 || arguments[0] === undefined ? _initGamestate2['default'].players[0] : arguments[0];
      var width = arguments.length <= 1 || arguments[1] === undefined ? _constantsSettings2['default'].screen.width : arguments[1];
      var height = arguments.length <= 2 || arguments[2] === undefined ? _constantsSettings2['default'].screen.height : arguments[2];

      var topLeftX = Math.max(0, centerPoint.x - Math.round(width / 2));
      topLeftX = Math.min(topLeftX, _initGamestate2['default'].world.width - width);

      var topLeftY = Math.max(0, centerPoint.y - Math.round(height / 2));
      topLeftY = Math.min(topLeftY, _initGamestate2['default'].world.height - height);

      return {
        x: topLeftX,
        y: topLeftY
      };
    }
  }, {
    key: 'drawTiles',
    value: function drawTiles(display, centerPoint) {
      var options = arguments.length <= 2 || arguments[2] === undefined ? { width: _constantsSettings2['default'].screen.width, height: _constantsSettings2['default'].screen.height, offset: this.getScreenOffsets(), gameOffset: { x: 0, y: 0 } } : arguments[2];
      var width = options.width;
      var height = options.height;
      var offset = options.offset;
      var gameOffset = options.gameOffset;

      var visible = [];

      var world = _initGamestate2['default'].world;
      var zLevel = centerPoint.z;

      var isDead = centerPoint.hp.atMin();

      var fov = world.fov[zLevel];
      fov.compute(centerPoint.x, centerPoint.y, isDead ? 1 : centerPoint.getSight(), function (x, y) {
        if (!visible[x]) visible[x] = [];
        visible[x][y] = true;
        world.setExplored(x, y, zLevel, true);
      });

      var cache = {};
      _lodash2['default'].each(['Telepathy', 'Clairvoyance', 'Warning'], function (trait) {
        return cache[trait] = centerPoint.getTraitValue(trait);
      });

      var projectileCache = {};
      _lodash2['default'].each(_initGamestate2['default'].projectiles, function (proj) {
        return projectileCache[proj.x + ',' + proj.y] = proj;
      });

      var lightingCache = {};

      var lights = _initGamestate2['default'].world.lighting[zLevel];
      if (lights && lights.length > 0) {
        (function () {
          var reflectivity = function reflectivity(x, y) {
            return _initGamestate2['default'].world.getTile(x, y, zLevel).reflect;
          };
          var lighting = new _rotJs2['default'].Lighting(reflectivity, { range: 5, passes: 2 });
          lighting.setFOV(fov);

          _lodash2['default'].each(lights, function (light) {
            return lighting.setLight(light.x, light.y, light._lightColor);
          });

          var lightCallback = function lightCallback(x, y, color) {
            return lightingCache[x + ',' + y] = color;
          };
          lighting.compute(lightCallback);
        })();
      }

      var isVisible = function isVisible(x, y) {
        return visible[x] && visible[x][y];
      };

      var hasValid = function hasValid(trait, x, y) {
        return !isDead && cache[trait] && centerPoint.distBetweenXY(x, y) <= cache[trait];
      };

      // white (doesn't count), green, yellow, orange, red, purple
      var warningColors = ['#fff', '#0f0', '#ff0', '#ffa500', '#f00', '#ff0'];
      var ambientLight = [30, 30, 30];

      for (var x = offset.x; x < offset.x + width; x++) {
        for (var y = offset.y; y < offset.y + height; y++) {
          var hasTelepathy = hasValid('Telepathy', x, y);
          var hasClairvoyance = hasValid('Clairvoyance', x, y);
          var hasWarning = hasValid('Warning', x, y);
          var hasSeen = _initGamestate2['default'].world.isExplored(x, y, centerPoint.z);
          if (!hasSeen && !_initGamestate2['default'].renderAll && !hasTelepathy && !hasClairvoyance && !hasWarning) continue;

          var tile = world.getTile(x, y, zLevel);
          if (!tile) continue; // no out of bounds drawing

          var glyph = { key: null };
          var foreground = null;
          var background = _rotJs2['default'].Color.fromString('#000');

          var baseIsVisible = isVisible(x, y) || hasClairvoyance;

          if (baseIsVisible || hasSeen) {
            glyph = tile.glyph;
            foreground = glyph.fg;
            if (glyph.bg) background = _rotJs2['default'].Color.fromString(glyph.bg);
          }

          if (baseIsVisible) {
            var items = world.getItemsAt(x, y, zLevel);
            if (items && items.length > 0) {
              glyph = items[items.length - 1].glyph;
              foreground = glyph.fg;
            }
          }

          if (baseIsVisible || hasTelepathy || hasWarning) {
            var entity = world.getEntity(x, y, zLevel);
            if (entity) {

              if (baseIsVisible || hasTelepathy) {
                glyph = entity.glyph;
                foreground = glyph.fg;
              } else if (hasWarning && centerPoint.canAttack(entity)) {
                var difficulty = centerPoint.calcDifficulty(entity);
                glyph = { key: difficulty };
                foreground = warningColors[difficulty];
              }
            }
          }

          var projectile = projectileCache[x + ',' + y];
          if (baseIsVisible && projectile) {
            glyph = projectile.glyph;
            foreground = glyph.fg;
          }

          // visible things have a black background
          if (baseIsVisible) {
            background = _rotJs2['default'].Color.fromString('#333');
          }

          var light = lightingCache[x + ',' + y];
          if (baseIsVisible && light) {
            background = _rotJs2['default'].Color.add(light, ambientLight);
          }

          // prevent taking color away from things that have it
          if (!baseIsVisible && !foreground) {
            foreground = '#555';
          }

          display.draw(gameOffset.x + x - offset.x, gameOffset.y + y - offset.y, glyph.key, foreground, _rotJs2['default'].Color.toRGB(background));
        }
      }

      cache = null;
      projectileCache = null;
      lightingCache = null;
    }
  }, {
    key: 'render',
    value: function render() {
      var livingPlayers = _lodash2['default'].reject(_initGamestate2['default'].players, function (player) {
        return player.hp.atMin();
      });
      var playerString = _initGamestate2['default'].players.length > 1 ? ' (' + livingPlayers.length + '/' + _initGamestate2['default'].players.length + ')' : '';
      (0, _libPageTitle2['default'])('Dungeoneering' + playerString);
    }
  }, {
    key: 'redrawHp',
    value: function redrawHp(display, foreground, player, string) {
      var x = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];
      var y = arguments.length <= 5 || arguments[5] === undefined ? _constantsSettings2['default'].screen.height - 1 : arguments[5];

      var str = '' + player.hp.cur;
      var index = string.indexOf('HP:' + player.hp.cur) + 3;
      var length = str.length;
      var strIdx = 0;
      for (var i = index; i < index + length; i++) {
        display.draw(x + i, y, str[strIdx], foreground);
      }
    }
  }]);

  return GameScreen;
})(_screen.Screen);

exports.GameScreen = GameScreen;

var SingleGameScreen = (function (_GameScreen) {
  _inherits(SingleGameScreen, _GameScreen);

  function SingleGameScreen() {
    _classCallCheck(this, SingleGameScreen);

    _get(Object.getPrototypeOf(SingleGameScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SingleGameScreen, null, [{
    key: 'drawMessages',
    value: function drawMessages(display, player) {

      if (!_initGamestate2['default'].messages) return;

      for (var y = 0; y < 3; y++) {

        for (var x = 0; x < _constantsSettings2['default'].screen.width; x++) {
          display.drawText(x, y, ' ');
        }
      }

      for (var y = 0; y < 3; y++) {
        var messageObj = _initGamestate2['default'].messages[y];
        if (!messageObj || messageObj.turn < player.currentTurn - 4) continue;
        display.drawText(0, y, messageObj.message);
      }

      _messageHandler2['default'].viewAllMessages();
    }
  }, {
    key: 'drawHUD',
    value: function drawHUD(display, player) {
      var tag = player.name + ' the ' + player.getAlign() + ' ' + player.gender + ' level ' + player.level + ' ' + player.race + ' ' + player.professionInst.title + ' (' + player.xp.cur + '/' + player.xp.max + ')';
      var stats = 'STR:' + player.getStr() + ' DEX:' + player.getDex() + ' CON:' + player.getCon() + ' INT:' + player.getInt() + ' WIS:' + player.getWis() + ' CHA:' + player.getCha() + ' AC:' + player.getAC();
      var miscInfo = 'Floor:' + (1 + _initGamestate2['default'].currentFloor) + ' (' + _initGamestate2['default'].world.tiles[_initGamestate2['default'].currentFloor].shortMapName + ') $:' + player.gold + ' HP:' + player.hp.cur + '/' + player.hp.max + ' MP:' + player.mp.cur + '/' + player.mp.max + ' Turn:' + player.currentTurn;

      for (var y = 1; y <= 3; y++) {
        for (var x = 0; x < _constantsSettings2['default'].screen.width; x++) {
          display.drawText(x, _constantsSettings2['default'].screen.height - y, ' ');
        }
      }

      display.drawText(0, _constantsSettings2['default'].screen.height - 3, tag);
      display.drawText(0, _constantsSettings2['default'].screen.height - 2, stats);
      display.drawText(0, _constantsSettings2['default'].screen.height - 1, miscInfo);

      if (player.hp.ltePercent(20)) {
        this.redrawHp(display, '#7f0000', player, miscInfo);
      } else if (player.hp.ltePercent(50)) {
        this.redrawHp(display, '#ffd700', player, miscInfo);
      }
    }
  }, {
    key: 'render',
    value: function render(display) {
      _get(Object.getPrototypeOf(SingleGameScreen), 'render', this).call(this, display);
      var player = _initGamestate2['default'].players[0];
      this.drawTiles(display, player);
      this.drawHUD(display, player);
      this.drawMessages(display, player);
    }
  }, {
    key: 'split',
    get: function get() {
      return SplitGameScreen;
    }
  }]);

  return SingleGameScreen;
})(GameScreen);

exports.SingleGameScreen = SingleGameScreen;

var SplitGameScreen = (function (_GameScreen2) {
  _inherits(SplitGameScreen, _GameScreen2);

  function SplitGameScreen() {
    _classCallCheck(this, SplitGameScreen);

    _get(Object.getPrototypeOf(SplitGameScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SplitGameScreen, null, [{
    key: 'enter',
    value: function enter() {
      this.width = _initGamestate2['default'].players.length > 2 ? _constantsSettings2['default'].screen.width / 2 : _constantsSettings2['default'].screen.width;
      this.height = _constantsSettings2['default'].screen.height / 2;

      this.tlCoords = [{ x: 0, y: 0 }, { x: 0, y: this.height + 1 }, { x: this.width + 1, y: 0 }, { x: this.width + 1, y: this.height + 1 }];

      this.hudCoords = [{ x: 0, y: this.height - 1 }, { x: 0, y: this.height * 2 - 1 }, { x: this.width + 1, y: this.height - 1 }, { x: this.width + 1, y: this.height * 2 - 1 }];
    }
  }, {
    key: 'render',
    value: function render(display) {
      var _this = this;

      _get(Object.getPrototypeOf(SplitGameScreen), 'render', this).call(this, display);

      _lodash2['default'].each(_initGamestate2['default'].players, function (player, i) {
        _this.drawTiles(display, player, { width: _this.width, height: _this.height, offset: _this.getScreenOffsets(player, _this.width, _this.height), gameOffset: _this.tlCoords[i] });
        _this.drawHUDs(display, player, _this.hudCoords[i]);
      });

      this.drawBorder(display);
    }
  }, {
    key: 'drawBorder',
    value: function drawBorder(display) {

      var middleY = _constantsSettings2['default'].screen.height / 2;
      for (var i = 0; i < _constantsSettings2['default'].screen.width; i++) {
        display.draw(i, middleY, '=');
      }

      if (_initGamestate2['default'].players.length > 2) {
        var middleX = _constantsSettings2['default'].screen.width / 2;
        for (var i = 0; i < _constantsSettings2['default'].screen.height; i++) {
          display.draw(middleX, i, '‖');
        }
      }

      this.drawLeftCenterText(display, middleY, 'Floor:' + (_initGamestate2['default'].currentFloor + 1) + ' (' + _initGamestate2['default'].world.tiles[_initGamestate2['default'].currentFloor].shortMapName + ')');
      this.drawRightCenterText(display, middleY, 'Turns:' + _lodash2['default'].max(_initGamestate2['default'].players, 'currentTurn').currentTurn);
    }
  }, {
    key: 'stripTo3',
    value: function stripTo3(string) {
      return string.substring(0, 3);
    }
  }, {
    key: 'drawHUDs',
    value: function drawHUDs(display, player, hudCoords) {
      var x = hudCoords.x;
      var y = hudCoords.y;

      var topString = player.name + ' ' + this.stripTo3(player.getAlign()) + ' ' + this.stripTo3(player.gender) + ' ' + this.stripTo3(player.race) + ' ' + this.stripTo3(player.profession);
      var bottomString = 'Lv.' + player.level + ' (' + player.xp.cur + '/' + player.xp.max + ') HP:' + player.hp.cur + '/' + player.hp.max + ' MP:' + player.mp.cur + '/' + player.mp.max;

      display.drawText(x, y - 1, topString);
      display.drawText(x, y, bottomString);

      if (player.hp.ltePercent(20)) {
        this.redrawHp(display, '#7f0000', player, bottomString, x, y);
      } else if (player.hp.ltePercent(50)) {
        this.redrawHp(display, '#ffd700', player, bottomString, x, y);
      }
    }
  }, {
    key: 'split',
    get: function get() {
      return SingleGameScreen;
    }
  }]);

  return SplitGameScreen;
})(GameScreen);

exports.SplitGameScreen = SplitGameScreen;

},{"../../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/page-title":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/page-title.js","../message-handler":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/message-handler.js","../screen":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screen.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/load.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _screen = require('../screen');

var LoadScreen = (function (_Screen) {
  _inherits(LoadScreen, _Screen);

  function LoadScreen() {
    _classCallCheck(this, LoadScreen);

    _get(Object.getPrototypeOf(LoadScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(LoadScreen, null, [{
    key: 'enter',
    value: function enter(display) {
      var _this = this;

      this.flicker = 0;

      var dotStatus = ['.  ', '.. ', '...', ' ..', '  .'];

      this.interval = setInterval(function () {
        display.clear();
        _this.render(display);

        _this.drawCenterText(display, 12, 'Generating ' + dotStatus[_this.flicker]);

        _this.flicker = ++_this.flicker % dotStatus.length;
      }, 500);
    }
  }, {
    key: 'exit',
    value: function exit() {
      window.clearInterval(this.interval);
    }
  }, {
    key: 'render',
    value: function render(display) {
      this.drawCenterText(display, 11, '-Welcome to Roguathia-');
    }
  }]);

  return LoadScreen;
})(_screen.Screen);

exports.LoadScreen = LoadScreen;

},{"../screen":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screen.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/newgame.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _screen = require('../screen');

var _initGameStarter = require('../../init/game-starter');

var _initGameStarter2 = _interopRequireDefault(_initGameStarter);

// this exists solely to transition and start a new game. I'm bad. :(

var NewGameScreen = (function (_Screen) {
  _inherits(NewGameScreen, _Screen);

  function NewGameScreen() {
    _classCallCheck(this, NewGameScreen);

    _get(Object.getPrototypeOf(NewGameScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(NewGameScreen, null, [{
    key: 'enter',
    value: function enter() {
      (0, _initGameStarter2['default'])();
    }
  }]);

  return NewGameScreen;
})(_screen.Screen);

exports['default'] = NewGameScreen;
module.exports = exports['default'];

},{"../../init/game-starter":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/game-starter.js","../screen":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screen.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/respawn.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _constantsSettings = require('../../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var _screen = require('../screen');

var _newgame = require('./newgame');

var _newgame2 = _interopRequireDefault(_newgame);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _libPageTitle = require('../../lib/page-title');

var _libPageTitle2 = _interopRequireDefault(_libPageTitle);

var RespawnScreen = (function (_Screen) {
  _inherits(RespawnScreen, _Screen);

  function RespawnScreen() {
    _classCallCheck(this, RespawnScreen);

    _get(Object.getPrototypeOf(RespawnScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(RespawnScreen, null, [{
    key: 'enter',
    value: function enter() {
      // would be nice if it redrew properly without needing duplicates in the list
      this.phases = ['/', '/', '|', '|', '\\', '\\', '-', '-'];
      this.stars = [];
      this.timer = 15 - _initGamestate2['default'].extra.respawnTime;

      // one tick per star move, 4 ticks = new star and timer countdown
      this.ticks = this.timer * this.phases.length;
    }
  }, {
    key: 'addStar',
    value: function addStar(x, y, length) {
      var _this = this;

      var minX = x - 1;
      var maxX = x + length + 1;
      var minY = y - 1;
      var maxY = y + 1;

      var inBadZone = true;
      var star = null;

      var distBetween = function distBetween(me, target) {
        var a = target.x - me.x;
        var b = target.y - me.y;
        return Math.sqrt(a * a + b * b);
      };

      var _loop = function () {
        var myX = _rotJs2['default'].RNG.getUniformInt(0, _constantsSettings2['default'].screen.width);
        var myY = _rotJs2['default'].RNG.getUniformInt(0, _constantsSettings2['default'].screen.height);
        var me = { x: myX, y: myY };

        if (_lodash2['default'].filter(_this.stars, function (star) {
          return distBetween(me, star) < 4;
        }).length !== 0 || myX >= minX && myX <= maxX && myY >= minY && myY <= maxY) {
          return 'continue';
        }

        inBadZone = false;
        star = { x: myX, y: myY, phase: _rotJs2['default'].RNG.getUniformInt(0, _this.phases.length - 1) };
      };

      while (inBadZone) {
        var _ret = _loop();

        if (_ret === 'continue') continue;
      }

      this.stars.push(star);
    }
  }, {
    key: 'drawStars',
    value: function drawStars(display) {
      var _this2 = this;

      _lodash2['default'].each(this.stars, function (star) {
        display.draw(star.x, star.y, _this2.phases[star.phase]);
        star.phase++;
        if (star.phase > _this2.phases.length - 1) {
          star.phase = 0;
        }
      });
    }
  }, {
    key: 'render',
    value: function render(display) {
      var _this3 = this;

      display.clear();
      var text = 'Respawning in ' + this.timer + ' seconds...';

      var _drawCenterText = this.drawCenterText(display, 11, text);

      var x = _drawCenterText.x;
      var y = _drawCenterText.y;

      (0, _libPageTitle2['default'])('Respawning (' + this.timer + 's)');

      if (this.ticks % this.phases.length === 0) {
        this.addStar(x, y, text.length);
        this.timer--;
      }

      this.ticks--;

      if (this.ticks <= 0) {
        _initGamestate2['default'].game.safeSwitchScreen(this, _newgame2['default']);
        return;
      }

      this.drawStars(display);
      setTimeout(function () {
        return _this3.render(display);
      }, 1000 / this.phases.length);
    }
  }]);

  return RespawnScreen;
})(_screen.Screen);

exports['default'] = RespawnScreen;
module.exports = exports['default'];

},{"../../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/page-title":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/page-title.js","../screen":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screen.js","./newgame":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/newgame.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/vanquished.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _screen = require('../screen');

var _conduct = require('./conduct');

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var SingleVanquishedScreen = (function (_SingleScrollingScreen) {
  _inherits(SingleVanquishedScreen, _SingleScrollingScreen);

  function SingleVanquishedScreen() {
    _classCallCheck(this, SingleVanquishedScreen);

    _get(Object.getPrototypeOf(SingleVanquishedScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SingleVanquishedScreen, null, [{
    key: 'enter',
    value: function enter() {
      _get(Object.getPrototypeOf(SingleVanquishedScreen), 'enter', this).call(this);
      var target = this.getMainPlayer();
      var killHash = target.conquest;
      var sortedKills = (0, _lodash2['default'])(killHash).keys().map(function (mon) {
        return { name: mon, num: killHash[mon] };
      }).sortBy('name').value();
      this.scrollContent = _lodash2['default'].map(sortedKills, function (kill) {
        return _lodash2['default'].padLeft(kill.num, 4) + ' ' + kill.name;
      });
      var totalKills = _lodash2['default'].reduce(sortedKills, function (prev, cur) {
        return prev + cur.num;
      }, 0);
      this.title = target.name + '\'s Conquest (' + sortedKills.length + ' types|' + totalKills + ' total)'; // shorten this for splitscreen
      if (!this.scrollContent.length) {
        this.scrollContent = ['No kills.'];
      }
      this.nextScreen = _conduct.SingleConductScreen;
    }

    // static get split() { return SplitVanquishedScreen; }
  }]);

  return SingleVanquishedScreen;
})(_screen.SingleScrollingScreen);

exports.SingleVanquishedScreen = SingleVanquishedScreen;

var SplitVanquishedScreen = (function (_SplitScrollingScreen) {
  _inherits(SplitVanquishedScreen, _SplitScrollingScreen);

  function SplitVanquishedScreen() {
    _classCallCheck(this, SplitVanquishedScreen);

    _get(Object.getPrototypeOf(SplitVanquishedScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SplitVanquishedScreen, null, [{
    key: 'enter',
    value: function enter() {
      var _this = this;

      _get(Object.getPrototypeOf(SplitVanquishedScreen), 'enter', this).call(this);

      this.scrollContent = [];
      this.title = [];

      _lodash2['default'].each(_initGamestate2['default'].players, function (target, i) {
        var killHash = target.conquest;
        var sortedKills = (0, _lodash2['default'])(killHash).keys().map(function (mon) {
          return { name: mon, num: killHash[mon] };
        }).sortBy('name').value();
        _this.scrollContent[i] = _lodash2['default'].map(sortedKills, function (kill) {
          return _lodash2['default'].padLeft(kill.num, 4) + ' ' + kill.name;
        });
        var totalKills = _lodash2['default'].reduce(sortedKills, function (prev, cur) {
          return prev + cur.num;
        }, 0);
        _this.title[i] = target.name + '\'s Conquest (' + sortedKills.length + ' types|' + totalKills + ' total)'; // shorten this for splitscreen
        if (!_this.scrollContent[i].length) {
          _this.scrollContent[i] = ['No kills.'];
        }
      });

      this.nextScreen = _conduct.SplitConductScreen;
    }

    // static get split() { return SingleVanquishedScreen; }
  }]);

  return SplitVanquishedScreen;
})(_screen.SplitScrollingScreen);

exports.SplitVanquishedScreen = SplitVanquishedScreen;

},{"../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../screen":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screen.js","./conduct":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/conduct.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/win.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _screen = require('../screen');

var _vanquished = require('./vanquished');

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _libPageTitle = require('../../lib/page-title');

var _libPageTitle2 = _interopRequireDefault(_libPageTitle);

var WinScreen = (function (_Screen) {
  _inherits(WinScreen, _Screen);

  function WinScreen() {
    _classCallCheck(this, WinScreen);

    _get(Object.getPrototypeOf(WinScreen.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(WinScreen, null, [{
    key: 'enter',
    value: function enter() {
      _initGamestate2['default'].game.engine.lock();
      this.changeScreenWithDelay({ single: _vanquished.SingleVanquishedScreen, multi: _vanquished.SplitVanquishedScreen }, 5000);
    }
  }, {
    key: 'render',
    value: function render(display) {
      this.drawCenterText(display, 11, 'You have won!');
      this.drawCenterText(display, 12, _initGamestate2['default'].winCondition.message);
      this.drawCenterText(display, 13, 'You earned ' + _initGamestate2['default'].spEarned + ' SP, ' + _initGamestate2['default'].kpEarned + ' KP and ' + _initGamestate2['default'].vpEarned + ' VP.');
      (0, _libPageTitle2['default'])('Victory');
    }
  }]);

  return WinScreen;
})(_screen.Screen);

exports['default'] = WinScreen;
module.exports = exports['default'];

},{"../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../../lib/page-title":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/page-title.js","../screen":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screen.js","./vanquished":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/vanquished.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/debug.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _gamestate = require('./gamestate');

var _gamestate2 = _interopRequireDefault(_gamestate);

window.GameState = _gamestate2['default'];

var debugInitialized = false;

exports['default'] = function () {
  if (debugInitialized) return;
  debugInitialized = true;

  document.body.addEventListener('keydown', function (e) {
    if (e.keyCode !== _rotJs2['default'].VK_P) return;

    _gamestate2['default'].isPaused = !_gamestate2['default'].isPaused;

    if (_gamestate2['default'].isPaused) {
      _gamestate2['default'].game.engine.lock();
    } else {
      _gamestate2['default'].game.engine.unlock();
    }
  });

  document.body.addEventListener('keydown', function (e) {
    if (e.keyCode !== _rotJs2['default'].VK_R) return;

    _gamestate2['default'].renderAll = !_gamestate2['default'].renderAll;
  });

  document.body.addEventListener('keydown', function (e) {
    if (e.keyCode !== _rotJs2['default'].VK_L) return;

    _gamestate2['default'].game.changeSplitScreen();
  });

  /*
  document.body.addEventListener('keydown', (e) => {
    if(e.keyCode !== ROT.VK_D) return;
     GameState.players[0].descend();
  });
  */

  document.body.addEventListener('keydown', function (e) {
    if (e.keyCode !== _rotJs2['default'].VK_M) return;

    _gamestate2['default'].manualMove = !_gamestate2['default'].manualMove;
    if (!_gamestate2['default'].manualMove) {
      _gamestate2['default'].game.engine.unlock();
    }
  });

  document.body.addEventListener('keydown', function (e) {
    var _offsets;

    var offsets = (_offsets = {}, _defineProperty(_offsets, _rotJs2['default'].VK_W, { x: 0, y: -1 }), _defineProperty(_offsets, _rotJs2['default'].VK_S, { x: 0, y: 1 }), _defineProperty(_offsets, _rotJs2['default'].VK_A, { x: -1, y: 0 }), _defineProperty(_offsets, _rotJs2['default'].VK_D, { x: 1, y: 0 }), _defineProperty(_offsets, _rotJs2['default'].VK_NUMPAD8, { x: 0, y: -1 }), _defineProperty(_offsets, _rotJs2['default'].VK_NUMPAD2, { x: 0, y: 1 }), _defineProperty(_offsets, _rotJs2['default'].VK_NUMPAD4, { x: -1, y: 0 }), _defineProperty(_offsets, _rotJs2['default'].VK_NUMPAD6, { x: 1, y: 0 }), _defineProperty(_offsets, _rotJs2['default'].VK_NUMPAD7, { x: -1, y: -1 }), _defineProperty(_offsets, _rotJs2['default'].VK_NUMPAD3, { x: 1, y: 1 }), _defineProperty(_offsets, _rotJs2['default'].VK_NUMPAD1, { x: -1, y: 1 }), _defineProperty(_offsets, _rotJs2['default'].VK_NUMPAD9, { x: 1, y: -1 }), _offsets);

    if (!offsets[e.keyCode] || !_gamestate2['default'].manualMove) return;

    var player = _gamestate2['default'].players[0];
    player.moveTo(player.x + offsets[e.keyCode].x, player.y + offsets[e.keyCode].y);
    _gamestate2['default'].game.engine.unlock();
  });
};

module.exports = exports['default'];

},{"./gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/game-starter.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _game = require('./game');

var _game2 = _interopRequireDefault(_game);

var _gamestate = require('./gamestate');

var _gamestate2 = _interopRequireDefault(_gamestate);

var _displayScreensLoad = require('../display/screens/load');

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

exports['default'] = function () {
  Array.prototype.slice.call(document.getElementsByTagName('canvas')).forEach(function (item) {
    item.parentNode.removeChild(item);
  });

  (0, _gamestate.FreshGame)();
  var game = _gamestate2['default'].game = new _game2['default']();
  document.getElementById('game-area').appendChild(game.display.getContainer());
  game.switchScreen(_displayScreensLoad.LoadScreen);

  setTimeout(function () {
    game.setup();
    (0, _debug2['default'])();
  }, 300);
};

module.exports = exports['default'];

},{"../display/screens/load":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/load.js","./debug":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/debug.js","./game":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/game.js","./gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/game.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var _worldgenWorld = require('../worldgen/world');

var _worldgenWorld2 = _interopRequireDefault(_worldgenWorld);

var _gamestate = require('./gamestate');

var _gamestate2 = _interopRequireDefault(_gamestate);

var _displayScreensGame = require('../display/screens/game');

var _displayScreensDead = require('../display/screens/dead');

var _displayScreensDead2 = _interopRequireDefault(_displayScreensDead);

var _displayScreensWin = require('../display/screens/win');

var _displayScreensWin2 = _interopRequireDefault(_displayScreensWin);

var _definitionsPlayer = require('../definitions/player');

var _definitionsPlayer2 = _interopRequireDefault(_definitionsPlayer);

var _constantsVictories = require('../constants/victories');

var Victories = _interopRequireWildcard(_constantsVictories);

var _libLogger = require('../lib/logger');

var _libLogger2 = _interopRequireDefault(_libLogger);

var Game = (function () {
  function Game() {
    var _this = this;

    _classCallCheck(this, Game);

    this.display = new _rotJs2['default'].Display({
      fontSize: 14,
      fontStyle: 'bold',
      font: 'Fixedsys500c',
      width: _constantsSettings2['default'].screen.width,
      height: _constantsSettings2['default'].screen.height
    });
    this.currentScreen = null;

    this.listeners = {};

    var bindToScreen = function bindToScreen(event) {
      var listener = window.addEventListener(event, function (e) {
        if (_this.currentScreen === null) return;

        _this.currentScreen.handleInput(event, e);
      });

      _this.listeners[event] = listener;
    };

    _lodash2['default'].each(['keydown', 'keypress'], function (event) {
      return bindToScreen(event);
    });
  }

  _createClass(Game, [{
    key: 'refresh',
    value: function refresh() {
      if (!this.display) return;
      this.display.clear();
      this.currentScreen.render(this.display);
    }
  }, {
    key: 'gameOver',
    value: function gameOver() {
      _gamestate2['default'].emit('gameend.gameover');
      this.switchScreen(_displayScreensDead2['default']);
    }
  }, {
    key: 'checkWin',
    value: function checkWin() {
      var didWin = _gamestate2['default'].winCondition.check();
      if (didWin) this.win();
      return didWin;
    }
  }, {
    key: 'win',
    value: function win() {
      _gamestate2['default'].emit('gameend.victory');
      this.switchScreen(_displayScreensWin2['default']);
    }
  }, {
    key: 'safeSwitchScreen',
    value: function safeSwitchScreen(me, newScreen) {
      if (this.currentScreen !== me) return;
      this.switchScreen(newScreen);
    }
  }, {
    key: 'changeSplitScreen',
    value: function changeSplitScreen() {
      if (!this.currentScreen.split || _gamestate2['default'].players.length === 1) return;
      _gamestate2['default'].splitScreen = !_gamestate2['default'].splitScreen;
      this.switchScreen(this.currentScreen.split);
    }
  }, {
    key: 'switchScreen',
    value: function switchScreen(screen) {
      if (this.currentScreen) {
        this.currentScreen.exit(this.display);
      }

      this.currentScreen = screen;

      if (this.currentScreen) {
        this.currentScreen.enter(this.display);
        this.refresh();
      }
    }
  }, {
    key: 'setup',
    value: function setup() {
      this.scheduler = new _rotJs2['default'].Scheduler.Speed();
      this.engine = new _rotJs2['default'].Engine(this.scheduler);

      /*    if(false) {
            this.loadOldData();
            return;
          }
      */

      this.startNewGame();
    }
  }, {
    key: 'loadOldData',
    value: function loadOldData() {}
  }, {
    key: 'startNewGame',
    value: function startNewGame() {
      var _this2 = this;

      _gamestate2['default'].winCondition = (0, _lodash2['default'])(Victories).values().sample();

      _gamestate2['default'].world = new _worldgenWorld2['default']();
      _gamestate2['default'].world.generateWorld({ depth: _gamestate2['default'].upgrades.depth, height: _gamestate2['default'].upgrades.squarity, width: _gamestate2['default'].upgrades.squarity });
      var zeroStartStairs = _gamestate2['default'].world.stairs[0].up;

      var playerLocations = _gamestate2['default'].world.getValidTilesInRange(zeroStartStairs[0], zeroStartStairs[1], 0, 2, function (tile) {
        return tile.glyph.key === '.';
      });

      if (_gamestate2['default'].players.length > 0) {
        (0, _libLogger2['default'])('Game', 'A second game started somehow.');
      }

      var spawnedPlayers = Math.min(4, Math.max(1, _gamestate2['default'].extra.players));

      for (var i = 0; i < spawnedPlayers; i++) {
        var startTile = playerLocations.shift();
        var player = new _definitionsPlayer2['default'](0, 0, 0, { template: _gamestate2['default'].templates[i] || {} });

        _gamestate2['default'].world.moveEntity(player, startTile.x, startTile.y, 0);
        _gamestate2['default'].players.push(player);
      }

      _gamestate2['default'].livingPlayers = _gamestate2['default'].players.length;
      _gamestate2['default'].playerTurnsTaken = 0;

      this.engine.start();
      _gamestate2['default'].emit('start');

      setTimeout(function () {
        if (_this2.currentScreen.name === 'DeadScreen') return; // turn 1 death (you spawned with an amulet of strangulation, etc)
        _this2.switchScreen(_displayScreensGame.SingleGameScreen);
        if (_gamestate2['default'].players.length > 1) _this2.changeSplitScreen();
      }, 100);
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      var _this3 = this;

      this.display._data = null;
      this.display = null;
      this.currentScreen = null;
      this.scheduler = null;
      this.engine = null;

      _lodash2['default'].each(['keydown', 'keypress'], function (event) {
        return window.removeEventListener(event, _this3.listeners[event]);
      });
      this.listeners = null;
    }
  }]);

  return Game;
})();

exports['default'] = Game;
module.exports = exports['default'];

},{"../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","../constants/victories":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/victories.js","../definitions/player":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/player.js","../display/screens/dead":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/dead.js","../display/screens/game":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/game.js","../display/screens/win":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/display/screens/win.js","../lib/logger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js","../worldgen/world":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/world.js","./gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _constantsSettings = require('../constants/settings');

var _constantsSettings2 = _interopRequireDefault(_constantsSettings);

var _gameupgrades = require('./gameupgrades');

var _eventemitter2 = require('eventemitter2');

var GameState = (function (_EventEmitter2) {
  _inherits(GameState, _EventEmitter2);

  function GameState() {
    _classCallCheck(this, GameState);

    _get(Object.getPrototypeOf(GameState.prototype), 'constructor', this).call(this);
    this.reset();
  }

  _createClass(GameState, [{
    key: 'reset',
    value: function reset() {
      if (this.players) {
        _lodash2['default'].each(this.players, function (p) {
          return p.cleanUp();
        });
      }

      if (this.world) {
        this.world.cleanUp();
        this.world = null;
      }

      if (this.game) {
        this.game.cleanUp();
        this.game = null;
      }

      this.identification = {};
      this._idMap = {};
      this.players = [];
      this.messages = [];
      this.projectiles = [];
      this.monsters = [];
      this.splitScreen = false;
      this.currentFloor = 0;

      this.loadExternalOptions();
    }
  }, {
    key: 'loadExternalOptions',
    value: function loadExternalOptions() {
      var _this = this;

      var GameUpgrades = (0, _gameupgrades.Current)();

      this.upgrades = {};
      _lodash2['default'].keys(_constantsSettings2['default'].upgrades).forEach(function (key) {
        _this.upgrades[key] = _constantsSettings2['default'].upgrades[key] + ~ ~GameUpgrades.dungeon[key];
        if (_constantsSettings2['default'].upgradesMax[key]) {
          _this.upgrades[key] = Math.min(_constantsSettings2['default'].upgradesMax[key], _this.upgrades[key]);
        }
      });

      this.templates = GameUpgrades.templates;
      this.unlocked = GameUpgrades.unlocked;
      this.extra = GameUpgrades.extra;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return JSON.stringify(_lodash2['default'].omit(this, 'game'));
    }
  }, {
    key: 'vpEarned',
    get: function get() {
      return this.winCondition.check() ? this.winCondition.vp() : 0;
    }
  }, {
    key: 'kpEarned',
    get: function get() {
      return _lodash2['default'].reduce(this.players, function (prev, cur) {
        return prev + cur.totalKpEarned;
      }, 0);
    }
  }, {
    key: 'spEarned',
    get: function get() {
      return _lodash2['default'].reduce(this.players, function (prev, cur) {
        return prev + cur.getScore();
      }, 0);
    }
  }]);

  return GameState;
})(_eventemitter2.EventEmitter2);

var exportedState = window.GameState = new GameState();

var FreshGame = function FreshGame() {
  for (var key in exportedState) {
    if (!exportedState.hasOwnProperty(key) || _lodash2['default'].contains(['_events', 'newListener'], key)) continue;
    delete exportedState[key];
  }

  exportedState.reset();
};

exports.FreshGame = FreshGame;
exports['default'] = exportedState;

},{"../constants/settings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/settings.js","./gameupgrades":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gameupgrades.js","eventemitter2":"/Users/seiyria/GitHub/Roguathia/node_modules/eventemitter2/lib/eventemitter2.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gameupgrades.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var baseState = {
  dungeon: {
    itemsInDungeon: 0,
    itemDropChance: 0,
    altarSpawnChance: 0,
    throneSpawnChance: 0,
    graveSpawnChance: 0,
    fountainSpawnChance: 0,
    sinkSpawnChance: 0,
    monsterLimit: 10,
    maxDifficulty: 5,
    depth: 10,
    squarity: 70

    /* itemDropChance: 100,
     altarSpawnChance: 1000,
     templeSpawnChance: 100,
     throneSpawnChance: 1000,
     throneRoomSpawnChance: 100,
     graveSpawnChance: 1000,
     graveyardSpawnChance: 100,
     fountainSpawnChance: 1000,
     oracleRoomChance: 100,
     sinkSpawnChance: 1000,
     bathroomSpawnChance: 100*/

  },

  templates: [],

  unlocked: {
    race: ['Elf', 'Human', 'Gnome'],
    profession: ['Tourist']
  },

  selectable: {
    race: [],
    profession: []
  },

  extra: {
    players: 1,
    respawnTime: 0
  }
};

var NewState = function NewState() {
  return _lodash2['default'].cloneDeep(baseState);
};

exports.NewState = NewState;
var curState = NewState();

var SetState = function SetState(newState) {
  return curState = newState;
};

exports.SetState = SetState;
var Current = function Current() {
  return curState;
};

exports.Current = Current;
exports['default'] = curState;

},{"lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/init.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _gameStarter = require('./game-starter');

var _gameStarter2 = _interopRequireDefault(_gameStarter);

var gameStarted = false;

var StartGameCycle = function StartGameCycle() {
  if (gameStarted) return;

  if (!_rotJs2['default'].isSupported()) {
    alert('rot.js isn\'t supported :(');
  } else {
    gameStarted = true;
    (0, _gameStarter2['default'])();
  }
};
exports.StartGameCycle = StartGameCycle;

},{"./game-starter":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/game-starter.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/default-calculations.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var AC = function AC(item) {
  var ac = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
  return item.buc * -ac - item.enchantment;
};
exports.AC = AC;

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _diceJs = require('dice.js');

var _diceJs2 = _interopRequireDefault(_diceJs);

exports['default'] = function (roll) {
  return +_diceJs2['default'].roll(roll);
};

module.exports = exports['default'];

},{"dice.js":"/Users/seiyria/GitHub/Roguathia/node_modules/dice.js/src/dice.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/directional-probability.js":[function(require,module,exports){

// thank you based stackexchange http://codereview.stackexchange.com/a/97310/64362
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var INDICES = [1, 2, 3, 6, 9, 8, 7, 4];
var PROBABILITIES = [10000, 2000, 500, 50, 10, 50, 500, 2000];

exports["default"] = function (lastNumpadDirection) {
  var lastIndexDirection = INDICES.indexOf(lastNumpadDirection);
  var shifted = PROBABILITIES.slice(PROBABILITIES.length - lastIndexDirection).concat(PROBABILITIES.slice(0, PROBABILITIES.length - lastIndexDirection));
  var result = {};
  for (var i = 0, l = INDICES.length; i < l; i++) {
    result[INDICES[i]] = shifted[i];
  }
  return result;
};

module.exports = exports["default"];

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/gen-id.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var id = 0;

exports["default"] = function () {
  return id++;
};

module.exports = exports["default"];

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _bragiBrowser = require('bragi-browser');

var _bragiBrowser2 = _interopRequireDefault(_bragiBrowser);

// remove extra log line
_bragiBrowser2['default'].transports.get('Console').property({ showMeta: false });

exports['default'] = function (group, message) {
  var isError = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  if (isError) console.error(new Error(message).stack);
  _bragiBrowser2['default'].log(group, message);
};

module.exports = exports['default'];

},{"bragi-browser":"/Users/seiyria/GitHub/Roguathia/node_modules/bragi-browser/lib/bragi.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/number-range.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NumberRange = (function () {
  function NumberRange(min, cur, max) {
    _classCallCheck(this, NumberRange);

    this.min = min;
    this.max = max;
    this._set(cur);
  }

  _createClass(NumberRange, [{
    key: "atMin",
    value: function atMin() {
      return this.cur === this.min;
    }
  }, {
    key: "atMax",
    value: function atMax() {
      return this.cur === this.max;
    }
  }, {
    key: "toMin",
    value: function toMin() {
      this.cur = this.min;
    }
  }, {
    key: "toMax",
    value: function toMax() {
      this.cur = this.max;
    }
  }, {
    key: "percent",
    value: function percent() {
      return ~ ~(this.cur / this.max * 100);
    }
  }, {
    key: "gtPercent",
    value: function gtPercent(pct) {
      return this.percent() > pct;
    }
  }, {
    key: "ltPercent",
    value: function ltPercent(pct) {
      return this.percent() < pct;
    }
  }, {
    key: "ePercent",
    value: function ePercent(pct) {
      return this.percent() === pct;
    }
  }, {
    key: "gtePercent",
    value: function gtePercent(pct) {
      return this.percent() >= pct;
    }
  }, {
    key: "ltePercent",
    value: function ltePercent(pct) {
      return this.percent() <= pct;
    }
  }, {
    key: "gt",
    value: function gt(num) {
      return this.cur > num;
    }
  }, {
    key: "lt",
    value: function lt(num) {
      return this.cur < num;
    }
  }, {
    key: "e",
    value: function e(num) {
      return this.cur === num;
    }
  }, {
    key: "gte",
    value: function gte(num) {
      return this.cur >= num;
    }
  }, {
    key: "lte",
    value: function lte(num) {
      return this.cur <= num;
    }
  }, {
    key: "_set",
    value: function _set(num) {
      this.cur = Math.max(this.min, Math.min(this.max, num));
    }
  }, {
    key: "add",
    value: function add(num) {
      this._set(num + this.cur);
    }
  }, {
    key: "sub",
    value: function sub(num) {
      this.add(-num);
    }
  }]);

  return NumberRange;
})();

exports["default"] = NumberRange;
module.exports = exports["default"];

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/page-title.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports["default"] = function (newTitle) {
  document.title = newTitle + " - Roguathia";
};

module.exports = exports["default"];

},{}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/rot-extensions.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var WeightedExtension = function WeightedExtension(hash) {
  var filterKey = arguments.length <= 1 || arguments[1] === undefined ? 'probability' : arguments[1];
  var predicate = arguments.length <= 2 || arguments[2] === undefined ? function () {
    return true;
  } : arguments[2];

  var valid = (0, _lodash2['default'])(hash).keys().filter(predicate).reduce(function (prev, key) {

    // handle pre-formatted probability hashes
    if (_lodash2['default'].isNumber(hash[key])) {
      prev[key] = hash[key];
    } else {
      prev[key] = hash[key][filterKey];
    }
    return prev;
  }, {});

  var choice = _rotJs2['default'].RNG.getWeightedValue(valid);
  return { key: choice, value: hash[choice] };
};
exports.WeightedExtension = WeightedExtension;

},{"lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/valid-colors.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var Colors = ['#00f', // blue
'#0f0', // green
'#f00', // red
'#0ff', // cyan
'#f0f', // magenta
'#ff0', // yellow

'#aaf', // lightblue
'#afa', // lightgreen
'#faa', // lightred
'#aaf', // lightcyan
'#faf', // lightmagenta
'#ffa' // lightyellow
];

exports.Colors = Colors;
var GetColor = function GetColor() {
  return _lodash2['default'].sample(Colors);
};
exports.GetColor = GetColor;

},{"lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/value-assign.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _diceRoller = require('./dice-roller');

var _diceRoller2 = _interopRequireDefault(_diceRoller);

exports['default'] = function (value, other) {
  if (_lodash2['default'].isString(other) && _lodash2['default'].contains(other, 'd')) {
    return (0, _diceRoller2['default'])(other);
  }
  return other;
};

module.exports = exports['default'];

},{"./dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/generator.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _tiles_all = require('./tiles/_all');

var Tiles = _interopRequireWildcard(_tiles_all);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var featureTypes = [{ name: 'throne', proto: Tiles.Throne }, { name: 'sink', proto: Tiles.Sink }, { name: 'fountain', proto: Tiles.Fountain } /* ,
                                                                                                                                              { name: 'grave' },*/
];

var Generator = (function () {
  function Generator() {
    _classCallCheck(this, Generator);
  }

  _createClass(Generator, null, [{
    key: 'generate',
    value: function generate() {}
  }, {
    key: 'placeTile',
    value: function placeTile(map, type, x, y, z) {
      map[x][y] = new type();
      map[x][y].x = x;
      map[x][y].y = y;
      map[x][y].z = z;
      return map[x][y];
    }
  }, {
    key: 'drawHorizontalWalls',
    value: function drawHorizontalWalls(map, room, z) {
      for (var i = room.getLeft() - 1; i <= room.getRight() + 1; i++) {
        if (!map[i][room.getTop() - 1].glyph.key) {
          this.placeTile(map, Tiles.DungeonHorizontalWall, i, room.getTop() - 1, z);
        }

        if (!map[i][room.getBottom() + 1].glyph.key) {
          this.placeTile(map, Tiles.DungeonHorizontalWall, i, room.getBottom() + 1, z);
        }
      }
    }
  }, {
    key: 'drawVerticalWalls',
    value: function drawVerticalWalls(map, room, z) {
      for (var i = room.getTop(); i <= room.getBottom(); i++) {

        var leftTile = map[room.getLeft() - 1][i].glyph.key;
        var rightTile = map[room.getRight() + 1][i].glyph.key;

        // these tiles take precedence, otherwise some walls look uggo
        if (!leftTile || leftTile === '-') {
          this.placeTile(map, Tiles.DungeonVerticalWall, room.getLeft() - 1, i, z);
        }

        if (!rightTile || rightTile === '-') {
          this.placeTile(map, Tiles.DungeonVerticalWall, room.getRight() + 1, i, z);
        }
      }
    }
  }, {
    key: 'getRandomFloorTile',
    value: function getRandomFloorTile(map) {
      return (0, _lodash2['default'])(map).flatten().filter(function (tile) {
        return tile.glyph.key === '.';
      }).sample();
    }
  }, {
    key: 'getRandomCoordsInRoom',
    value: function getRandomCoordsInRoom(room) {
      return [Math.floor(_rotJs2['default'].RNG.getUniform() * (room._x2 - room._x1)) + room._x1, Math.floor(_rotJs2['default'].RNG.getUniform() * (room._y2 - room._y1)) + room._y1];
    }
  }, {
    key: 'placeStairsInRoom',
    value: function placeStairsInRoom(map, room, z, stairs) {
      var _this = this;

      this.markRoomInelligible(room);
      var setStairs = function setStairs(stairs, x, y) {
        return _this.placeTile(map, stairs, x, y, z);
      };

      var _getRandomCoordsInRoom = this.getRandomCoordsInRoom(room);

      var _getRandomCoordsInRoom2 = _slicedToArray(_getRandomCoordsInRoom, 2);

      var x = _getRandomCoordsInRoom2[0];
      var y = _getRandomCoordsInRoom2[1];

      return setStairs(stairs, x, y);
    }
  }, {
    key: 'getStairs',
    value: function getStairs(z) {
      return _initGamestate2['default'].winCondition.mapStairs(z);
    }
  }, {
    key: 'markRoomInelligible',
    value: function markRoomInelligible(room) {
      if (!room) return;
      room._noMoreFeatures = false;
    }
  }, {
    key: 'attemptFeaturePlacement',
    value: function attemptFeaturePlacement(map, z, rooms) {
      var _this2 = this;

      var validRooms = _lodash2['default'].reject(rooms, function (room) {
        return room._noMoreFeatures;
      });
      _lodash2['default'].each(validRooms, function (room) {
        _lodash2['default'].each(featureTypes, function (type) {
          if (_rotJs2['default'].RNG.getUniformInt(1, 10000) <= _initGamestate2['default'].upgrades[type.name + 'SpawnChance']) {
            var _getRandomCoordsInRoom3 = _this2.getRandomCoordsInRoom(room);

            var _getRandomCoordsInRoom32 = _slicedToArray(_getRandomCoordsInRoom3, 2);

            var x = _getRandomCoordsInRoom32[0];
            var y = _getRandomCoordsInRoom32[1];

            _this2.placeTile(map, type.proto, x, y, z);
            _this2.markRoomInelligible(room);
            return false;
          }
        });
      });
    }
  }]);

  return Generator;
})();

exports['default'] = Generator;
module.exports = exports['default'];

},{"../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","./tiles/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/item-generator.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _definitionsEquipment = require('../definitions/equipment');

var EquipmentTypes = _interopRequireWildcard(_definitionsEquipment);

var _contentItemsFoods = require('../content/items/foods');

var Food = _interopRequireWildcard(_contentItemsFoods);

var _contentItemsFeets = require('../content/items/feets');

var Feet = _interopRequireWildcard(_contentItemsFeets);

var _contentItemsHeads = require('../content/items/heads');

var Head = _interopRequireWildcard(_contentItemsHeads);

var _contentItemsBodys = require('../content/items/bodys');

var Body = _interopRequireWildcard(_contentItemsBodys);

var _contentItemsRings = require('../content/items/rings');

var Ring = _interopRequireWildcard(_contentItemsRings);

var _contentItemsNecks = require('../content/items/necks');

var Neck = _interopRequireWildcard(_contentItemsNecks);

var _contentItemsWands = require('../content/items/wands');

var Wand = _interopRequireWildcard(_contentItemsWands);

var _contentItemsWrists = require('../content/items/wrists');

var Wrist = _interopRequireWildcard(_contentItemsWrists);

var _contentItemsCloaks = require('../content/items/cloaks');

var Cloak = _interopRequireWildcard(_contentItemsCloaks);

var _contentItems_weapons = require('../content/items/_weapons');

var Weapon = _interopRequireWildcard(_contentItems_weapons);

var _contentItemsPotions = require('../content/items/potions');

var Potion = _interopRequireWildcard(_contentItemsPotions);

var _contentItemsSpellbooks = require('../content/items/spellbooks');

var Spellbook = _interopRequireWildcard(_contentItemsSpellbooks);

var _contentItemsProjectiles = require('../content/items/projectiles');

var Projectile = _interopRequireWildcard(_contentItemsProjectiles);

var itemTypeHash = {
  Food: Food, Feet: Feet, Head: Head, Body: Body, Ring: Ring, Neck: Neck, Wand: Wand, Wrist: Wrist, Cloak: Cloak, Potion: Potion, Spellbook: Spellbook, Hands: _lodash2['default'].extend({}, Projectile, Weapon)
};

var ItemGenerator = (function () {
  function ItemGenerator() {
    _classCallCheck(this, ItemGenerator);
  }

  _createClass(ItemGenerator, null, [{
    key: 'getValidTypes',
    value: function getValidTypes(types) {
      return (0, _lodash2['default'])(types).keys().filter(function (key) {
        return types[key].rarity;
      }).map(function (key) {
        return [key, types[key].rarity];
      }).zipObject().value();
    }
  }, {
    key: 'spawn',
    value: function spawn() {
      var validTypes = this.getValidTypes(EquipmentTypes);
      var chosenType = _rotJs2['default'].RNG.getWeightedValue(validTypes);
      var validItems = this.getValidTypes(itemTypeHash[chosenType]);
      var chosenItem = _rotJs2['default'].RNG.getWeightedValue(validItems);
      return new itemTypeHash[chosenType][chosenItem]();
    }
  }]);

  return ItemGenerator;
})();

exports['default'] = ItemGenerator;
module.exports = exports['default'];

},{"../content/items/_weapons":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_weapons.js","../content/items/bodys":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/bodys.js","../content/items/cloaks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/cloaks.js","../content/items/feets":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/feets.js","../content/items/foods":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/foods.js","../content/items/heads":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/heads.js","../content/items/necks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/necks.js","../content/items/potions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/potions.js","../content/items/projectiles":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/projectiles.js","../content/items/rings":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/rings.js","../content/items/spellbooks":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/spellbooks.js","../content/items/wands":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/wands.js","../content/items/wrists":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/wrists.js","../definitions/equipment":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/equipment.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/maptypes/altar.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _tiles_all = require('../tiles/_all');

var Tiles = _interopRequireWildcard(_tiles_all);

var _generator = require('../generator');

var _generator2 = _interopRequireDefault(_generator);

var Altar = (function (_Generator) {
  _inherits(Altar, _Generator);

  function Altar() {
    _classCallCheck(this, Altar);

    _get(Object.getPrototypeOf(Altar.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Altar, null, [{
    key: 'generate',
    value: function generate(opts) {
      var _this = this;

      var _$extend = _lodash2['default'].extend({ w: 15, h: 15 }, opts);

      var w = _$extend.w;
      var h = _$extend.h;
      var z = _$extend.z;

      var map = [];

      var arena = new _rotJs2['default'].Map.Arena(w, h);

      arena.create(function (x, y, value) {
        if (!map[x]) map[x] = [];

        var proto = Tiles.Void;
        if (!value) proto = Tiles.DungeonFloor;

        _this.placeTile(map, proto, x, y, z);
      });

      var room = new _rotJs2['default'].Map.Feature.Room(1, 1, w - 2, h - 2);

      this.drawVerticalWalls(map, room, z);
      this.drawHorizontalWalls(map, room, z);

      var stairs = [this.placeStairsInRoom(map, room, z, Tiles.StairsUp)];

      var altarTile = this.getRandomFloorTile(map);
      this.placeTile(map, Tiles.SelykAltar, altarTile.x, altarTile.y, z);

      return { map: map, stairs: stairs, rooms: [room], mapName: 'Selyk\'s Altar', shortMapName: 'Altar' };
    }
  }]);

  return Altar;
})(_generator2['default']);

exports['default'] = Altar;
module.exports = exports['default'];

},{"../generator":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/generator.js","../tiles/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/maptypes/dungeon.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _tiles_all = require('../tiles/_all');

var Tiles = _interopRequireWildcard(_tiles_all);

var _generator = require('../generator');

var _generator2 = _interopRequireDefault(_generator);

var _libLogger = require('../../lib/logger');

var _libLogger2 = _interopRequireDefault(_libLogger);

var Dungeon = (function (_Generator) {
  _inherits(Dungeon, _Generator);

  function Dungeon() {
    _classCallCheck(this, Dungeon);

    _get(Object.getPrototypeOf(Dungeon.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Dungeon, null, [{
    key: 'generate',
    value: function generate(opts) {
      var _this = this;

      var w = opts.w;
      var h = opts.h;
      var z = opts.z;

      var map = [];

      // -3 to adjust for the UI components at the bottom
      var digger = new _rotJs2['default'].Map.Digger(w, h - 3, { roomWidth: [4, 8], roomHeight: [4, 7], corridorLength: [5, 13], dugPercentage: 0.3 });

      digger.create(function (x, y, value) {
        if (!map[x]) map[x] = [];

        var proto = Tiles.Void;
        if (!value) proto = Tiles.DungeonFloor;

        _this.placeTile(map, proto, x, y, z);
      });

      // replace all corridors with corridor tiles
      _lodash2['default'].each(digger.getCorridors(), function (corridor) {
        _this.placeCorridorTiles(map, corridor, z);
      });

      var rooms = digger.getRooms();

      if (rooms.length < 2) {
        (0, _libLogger2['default'])('DungeonGenerator', 'Only one room was generated, this is probably a rare bug.');
      }

      // handle room outlines and doors
      _lodash2['default'].each(rooms, function (room) {

        // draw left and right walls
        _this.drawVerticalWalls(map, room, z);

        // draw top and bottom walls
        _this.drawHorizontalWalls(map, room, z);

        // maybe draw some doors
        _this.drawDoors(map, room, z);
      });

      var _getStairs = this.getStairs(z);

      var _getStairs2 = _slicedToArray(_getStairs, 2);

      var stairsUp = _getStairs2[0];
      var stairsDown = _getStairs2[1];

      var chosenRooms = _lodash2['default'].sample(digger.getRooms(), 2);
      var stairs = [this.placeStairsInRoom(map, chosenRooms[0], z, stairsUp), stairsDown ? this.placeStairsInRoom(map, chosenRooms[1], z, stairsDown) : null];

      this.attemptFeaturePlacement(map, z, rooms);

      return { map: map, stairs: stairs, rooms: rooms, mapName: 'The Dungeons of Doom', shortMapName: 'Dungeon' };
    }
  }, {
    key: 'placeCorridorTiles',
    value: function placeCorridorTiles(map, corridor, z) {
      var xStart = corridor._startX;
      var xEnd = corridor._endX;

      if (xStart > xEnd) {
        var _ref = [xEnd, xStart];
        xStart = _ref[0];
        xEnd = _ref[1];
      }

      var yStart = corridor._startY;
      var yEnd = corridor._endY;

      if (yStart > yEnd) {
        var _ref2 = [yEnd, yStart];
        yStart = _ref2[0];
        yEnd = _ref2[1];
      }

      for (var x = xStart; x <= xEnd; x++) {
        for (var y = yStart; y <= yEnd; y++) {
          this.placeTile(map, Tiles.Corridor, x, y, z);
        }
      }
    }
  }, {
    key: 'drawDoors',
    value: function drawDoors(map, room, z) {
      var _this2 = this;

      room.getDoors(function (x, y) {
        if (_rotJs2['default'].RNG.getPercentage() > 30) {
          _this2.placeTile(map, Tiles.DungeonFloor, x, y, z);
        } else {
          var door = _this2.placeTile(map, Tiles.Door, x, y, z);
          door.setProperCharacter(map[x - 1][y]);
        }
      });
    }
  }]);

  return Dungeon;
})(_generator2['default']);

exports['default'] = Dungeon;
module.exports = exports['default'];

},{"../../lib/logger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js","../generator":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/generator.js","../tiles/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/monster-spawner.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _libDiceRoller = require('../lib/dice-roller');

var _libDiceRoller2 = _interopRequireDefault(_libDiceRoller);

var _contentMonsters_all = require('../content/monsters/_all');

var _contentMonsters_all2 = _interopRequireDefault(_contentMonsters_all);

var _definitionsMonster = require('../definitions/monster');

var _definitionsMonster2 = _interopRequireDefault(_definitionsMonster);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _libLogger = require('../lib/logger');

var _libLogger2 = _interopRequireDefault(_libLogger);

var _libRotExtensions = require('../lib/rot-extensions');

var MonsterSpawner = (function () {
  function MonsterSpawner() {
    _classCallCheck(this, MonsterSpawner);
  }

  _createClass(MonsterSpawner, null, [{
    key: 'spawn',
    value: function spawn(basedOn) {
      var dungeonLevel = basedOn.z + 1;
      var targetLevel = basedOn.level;

      var highestDifficulty = Math.min(_initGamestate2['default'].upgrades.maxDifficulty, 5 * dungeonLevel);
      var lowestDifficulty = Math.min(highestDifficulty, Math.floor((dungeonLevel + targetLevel) / 2));

      var chosenName = (0, _libRotExtensions.WeightedExtension)(_contentMonsters_all2['default'], 'frequency', function (monsterName) {
        return _contentMonsters_all2['default'][monsterName].difficulty >= lowestDifficulty && _contentMonsters_all2['default'][monsterName].difficulty < highestDifficulty;
      }).key;

      if (!chosenName || !_contentMonsters_all2['default'][chosenName]) {
        (0, _libLogger2['default'])('MonsterSpawner', 'Monster (' + chosenName + ') could not be spawned: DLvl ' + dungeonLevel + ' TargetLevel ' + targetLevel + ' | difficulty range ' + lowestDifficulty + '-' + highestDifficulty + ' -- picking random monster to spawn...', false);
        chosenName = (0, _libRotExtensions.WeightedExtension)(_contentMonsters_all2['default'], 'frequency', function (monsterName) {
          return _contentMonsters_all2['default'][monsterName].difficulty > 0 && _contentMonsters_all2['default'][monsterName].difficulty < highestDifficulty;
        }).key;
      }

      var numMonsters = (0, _libDiceRoller2['default'])(_contentMonsters_all2['default'][chosenName].spawnPattern);

      for (var i = 0; i < numMonsters; i++) {
        var tile = _lodash2['default'].sample(_initGamestate2['default'].world.getValidTilesInRange(basedOn.x, basedOn.y, basedOn.z, 50, function (tile) {
          return basedOn.distBetween(tile) > basedOn.getSight();
        }));
        this.spawnSingle(chosenName, tile);
      }
    }
  }, {
    key: 'spawnSingle',
    value: function spawnSingle(monsterName, tile) {

      while (_initGamestate2['default'].monsters.length >= _initGamestate2['default'].upgrades.monsterLimit) {

        // some monsters can be marked important, like Selyk, so they will always spawn and never despawn
        var firstBadMonster = _lodash2['default'].find(_initGamestate2['default'].monsters, function (mon) {
          return !mon.important;
        });

        // clean up old monsters
        firstBadMonster.die({ name: 'Selyk\'s Divine Hand' });
      }

      var monster = _contentMonsters_all2['default'][monsterName];

      if (!monster) {
        (0, _libLogger2['default'])('MonsterSpawner', 'Bad monster ' + monsterName + ': ' + new Error().stack);
      }

      if (!tile) {
        (0, _libLogger2['default'])('MonsterSpawner', 'Bad tile ' + JSON.stringify(tile));
      }

      try {
        var monsterOpts = monster.init();
        monsterOpts.difficulty = monster.difficulty;
        var monsterInstance = new _definitionsMonster2['default'](tile.x, tile.y, tile.z, monsterOpts);
        monsterInstance._name = monsterName;

        return monsterInstance;
      } catch (e) {
        (0, _libLogger2['default'])('MonsterSpawner', 'Could not spawn monster ' + monsterName + ': ' + e.stack);
      }
    }
  }]);

  return MonsterSpawner;
})();

exports['default'] = MonsterSpawner;
module.exports = exports['default'];

},{"../content/monsters/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/monsters/_all.js","../definitions/monster":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/monster.js","../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../lib/dice-roller":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/dice-roller.js","../lib/logger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js","../lib/rot-extensions":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/rot-extensions.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/_all.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _walls = require('./walls');

var Walls = _interopRequireWildcard(_walls);

var _floors = require('./floors');

var Floors = _interopRequireWildcard(_floors);

var _stairs = require('./stairs');

var Stairs = _interopRequireWildcard(_stairs);

var _features = require('./features');

var Features = _interopRequireWildcard(_features);

exports['default'] = _lodash2['default'].extend({}, Walls, Floors, Stairs, Features);
module.exports = exports['default'];

},{"./features":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/features.js","./floors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/floors.js","./stairs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/stairs.js","./walls":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/walls.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/features.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _definitionsTile = require('../../definitions/tile');

var _definitionsTile2 = _interopRequireDefault(_definitionsTile);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _contentEffectsFountain = require('../../content/effects/fountain');

var FountainEffects = _interopRequireWildcard(_contentEffectsFountain);

var _contentEffectsThrone = require('../../content/effects/throne');

var ThroneEffects = _interopRequireWildcard(_contentEffectsThrone);

var _contentEffectsSinkDrink = require('../../content/effects/sink-drink');

var SinkDrinkEffects = _interopRequireWildcard(_contentEffectsSinkDrink);

var _contentEffectsSinkKick = require('../../content/effects/sink-kick');

var SinkKickEffects = _interopRequireWildcard(_contentEffectsSinkKick);

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var Door = (function (_Tile) {
  _inherits(Door, _Tile);

  function Door() {
    _classCallCheck(this, Door);

    var isClosed = !!Math.round(_rotJs2['default'].RNG.getUniform());
    var openChar = isClosed ? _constantsGlyphs.Tiles.DoorOpenHorizontal : _constantsGlyphs.Tiles.DoorClosed;
    _get(Object.getPrototypeOf(Door.prototype), 'constructor', this).call(this, openChar, _constantsGlyphColors.Tiles.Door);
    this._isAIPassable = true;

    this.opacity = ! ~ ~isClosed;
    this.density = ! ~ ~isClosed;
  }

  // the door should look different than the walls next to it

  _createClass(Door, [{
    key: 'getOpenChar',
    value: function getOpenChar(basedOn) {
      var leftTileGlyph = basedOn.glyph.key;
      return leftTileGlyph === _constantsGlyphs.Tiles.DoorOpenHorizontal ? _constantsGlyphs.Tiles.DoorOpenVertical : _constantsGlyphs.Tiles.DoorOpenHorizontal;
    }
  }, {
    key: 'canInteract',
    value: function canInteract() {
      return this.density;
    }
  }, {
    key: 'setProperCharacter',
    value: function setProperCharacter() {
      var basedOn = arguments.length <= 0 || arguments[0] === undefined ? _initGamestate2['default'].world.getTile(this.x - 1, this.y, this.z) : arguments[0];

      var isOpen = this.density;
      var toggleChar = isOpen ? _constantsGlyphs.Tiles.DoorClosed : this.getOpenChar(basedOn);
      this.glyph.key = toggleChar;
    }
  }, {
    key: 'interact',
    value: function interact(entity) {
      this.opacity = !this.opacity;
      this.density = !this.density;
      this.setProperCharacter();

      return entity.name + ' ' + (this.density ? 'closed' : 'opened') + ' the door.';
    }
  }]);

  return Door;
})(_definitionsTile2['default']);

exports.Door = Door;

var SelykAltar = (function (_Tile2) {
  _inherits(SelykAltar, _Tile2);

  function SelykAltar() {
    _classCallCheck(this, SelykAltar);

    _get(Object.getPrototypeOf(SelykAltar.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.Altar, _constantsGlyphColors.Special.Selyk);
  }

  _createClass(SelykAltar, [{
    key: 'canInteract',
    value: function canInteract(entity) {
      return this.distBetween(entity) <= 1;
    }
  }, {
    key: 'interact',
    value: function interact(entity) {
      entity._ascended = true;
      return entity.name + ' has acended to the Selykian Plane.';
    }
  }]);

  return SelykAltar;
})(_definitionsTile2['default']);

exports.SelykAltar = SelykAltar;

var Fountain = (function (_Tile3) {
  _inherits(Fountain, _Tile3);

  function Fountain() {
    _classCallCheck(this, Fountain);

    _get(Object.getPrototypeOf(Fountain.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.Fountain, _constantsGlyphColors.Tiles.Fountain);
    this.density = 1;
  }

  _createClass(Fountain, [{
    key: 'canInteract',
    value: function canInteract(entity) {
      return this.distBetween(entity) <= 1;
    }
  }, {
    key: 'interact',
    value: function interact(entity) {
      var effect = this.getRandomEffect(FountainEffects);
      effect.use(entity, this);
      if (_rotJs2['default'].RNG.getPercentage() <= 33) {
        this.ceaseExisting();
        return 'The fountain dried up!';
      }
    }
  }]);

  return Fountain;
})(_definitionsTile2['default']);

exports.Fountain = Fountain;

var Throne = (function (_Tile4) {
  _inherits(Throne, _Tile4);

  function Throne() {
    _classCallCheck(this, Throne);

    _get(Object.getPrototypeOf(Throne.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.Throne, _constantsGlyphColors.Tiles.Throne);
  }

  _createClass(Throne, [{
    key: 'canInteract',
    value: function canInteract(entity) {
      return this.distBetween(entity) === 0;
    }
  }, {
    key: 'interact',
    value: function interact(entity) {
      var effect = this.getRandomEffect(ThroneEffects);
      effect.use(entity, this);
      if (_rotJs2['default'].RNG.getPercentage() <= 33) {
        this.ceaseExisting();
        return 'The throne vanishes in a puff of logic!';
      }
    }
  }]);

  return Throne;
})(_definitionsTile2['default']);

exports.Throne = Throne;

var Sink = (function (_Tile5) {
  _inherits(Sink, _Tile5);

  function Sink() {
    _classCallCheck(this, Sink);

    _get(Object.getPrototypeOf(Sink.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.Sink, _constantsGlyphColors.Tiles.Sink);
    this.density = 1;
  }

  _createClass(Sink, [{
    key: 'canInteract',
    value: function canInteract(entity) {
      return this.distBetween(entity) <= 1;
    }
  }, {
    key: 'becomeFountain',
    value: function becomeFountain() {
      _initGamestate2['default'].world.placeNewTile(Fountain, this.x, this.y, this.z);
    }
  }, {
    key: 'interact',
    value: function interact(entity) {
      if (_rotJs2['default'].RNG.getPercentage() <= 60) {
        this.getRandomEffect(SinkDrinkEffects).use(entity, this);
      } else {
        this.getRandomEffect(SinkKickEffects).use(entity, this);
      }

      // break chance
      if (_rotJs2['default'].RNG.getPercentage() <= 30) {

        // it might turn into a fountain, but probably not
        if (_rotJs2['default'].RNG.getPercentage() <= 20) {
          this.becomeFountain();
          return 'The pipes explode! Water spurts out!';
        }

        this.ceaseExisting();
        return 'The sink stops providing water.';
      }
    }
  }]);

  return Sink;
})(_definitionsTile2['default']);

exports.Sink = Sink;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../../content/effects/fountain":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/effects/fountain.js","../../content/effects/sink-drink":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/effects/sink-drink.js","../../content/effects/sink-kick":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/effects/sink-kick.js","../../content/effects/throne":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/effects/throne.js","../../definitions/tile":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/tile.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/floors.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsTile = require('../../definitions/tile');

var _definitionsTile2 = _interopRequireDefault(_definitionsTile);

var _constantsGlyphs = require('../../constants/glyphs');

var Void = (function (_Tile) {
  _inherits(Void, _Tile);

  function Void() {
    _classCallCheck(this, Void);

    _get(Object.getPrototypeOf(Void.prototype), 'constructor', this).call(this);this.opacity = 1;this.reflect = 0;
  }

  return Void;
})(_definitionsTile2['default']);

exports.Void = Void;

var DungeonFloor = (function (_Tile2) {
  _inherits(DungeonFloor, _Tile2);

  function DungeonFloor() {
    _classCallCheck(this, DungeonFloor);

    _get(Object.getPrototypeOf(DungeonFloor.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.Floor);
  }

  return DungeonFloor;
})(_definitionsTile2['default']);

exports.DungeonFloor = DungeonFloor;

var Corridor = (function (_Tile3) {
  _inherits(Corridor, _Tile3);

  function Corridor() {
    _classCallCheck(this, Corridor);

    _get(Object.getPrototypeOf(Corridor.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.Corridor);
  }

  return Corridor;
})(_definitionsTile2['default']);

exports.Corridor = Corridor;

},{"../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../../definitions/tile":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/tile.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/stairs.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsTile = require('../../definitions/tile');

var _definitionsTile2 = _interopRequireDefault(_definitionsTile);

var _initGamestate = require('../../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _contentItems_special = require('../../content/items/_special');

var _constantsGlyphs = require('../../constants/glyphs');

var _constantsGlyphColors = require('../../constants/glyphColors');

var Stairs = (function (_Tile) {
  _inherits(Stairs, _Tile);

  function Stairs() {
    _classCallCheck(this, Stairs);

    _get(Object.getPrototypeOf(Stairs.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Stairs, [{
    key: 'canInteract',
    value: function canInteract(entity) {
      return this.distBetween(entity) === 0;
    }
  }]);

  return Stairs;
})(_definitionsTile2['default']);

var StairsDown = (function (_Stairs) {
  _inherits(StairsDown, _Stairs);

  function StairsDown() {
    _classCallCheck(this, StairsDown);

    _get(Object.getPrototypeOf(StairsDown.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.StairsDown);
  }

  _createClass(StairsDown, [{
    key: 'canInteract',
    value: function canInteract(entity) {
      return _get(Object.getPrototypeOf(StairsDown.prototype), 'canInteract', this).call(this, entity) && entity.descend && this.z !== _initGamestate2['default'].world.depth - 1;
    }
  }, {
    key: 'interact',
    value: function interact(entity) {
      entity.descend();
      return entity.name + ' descended the stairs.';
    }
  }]);

  return StairsDown;
})(Stairs);

exports.StairsDown = StairsDown;

var SelykStairsDown = (function (_Stairs2) {
  _inherits(SelykStairsDown, _Stairs2);

  function SelykStairsDown() {
    _classCallCheck(this, SelykStairsDown);

    _get(Object.getPrototypeOf(SelykStairsDown.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.StairsDown, _constantsGlyphColors.Special.Selyk);
  }

  _createClass(SelykStairsDown, [{
    key: 'canInteract',
    value: function canInteract(entity) {
      return entity.hasInInventory(_contentItems_special.SelykCellarKey) && entity.descend;
    }
  }, {
    key: 'interact',
    value: function interact(entity) {
      entity.descend();
      return entity.name + ' descended the stairs to Selyk\'s Cellar.';
    }
  }]);

  return SelykStairsDown;
})(Stairs);

exports.SelykStairsDown = SelykStairsDown;

var StairsUp = (function (_Stairs3) {
  _inherits(StairsUp, _Stairs3);

  function StairsUp() {
    _classCallCheck(this, StairsUp);

    _get(Object.getPrototypeOf(StairsUp.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.StairsUp);
  }

  _createClass(StairsUp, [{
    key: 'canInteract',
    value: function canInteract() {
      return false;
      // return super.canInteract(entity) && this.z !== 0;
    }
  }, {
    key: 'interact',
    value: function interact(entity) {
      entity.ascend();
      return entity.name + ' ascended the stairs.';
    }
  }]);

  return StairsUp;
})(Stairs);

exports.StairsUp = StairsUp;

},{"../../constants/glyphColors":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphColors.js","../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../../content/items/_special":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/content/items/_special.js","../../definitions/tile":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/tile.js","../../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/walls.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _definitionsTile = require('../../definitions/tile');

var _definitionsTile2 = _interopRequireDefault(_definitionsTile);

var _constantsGlyphs = require('../../constants/glyphs');

var DungeonHorizontalWall = (function (_Tile) {
  _inherits(DungeonHorizontalWall, _Tile);

  function DungeonHorizontalWall() {
    _classCallCheck(this, DungeonHorizontalWall);

    _get(Object.getPrototypeOf(DungeonHorizontalWall.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.WallHorizontal);this.density = this.opacity = 1;this.reflect = 0;
  }

  return DungeonHorizontalWall;
})(_definitionsTile2['default']);

exports.DungeonHorizontalWall = DungeonHorizontalWall;

var DungeonVerticalWall = (function (_Tile2) {
  _inherits(DungeonVerticalWall, _Tile2);

  function DungeonVerticalWall() {
    _classCallCheck(this, DungeonVerticalWall);

    _get(Object.getPrototypeOf(DungeonVerticalWall.prototype), 'constructor', this).call(this, _constantsGlyphs.Tiles.WallVertical);this.density = this.opacity = 1;this.reflect = 0;
  }

  return DungeonVerticalWall;
})(_definitionsTile2['default']);

exports.DungeonVerticalWall = DungeonVerticalWall;

},{"../../constants/glyphs":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/constants/glyphs.js","../../definitions/tile":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/definitions/tile.js"}],"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/world.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _rotJs = require('rot-js');

var _rotJs2 = _interopRequireDefault(_rotJs);

var _tiles_all = require('./tiles/_all');

var Tiles = _interopRequireWildcard(_tiles_all);

var _maptypesDungeon = require('./maptypes/dungeon');

var _maptypesDungeon2 = _interopRequireDefault(_maptypesDungeon);

var _initGamestate = require('../init/gamestate');

var _initGamestate2 = _interopRequireDefault(_initGamestate);

var _itemGenerator = require('./item-generator');

var _itemGenerator2 = _interopRequireDefault(_itemGenerator);

var _libLogger = require('../lib/logger');

var _libLogger2 = _interopRequireDefault(_libLogger);

var badTile = new Tiles.Void();

var World = (function () {
  function World() {
    _classCallCheck(this, World);

    this.tiles = [];

    this.stairs = [];

    this.entities = [];
    this.items = [];

    this.fov = [];
    this.lighting = [];
    this.explored = [];
  }

  _createClass(World, [{
    key: 'setMapAt',
    value: function setMapAt(floor, i) {
      var map = floor.map;
      var mapName = floor.mapName;
      var rooms = floor.rooms;
      var shortMapName = floor.shortMapName;
      var stairs = floor.stairs;

      this.tiles[i] = map;
      this.tiles[i].mapName = mapName;
      this.tiles[i].shortMapName = shortMapName;
      this.tiles[i].rooms = rooms;

      var _stairs = _slicedToArray(stairs, 2);

      var upStairs = _stairs[0];
      var downStairs = _stairs[1];

      this.stairs[i] = {};
      if (upStairs) this.stairs[i].up = [upStairs.x, upStairs.y];
      if (downStairs) this.stairs[i].down = [downStairs.x, downStairs.y];

      this.placeItemsOnMap(i);
    }
  }, {
    key: 'generateWorld',
    value: function generateWorld() {
      var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      _lodash2['default'].defaults(opts, { width: 70, height: 70, depth: 10 });

      var width = opts.width;
      var height = opts.height;
      var depth = opts.depth;

      this.width = width;
      this.height = height;
      this.depth = depth;

      for (var i = 0; i < depth; i++) {
        var genOpts = { w: width, h: height, z: i };
        this.setMapAt(_maptypesDungeon2['default'].generate(genOpts), i);
      }

      if (_initGamestate2['default'].winCondition.mapAdditions()) {
        this.depth = this.tiles.length;
      }

      this.setup();
    }

    // region Setup functions
  }, {
    key: 'setup',
    value: function setup() {
      this.setupExplored();
      this.setupFOV();
    }
  }, {
    key: 'setupExplored',
    value: function setupExplored() {
      for (var z = 0; z < this.depth; z++) {
        this.explored[z] = [];
        for (var x = 0; x < this.width; x++) {
          this.explored[z][x] = [];
          for (var y = 0; y < this.height; y++) {
            this.explored[z][x][y] = false;
          }
        }
      }
    }
  }, {
    key: 'setupFOV',
    value: function setupFOV() {
      var _this = this;

      var _loop = function (z) {
        _this.fov[z] = new _rotJs2['default'].FOV.RecursiveShadowcasting(function (x, y) {
          return !_this.getTile(x, y, z).isBlockingLight();
        });
      };

      for (var z = 0; z < this.depth; z++) {
        _loop(z);
      }
    }

    // endregion

    // region Exploration functions
  }, {
    key: 'setExplored',
    value: function setExplored(x, y, z) {
      var state = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

      if (this.isVoid(x, y, z)) return;
      this.explored[z][x][y] = state;
    }
  }, {
    key: 'isExplored',
    value: function isExplored(x, y, z) {
      return this.isVoid(x, y, z) ? false : this.explored[z][x][y];
    }

    // endregion

    // region Tile functions
  }, {
    key: 'getTile',
    value: function getTile(x, y, z) {
      if (z < 0 || z > this.tiles.length || x < 0 || x >= this.tiles[z].length || y < 0 || y >= this.tiles[z][x].length) {
        return badTile;
      }

      return this.tiles[z][x][y];
    }
  }, {
    key: 'placeNewTile',
    value: function placeNewTile(tileProto, x, y, z) {
      var tile = new tileProto();
      tile.x = x;
      tile.y = y;
      tile.z = z;
      this.tiles[z][x][y] = tile;
    }
  }, {
    key: 'isVoid',
    value: function isVoid(x, y, z) {
      var tile = this.getTile(x, y, z);
      return !tile || !this.getTile(x, y, z).glyph.key;
    }
  }, {
    key: 'isTileEmpty',
    value: function isTileEmpty(x, y, z) {
      var tile = this.getTile(x, y, z);
      return tile && !tile.isDense() && !this.getEntity(x, y, z) && !this.isVoid(x, y, z);
    }
  }, {
    key: 'isTilePassable',
    value: function isTilePassable(x, y, z) {
      var inclAIPass = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

      var tile = this.getTile(x, y, z);
      var aiPass = inclAIPass ? tile._isAIPassable : true;
      return tile && aiPass || this.isTileEmpty(x, y, z);
    }
  }, {
    key: 'getAllTilesInRange',
    value: function getAllTilesInRange(x, y, z, radius) {
      var tiles = [];

      // line these tiles up with the numpad
      for (var newY = y + radius; newY >= y - radius; newY--) {
        for (var newX = x - radius; newX <= x + radius; newX++) {
          var tile = this.tiles[z][newX][newY];
          tiles.push(tile);
        }
      }

      return tiles;
    }
  }, {
    key: 'getValidTilesInRange',
    value: function getValidTilesInRange(x, y, z, radius) {
      var filter = arguments.length <= 4 || arguments[4] === undefined ? function () {
        return true;
      } : arguments[4];

      var tiles = [];

      var lowerX = Math.max(x - radius, 0);
      var upperX = Math.min(x + radius, this.width);
      var lowerY = Math.max(y - radius, 0);
      var upperY = Math.min(y + radius, this.height);

      for (var newX = lowerX; newX <= upperX; newX++) {
        for (var newY = lowerY; newY <= upperY; newY++) {
          if (!this.tiles[z][newX]) continue;
          var tile = this.tiles[z][newX][newY];
          if (!tile) continue;
          if (!this.isTileEmpty(newX, newY, z)) continue;
          tiles.push(tile);
        }
      }

      return _lodash2['default'].filter(tiles, filter);
    }

    // endregion

    // region Dual-purpose getters/setters
  }, {
    key: 'getWithoutInits',
    value: function getWithoutInits(x, y, z) {
      var list = arguments.length <= 3 || arguments[3] === undefined ? 'entities' : arguments[3];

      if (!this[list][z]) return null;
      if (!this[list][z][x]) return null;
      if (!this[list][z][x][y]) return null;

      return this[list][z][x][y];
    }
  }, {
    key: 'ensureLocation',
    value: function ensureLocation(x, y, z) {
      var list = arguments.length <= 3 || arguments[3] === undefined ? 'entities' : arguments[3];
      var setTo = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];

      if (!this[list][z]) this[list][z] = [];
      if (!this[list][z][x]) this[list][z][x] = [];
      if (!this[list][z][x][y]) this[list][z][x][y] = setTo;
    }

    // endregion

    // region Item functions
  }, {
    key: 'placeItemsOnMap',
    value: function placeItemsOnMap(z) {
      var itemsRemaining = arguments.length <= 1 || arguments[1] === undefined ? _initGamestate2['default'].upgrades.itemsInDungeon : arguments[1];

      while (itemsRemaining > 0 && _rotJs2['default'].RNG.getPercentage() <= _initGamestate2['default'].upgrades.itemDropChance) {
        itemsRemaining--;
        _initGamestate2['default'].world.placeItemAtRandomLocation(_itemGenerator2['default'].spawn(), z);
      }
    }
  }, {
    key: 'getItemsAt',
    value: function getItemsAt(x, y, z) {
      return this.getWithoutInits(x, y, z, 'items');
    }
  }, {
    key: 'removeItem',
    value: function removeItem(item) {
      var myItems = this.getItemsAt(item.x, item.y, item.z);
      if (!_lodash2['default'].contains(myItems, item)) {
        (0, _libLogger2['default'])('World', 'Invalid item removal attempt. ' + item.name + ' not found in list: ' + _lodash2['default'].pluck(myItems, 'name').join(', '));
        return false;
      }
      this.items[item.z][item.x][item.y] = _lodash2['default'].without(this.items[item.z][item.x][item.y], item);
      item.x = item.y = item.z = undefined;
    }
  }, {
    key: 'moveItem',
    value: function moveItem(item, x, y, z) {
      this.ensureLocation(x, y, z, 'items', []);

      if (item.x && item.y && item.z) {
        this.removeItem(item);
      }

      item.x = x;
      item.y = y;
      item.z = z;
      this.items[z][x][y].push(item);
    }
  }, {
    key: 'placeItemAtRandomLocation',
    value: function placeItemAtRandomLocation(item, z) {
      var tile = (0, _lodash2['default'])(this.tiles[z]).flatten().filter(function (tile) {
        return tile.glyph.key;
      }).reject(function (tile) {
        return tile.isDense();
      }).sample();
      this.moveItem(item, tile.x, tile.y, z);
    }

    // endregion

    // region Entity functions
  }, {
    key: 'moveEntity',
    value: function moveEntity(entity, x, y, z) {
      if (!this.isTileEmpty(x, y, z)) return false;

      this.ensureLocation(x, y, z);
      this.ensureLocation(entity.x, entity.y, entity.z);

      this.entities[entity.z][entity.x][entity.y] = null;

      entity.x = x;
      entity.y = y;
      entity.z = z;
      this.entities[z][x][y] = entity;
      return true;
    }
  }, {
    key: 'removeEntity',
    value: function removeEntity(entity) {
      var myEntity = this.getEntity(entity.x, entity.y, entity.z);
      if (myEntity !== entity) {
        (0, _libLogger2['default'])('World', 'Invalid entity removal attempt. ' + (entity ? entity.name : null) + ' tried to remove ' + (myEntity ? myEntity.name : null));
        return false;
      }
      this.entities[entity.z][entity.x][entity.y] = null;
    }
  }, {
    key: 'getEntity',
    value: function getEntity(x, y, z) {
      return this.getWithoutInits(x, y, z);
    }
  }, {
    key: 'placeEntityAtRandomLocation',
    value: function placeEntityAtRandomLocation(entity) {
      var z = arguments.length <= 1 || arguments[1] === undefined ? entity.z : arguments[1];
      return (function () {
        var tile = (0, _lodash2['default'])(this.tiles[z]).flatten().filter(function (tile) {
          return tile.glyph.key;
        }).reject(function (tile) {
          return tile.isDense();
        }).sample();
        this.moveEntity(entity, tile.x, tile.y, z);
      }).apply(this, arguments);
    }
  }, {
    key: 'getValidEntitiesInRange',
    value: function getValidEntitiesInRange(x, y, z, radius) {
      var filter = arguments.length <= 4 || arguments[4] === undefined ? function () {
        return true;
      } : arguments[4];

      var entities = [];

      var lowerX = Math.max(x - radius, 0);
      var upperX = Math.min(x + radius, this.width);
      var lowerY = Math.max(y - radius, 0);
      var upperY = Math.min(y + radius, this.height);

      for (var newX = lowerX; newX <= upperX; newX++) {
        for (var newY = lowerY; newY <= upperY; newY++) {
          var entity = this.getEntity(newX, newY, z);
          if (!entity) continue;
          entities.push(entity);
        }
      }

      return _lodash2['default'].filter(entities, filter);
    }

    // endregion

    // region Lighting functions
  }, {
    key: 'addLighting',
    value: function addLighting(lightSource) {
      if (!this.lighting[lightSource.z]) this.lighting[lightSource.z] = [];
      this.lighting[lightSource.z].push(lightSource);
    }
  }, {
    key: 'removeLighting',
    value: function removeLighting(lightSource) {
      this.lighting[lightSource.z] = _lodash2['default'].without(this.lighting[lightSource.z], lightSource);
    }

    // endregion

  }, {
    key: 'descend',
    value: function descend() {
      if (!_initGamestate2['default'].winCondition.shouldTrigger()) return;
      _initGamestate2['default'].winCondition.trigger();
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      _lodash2['default'].each(_lodash2['default'].compact(_lodash2['default'].flattenDeep(this.entities)), function (e) {
        return e.removeSelf() && e.cleanUp();
      });

      for (var z = 0; z < this.tiles.length; z++) {
        for (var x = 0; x < this.tiles[z].length; x++) {
          for (var y = 0; y < this.tiles[z][x].length; y++) {
            this.tiles[z][x][y] = null;
          }
          this.tiles[z][x] = null;
        }
        this.tiles[z] = null;
      }

      this.tiles = null;
      this.stairs = null;
      this.entities = null;
      this.items = null;
      this.fov = null;
      this.lighting = null;
      this.explored = null;
    }
  }]);

  return World;
})();

exports['default'] = World;
module.exports = exports['default'];

},{"../init/gamestate":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/init/gamestate.js","../lib/logger":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/lib/logger.js","./item-generator":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/item-generator.js","./maptypes/dungeon":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/maptypes/dungeon.js","./tiles/_all":"/Users/seiyria/GitHub/Roguathia/src/js/rogue/worldgen/tiles/_all.js","lodash":"/Users/seiyria/GitHub/Roguathia/node_modules/lodash/index.js","rot-js":"/Users/seiyria/GitHub/Roguathia/node_modules/rot-js/lib/rot.js"}]},{},["/Users/seiyria/GitHub/Roguathia/src/js/init.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJhZ2ktYnJvd3Nlci9saWIvYnJhZ2kuanMiLCJub2RlX21vZHVsZXMvYnJhZ2ktYnJvd3Nlci9saWIvYnJhZ2kvY2FuTG9nLmpzIiwibm9kZV9tb2R1bGVzL2JyYWdpLWJyb3dzZXIvbGliL2JyYWdpL3N5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvYnJhZ2ktYnJvd3Nlci9saWIvYnJhZ2kvdHJhbnNwb3J0cy5qcyIsIm5vZGVfbW9kdWxlcy9icmFnaS1icm93c2VyL2xpYi9icmFnaS90cmFuc3BvcnRzL0NvbnNvbGUuanMiLCJub2RlX21vZHVsZXMvYnJhZ2ktYnJvd3Nlci9saWIvYnJhZ2kvdHJhbnNwb3J0cy9IaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2JyYWdpLWJyb3dzZXIvbGliL2JyYWdpL3RyYW5zcG9ydHMvVHJhbnNwb3J0cy5qcyIsIm5vZGVfbW9kdWxlcy9icmFnaS1icm93c2VyL2xpYi9icmFnaS90cmFuc3BvcnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RpY2UuanMvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL2RpY2UuanMvc3JjL2RpY2UuanMiLCJub2RlX21vZHVsZXMvZGljZS5qcy9zcmMvZXZhbHVhdGUuanMiLCJub2RlX21vZHVsZXMvZGljZS5qcy9zcmMvcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjIvbGliL2V2ZW50ZW1pdHRlcjIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yb3QtanMvbGliL3JvdC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvYW5ndWxhci9jb250cm9sbGVycy9EdW5nZW9uLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvYW5ndWxhci9jb250cm9sbGVycy9Mb2cuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9hbmd1bGFyL2NvbnRyb2xsZXJzL09wdGlvbnMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9hbmd1bGFyL2NvbnRyb2xsZXJzL1BhcnR5LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvYW5ndWxhci9jb250cm9sbGVycy9Sb290LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvYW5ndWxhci9jb250cm9sbGVycy9VcGdyYWRlcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL2FuZ3VsYXIvZGlyZWN0aXZlcy9maWxsLWhlaWdodC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL2FuZ3VsYXIvZGlyZWN0aXZlcy90YWJzL2xvZy10YWIuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9hbmd1bGFyL2luaXQuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9hbmd1bGFyL21vZHVsZS5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL2FuZ3VsYXIvc2VydmljZXMvQ3VycmVuY3lEYXRhTWFuYWdlci5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL2FuZ3VsYXIvc2VydmljZXMvVGVtcGxhdGVEYXRhTWFuYWdlci5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL2FuZ3VsYXIvc2VydmljZXMvVXBncmFkZURhdGFNYW5hZ2VyLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvaW5pdC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnN0YW50cy9jb25kdWN0cy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnN0YW50cy9kZWNvcmF0b3JzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29uc3RhbnRzL2ZhY3Rpb25zLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29uc3RhbnRzL2Zha2V0eXBlcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnN0YW50cy9nbHlwaENvbG9ycy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnN0YW50cy9nbHlwaHMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb25zdGFudHMvbWF0ZXJpYWxzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29uc3RhbnRzL3JhbmRvbS5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnN0YW50cy9zZXR0aW5ncy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnN0YW50cy9za2lsbC10aHJlc2hvbGRzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29uc3RhbnRzL3VwZ3JhZGVzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29uc3RhbnRzL3ZpY3Rvcmllcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvYXR0YWNrcy9fYWxsLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9hdHRhY2tzL21hZ2ljLWF0dGFja3MuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2F0dGFja3MvbW9uc3Rlci1hdHRhY2tzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9hdHRhY2tzL3BoeXNpY2FsLWF0dGFja3MuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2JlaGF2aW9ycy9fYWxsLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9iZWhhdmlvcnMvYW1iaWVudC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvYmVoYXZpb3JzL2NvbWJhdC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvYmVoYXZpb3JzL2NvbmRpdGlvbnMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2JlaGF2aW9ycy9kZWF0aC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvYmVoYXZpb3JzL2ludGVyYWN0aW9ucy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvYmVoYXZpb3JzL3JlZ2VuZXJhdGlvbi5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvYmVoYXZpb3JzL3RhcmdldHRpbmcuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2VmZmVjdHMvZm91bnRhaW4uanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2VmZmVjdHMvc2luay1kcmluay5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvZWZmZWN0cy9zaW5rLWtpY2suanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2VmZmVjdHMvdGhyb25lLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9mbGF2b3IvbmFtZXMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2l0ZW1zL19zcGVjaWFsLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9pdGVtcy9fd2VhcG9ucy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvaXRlbXMvYm9keXMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2l0ZW1zL2Nsb2Frcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvaXRlbXMvZmVldHMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2l0ZW1zL2Zvb2RzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9pdGVtcy9oZWFkcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvaXRlbXMvbmVja3MuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2l0ZW1zL3BvdGlvbnMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2l0ZW1zL3Byb2plY3RpbGVzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9pdGVtcy9yaW5ncy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvaXRlbXMvc3BlbGxib29rcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvaXRlbXMvd2FuZHMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2l0ZW1zL3dlYXBvbnMvYXhlcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvaXRlbXMvd2VhcG9ucy9ib3dzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9pdGVtcy93ZWFwb25zL2RhZ2dlcnMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2l0ZW1zL3dlYXBvbnMvbG9uZ3N3b3Jkcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvaXRlbXMvd2VhcG9ucy9tYWNlcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvaXRlbXMvd2VhcG9ucy9zaG9ydHN3b3Jkcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvaXRlbXMvd2VhcG9ucy9zcGVhcnMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L2l0ZW1zL3dlYXBvbnMvc3RhdmVzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9pdGVtcy93cmlzdHMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L21vbnN0ZXJzL19hbGwuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L21vbnN0ZXJzL19zcGVjaWFsLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9tb25zdGVycy9fc3VtbW9uZWQuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L21vbnN0ZXJzL2NhbmluZXMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L21vbnN0ZXJzL2VsZW1lbnRhbHMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L21vbnN0ZXJzL2dub21lcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvbW9uc3RlcnMvaW5zZWN0cy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvbW9uc3RlcnMvamVsbGllcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvbW9uc3RlcnMva29ib2xkcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvbW9uc3RlcnMvbGl6YXJkcy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvbW9uc3RlcnMvbnltcGhzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9tb25zdGVycy9vcmNzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9tb25zdGVycy9wdWRkaW5ncy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvbW9uc3RlcnMvcmF0cy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvbW9uc3RlcnMvc3BvcmVzLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9wcm9mZXNzaW9ucy9fYWxsLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9wcm9mZXNzaW9ucy9hcmNoYWVvbG9naXN0LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9wcm9mZXNzaW9ucy9iYXJiYXJpYW4uanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3Byb2Zlc3Npb25zL2NhdmVtYW4uanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3Byb2Zlc3Npb25zL2RldmVsb3Blci5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcHJvZmVzc2lvbnMvaGVhbGVyLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9wcm9mZXNzaW9ucy9rbmlnaHQuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3Byb2Zlc3Npb25zL21vbmsuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3Byb2Zlc3Npb25zL21vbnN0ZXIuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3Byb2Zlc3Npb25zL3ByaWVzdC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcHJvZmVzc2lvbnMvcmFuZ2VyLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9wcm9mZXNzaW9ucy9yb2d1ZS5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcHJvZmVzc2lvbnMvdG91cmlzdC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcHJvZmVzc2lvbnMvdmFsa3lyaWUuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3Byb2Zlc3Npb25zL3dpemFyZC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcmFjZXMvX2FsbC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcmFjZXMvX2h1bWFub2lkLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9yYWNlcy9jYW5pbmUuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3JhY2VzL2RlbW9uLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9yYWNlcy9lbGVtZW50YWwuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3JhY2VzL2VsZi5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcmFjZXMvZ25vbWUuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3JhY2VzL2h1bWFuLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9yYWNlcy9pbnNlY3QuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3JhY2VzL2plbGx5LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9yYWNlcy9rb2JvbGQuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3JhY2VzL2xpemFyZC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcmFjZXMvbGl6YXJkbWFuLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9yYWNlcy9tYW50aWNvcmUuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9jb250ZW50L3JhY2VzL29yYy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcmFjZXMvcHNpb25pYy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcmFjZXMvcHVkZGluZy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcmFjZXMvcmF0LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9yYWNlcy9zbmFrZS5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvcmFjZXMvc3BpZGVyLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvY29udGVudC9yYWNlcy9zcG9yZS5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2NvbnRlbnQvdHJhaXRzL19hbGwuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9kZWZpbml0aW9ucy9hYnN0cmFjdC5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2RlZmluaXRpb25zL2F0dGFjay5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2RlZmluaXRpb25zL2JlaGF2aW9yLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGVmaW5pdGlvbnMvY2hhcmFjdGVyLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGVmaW5pdGlvbnMvZWZmZWN0LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGVmaW5pdGlvbnMvZW50aXR5LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGVmaW5pdGlvbnMvZXF1aXBtZW50LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGVmaW5pdGlvbnMvZ2x5cGguanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9kZWZpbml0aW9ucy9pdGVtLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGVmaW5pdGlvbnMvbW9uc3Rlci5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2RlZmluaXRpb25zL3BsYXllci5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2RlZmluaXRpb25zL3Byb2Zlc3Npb24uanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9kZWZpbml0aW9ucy9yYWNlLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGVmaW5pdGlvbnMvdGlsZS5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2RlZmluaXRpb25zL3RyYWl0LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGlzcGxheS9tZXNzYWdlLWhhbmRsZXIuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9kaXNwbGF5L3NjcmVlbi5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2Rpc3BsYXkvc2NyZWVucy9jb25kdWN0LmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGlzcGxheS9zY3JlZW5zL2RlYWQuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9kaXNwbGF5L3NjcmVlbnMvZ2FtZS5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2Rpc3BsYXkvc2NyZWVucy9sb2FkLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGlzcGxheS9zY3JlZW5zL25ld2dhbWUuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9kaXNwbGF5L3NjcmVlbnMvcmVzcGF3bi5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2Rpc3BsYXkvc2NyZWVucy92YW5xdWlzaGVkLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvZGlzcGxheS9zY3JlZW5zL3dpbi5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2luaXQvZGVidWcuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9pbml0L2dhbWUtc3RhcnRlci5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2luaXQvZ2FtZS5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2luaXQvZ2FtZXN0YXRlLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvaW5pdC9nYW1ldXBncmFkZXMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9pbml0L2luaXQuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9saWIvZGVmYXVsdC1jYWxjdWxhdGlvbnMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9saWIvZGljZS1yb2xsZXIuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9saWIvZGlyZWN0aW9uYWwtcHJvYmFiaWxpdHkuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9saWIvZ2VuLWlkLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvbGliL2xvZ2dlci5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2xpYi9udW1iZXItcmFuZ2UuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9saWIvcGFnZS10aXRsZS5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2xpYi9yb3QtZXh0ZW5zaW9ucy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL2xpYi92YWxpZC1jb2xvcnMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS9saWIvdmFsdWUtYXNzaWduLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvd29ybGRnZW4vZ2VuZXJhdG9yLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvd29ybGRnZW4vaXRlbS1nZW5lcmF0b3IuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS93b3JsZGdlbi9tYXB0eXBlcy9hbHRhci5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL3dvcmxkZ2VuL21hcHR5cGVzL2R1bmdlb24uanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS93b3JsZGdlbi9tb25zdGVyLXNwYXduZXIuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS93b3JsZGdlbi90aWxlcy9fYWxsLmpzIiwiL1VzZXJzL3NlaXlyaWEvR2l0SHViL1JvZ3VhdGhpYS9zcmMvanMvcm9ndWUvd29ybGRnZW4vdGlsZXMvZmVhdHVyZXMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS93b3JsZGdlbi90aWxlcy9mbG9vcnMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS93b3JsZGdlbi90aWxlcy9zdGFpcnMuanMiLCIvVXNlcnMvc2VpeXJpYS9HaXRIdWIvUm9ndWF0aGlhL3NyYy9qcy9yb2d1ZS93b3JsZGdlbi90aWxlcy93YWxscy5qcyIsIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWEvc3JjL2pzL3JvZ3VlL3dvcmxkZ2VuL3dvcmxkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2htQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNTRLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7dUJDemtCbUIsV0FBVzs7OztrQ0FDUiw0QkFBNEI7Ozs7QUFFbEQsb0JBQU8sVUFBVSxDQUFDLFNBQVMsRUFBRSxVQUFDLE1BQU0sRUFBSzs7QUFFdkMsUUFBTSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7O0FB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TSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDckIsUUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7O0FBRXZCLFFBQU0sQ0FBQyxPQUFPLEdBQUcsQ0FDZixFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxFQUNqQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUM1QixFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxDQUNqQyxDQUFDOztBQUVGLFFBQU0sQ0FBQyxNQUFNLEdBQUcsQ0FDZCxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxFQUNqQyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQzVCLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFDMUIsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFDMUIsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFDekIsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FDNUIsQ0FBQzs7QUFFRixRQUFNLENBQUMsV0FBVyxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFL0MsUUFBTSxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRXhDLFFBQU0sQ0FBQyxNQUFNLEdBQUcsQ0FDZCxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxFQUNsQyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUMzQixFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUM1QixFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUM3QixFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUM5QixFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUM1QixFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxDQUNoQyxDQUFDOztBQUVGLFFBQU0sQ0FBQyxPQUFPLEdBQUcsZUFBZSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUN0RCxRQUFNLENBQUMsTUFBTSxHQUFHLGVBQWUsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDckQsUUFBTSxDQUFDLE9BQU8sR0FBRyxlQUFlLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3RELFFBQU0sQ0FBQyxJQUFJLEdBQUcsZUFBZSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQzs7QUFFL0MsUUFBTSxDQUFDLEdBQUcsR0FBRyxDQUNYLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsRUFDMUMsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsQ0FDakMsQ0FBQztDQUNILENBQUMsQ0FBQzs7Ozs7Ozt1QkN2RmdCLFdBQVc7Ozs7QUFFOUIsb0JBQU8sVUFBVSxDQUFDLE1BQU0sRUFBRSxVQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBSzs7O0FBRy9ELE9BQUssQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUEsR0FBRyxFQUFJO0FBQ3BDLFVBQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7R0FDM0IsQ0FBQyxDQUFDOzs7QUFHSCxRQUFNLENBQUMsS0FBSyxHQUFHLFlBQU07QUFDbkIsUUFBRyxNQUFNLENBQUMsR0FBRyxFQUFFO0FBQ2IsNkJBQXFCLE1BQU0sQ0FBQyxHQUFHLENBQUc7S0FDbkM7O0FBRUQsV0FBTyxXQUFXLENBQUM7R0FDcEIsQ0FBQzs7QUFFRixRQUFNLENBQUMsTUFBTSxHQUFHO1dBQU0sT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUU7R0FBQSxDQUFDOzs7QUFHaEQsV0FBUyxDQUFDLFlBQU07QUFDZCxTQUFLLENBQUMsR0FBRyxDQUFDLHFEQUFxRCxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUEsR0FBRyxFQUFJO0FBQzNFLFlBQU0sQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDdEQsWUFBTSxDQUFDLGVBQWUsR0FBRyxNQUFNLENBQUMsR0FBRyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUM7S0FDekQsQ0FBQyxDQUFDO0dBQ0osRUFBRSxNQUFNLENBQUMsQ0FBQztDQUNaLENBQUMsQ0FBQzs7Ozs7OztzQkMzQlcsUUFBUTs7Ozt1QkFFSCxXQUFXOzs7O2tDQUNSLDRCQUE0Qjs7Ozs2QkFDbkIsdUJBQXVCOztxQ0FDbkIsK0JBQStCOztzQ0FDN0MsZ0NBQWdDOzs7O0FBRXJELG9CQUFPLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxVQUFDLG1CQUFtQixFQUFFLGtCQUFrQixFQUFLO0FBQzVFLFNBQU8sVUFBQyxRQUFRLEVBQUUsSUFBSSxFQUFLO0FBQ3pCLFdBQU8sb0JBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxVQUFBLE9BQU87YUFBSSxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQ3JGLE9BQU8sQ0FBQyxRQUFRLEtBQUssSUFBSSxJQUN6QixrQkFBa0IsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDO0tBQUEsQ0FDN0MsQ0FBQztHQUNILENBQUM7Q0FDSCxDQUFDLENBQUM7O0FBRUgsb0JBQU8sVUFBVSxDQUFDLFVBQVUsRUFBRSxVQUFDLE1BQU0sRUFBRSxhQUFhLEVBQUMsUUFBUSxFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLG1CQUFtQixFQUFLOztBQUU5SCxRQUFNLENBQUMsUUFBUSxzQ0FBVyxDQUFDO0FBQzNCLFFBQU0sQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQztBQUMvQyxRQUFNLENBQUMsbUJBQW1CLEdBQUcsbUJBQW1CLENBQUM7O0FBRWpELE1BQUksUUFBUSxHQUFHLEVBQUUsQ0FBQzs7QUFFbEIsUUFBTSxDQUFDLFVBQVUsR0FBRyxVQUFDLE9BQU8sRUFBSztBQUMvQixRQUFHLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFLE9BQU87QUFDbkQsUUFBRyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7R0FDL0MsQ0FBQzs7QUFFRixNQUFNLGVBQWUsR0FBRyxTQUFsQixlQUFlLEdBQVM7QUFDNUIsUUFBTSxRQUFRLEdBQUcsUUFBUSxHQUFHLHNDQUFVLENBQUM7O0FBRXZDLHdCQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxVQUFBLE1BQU0sRUFBSTtBQUM1RSxVQUFHLG9CQUFFLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLGVBQWEsTUFBTSxDQUFHLEVBQUUsT0FBTztBQUN4RSx3QkFBa0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxjQUFZLE1BQU0sQ0FBRyxDQUFDO0tBQ3ZELENBQUMsQ0FBQzs7QUFFSCx3QkFBRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxFQUFFLFVBQUEsSUFBSSxFQUFJO0FBQzFDLFVBQU0sT0FBTyxHQUFHLG9CQUFFLFNBQVMsc0NBQVcsRUFBRSxJQUFJLEVBQUosSUFBSSxFQUFFLENBQUMsQ0FBQztBQUNoRCxVQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDMUQsQ0FBQyxDQUFDOztBQUVILFlBQVEsQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsU0FBUyxDQUFDOztBQUVuRCx5Q0FBUyxRQUFRLENBQUMsQ0FBQztHQUNwQixDQUFDOztBQUVGLE1BQU0sZUFBZSxHQUFHLFNBQWxCLGVBQWUsQ0FBSSxLQUFLLEVBQUs7QUFDakMsd0JBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxVQUFBLEdBQUcsRUFBSTtBQUNoQyxVQUFNLEdBQUcsR0FBRyxLQUFLLENBQUksR0FBRyxZQUFTLElBQUksQ0FBQyxDQUFDO0FBQ3ZDLHlCQUFtQixDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7S0FDM0MsQ0FBQyxDQUFDO0dBQ0osQ0FBQzs7QUFFRixNQUFHLGFBQWEsQ0FBQyxjQUFjLEVBQUU7QUFDL0IsbUJBQWUsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDOUMsaUJBQWEsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO0dBQ3JDOztBQUVELGlCQUFlLEVBQUUsQ0FBQztBQUNsQixzQ0FBZ0IsQ0FBQzs7QUFFakIsa0NBQVUsRUFBRSxDQUFDLFFBQVEsRUFBRSxZQUFNO0FBQzNCLGlCQUFhLENBQUMsY0FBYyxHQUFHO0FBQzdCLGNBQVEsRUFBRSxnQ0FBVSxRQUFRO0FBQzVCLGNBQVEsRUFBRSxnQ0FBVSxRQUFRO0tBQzdCLENBQUM7R0FDSCxDQUFDLENBQUM7O0FBRUgsTUFBTSxhQUFhLEdBQUcsU0FBaEIsYUFBYSxHQUFTOztBQUUxQixZQUFRLENBQUMsWUFBVztBQUNsQixxQkFBZSxpQ0FBVyxDQUFDOztBQUUzQixtQkFBYSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7O0FBRXBDLHFCQUFlLEVBQUUsQ0FBQztLQUNuQixDQUFDLENBQUM7R0FFSixDQUFDOztBQUVGLGtDQUFVLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxhQUFhLENBQUMsQ0FBQztBQUNoRCxrQ0FBVSxFQUFFLENBQUMsaUJBQWlCLEVBQUUsYUFBYSxDQUFDLENBQUM7Q0FFaEQsQ0FBQyxDQUFDOzs7Ozs7O3VCQ3JGZ0IsV0FBVzs7OztBQUU5QixvQkFBTyxTQUFTLENBQUMsWUFBWSxFQUFFLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSztBQUNsRCxTQUFPO0FBQ0wsU0FBSyxFQUFFO0FBQ0wsa0JBQVksRUFBRSxHQUFHO0tBQ2xCO0FBQ0QsUUFBSSxFQUFFLGNBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUs7QUFDL0IsVUFBTSxPQUFPLEdBQUcsU0FBVixPQUFPLEdBQVM7QUFDcEIsZUFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQU0sT0FBTyxDQUFDLFdBQVcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQSxBQUFDLE9BQUksQ0FBQztPQUMzRixDQUFDOztBQUVGLGFBQU8sRUFBRSxDQUFDOztBQUVWLGFBQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFakQsV0FBSyxDQUFDLE1BQU0sQ0FBQztlQUFNLEtBQUssQ0FBQyxNQUFNO09BQUEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFMUMsVUFBRyxLQUFLLENBQUMsWUFBWSxFQUFFO0FBQ3JCLGFBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLEVBQUUsVUFBQyxRQUFRLEVBQUs7QUFDbkQsY0FBRyxDQUFDLFFBQVEsRUFBRSxPQUFPO0FBQ3JCLGlCQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7U0FDaEQsQ0FBQyxDQUFDO09BQ0o7S0FDRjtHQUNGLENBQUM7Q0FDSCxDQUFDLENBQUM7Ozs7Ozs7dUJDMUJnQixjQUFjOzs7O0FBRWpDLG9CQUFPLFNBQVMsQ0FBQyxLQUFLLEVBQUUsWUFBTTtBQUM1QixTQUFPO0FBQ0wsY0FBVSxFQUFFLEtBQUs7QUFDakIsWUFBUSxFQUFFLEdBQUc7QUFDYixlQUFXLEVBQUUsU0FBUztHQUN2QixDQUFDO0NBQ0gsQ0FBQyxDQUFDOzs7OztRQ1JJLG9CQUFvQjs7UUFDcEIscUJBQXFCOztRQUNyQixtQkFBbUI7O1FBQ25CLHVCQUF1Qjs7UUFDdkIsdUJBQXVCOztRQUN2Qix3QkFBd0I7O1FBR3hCLCtCQUErQjs7UUFDL0IsZ0NBQWdDOztRQUNoQyxnQ0FBZ0M7O1FBRWhDLDJCQUEyQjs7UUFFM0IsMEJBQTBCOzs7Ozs7Ozs7OztzQkNkbkIsUUFBUTs7OztBQUV0QixJQUFNLE9BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDLGNBQWMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDOztBQUUxRSxPQUFNLENBQUMsR0FBRyxDQUFDLFVBQUMsVUFBVTtTQUFLLFVBQVUsQ0FBQyxDQUFDLHNCQUFJO0NBQUEsQ0FBQyxDQUFDOztxQkFFOUIsT0FBTTs7Ozs7Ozs7dUJDTkYsV0FBVzs7OztBQUU5QixvQkFBTyxPQUFPLENBQUMscUJBQXFCLEVBQUUsVUFBQyxhQUFhLEVBQUs7O0FBRXZELE1BQUcsQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFO0FBQzFCLGlCQUFhLENBQUMsUUFBUSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztHQUNsRDs7QUFFRCxNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDOztBQUV4QyxNQUFNLFdBQVcsR0FBRyxTQUFkLFdBQVcsQ0FBSSxHQUFHLEVBQUUsR0FBRyxFQUFLO0FBQ2hDLFlBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUM7QUFDckIsaUJBQWEsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0dBQ25DLENBQUM7O0FBRUYsTUFBTSxXQUFXLEdBQUcsU0FBZCxXQUFXLENBQUksR0FBRyxFQUFFLEdBQUc7V0FBSyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRztHQUFBLENBQUM7O0FBRXZELE1BQU0sV0FBVyxHQUFHLFNBQWQsV0FBVyxDQUFJLEdBQUcsRUFBRSxHQUFHLEVBQUs7QUFDaEMsUUFBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsT0FBTztBQUNsQyxlQUFXLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDeEIsQ0FBQzs7QUFFRixTQUFPO0FBQ0wsZUFBVyxFQUFYLFdBQVc7QUFDWCxlQUFXLEVBQVgsV0FBVztBQUNYLGVBQVcsRUFBWCxXQUFXO0FBQ1gsWUFBUSxFQUFSLFFBQVE7R0FDVCxDQUFDO0NBRUgsQ0FBQyxDQUFDOzs7Ozs7O3VCQzdCZ0IsV0FBVzs7OztBQUU5QixvQkFBTyxPQUFPLENBQUMscUJBQXFCLEVBQUUsVUFBQyxhQUFhLEVBQUs7O0FBRXZELE1BQUcsQ0FBQyxhQUFhLENBQUMsU0FBUyxFQUFFO0FBQzNCLGlCQUFhLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztHQUM5Qjs7QUFFRCxNQUFNLFNBQVMsR0FBRyxhQUFhLENBQUMsU0FBUyxDQUFDOztBQUUxQyxTQUFPO0FBQ0wsYUFBUyxFQUFULFNBQVM7R0FDVixDQUFDO0NBRUgsQ0FBQyxDQUFDOzs7Ozs7O3NCQ2RXLFFBQVE7Ozs7dUJBQ0gsV0FBVzs7OztBQUU5QixvQkFBTyxPQUFPLENBQUMsb0JBQW9CLEVBQUUsVUFBQyxtQkFBbUIsRUFBRSxhQUFhLEVBQUs7O0FBRTNFLE1BQUcsQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFO0FBQzFCLGlCQUFhLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztHQUM3Qjs7QUFFRCxNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDOztBQUV4QyxNQUFNLFdBQVcsR0FBRyxTQUFkLFdBQVcsQ0FBSSxXQUFXO1dBQUssb0JBQUUsUUFBUSxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUM7R0FBQSxDQUFDO0FBQ3ZFLE1BQU0sVUFBVSxHQUFHLFNBQWIsVUFBVSxDQUFJLE9BQU87V0FBSyxXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztHQUFBLENBQUM7O0FBRTFELE1BQU0sYUFBYSxHQUFHLFNBQWhCLGFBQWEsQ0FBSSxPQUFPO1dBQUssT0FBTyxDQUFDLEdBQUcsR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUk7R0FBQSxDQUFDOztBQUVqRixNQUFNLFVBQVUsR0FBRyxTQUFiLFVBQVUsQ0FBSSxPQUFPLEVBQUs7QUFDOUIsUUFBRyxDQUFDLG1CQUFtQixDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPO0FBQzVFLFFBQUcsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUUsT0FBTztBQUNuQyx1QkFBbUIsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDaEUsWUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUIsaUJBQWEsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0dBQ25DLENBQUM7O0FBRUYsTUFBTSxhQUFhLEdBQUcsU0FBaEIsYUFBYSxDQUFJLE9BQU87V0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxhQUFhLENBQUMsT0FBTyxDQUFDO0dBQUEsQ0FBQzs7QUFFbEYsU0FBTztBQUNMLGNBQVUsRUFBVixVQUFVO0FBQ1YsY0FBVSxFQUFWLFVBQVU7QUFDVixlQUFXLEVBQVgsV0FBVztBQUNYLGlCQUFhLEVBQWIsYUFBYTtBQUNiLFlBQVEsRUFBUixRQUFRO0dBQ1QsQ0FBQztDQUVILENBQUMsQ0FBQzs7Ozs7UUNsQ0ksZ0JBQWdCOzs7Ozs7Ozs7OztzQkNBVCxRQUFROzs7O3dCQUNELFlBQVk7Ozs7QUFFakMsSUFBTSxRQUFRLEdBQUc7O0FBRWYsRUFBRSxLQUFLLEVBQUUsZUFBQyxNQUFNO1dBQUssQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFFBQVE7R0FBQSxFQUFFLGFBQWEsRUFBRSw4QkFBOEIsRUFBRSxFQUNwRyxFQUFFLEtBQUssRUFBRSxlQUFDLE1BQU07V0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsYUFBYTtHQUFBLEVBQUUsYUFBYSxFQUFFLHNDQUFzQyxFQUFFLEVBQ2pILEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxRQUFRO0dBQUEsRUFBRSxhQUFhLEVBQUUsdUJBQXVCLEVBQUUsRUFDN0YsRUFBRSxLQUFLLEVBQUUsZUFBQyxNQUFNO1dBQUssQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLE1BQU07R0FBQSxFQUFFLGFBQWEsRUFBRSwyQkFBMkIsRUFBRSxFQUMvRixFQUFFLEtBQUssRUFBRSxlQUFDLE1BQU07V0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsUUFBUTtHQUFBLEVBQUUsYUFBYSxFQUFFLHFCQUFxQixFQUFFLEVBQzNGLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxhQUFhLENBQUMsUUFBUTtHQUFBLEVBQUUsYUFBYSxFQUFFLHVCQUF1QixFQUFFOzs7QUFHNUYsRUFBRSxLQUFLLEVBQUUsZUFBQyxNQUFNO1dBQUssTUFBTSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUM7R0FBQSxFQUFFLGFBQWEsRUFBRSx1QkFBdUIsRUFBRSxFQUM3RixFQUFFLEtBQUssRUFBRSxlQUFDLE1BQU07V0FBSyxNQUFNLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQztHQUFBLEVBQUUsYUFBYSxFQUFFLHNCQUFzQixFQUFFLEVBQzNGLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDO0dBQUEsRUFBRSxhQUFhLEVBQUUsd0JBQXdCLEVBQUUsRUFDL0YsRUFBRSxLQUFLLEVBQUUsZUFBQyxNQUFNO1dBQUssTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUM7R0FBQSxFQUFFLGFBQWEsRUFBRSxtQkFBbUIsRUFBRSxFQUNyRixFQUFFLEtBQUssRUFBRSxlQUFDLE1BQU07V0FBSyxNQUFNLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQztHQUFBLEVBQUUsYUFBYSxFQUFFLHVCQUF1QixFQUFFLEVBQzNGLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO0dBQUEsRUFBRSxhQUFhLEVBQUUscUJBQXFCLEVBQUUsRUFDdkYsRUFBRSxLQUFLLEVBQUUsZUFBQyxNQUFNO1dBQUssTUFBTSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUM7R0FBQSxFQUFFLGFBQWEsRUFBRSxzQkFBc0IsRUFBRSxFQUMxRixFQUFFLEtBQUssRUFBRSxlQUFDLE1BQU07V0FBSyxNQUFNLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQztHQUFBLEVBQUUsYUFBYSxFQUFFLDJCQUEyQixFQUFFLEVBQ2xHLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxRQUFRLEVBQUUsR0FBRyxzQkFBUyxJQUFJLENBQUMsU0FBUztHQUFBLEVBQUUsYUFBYSxFQUFFLGlCQUFpQixFQUFFLEVBQ3BHLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxRQUFRLEVBQUUsR0FBRyxzQkFBUyxJQUFJLENBQUMsU0FBUztHQUFBLEVBQUUsYUFBYSxFQUFFLGlCQUFpQixFQUFFLEVBRXBHLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUM7R0FBQSxFQUFFLGFBQWEsRUFBRSw2QkFBNkIsRUFBRSxFQUN4RyxFQUFFLEtBQUssRUFBRSxlQUFDLE1BQU07V0FBSyxNQUFNLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDO0dBQUEsRUFBRSxhQUFhLEVBQUUsNEJBQTRCLEVBQUUsRUFDdEcsRUFBRSxLQUFLLEVBQUUsZUFBQyxNQUFNO1dBQUssTUFBTSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztHQUFBLEVBQUUsYUFBYSxFQUFFLDJCQUEyQixFQUFFLEVBQ3BHLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUM7R0FBQSxFQUFFLGFBQWEsRUFBRSwyQkFBMkIsRUFBRSxFQUNwRyxFQUFFLEtBQUssRUFBRSxlQUFDLE1BQU07V0FBSyxNQUFNLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQztHQUFBLEVBQUUsYUFBYSxFQUFFLDBCQUEwQixFQUFFOzs7QUFHbEcsRUFBRSxLQUFLLEVBQUUsZUFBQyxNQUFNO1dBQUssTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUM7R0FBQSxFQUFFLGFBQWEsRUFBRSxvQkFBb0IsRUFBRSxFQUN6RixFQUFFLEtBQUssRUFBRSxlQUFDLE1BQU07V0FBSyxNQUFNLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQztHQUFBLEVBQUUsYUFBYSxFQUFFLHFCQUFxQixFQUFFLEVBQzNGLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDO0dBQUEsRUFBRSxhQUFhLEVBQUUsb0JBQW9CLEVBQUU7OztBQUd6RixFQUFFLEtBQUssRUFBRSxlQUFDLE1BQU07V0FBSyxNQUFNLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQztHQUFBLEVBQUUsYUFBYSxFQUFFLG9CQUFvQixFQUFFLEVBQ25GLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDO0dBQUEsRUFBRSxhQUFhLEVBQUUsaUJBQWlCLEVBQUUsRUFDOUUsRUFBRSxLQUFLLEVBQUUsZUFBQyxNQUFNO1dBQUssTUFBTSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUM7R0FBQSxFQUFFLGFBQWEsRUFBRSxpQkFBaUIsRUFBRTs7O0FBRzlFLEVBQUUsS0FBSyxFQUFFLGVBQUMsTUFBTTtXQUFLLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFO0dBQUEsRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLENBQ3JFLENBQUM7O3FCQUVhLFVBQUMsTUFBTSxFQUFLO0FBQ3pCLE1BQU0sWUFBWSxHQUFHLEVBQUUsQ0FBQzs7QUFFeEIsTUFBTSxNQUFNLEdBQUcsQ0FDYixFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQzlDLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRyxJQUFJLEVBQUUsTUFBTSxFQUFHLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFDOUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFJLElBQUksRUFBRSxLQUFLLEVBQUksR0FBRyxFQUFFLFNBQVMsRUFBRSxFQUNsRCxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUksSUFBSSxFQUFFLEtBQUssRUFBSSxHQUFHLEVBQUUsTUFBTSxFQUFFLENBQ2hELENBQUM7O0FBRUYsTUFBTSxhQUFhLEdBQUcsU0FBaEIsYUFBYSxDQUFJLEdBQUc7V0FBSyxvQkFBRSxNQUFNLENBQUMsTUFBTSxFQUFHLFVBQUMsSUFBSSxFQUFFLEdBQUc7YUFBSyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUM7S0FBQSxFQUFHLEdBQUcsQ0FBQztHQUFBLENBQUM7QUFDMUksTUFBTSxVQUFVLEdBQUcsU0FBYixVQUFVLENBQUksR0FBRztXQUFLLFlBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQUEsQ0FBQzs7QUFFbEUsc0JBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxVQUFDLE9BQU8sRUFBSztBQUM1QixRQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDeEIsZ0JBQVUsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDbkMsTUFBTSxJQUFHLE9BQU8sQ0FBQyxhQUFhLEVBQUU7QUFDL0IsZ0JBQVUsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDbkM7R0FDRixDQUFDLENBQUM7O0FBRUgsU0FBTyxvQkFBRSxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7Q0FDL0I7Ozs7Ozs7Ozs7Ozs7c0JDbEVhLFFBQVE7Ozs7QUFFZixJQUFNLE1BQU0sR0FBRyxnQkFBQyxPQUFNO1NBQUssVUFBQyxNQUFNLEVBQUs7QUFBRSxXQUFPLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUU7YUFBTSxPQUFNO0tBQUEsQ0FBQyxFQUFFLE1BQU0sQ0FBQztHQUFFO0NBQUEsQ0FBQzs7QUFDM0csSUFBTSxRQUFRLEdBQUcsa0JBQUMsU0FBUTtTQUFLLFVBQUMsTUFBTSxFQUFLO0FBQUUsV0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxTQUFRLEVBQUUsTUFBTSxDQUFDO0dBQUU7Q0FBQSxDQUFDOztBQUNwRyxJQUFNLFNBQVMsR0FBRyxTQUFaLFNBQVMsQ0FBSSxNQUFNLEVBQUs7QUFBRSxTQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRSxNQUFNLENBQUM7Q0FBRSxDQUFDOztBQUNsRixJQUFNLE1BQU0sR0FBRyxTQUFULE1BQU0sQ0FBSSxLQUFLO1NBQUssVUFBQyxNQUFNLEVBQUs7QUFDM0MsV0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxvQkFBRSxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxFQUFFLE1BQU0sQ0FBQztHQUN4RztDQUFBLENBQUM7Ozs7Ozs7OztxQkNQYTtBQUNiLFNBQU8sRUFBRSxTQUFTO0FBQ2xCLFFBQU0sRUFBRSxRQUFROztBQUVoQixPQUFLLEVBQUUsT0FBTzs7QUFFZCxLQUFHLEVBQUUsS0FBSztDQUNYOzs7Ozs7Ozs7QUNQTSxJQUFNLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDOzs7QUFFcFMsSUFBTSxNQUFNLEdBQUcsQ0FBQyxNQUFNLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDOzs7Ozs7Ozs7QUNGblIsSUFBTSxRQUFRLEdBQUc7QUFDdEIsVUFBUSxFQUFFO0FBQ1IsU0FBSyxFQUFFLE1BQU07QUFDYixRQUFJLEVBQUUsS0FBSztBQUNYLFNBQUssRUFBRSxPQUFPO0FBQ2QsT0FBRyxFQUFFLFdBQVc7R0FDakI7QUFDRCxPQUFLLEVBQUU7QUFDTCxTQUFLLEVBQUUsTUFBTTtBQUNiLFFBQUksRUFBRSxPQUFPO0FBQ2IsY0FBVSxFQUFFLFFBQVE7QUFDcEIsWUFBUSxFQUFFLFFBQVE7QUFDbEIsWUFBUSxFQUFFLEtBQUs7QUFDZixVQUFNLEVBQUUsRUFBRTtBQUNWLFlBQVEsRUFBRSxFQUFFO0FBQ1osYUFBUyxFQUFFLEVBQUU7QUFDYixlQUFXLEVBQUUsRUFBRTtHQUNoQjtBQUNELFFBQU0sRUFBRTtBQUNOLFNBQUssRUFBRSxNQUFNO0FBQ2IsVUFBTSxFQUFFLFFBQVE7QUFDaEIsU0FBSyxFQUFFLE9BQU87QUFDZCxTQUFLLEVBQUUsT0FBTztBQUNkLE9BQUcsRUFBRSxLQUFLO0FBQ1YsUUFBSSxFQUFFLE1BQU07R0FDYjtDQUNGLENBQUM7OztBQUVLLElBQU0sS0FBSyxHQUFHO0FBQ25CLE1BQUksRUFBRSxNQUFNO0NBQ2IsQ0FBQzs7O0FBRUssSUFBTSxLQUFLLEdBQUc7QUFDbkIsTUFBSSxFQUFFLE1BQU07QUFDWixVQUFRLEVBQUUsTUFBTTtBQUNoQixNQUFJLEVBQUUsU0FBUztBQUNmLFFBQU0sRUFBRSxRQUFRO0NBQ2pCLENBQUM7OztBQUVLLElBQU0sT0FBTyxHQUFHO0FBQ3JCLE9BQUssRUFBRSxNQUFNO0NBQ2QsQ0FBQzs7Ozs7Ozs7O0FDekNLLElBQU0sUUFBUSxHQUFHO0FBQ3RCLFFBQU0sRUFBRSxHQUFHOztBQUVYLEtBQUcsRUFBRSxHQUFHO0FBQ1IsUUFBTSxFQUFFLEdBQUc7QUFDWCxPQUFLLEVBQUUsR0FBRztBQUNWLFdBQVMsRUFBRSxHQUFHO0FBQ2QsT0FBSyxFQUFFLEdBQUc7QUFDVixVQUFRLEVBQUUsR0FBRztBQUNiLE9BQUssRUFBRSxHQUFHO0FBQ1YsUUFBTSxFQUFFLEdBQUc7QUFDWCxRQUFNLEVBQUUsR0FBRztBQUNYLFVBQVEsRUFBRSxHQUFHO0FBQ2IsT0FBSyxFQUFFLEdBQUc7QUFDVixLQUFHLEVBQUUsR0FBRztBQUNSLFNBQU8sRUFBRSxHQUFHO0FBQ1osS0FBRyxFQUFFLEdBQUc7QUFDUixPQUFLLEVBQUUsR0FBRztBQUNWLE9BQUssRUFBRSxHQUFHO0NBQ1gsQ0FBQzs7O0FBRUssSUFBTSxLQUFLLEdBQUc7QUFDbkIsTUFBSSxFQUFFLEdBQUc7QUFDVCxPQUFLLEVBQUUsR0FBRztBQUNWLFlBQVUsRUFBRSxHQUFHO0FBQ2YsTUFBSSxFQUFFLEdBQUc7QUFDVCxLQUFHLEVBQUUsR0FBRztBQUNSLE1BQUksRUFBRSxHQUFHO0FBQ1QsT0FBSyxFQUFFLEdBQUc7QUFDVixNQUFJLEVBQUUsR0FBRztBQUNULE1BQUksRUFBRSxHQUFHO0FBQ1QsUUFBTSxFQUFFLEdBQUc7QUFDWCxNQUFJLEVBQUUsR0FBRztBQUNULFFBQU0sRUFBRSxHQUFHO0FBQ1gsV0FBUyxFQUFFLEdBQUc7QUFDZCxNQUFJLEVBQUUsR0FBRztBQUNULE1BQUksRUFBRSxHQUFHO0FBQ1QsT0FBSyxFQUFFLEdBQUc7Q0FDWCxDQUFDOzs7QUFFSyxJQUFNLEtBQUssR0FBRztBQUNuQixPQUFLLEVBQUUsR0FBRztBQUNWLFVBQVEsRUFBRSxHQUFHO0FBQ2IsWUFBVSxFQUFFLEdBQUc7QUFDZixvQkFBa0IsRUFBRSxHQUFHO0FBQ3ZCLGtCQUFnQixFQUFFLEdBQUc7QUFDckIsT0FBSyxFQUFFLEdBQUc7QUFDVixVQUFRLEVBQUUsR0FBRztBQUNiLE1BQUksRUFBRSxHQUFHO0FBQ1QsWUFBVSxFQUFFLEdBQUc7QUFDZixVQUFRLEVBQUUsR0FBRztBQUNiLFFBQU0sRUFBRSxJQUFJO0FBQ1osZ0JBQWMsRUFBRSxHQUFHO0FBQ25CLGNBQVksRUFBRSxHQUFHO0NBQ2xCLENBQUM7Ozs7Ozs7Ozs7OztzQkN0RFksUUFBUTs7OztBQUV0QixJQUFNLFNBQVMsR0FBRztBQUNoQixTQUFPLEVBQUUsQ0FBQztBQUNWLE9BQUssRUFBRSxDQUFDO0FBQ1IsU0FBTyxFQUFFLENBQUM7QUFDVixNQUFJLEVBQUUsQ0FBQztBQUNQLFNBQU8sRUFBRSxDQUFDO0FBQ1YsUUFBTSxFQUFFLENBQUM7QUFDVCxPQUFLLEVBQUUsQ0FBQztBQUNSLFFBQU0sRUFBRSxDQUFDO0FBQ1QsTUFBSSxFQUFFLENBQUM7QUFDUCxNQUFJLEVBQUUsQ0FBQztBQUNQLFFBQU0sRUFBRSxFQUFFO0FBQ1YsTUFBSSxFQUFFLEVBQUU7QUFDUixTQUFPLEVBQUUsRUFBRTtBQUNYLFNBQU8sRUFBRSxFQUFFO0FBQ1gsT0FBSyxFQUFFLEVBQUU7Q0FDVixDQUFDOztxQkFFYSxTQUFTO0FBRWpCLElBQU0sY0FBYyxHQUFLLFNBQW5CLGNBQWMsQ0FBTSxJQUFJO1NBQUssb0JBQUUsUUFBUSxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQztDQUFBLENBQUM7O0FBQ3ZKLElBQU0sY0FBYyxHQUFLLFNBQW5CLGNBQWMsQ0FBTSxJQUFJO1NBQUssb0JBQUUsUUFBUSxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDO0NBQUEsQ0FBQzs7QUFDbEgsSUFBTSxnQkFBZ0IsR0FBRyxTQUFuQixnQkFBZ0IsQ0FBSSxJQUFJO1NBQUssb0JBQUUsUUFBUSxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDO0NBQUEsQ0FBQzs7QUFDbkgsSUFBTSxhQUFhLEdBQU0sU0FBbkIsYUFBYSxDQUFPLElBQUk7U0FBSyxvQkFBRSxRQUFRLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQztDQUFBLENBQUM7Ozs7Ozs7Ozs7Ozs7O3NCQ3pCekUsUUFBUTs7OztpQ0FDQyx3QkFBd0I7O0lBQW5DLEtBQUs7O2lDQUNNLHdCQUF3Qjs7SUFBbkMsS0FBSzs7aUNBQ00sd0JBQXdCOztJQUFuQyxLQUFLOztpQ0FDTSx3QkFBd0I7O0lBQW5DLEtBQUs7O2lDQUNNLHdCQUF3Qjs7SUFBbkMsS0FBSzs7aUNBQ00sd0JBQXdCOztJQUFuQyxLQUFLOztpQ0FDTSx3QkFBd0I7O0lBQW5DLEtBQUs7O2tDQUNPLHlCQUF5Qjs7SUFBckMsTUFBTTs7a0NBQ00seUJBQXlCOztJQUFyQyxNQUFNOztvQ0FDTywyQkFBMkI7O0lBQXhDLE9BQU87O21DQUNNLDBCQUEwQjs7SUFBdkMsT0FBTzs7c0NBQ1MsNkJBQTZCOztJQUE3QyxVQUFVOzt1Q0FDTyw4QkFBOEI7O0lBQS9DLFdBQVc7O3NDQUNNLDZCQUE2Qjs7SUFBOUMsV0FBVzs7Z0NBQ0EsdUJBQXVCOztJQUFsQyxLQUFLOztBQUVqQixJQUFNLFNBQVMsR0FBRyxTQUFaLFNBQVMsQ0FBSSxJQUFJO01BQUUsT0FBTyx5REFBRyxFQUFFO1NBQUsseUJBQUUsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQUMsSUFBSTtXQUFLLENBQUMsb0JBQUUsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDO0dBQUEsQ0FBQyxDQUFDLE1BQU0sRUFBRTtDQUFBLENBQUM7O0FBRS9HLElBQU0sSUFBSSxHQUFHLFNBQVAsSUFBSSxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQ3RFLElBQU0sSUFBSSxHQUFHLFNBQVAsSUFBSSxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQ3RFLElBQU0sSUFBSSxHQUFHLFNBQVAsSUFBSSxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQ3RFLElBQU0sSUFBSSxHQUFHLFNBQVAsSUFBSSxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQ3RFLElBQU0sSUFBSSxHQUFHLFNBQVAsSUFBSSxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQ3RFLElBQU0sSUFBSSxHQUFHLFNBQVAsSUFBSSxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQ3RFLElBQU0sSUFBSSxHQUFHLFNBQVAsSUFBSSxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQ3RFLElBQU0sS0FBSyxHQUFHLFNBQVIsS0FBSyxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQ3hFLElBQU0sS0FBSyxHQUFHLFNBQVIsS0FBSyxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQ3hFLElBQU0sTUFBTSxHQUFHLFNBQVQsTUFBTSxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQzFFLElBQU0sTUFBTSxHQUFHLFNBQVQsTUFBTSxDQUFJLElBQUksRUFBRSxPQUFPO1NBQUssS0FBSyxTQUFTLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBQyxDQUFFLElBQUksQ0FBQztDQUFBLENBQUM7O0FBQzFFLElBQU0sU0FBUyxHQUFHLFNBQVosU0FBUyxDQUFJLElBQUksRUFB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QUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztXQUM1QjtBQUNELGNBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1NBQ3pCO0FBQ0QsWUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7T0FDdEI7O0FBRUQsVUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDbEIsVUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7QUFDbkIsVUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7QUFDckIsVUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDbEIsVUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDaEIsVUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7QUFDckIsVUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7S0FDdEI7OztTQXBUa0IsS0FBSzs7O3FCQUFMLEtBQUsiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQnJhZ2kgKEphdmFzY3JpcHQgTG9nZ2VyIC0gQnJvd3NlcilcbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqIEF1dGhvciA6IEVyaWsgSGF6emFyZCAoIGh0dHA6Ly92YXNpci5uZXQgKVxuICpcbiAqIFByb3ZpZGVzIGEgTE9HR0VSIG9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGxvZ2dpbmdcbiAqICAgICAgTE9HR0VSLmxvZygnZ3JvdXAxJywgJ2hlbGxvIHdvcmxkJyk7XG4gKlxuICogICAgICAvLyBBbHNvLCBwYXJhc20gY2FuIGJlIHBhc3NlZCBpblxuICogICAgICBMT0dHRVIubG9nKCdncm91cDEnLCAnbWVzc2FnZScsIHBhcmFtMSwgcGFyYW0yLCBldGMuLi4pO1xuICogICAgICBcbiAqICAgICAgLy8gQW5kIHN1Ymdyb3VwcyBjYW4gYmUgbG9nZ2VkXG4gKiAgICAgIExPR0dFUi5sb2coJ2dyb3VwMTpzdWJncm91cCcsICdtZXNzYWdlICVqJywgcGFyYW0xKTsgXG4gKiAgICAgIFxuICogVG8gY2hhbmdlIGxvZ2dlciBvcHRpb25zOlxuICogICAgICAvLyBTaG93cyBBTEwgbWVzc2FnZXMgKGZhbHNlIHRvIHNob3cgbm9uZSlcbiAqICAgICAgTE9HR0VSLm9wdGlvbnMuZ3JvdXBzRW5hYmxlZCA9IHRydWU7IFxuICpcbiAqICAgICAgLy8gU2hvd3Mgb25seSBzcGVjaWZpYyBncm91cHNcbiAqICAgICAgTE9HR0VSLm9wdGlvbnMuZ3JvdXBzRW5hYmxlZCA9IFsnZXJyb3InLCAnZGVidWcnXTsgLy8gb25seSBzaG93cyBwYXNzZWQgaW4gZ3JvdXBzIFxuICpcbiAqICAgICAgLy8gQ2FuIGFsc28gZmlsdGVyIG9uIHN1Ymdyb3Vwc1xuICogICAgICBMT0dHRVIub3B0aW9ucy5ncm91cHNFbmFibGVkID0gWydncm91cDE6c3ViZ3JvdXAxJ107IFxuICpcbiAqICAgICAgLy8gT3IgcmVndWxhciBleHByZXNzaW9uc1xuICogICAgICBMT0dHRVIub3B0aW9ucy5ncm91cHNFbmFibGVkID0gWy9ec3RhcnQ6dG86ZW5kJC9dXG4gKlxuICogVG8gY2hhbmdlIHN0b3Jpbmcgc3RhY2sgdHJhY2VzIChnaXZlcyBtb3JlIGluZm8sIGJ1dCBhZGRzIGEgbm9udHJpdmlhbCBhbW91bnQgXG4gKiAgICAgIG9mIHRpbWUpLCBjaGFuZ2UgdGhlIGBzdG9yZVN0YWNrVHJhY2VgIHByb3BlcnR5LiBJdCBpcyBgZmFsc2VgIGJ5IGRlZmF1bHRcbiAqXG4gKiAgICAgIExPR0dFUi5vcHRpb25zLnN0b3JlU3RhY2tUcmFjZSA9IHRydWU7XG4gKlxuICogVFJBTlNQT1JUU1xuICogICAgICBMb2dzIGFyZSBvdXRwdXQgLyB3cml0dGVuIHRvIGEgZmlsZSAvIHBpcHBlZCB0byBhIHNlcnZlciBieSBtZWFuc1xuICogICAgICBvZiB0cmFuc3BvcnRzXG4gKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBjYW5Mb2cgPSByZXF1aXJlKCcuL2JyYWdpL2NhbkxvZycpO1xuXG4vLyBUcmFuc3BvcnRzIGlzIGFuIG9iamVjdCB3aGljaCB3ZSBjYW4gYWRkIC8gcmVtb3ZlIHRyYW5zcG9ydCBvYmplY3RzIHRvXG52YXIgVHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vYnJhZ2kvdHJhbnNwb3J0cy9UcmFuc3BvcnRzJyk7XG5cbi8vIHRyYW5zcG9ydHMgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGF2YWlsYWJsZSB0cmFuc3BvcnRzXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vYnJhZ2kvdHJhbnNwb3J0cycpO1xuXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBpbiB0aGUgdHJhbnNwb3J0c1xudmFyIFNZTUJPTFMgPSByZXF1aXJlKCcuL2JyYWdpL3N5bWJvbHMnKTtcblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAvLyBTZXR1cCBsb2dnZXIgZm9yIHRoZSBlbnZpcm9ubWVudFxuICAgIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBSZXF1aXJlSlMgLyBBTURcbiAgICAgICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgICAgICAgICByb290ID0gZmFjdG9yeShyb290LCBleHBvcnRzKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBDb21tb25KU1xuICAgICAgICBmYWN0b3J5KHJvb3QsIGV4cG9ydHMpOyBcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYnJvd3NlciBnbG9iYWwgaWYgbmVpdGhlciBhcmUgc3VwcG9ydGVkXG4gICAgICAgIHJvb3QubG9nZ2VyID0gZmFjdG9yeShyb290LCB7fSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbihyb290LCBsb2dnZXIpIHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBTZXR1cCBsb2dnZXIgb2JqZWN0XG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEhlcmUsIHdlIHVzZSBvbmx5IGEgc2luZ2xlIExPR0dFUiBvYmplY3Qgd2hpY2ggaXMgc2hhcmVkIGFtb25nIGFsbCBmaWxlc1xuICAgIC8vIHdoaWNoIGltcG9ydCBCcmFnaS4gXG4gICAgLy8gTk9URTogV2h5IHVzZSBhIHNpbmdsZSBvYmplY3Q/IFdoYXQgYXJlIGJlbmVmaXRzPyBDb3VsZCBleHBvc2UgYSBcIm5ld1wiXG4gICAgLy8gIGxvZ2dlciBvYmplY3RcblxuICAgIC8vIE5PVEU6IEl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBoYXZlIG11bHRpcGxlIGxvZ2dlcnM/XG4gICAgdmFyIExPR0dFUiA9IHtcbiAgICAgICAgdXRpbDoge30sXG5cbiAgICAgICAgLy8gcmVmZXJlbmNlIHRvIGNhbkxvZyBmdW5jdGlvblxuICAgICAgICBjYW5Mb2c6IGNhbkxvZ1xuICAgIH07XG5cbiAgICAvLyBTZXR1cCBsaW5lIG51bWJlciAvIGZ1bmN0aW9uIG5hbWUgbG9nZ2luZyBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIExPR0dFUi51dGlsLl9fc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXRpbGl0eSB0byBnZXQgc3RhY2sgaW5mb3JtYXRpb25cbiAgICAgICAgdmFyIHN0YWNrID0gbnVsbDtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgdmFyIG9yaWcgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24oXywgc3RhY2spIHsgcmV0dXJuIHN0YWNrOyB9O1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICAgIHN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBvcmlnO1xuICAgICAgICB9IGNhdGNoKGUpeyB9XG5cbiAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEV4cG9zZSBzdHlsZXMgdG8gdXNlcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNvbWUgc3ltYm9scyBmb3IgdGhlIHVzZXJcbiAgICBMT0dHRVIudXRpbC5zeW1ib2xzID0gU1lNQk9MUzsgXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gU2V0dXAgb3B0aW9uc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBMT0dHRVIub3B0aW9ucyA9IHtcbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIC8vIFByaW1hcnkgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gZ3JvdXBzRW5hYmxlZDogc3BlY2lmaWVzIHdoYXQgbG9ncyB0byBkaXNwbGF5LiBDYW4gYmUgZWl0aGVyOlxuICAgICAgICAvLyAgICAgIDEuIGFuIHthcnJheX0gb2YgbG9nIGxldmVscyBcbiAgICAgICAgLy8gICAgICAgICAgZS5nLC4gWydlcnJvcicsICdteUxvZzEnLCAnbXlMb2cyJ11cbiAgICAgICAgLy8gICAgb3JcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAyLiBhIHtCb29sZWFufSA6IHRydWUgdG8gc2VlICphbGwqIGxvZyBtZXNzYWdlcywgZmFsc2UgdG9cbiAgICAgICAgLy8gICAgICAgICAgc2VlICpubyogbWVzc2FnZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZ3JvdXBzRW5hYmxlZCBhY3RzIGFzIGEgXCJ3aGl0ZWxpc3RcIiBmb3Igd2hhdCBtZXNzYWdlcyB0byBsb2dcbiAgICAgICAgZ3JvdXBzRW5hYmxlZDogdHJ1ZSxcblxuICAgICAgICAvLyBibGFja0xpc3QgaXMgYW4gYXJyYXkgb2YgbG9nIGxldmVsIGdyb3VwcyB3aGljaCB3aWxsIGFsd2F5cyBiZSBleGNsdWRlZC5cbiAgICAgICAgLy8gTGV2ZWxzIHNwZWNpZmllZCBoZXJlIHRha2UgcHJpb3JpdHkgb3ZlciBsb2cgZ3JvdXBzIHNwZWNpZmllZCBpbiBncm91cHNFbmFibGVkXG4gICAgICAgIGdyb3Vwc0Rpc2FibGVkOiBbXSxcblxuICAgICAgICAvLyBTdG9yZSBzdGFjayB0cmFjZT8gUHJvdmlkZXMgbW9yZSBpbmZvLCBidXQgYWRkcyBvdmVyaGVhZC4gVmVyeSB1c2VmdWxcbiAgICAgICAgLy8gd2hlbiBpbiBkZXZlbG9wbWVudCwgdHJhZGVvZmZzIHNob3VsZCBiZSBjb25zaWRlcmVkIHdoZW4gaW4gcHJvZHVjdGlvblxuICAgICAgICBzdG9yZVN0YWNrVHJhY2U6IGZhbHNlXG4gICAgfTtcblxuXG4gICAgLy8gU2V0dXAgZGVmYXVsdCB0cmFuc3BvcnRzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0cmFuc3BvcnRzIGlzIHRoZSB0cmFuc3BvcnRzIGFycmF5IHRoZSBsb2dnZXIgdXNlcnMuIFxuICAgIExPR0dFUi50cmFuc3BvcnRzID0gbmV3IFRyYW5zcG9ydHMoKTtcblxuICAgIC8vIERlZmF1bHQgdHJhbnNwb3J0c1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOT1RFOiAgc2VlIHRoZSBDb25zb2xlIHRyYW5zcG9ydCBmb3IgaW5mbyBvbiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgIC8vIE5PVEU6IERvIG5vdCBcbiAgICB2YXIgX2RlZmF1bHRUcmFuc3BvcnRzID0gW1xuICAgICAgICBuZXcgdHJhbnNwb3J0cy5Db25zb2xlKHtcbiAgICAgICAgICAgIHNob3dNZXRhOiB0cnVlLFxuICAgICAgICAgICAgc2hvd1N0YWNrVHJhY2U6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgXTtcblxuICAgIC8vIE90aGVyIHRyYW5zcG9ydHMgaW5jbHVkZTpcbiAgICAvLyAgICAgIG5ldyB0cmFuc3BvcnRzLkNvbnNvbGVKU09OKHt9KSBcbiAgICAvLyBcbiAgICAvLyAgICAgIG5ldyB0cmFuc3BvcnRzLkhpc3Rvcnkoe1xuICAgIC8vICAgICAgICAgIHN0b3JlRXZlcnl0aGluZzogZmFsc2VcbiAgICAvLyAgICAgIH0pXG4gICAgLy9cbiAgICAvLyAgICAgIG5ldyB0cmFuc3BvcnRzLkZpbGUoe1xuICAgIC8vICAgICAgICAgIGZpbGVuYW1lOiAnL3RtcC90ZXN0Lmpzb24nXG4gICAgLy8gICAgICAgICB9KVxuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IF9kZWZhdWx0VHJhbnNwb3J0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIExPR0dFUi50cmFuc3BvcnRzLmFkZCggX2RlZmF1bHRUcmFuc3BvcnRzW2ldICk7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGEgcmVmZXJlbmNlIHRvIGFsbCBhdmFpbGFibGUgdHJhbnNwb3J0c1xuICAgIC8vIE5PVEU6IFRoaXMgaXNuJ3QgdGhlIGNsZWFuZXN0IHdheSB0byBkbyB0aGlzLCBjb3VsZCB1c2UgaW1wcm92ZW1lbnRcbiAgICBMT0dHRVIudHJhbnNwb3J0Q2xhc3NlcyA9IHRyYW5zcG9ydHM7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBHcm91cCBBZGRpdGlvbiAvIFJlbW92YWwgRnVuY3Rpb25zXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgTE9HR0VSLmFkZEdyb3VwID0gZnVuY3Rpb24gYWRkR3JvdXAgKCBncm91cCApe1xuICAgICAgICAvLyBBZGQgYSBwYXNzZWQgaW4gZ3JvdXAgKGVpdGhlciBhIHtTdHJpbmd9IG9yIHtSZWdFeHB9KSB0byB0aGVcbiAgICAgICAgLy8gZ3JvdXBzRW5hYmxlZCBhcnJheVxuXG4gICAgICAgIC8vIElmIGdyb3Vwc0VuYWJsZWQgaXMgdHJ1ZSBvciBmYWxzZSwgdHVybiBpdCBpbnRvIGFuIGFycmF5XG4gICAgICAgIHZhciBncm91cHNFbmFibGVkID0gTE9HR0VSLm9wdGlvbnMuZ3JvdXBzRW5hYmxlZDtcblxuICAgICAgICBpZihncm91cHNFbmFibGVkID09PSB0cnVlIHx8IGdyb3Vwc0VuYWJsZWQgPT09IGZhbHNlKXtcbiAgICAgICAgICAgIExPR0dFUi5vcHRpb25zLmdyb3Vwc0VuYWJsZWQgPSBncm91cHNFbmFibGVkID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgaXQgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSBncm91cHNFbmFibGVkLmxlbmd0aDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgaWYoZ3JvdXBzRW5hYmxlZFtpXS50b1N0cmluZygpID09PSBncm91cC50b1N0cmluZygpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gTE9HR0VSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR3JvdXAgd2Fzbid0IGZvdW5kIHlldCwgYWRkIGl0XG4gICAgICAgIGdyb3Vwc0VuYWJsZWQucHVzaCggZ3JvdXAgKTtcblxuICAgICAgICByZXR1cm4gTE9HR0VSO1xuICAgIH07XG5cbiAgICBMT0dHRVIucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbiByZW1vdmVHcm91cCAoIGdyb3VwICl7XG4gICAgICAgIC8vIFRha2VzIGluIGEgZ3JvdXAgYW5kIHJlbW92ZXMgYWxsIG9jY3VyZW5jZXMgb2YgaXQgZnJvbSBcbiAgICAgICAgLy8gZ3JvdXBzRW5hYmxlZFxuICAgICAgICBcbiAgICAgICAgLy8gSWYgZ3JvdXBzRW5hYmxlZCBpcyB0cnVlIG9yIGZhbHNlLCB0dXJuIGl0IGludG8gYW4gYXJyYXlcbiAgICAgICAgdmFyIGdyb3Vwc0VuYWJsZWQgPSBMT0dHRVIub3B0aW9ucy5ncm91cHNFbmFibGVkO1xuXG4gICAgICAgIGlmKGdyb3Vwc0VuYWJsZWQgPT09IHRydWUgfHwgZ3JvdXBzRW5hYmxlZCA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgTE9HR0VSLm9wdGlvbnMuZ3JvdXBzRW5hYmxlZCA9IGdyb3Vwc0VuYWJsZWQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSBpdCBkb2VzIG5vdCBleGlzdFxuICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGdyb3Vwc0VuYWJsZWQubGVuZ3RoO1xuICAgICAgICB2YXIgZ3JvdXBzRW5hYmxlZFdpdGhvdXRHcm91cCA9IFtdO1xuXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgIGlmKGdyb3Vwc0VuYWJsZWRbaV0udG9TdHJpbmcoKSAhPT0gZ3JvdXAudG9TdHJpbmcoKSl7XG4gICAgICAgICAgICAgICAgZ3JvdXBzRW5hYmxlZFdpdGhvdXRHcm91cC5wdXNoKCBncm91cHNFbmFibGVkW2ldICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGdyb3Vwc0VuYWJsZWRcbiAgICAgICAgTE9HR0VSLm9wdGlvbnMuZ3JvdXBzRW5hYmxlZCA9IGdyb3Vwc0VuYWJsZWRXaXRob3V0R3JvdXA7XG5cbiAgICAgICAgcmV0dXJuIExPR0dFUjtcbiAgICB9O1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gVVRJTCBmdW5jdGlvbnNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBMT0dHRVIudXRpbC5wcmludCA9IGZ1bmN0aW9uIHByaW50KG1lc3NhZ2UsIGNvbG9yKXtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBhIHN0dWIgZnVuY3Rpb24gd2hpY2ggZXhpc3RzIGluIEJyYWdpLCBidXQgbm90IGluXG4gICAgICAgIC8vIHRoZSBicm93c2VyIHZlcnNpb24uIFdlIGNvdWxkIHByaW50IGluZGl2aWR1YWwgY29sb3JzLCBidXQgaXQgXG4gICAgICAgIC8vIHJlcXVpcmVzIGFkZGluZyBhbiBhZGRpdGlvbmFsIENTUyBzdHJpbmcgdG8gY29uc29sZS5sb2coKS4gVGhpcyBpc1xuICAgICAgICAvLyBhIFRPRE9cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIExPRyBmdW5jdGlvblxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIExPR0dFUi5sb2cgPSBmdW5jdGlvbiBsb2dnZXJMb2coZ3JvdXAsIG1lc3NhZ2Upe1xuICAgICAgICAvLyBNYWluIGxvZ2dpbmcgZnVuY3Rpb24uIFRha2VzIGluIHR3byAocGx1cyBuKSBwYXJhbWV0ZXJzOlxuICAgICAgICAvLyAgIGdyb3VwOiB7U3RyaW5nfSBzcGVjaWZpZXMgdGhlIGxvZyBsZXZlbCwgb3IgbG9nIGdyb3VwXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgbWVzc2FnZToge1N0cmluZ30gdGhlIG1lc3NhZ2UgdG8gbG9nLiBUaGUgbWVzc2FnZSBtdXN0IGJlIGEgc2luZ2xlXG4gICAgICAgIC8vICAgICAgc3RyaW5nLCBidXQgY2FuIGhhdmUgbXVsdGlwbGUgb2JqZWN0cyBpbnNpZGUgdXNpbmcgYCVPYC4gZS5nLixcbiAgICAgICAgLy8gICAgICAgICAgbG9nZ2VyLmxvZygndGVzdCcsICdzb21lIG9iamVjdDogJU8nLCB7YW5zd2VyOiA0Mn0pO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgIGFsbCBvdGhlciBwYXJhbWV0ZXJzIGFyZSBvYmplY3RzIG9yIHN0cmluZ3MgdGhhdCB3aWxsIGJlIGZvcm1hdHRlZFxuICAgICAgICAvLyAgIGludG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIGdyb3Vwc0VuYWJsZWQsIGdyb3Vwc0Rpc2FibGVkLCBjdXJyZW50VHJhbnNwb3J0O1xuICAgICAgICB2YXIgdHJhbnNwb3J0RnVuY3NUb0NhbGwgPSBbXTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNhbiBiZSBsb2dnZWQgb3Igbm90LiBBbGwgdHJhbnNwb3J0cyBtdXN0IGJlIGNoZWNrZWQgYXNcbiAgICAgICAgLy8gd2VsbCwgYXMgdGhleSBjYW4gb3ZlcnJpZGUgTE9HR0VSLm9wdGlvbnMuZ3JvdXBzRW5hYmxlZCBcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBGb3IgZWFjaCB0cmFuc3BvcnQsIGlmIGl0IGNhbiBiZSBsb2dnZWQsIGxvZyBpdFxuICAgICAgICBmb3IodmFyIHRyYW5zcG9ydCBpbiBMT0dHRVIudHJhbnNwb3J0cy5fdHJhbnNwb3J0cyl7XG4gICAgICAgICAgICBjdXJyZW50VHJhbnNwb3J0ID0gTE9HR0VSLnRyYW5zcG9ydHMuX3RyYW5zcG9ydHNbdHJhbnNwb3J0XTtcblxuICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCwgdXNlIHRoZSBncm91cHNFbmFibGVkIGFuZCBncm91cHNEaXNhYmxlZCBzcGVjaWZpZWQgaW4gXG4gICAgICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgICAgICBncm91cHNFbmFibGVkID0gTE9HR0VSLm9wdGlvbnMuZ3JvdXBzRW5hYmxlZDtcbiAgICAgICAgICAgIGdyb3Vwc0Rpc2FibGVkID0gTE9HR0VSLm9wdGlvbnMuZ3JvdXBzRGlzYWJsZWQ7XG5cbiAgICAgICAgICAgIC8vIElmIHRyYW5zcG9ydCBvdmVycmlkZXMgZXhpc3QsIHVzZSB0aGVtXG4gICAgICAgICAgICBpZihjdXJyZW50VHJhbnNwb3J0Lmdyb3Vwc0VuYWJsZWQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgZ3JvdXBzRW5hYmxlZCA9IGN1cnJlbnRUcmFuc3BvcnQuZ3JvdXBzRW5hYmxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGN1cnJlbnRUcmFuc3BvcnQuZ3JvdXBzRGlzYWJsZWQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgZ3JvdXBzRGlzYWJsZWQgPSBjdXJyZW50VHJhbnNwb3J0Lmdyb3Vwc0Rpc2FibGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBtZXNzYWdlIGNhbiBiZSBsb2dnZWRcbiAgICAgICAgICAgIGlmKGNhbkxvZyhncm91cCwgZ3JvdXBzRW5hYmxlZCwgZ3JvdXBzRGlzYWJsZWQpKXtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRGdW5jc1RvQ2FsbC5wdXNoKCBjdXJyZW50VHJhbnNwb3J0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYW4gdGhpcyBtZXNzYWdlIGJlIGxvZ2dlZD8gSWYgbm90LCBkbyBub3RoaW5nXG4gICAgICAgIGlmKHRyYW5zcG9ydEZ1bmNzVG9DYWxsLmxlbmd0aCA8IDEpeyBcbiAgICAgICAgICAgIC8vIENhbiBOT1QgYmUgbG9nZ2VkIGlmIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRGdW5jcyB0byBjYWxsIFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIHN0b3JlQWxsSGlzdG9yeSBpcyBub3QgdHJ1ZSwgcmV0dXJuIGltbWVkaWF0ZWx5IChpZiBpdCBpc1xuICAgICAgICAgICAgLy8gdHJ1ZSwgdGhlIG1lc3NhZ2Ugd2lsbCBnZXQgc3RvcmVkIGp1c3Qgbm90IHBhc3NlZCB0byBhbnlcbiAgICAgICAgICAgIC8vIHRyYW5zcG9ydHMpXG4gICAgICAgICAgICBpZighTE9HR0VSLm9wdGlvbnMuc3RvcmVBbGxIaXN0b3J5KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYWxsIGFyZ3VtZW50c1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZ3JvdXAgYW5kIG1lc3NhZ2UgZnJvbSB0aGUgYXJncyBhcnJheSwgc28gdGhlIG5ldyBhcmdzIGFycmF5IHdpbGxcbiAgICAgICAgLy8ganVzdCBiZSBhbiBhcnJheSBvZiB0aGUgcGFzc2VkIGluIGFyZ3VtZW50c1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIEJ1aWxkIHVwIGEgYGxvZ2dlZE9iamVjdGAsIGEgc3RydWN0dXJlZCBvYmplY3QgY29udGFpbmluZyBsb2cgXG4gICAgICAgIC8vIGluZm9ybWF0aW9uLiBJdCBjYW4gYmUgb3V0cHV0IHRvIHRoZSBjb25zb2xlLCB0byBhbm90aGVyIGZpbGUsIHRvXG4gICAgICAgIC8vIGEgcmVtb3RlIGhvc3QsIGV0Yy5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciBsb2dnZWRPYmplY3QgPSB7fTtcblxuICAgICAgICAvLyBDYWxsZXIgaW5mb1xuICAgICAgICB2YXIgY2FsbGVyID0gbnVsbDtcblxuICAgICAgICAvLyBPbmx5IGNhcHR1cmUgY2FsbGVyIGlmIHN0b3JlU3RhY2tUcmFjZSBpcyB0cnVlLlxuICAgICAgICAvLyBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgaW4gc3RyaWN0IG1vZGUsIGFzIHdlIGNhbm5vdCBhY2Nlc3NcbiAgICAgICAgLy8gdGhlIGNhbGxlcidzIG5hbWVcbiAgICAgICAgaWYoTE9HR0VSLm9wdGlvbnMuc3RvcmVTdGFja1RyYWNlKXtcbiAgICAgICAgICAgIGNhbGxlciA9ICdnbG9iYWwgc2NvcGUnO1xuICAgICAgICAgICAgaWYobG9nZ2VyTG9nLmNhbGxlciAmJiBsb2dnZXJMb2cuY2FsbGVyLm5hbWUpe1xuICAgICAgICAgICAgICAgIGNhbGxlciA9IGxvZ2dlckxvZy5jYWxsZXIubmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZigobG9nZ2VyTG9nLmNhbGxlcisnJykuaW5kZXhPZignZnVuY3Rpb24gKCknKSA9PT0gMCl7XG4gICAgICAgICAgICAgICAgY2FsbGVyID0gJ2Fub255bW91cyBmdW5jdGlvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR1cCBwcm9wZXJ0aWVzIG9uIHRoZSBsb2dnZWRPYmplY3QgYmFzZWQgb24gcGFzc2VkIGluIHByb3BlcnRpZXNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBUaGVzZSBhcmUgc2V0IGJlZm9yZSBhbnkgb2Ygb3VyIGxpYnJhcnkgc2V0dGVycyB0byBlbnN1cmUgY2xpZW50cyBkbyBub3RcbiAgICAgICAgLy8gb3ZlcnJpZGUgcHJvcGVydGllcyBzZXQgYnkgQnJhZ2lcbiAgICAgICAgLy8gTk9URTogQWxsIHByb3BlcnRpZXMgc2V0IGJ5IEJyYWdpIGFyZSBwcmVmaXhlZCB3aXRoIGFuIHVuZGVyc2NvcmVcbiAgICAgICAgbG9nZ2VkT2JqZWN0LnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgbG9nZ2VkT2JqZWN0Lm9yaWdpbmFsQXJncyA9IFtdO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBleHRyYUFyZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgLy8gRm9yIGVhY2ggYXJndW1lbnQsIHdlIG5lZWQgdG8gY2hlY2sgaXRzIHR5cGUuIElmIGl0J3MgYW4gb2JqZWN0LCB0aGVuXG4gICAgICAgICAgICAvLyB3ZSdsbCBleHRlbmQgdGhlIGxvZ2dlZE9iamVjdCBgcHJvcGVydGllc2Agb2JqZWN0XG4gICAgICAgICAgICAvLyAoaWYgdGhlcmUgYXJlIG11bHRpcGxlIGtleXMsIHRoZSBsYXN0XG4gICAgICAgICAgICAvLyBrZXkgZm91bmQgdGFrZXMgcHJpb3JpdHkpLiBJZiBpdCdzIGFuIGFycmF5IG9yIGFueSBvdGhlciBkYXRhIHR5cGUsXG4gICAgICAgICAgICAvLyB3ZSdsbCBzZXQgYSBuZXcgcHJvcGVydHkgY2FsbGVkIGBhcmd1bWVudFhgIGFuZCBzZXQgdGhlIHZhbHVlXG5cbiAgICAgICAgICAgIGlmKCEoZXh0cmFBcmdzW2ldIGluc3RhbmNlb2YgQXJyYXkpICYmIHR5cGVvZiBleHRyYUFyZ3NbaV0gPT09ICdvYmplY3QnKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGtleSBpbiBleHRyYUFyZ3NbaV0pe1xuICAgICAgICAgICAgICAgICAgICBsb2dnZWRPYmplY3QucHJvcGVydGllc1trZXldID0gZXh0cmFBcmdzW2ldW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZWRPYmplY3QucHJvcGVydGllc1snX2FyZ3VtZW50JyArIGldID0gZXh0cmFBcmdzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgdG8gb3JpZ2luYWxBcmdzIGFycmF5LCBzbyB3ZSBjYW4ga25vdyBieSBpbmRleCB3aGF0IGFyZ3Mgd2VyZVxuICAgICAgICAgICAgLy8gcGFzc2VkIGluXG4gICAgICAgICAgICBsb2dnZWRPYmplY3Qub3JpZ2luYWxBcmdzLnB1c2goZXh0cmFBcmdzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIG1ldGFcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBsb2dnZWRPYmplY3QubWV0YSA9IHtcbiAgICAgICAgICAgIGNhbGxlcjogY2FsbGVyLFxuICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0pTT04oKVxuICAgICAgICB9O1xuICAgICAgICBsb2dnZWRPYmplY3QudW5peFRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMDtcblxuICAgICAgICB2YXIgc3RhY2sgPSBmYWxzZTtcbiAgICAgICAgaWYoTE9HR0VSLm9wdGlvbnMuc3RvcmVTdGFja1RyYWNlKXtcbiAgICAgICAgICAgIC8vIFN0b3JlIGFuZCB1c2Ugc3RhY2sgdHJhY2UgaWYgc2V0LiBBaWRlcyBpbiBkZXZlbG9waW5nLCBidXQgYWRkc1xuICAgICAgICAgICAgLy8gc29tZSBvdmVyaGVhZFxuICAgICAgICAgICAgc3RhY2sgPSBMT0dHRVIudXRpbC5fX3N0YWNrKCk7XG4gICAgICAgICAgICAvLyBDdXJyZW50bHksIGdldHRpbmcgc3RhY2sgaW5mbyB2aWEgdGhpcyBtZXRob2RcbiAgICAgICAgICAgIC8vIGlzIHVuc3VwcG9ydGVkIGluIG1hbnkgYnJvd3NlcnNcbiAgICAgICAgICAgIGlmKHN0YWNrKXtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tMZW5ndGggPSBzdGFjay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNlID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IoaSA9IDE7IGkgPCBzdGFjay5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlLnB1c2goc3RhY2tbaV0gKyAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9nZ2VkT2JqZWN0Lm1ldGEuZmlsZSA9IHN0YWNrWzFdLmdldEZpbGVOYW1lKCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VkT2JqZWN0Lm1ldGEubGluZSA9IHN0YWNrWzFdLmdldExpbmVOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBsb2dnZWRPYmplY3QubWV0YS5jb2x1bW4gPSBzdGFja1sxXS5nZXRDb2x1bW5OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBsb2dnZWRPYmplY3QubWV0YS50cmFjZSA9IHRyYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0dXAgZ3JvdXAsIG1lc3NhZ2UsIG90aGVyIHBhcmFtc1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGxvZ2dlZE9iamVjdC5ncm91cCA9IGdyb3VwO1xuXG4gICAgICAgIC8vIFNldHVwIHRoZSBtZXNzYWdlXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgbG9nZ2VkT2JqZWN0Lm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gICAgICAgIC8vIFNlbmQgbG9nZ2VkT2JqZWN0IHRvIGVhY2ggdHJhbnNwb3J0XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gVGhlIGxvZ2dlZE9iamVjdCBpcyBzZXR1cCBub3csIGNhbGwgZWFjaCBvZiB0aGUgdHJhbnNwb3J0IGxvZyBjYWxscyB0aGF0XG4gICAgICAgIC8vIGNhbiBiZSBjYWxsZWRcbiAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgZm9yKGkgPSAwLCBsZW4gPSB0cmFuc3BvcnRGdW5jc1RvQ2FsbC5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICB0cmFuc3BvcnRGdW5jc1RvQ2FsbFtpXS5sb2cuY2FsbCggdHJhbnNwb3J0RnVuY3NUb0NhbGxbaV0sIGxvZ2dlZE9iamVjdCApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZSB0aGlzIHRvIHRoZSB3aW5kb3dcbiAgICBpZighKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkpIHtcbiAgICAgICAgd2luZG93LkJSQUdJID0gTE9HR0VSO1xuICAgIH1cbiAgICByZXR1cm4gTE9HR0VSO1xufSkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIGNhbkxvZ1xuICpcbiAqICAgICAgRnVuY3Rpb24gd2hpY2ggdGFrZXMgaW4gYSBncm9wdSBhbmQgZ3JvdXBzRW5hYmxlZCBhbmQgcmV0dXJucyBhIHtCb29sZWFufVxuICogICAgICBpbmRpY2F0aW5nIGlmIG1lc3NhZ2UgY2FuIGJlIGxvZ2dlZFxuICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbmZ1bmN0aW9uIGNhbkxvZyhncm91cCwgZ3JvdXBzRW5hYmxlZCwgZ3JvdXBzRGlzYWJsZWQpeyBcbiAgICAvLyBDaGVjayBpZiBhIHBhc3NlZCBpbiBncm91cCB7c3RyaW5nfSBjYW4gYmUgbG9nZ2VkIGJhc2VkIG9uIHRoZSBwYXNzZWQgaW5cbiAgICAvLyBncm91cHNFbmFibGVkICh7QXJyYXl9IG9yIHtCb29sZWFufSkuIFxuICAgIC8vIElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBsb2dnZWQsIHJldHVybiBmYWxzZSAtIG90aGVyd2lzZSwgcmV0dXJuIHRydWVcbiAgICAvL1xuICAgIC8vICBOT1RFOiBlcnJvcnMgd2lsbCBhbHdheXMgYmUgbG9nZ2VkIHVubGVzcyBleHBsaWN0bHkgZGlzYWJsZWRcblxuICAgIGlmKGdyb3Vwc0VuYWJsZWQgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIGdyb3Vwc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgaSxsZW47XG5cbiAgICAvLyBieSBkZWZhdWx0LCBhbGxvdyBsb2dnaW5nXG4gICAgdmFyIGNhbkxvZ0l0ID0gdHJ1ZTtcblxuICAgIC8vIEZpcnN0LCBjaGVjayBmb3IgYWxsb3dlZCBncm91cHMgKHdoaXRlbGlzdClcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYoZ3JvdXBzRW5hYmxlZCA9PT0gdHJ1ZSl7XG4gICAgICAgIGNhbkxvZ0l0ID0gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZihncm91cHNFbmFibGVkID09PSBmYWxzZSB8fCBncm91cHNFbmFibGVkID09PSBudWxsKXtcbiAgICAgICAgLy8gRG9uJ3QgZXZlciBsb2cgaWYgbG9nZ2luZyBpcyBkaXNhYmxlZFxuICAgICAgICBjYW5Mb2dJdCA9IGZhbHNlO1xuXG4gICAgfSBlbHNlIGlmKGdyb3Vwc0VuYWJsZWQgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgIC8vIGlmIGFuIGFycmF5IG9mIGxvZyBsZXZlbHMgaXMgc2V0LCBjaGVjayBpdFxuICAgICAgICBjYW5Mb2dJdCA9IGZhbHNlO1xuXG4gICAgICAgIGZvcihpPTAsIGxlbj1ncm91cHNFbmFibGVkLmxlbmd0aDsgaTxsZW47IGkrKyl7XG4gICAgICAgICAgICAvLyB0aGUgY3VycmVudCBncm91cHNFbmFibGVkIHdpbGwgYmUgYSBzdHJpbmcgd2UgY2hlY2sgZ3JvdXAgYWdhaW5zdDtcbiAgICAgICAgICAgIC8vIGZvciBpbnN0YW5jZSxcbiAgICAgICAgICAgIC8vICAgICAgaWYgZ3JvdXAgaXMgXCJncm91cDE6Z3JvdXAyXCIsIGFuZCBpZiB0aGUgY3VycmVudCBsb2cgbGV2ZWxcbiAgICAgICAgICAgIC8vICAgICAgaXMgXCJncm91cDE6Z3JvdXAzXCIsIGl0IHdpbGwgTk9UIG1hdGNoOyBidXQsIFwiZ3JvdXAxOmdyb3VwMlwiIFxuICAgICAgICAgICAgLy8gICAgICB3b3VsZCBtYXRjaC5cbiAgICAgICAgICAgIC8vICAgICAgICAgIExpa2V3aXNlLCBcImdyb3VwMTpncm91cDI6Z3JvdXAzXCIgV09VTEQgbWF0Y2hcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgcnVuIHRoZSByZWdleFxuICAgICAgICAgICAgaWYoZ3JvdXBzRW5hYmxlZFtpXSBpbnN0YW5jZW9mIFJlZ0V4cCl7XG4gICAgICAgICAgICAgICAgaWYoZ3JvdXBzRW5hYmxlZFtpXS50ZXN0KGdyb3VwKSl7XG4gICAgICAgICAgICAgICAgICAgIGNhbkxvZ0l0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKGdyb3VwLmluZGV4T2YoZ3JvdXBzRW5hYmxlZFtpXSkgPT09IDApe1xuICAgICAgICAgICAgICAgIGNhbkxvZ0l0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gXG5cbiAgICAvLyBzZXQgZXJyb3IgYW5kIHdhcm4gdG8gYmUgYWx3YXlzIG9uIHVubGVzcyBleHBsaWN0bHkgZGlzYWJsZWRcbiAgICBpZihncm91cC5pbmRleE9mKCdlcnJvcicpID09PSAwIHx8IGdyb3VwLmluZGV4T2YoJ3dhcm4nKSA9PT0gMCl7XG4gICAgICAgIGNhbkxvZ0l0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQsIGNoZWNrIGRpc2FsbG93ZWQgZ3JvdXBzIChibGFja2xpc3QpXG4gICAgaWYoZ3JvdXBzRGlzYWJsZWQgJiYgZ3JvdXBzRGlzYWJsZWQgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgIGZvcihpPTAsIGxlbj1ncm91cHNEaXNhYmxlZC5sZW5ndGg7IGk8bGVuOyBpKyspe1xuICAgICAgICAgICAgLy8gU2FtZSBsb2dpYyBhcyBjaGVja2luZyBncm91cHNFbmFibGVkLCBqdXN0IHRoZSBpbnZlcnNlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgcnVuIHRoZSByZWdleFxuICAgICAgICAgICAgaWYoZ3JvdXBzRGlzYWJsZWRbaV0gaW5zdGFuY2VvZiBSZWdFeHApe1xuICAgICAgICAgICAgICAgIGlmKGdyb3Vwc0Rpc2FibGVkW2ldLnRlc3QoZ3JvdXApKXtcbiAgICAgICAgICAgICAgICAgICAgY2FuTG9nSXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKGdyb3VwLmluZGV4T2YoZ3JvdXBzRGlzYWJsZWRbaV0pID09PSAwKXtcbiAgICAgICAgICAgICAgICBjYW5Mb2dJdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbkxvZ0l0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkxvZztcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiAgc3ltYm9sc1xuICogICAgICBEZWZpbmVzIHNwZWNpYWwgc3ltYm9scyB1c2VkIGJ5IGxvZ2dlclxuICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHN1Y2Nlc3M6ICfinJTvuI4gJyxcbiAgICBlcnJvcjogJ+KcmCAnLFxuICAgIHdhcm46ICfimpEgJyxcbiAgICBhcnJvdzogJ+KepCAnLFxuICAgIHN0YXI6ICfimIYgJyxcbiAgICBib3g6ICfimJAgJyxcbiAgICBib3hTdWNjZXNzOiAn4piR77iOICcsXG4gICAgYm94RXJyb3I6ICfimJIgJyxcbiAgICBjaXJjbGU6ICfil68gJyxcbiAgICBjaXJjbGVGaWxsZWQ6ICfil4kgJyxcbiAgICBhc3RlcmlzazogJ+KcoicsXG4gICAgZmxvcmFsOiAn4p2nJyxcbiAgICBzbm93Zmxha2U6ICfinYTvuI4nLFxuICAgIGZvdXJEaWFtb25kOifinZYnLFxuICAgIHNwYWRlOiAn4pmg77iOJyxcbiAgICBjbHViOiAn4pmj77iOJyxcbiAgICBoZWFydDogJ+KZpe+4jicsXG4gICAgZGlhbW9uZDogJ+KZpu+4jicsXG4gICAgcXVlZW46ICfimZsnLFxuICAgIHJvb2s6ICfimZwnLFxuICAgIHBhd246ICfimZ8nLFxuICAgIGF0b206ICfimpsnXG59O1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogIHRyYW5zcG9ydHNcbiAqICAgICAgSGFuZGxlcyBhbGwgdHJhbnNwb3J0c1xuICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbnZhciBmaWxlcyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xuXG52YXIgdHJhbnNwb3J0cyA9IHt9O1xuXG5mb3IodmFyIGZpbGUgaW4gZmlsZXMpeyBcbiAgICB0cmFuc3BvcnRzW2ZpbGVdID0gZmlsZXNbZmlsZV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3J0cztcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBDb25zb2xlXG4gKiAgICAgIERlZmF1bHQgdHJhbnNwb3J0IC0gY29uc29sZVxuICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbnZhciBTWU1CT0xTID0gcmVxdWlyZSgnLi4vc3ltYm9scycpO1xuXG4vLyBJbiA8IElFMTAgY29uc29sZSBpcyB1bmRlZmluZWQgdW5sZXNzIHRoZSBkZXZlbG9wZXIgdG9vbHMgaGF2ZSBhdCBzb21lXG4vLyBwb2ludCBiZWVuIG9wZW5lZCBpbiB0aGF0IHRhYi4gSG93ZXZlciwgZXZlbiBhZnRlciBjb25zb2xlIGFuZCBjb25zb2xlLmxvZ1xuLy8gZXhpc3QsIHR5cGVvZiBjb25zb2xlLmxvZyBzdGlsbCBldmFsdWF0ZSB0byBvYmplY3QsIG5vdCBmdW5jdGlvbiwgc29cbi8vIG1ldGhvZHMgbGlrZSAuYXBwbHkgd2lsbCBjYXVzZSBlcnJvcnNcbmlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5jb25zb2xlLmxvZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG59IGVsc2Uge1xuICAgIHdpbmRvdy5jb25zb2xlID0ge307XG4gICAgd2luZG93LmNvbnNvbGUubG9nID0gZnVuY3Rpb24gKCkge307XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gU2V0dXAgZ3JvdXAgQ29sb3JzIHRvIHByaW50XG4vL1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBHUk9VUF9DT0xPUlMgPSBbXG4gICAgLy8gZmlyc3QgaXMgQkcgY29sb3IsIHNlY29uZCBpcyBmb3JlZ3JvdW5kIGNvbG9yLCB0aGlyZCBpcyBib3JkZXJcbiAgICBbJyMzMTgyYmQnLCAnI2ZmZmZmZicsICcjMjI1NTg4J10sXG4gICAgWycjZjM4NjMwJywgJyNmZmZmZmYnXSxcbiAgICBbJyNlMGU0Y2MnLCAnIzAwMDAwMCcsICcjYzhjYmI2J10sXG4gICAgWycjOGM1MTBhJywgJyNmZmZmZmYnXSxcbiAgICBbJyMzNTk3OGYnLCAnI2ZmZmZmZicsIFwiIzEzNzU2ZFwiXSxcbiAgICBbJyNjNTFiN2QnLCAnI2ZmZmZmZiddLFxuICAgIFsnI2M2ZGJlZicsICcjMDAwMDAwJ10sXG4gICAgWycjYWY4ZGMzJywgJyMwMDAwMDAnXSxcbiAgICBbJyM1NDMwMDUnLCAnI2ZmZmZmZicsIFwiIzMyMTAwMlwiXSxcbiAgICBbJyM3ZmJmN2InLCAnIzAwMDAwMCddLFxuICAgIFsnI2RmYzI3ZCcsICcjMDAwMDAwJywgXCIjYmRhMDViXCJdLFxuICAgIFsnI2Y1ZjVmNScsICcjMDAwMDAwJ10sXG4gICAgWycjZTlhM2M5JywgJyMwMDAwMDAnXSxcbiAgICBbJyM1OTMyM0MnLCAnI2ZmZmZmZiddLFxuICAgIFsnIzY2YzJhNScsICcjMDAwMDAwJ10sXG4gICAgWycjZjZlOGMzJywgJyMwMDAwMDAnXSxcbiAgICBbJyM2MDYwNjAnLCAnI2YwZjBmMCddLFxuICAgIFsnIzhjNTEwYScsICcjZmZmZmZmJ10sXG4gICAgWycjODBjZGMxJywgJyMwMDAwMDAnXSxcbiAgICBbJyM1NDI3ODgnLCAnI2ZmZmZmZiddLFxuICAgIFsnI0ZCOEFGRScsICcjMzQzNDM0J10sXG4gICAgWycjMDAzYzMwJywgJyNmZmZmZmYnXSxcbiAgICBbJyNlNmY1OTgnLCAnIzAwMDAwMCddLFxuICAgIFsnI2M3ZWFlNScsICcjMDAwMDAwJ10sXG4gICAgWycjMDAwMDAwJywgJyNmMGYwZjAnXSxcbiAgICBbJyNDM0ZGMEUnLCAnIzM0MzQzNCddXG5dO1xudmFyIE9WRVJGTE9XX1NZTUJPTFMgPSBbXG4gICAgJ2FzdGVyaXNrJywgJ2Zsb3JhbCcsICdzbm93Zmxha2UnLCAnZm91ckRpYW1vbmQnLCAnc3BhZGUnLCAnY2x1YicsICdoZWFydCcsXG4gICAgJ2RpYW1vbmQnLCAncXVlZW4nLCAncm9vaycsICdwYXduJywgJ2F0b20nXG5dO1xuXG52YXIgQkFTRV9DU1MgPSAncGFkZGluZzogMnB4OyBtYXJnaW46MnB4OyBsaW5lLWhlaWdodDogMS44ZW07JztcbnZhciBNRVRBX1NUWUxFID0gQkFTRV9DU1MgKyAnZm9udC1zaXplOjAuOWVtOyBjb2xvcjogI2NkY2RjZDsgcGFkZGluZy1sZWZ0OjMwcHg7JztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBDb25zb2xlIFRyYW5zcG9ydFxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5mdW5jdGlvbiBUcmFuc3BvcnRDb25zb2xlICggb3B0aW9ucyApe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIFRyYW5zcG9ydCBtdXN0IHNldCBncm91cHNFbmFibGVkIGFuZCBncm91cHNEaXNhYmxlZCB0byBwcm92aWRlIHRyYW5zcG9ydFxuICAgIC8vIGxldmVsIHN1cHBvcnQgZm9yIG92ZXJyaWRpbmcgd2hhdCBncm91cHMgdG8gbG9nXG4gICAgLy8gKE5PVEUgLSB0aGUgdXNlciBkb2VzIG5vdCBuZWVkIHRvIHBhc3MgaW4gZ3JvdXBzRW5hYmxlZCwgYnV0IHRoZVxuICAgIC8vIHRyYW5zcG9ydCBtdXN0IHNldCB0aGVzZSBwcm9wZXJ0aWVzKVxuICAgIHRoaXMuZ3JvdXBzRW5hYmxlZCA9IG9wdGlvbnMuZ3JvdXBzRW5hYmxlZDtcbiAgICB0aGlzLmdyb3Vwc0Rpc2FibGVkID0gb3B0aW9ucy5ncm91cHNEaXNhYmxlZDtcblxuICAgIC8vIERpc3BsYXkgLyBtZXRhIHJlbGF0ZWQgY29uZmlnIG9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQWRkIGEgbGluZSBicmVhayBhZnRlciB0aGUgbGFzdCB0aGluZyBzZW50P1xuICAgIHRoaXMuYWRkTGluZUJyZWFrID0gb3B0aW9ucy5hZGRMaW5lQnJlYWsgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYWRkTGluZUJyZWFrIDogZmFsc2U7XG5cbiAgICAvLyBzaG93TWV0YToge0Jvb2xlYW59IFNob3cgdGhlIG1ldGEgaW5mbyAoY2FsbGluZyBmdW5jLCB0aW1lLCBsaW5lIG51bSwgZXRjKVxuICAgIC8vICBgZmFsc2VgIGJ5IGRlZmF1bHRcbiAgICAvLyAgTk9URTogVGhpcyBpcyBwcmltYXJpbHkgdXNlZCBvbmx5IGlmIHlvdSB3YW50IHRvIGRpc2FibGUgZXZlcnl0aGluZy5cbiAgICAvLyAgSWYgdGhpcyBpcyB0cnVlIGFuZCBzaG93U3RhY2tUcmFjZSBcbiAgICAvLyAgb3B0aW9ucyB3aWxsIGJlIGNoZWNrZWQuIElmIGl0IGlzIHNldCB0byBmYWxzZSwgbm90aGluZyB3aWxsIGJlIHNob3duXG4gICAgdGhpcy5zaG93TWV0YSA9IG9wdGlvbnMuc2hvd01ldGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2hvd01ldGEgOiBmYWxzZTtcblxuICAgIC8vIHNob3dTdGFja1RyYWNlOiB7Qm9vbGVhbn0gcHJvdmlkZSB0aGUgZnVsbCBzdGFjayB0cmFjZT8gRW5hYmxlZCBieSBkZWZhdWx0LFxuICAgIC8vIGJ1dCB3aWxsIG9ubHkgYmUgc2hvd24gaWYgbWV0YSBpcyBzaG93blxuICAgIHRoaXMuc2hvd1N0YWNrVHJhY2UgPSBvcHRpb25zLnNob3dTdGFja1RyYWNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNob3dTdGFja1RyYWNlOiB0cnVlO1xuXG4gICAgLy8gVHJhbnNwb3J0IHNwZWNpZmljIHNldHRpbmdzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMuc2hvd0NvbG9ycyA9IG9wdGlvbnMuc2hvd0NvbG9ycyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuc2hvd0NvbG9yO1xuXG4gICAgdGhpcy5fZm91bmRDb2xvcnMgPSBbXTtcbiAgICB0aGlzLl9jb2xvckRpY3QgPSB7XG4gICAgICAgIGVycm9yOiBCQVNFX0NTUyArICdiYWNrZ3JvdW5kOiAjZmYwMDAwOyBjb2xvcjogI2ZmZmZmZjsgZm9udC1zdHlsZTogYm9sZDsgYm9yZGVyOiA0cHggc29saWQgI2NjMDAwMDsnLFxuICAgICAgICB3YXJuOiBCQVNFX0NTUyArICdwYWRkaW5nOiAycHg7IGJhY2tncm91bmQ6ICNmZmZmMDA7IGNvbG9yOiAjMzQzNDM0OyBmb250LXN0eWxlOiBib2xkOyBib3JkZXI6IDRweCBzb2xpZCAjY2NjYzAwOydcbiAgICB9O1xuXG4gICAgdGhpcy5jdXJTeW1ib2xJbmRleCA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuVHJhbnNwb3J0Q29uc29sZS5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiBnZXRDb2xvcihncm91cCl7XG4gICAgLy8gQ29sb3IgRm9ybWF0dGluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZXR1cm5zIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGZvciBhIHBhc3NlZCBpbiBsb2cgZ3JvdXBcbiAgICAvLyBUT0RPOiBpZiBtb3JlIGZvdW5kIGNvbG9ycyBleGlzdCB0aGFuIHRoZSBvcmlnaW5hbCBsZW5ndGggb2YgdGhlXG4gICAgLy8gQ09MT1IgYXJyYXksIGN5Y2xlIGJhY2sgYW5kIG1vZGlmeSB0aGUgb3JpZ2luYWwgY29sb3JcbiAgICAvL1xuICAgIHZhciBjb2xvciA9ICcnO1xuICAgIHZhciBiYXNlQ29sb3IgPSAnJztcbiAgICB2YXIgY3VyU3ltYm9sO1xuICAgIHZhciBjc3NTdHJpbmcgPSAnJztcblxuICAgIC8vIEZvciBjb2xvciwgZ2V0IHRoZSBmaXJzdCBncm91cFxuICAgIGdyb3VwID0gZ3JvdXAuc3BsaXQoJzonKVswXTtcblxuICAgIC8vIGlmIGEgY29sb3IgZXhpc3RzIGZvciB0aGUgcGFzc2VkIGluIGxvZyBncm91cCwgdXNlIGl0XG4gICAgaWYodGhpcy5fY29sb3JEaWN0W2dyb3VwXSl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvckRpY3RbZ3JvdXBdO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX2ZvdW5kQ29sb3JzLmxlbmd0aCA+PSBHUk9VUF9DT0xPUlMubGVuZ3RoKXtcbiAgICAgICAgLy8gaXMgdGhlIGluZGV4IHRvbyBoaWdoPyBsb29wIGFyb3VuZCBpZiBzb1xuICAgICAgICBjb2xvciA9IEdST1VQX0NPTE9SU1t0aGlzLl9mb3VuZENvbG9ycy5sZW5ndGggJSBHUk9VUF9DT0xPUlMubGVuZ3RoXTtcbiAgICAgICAgYmFzZUNvbG9yID0gY29sb3I7XG5cbiAgICAgICAgLy8gYWRkIHVuZGVybGluZSBpZiBvZGRcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGNzc1N0cmluZyArPSAnZm9udC1zdHlsZTogaXRhbGljOyc7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFdlIGhhdmVuJ3QgeWV0IGV4aGF1c3RlZCBhbGwgdGhlIGNvbG9yc1xuICAgICAgICBjb2xvciA9IEdST1VQX0NPTE9SU1t0aGlzLl9mb3VuZENvbG9ycy5sZW5ndGhdO1xuICAgIH1cblxuICAgIHZhciBib3JkZXJDb2xvciA9IGNvbG9yWzJdO1xuICAgIC8vIElmIG5vIGJvcmRlciBjb2xvciB3YXMgcHJvdmlkZWQsIGp1c3QgYnJpbmcgYWxsIHZhbHVlcyBkb3duIGJ5IDNcbiAgICAvLyBhbmQgdXNlIHRoZSByZXN1bHRcbiAgICBpZighY29sb3JbMl0pe1xuICAgICAgICBib3JkZXJDb2xvciA9ICcjJztcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGNvbG9yWzBdLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGJvcmRlckNvbG9yICs9IChcbiAgICAgICAgICAgICAgICAoTWF0aC5tYXgoIDAsIChwYXJzZUludChjb2xvclswXVtpXSwgMTYpIC0gMikgKSkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBjc3NTdHJpbmcgKz0gQkFTRV9DU1MgK1xuICAgICAgICBcImJhY2tncm91bmQ6IFwiICsgY29sb3JbMF0gKyBcIjtcIiArXG4gICAgICAgIFwiYm9yZGVyOiAxcHggc29saWQgXCIgKyBib3JkZXJDb2xvciArIFwiO1wiICtcbiAgICAgICAgXCJjb2xvcjogXCIgKyBjb2xvclsxXSArIFwiO1wiO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBzdG9yZWQgY29sb3IgaW5mb1xuICAgIHRoaXMuX2ZvdW5kQ29sb3JzLnB1c2goY29sb3IpO1xuICAgIHRoaXMuX2NvbG9yRGljdFtncm91cF0gPSBjc3NTdHJpbmc7XG5cbiAgICByZXR1cm4gY3NzU3RyaW5nO1xufTtcblxuXG4vLyBQcm90b3R5cGUgcHJvcGVydGllcyAoQWxsIHRoZXNlIG11c3QgZXhpc3QgdG8gYmUgYSB2YWxpZCB0cmFuc3BvcnQpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuVHJhbnNwb3J0Q29uc29sZS5wcm90b3R5cGUubmFtZSA9ICdDb25zb2xlJztcblxuVHJhbnNwb3J0Q29uc29sZS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gdHJhbnNwb3J0Q29uc29sZUxvZyggbG9nZ2VkT2JqZWN0ICl7XG4gICAgLy8gbG9nXG4gICAgLy8gIExvZ3MgYSBwYXNzZWQgb2JqZWN0IHRvIHRoZSBjb25zb2xlXG4gICAgLy9cbiAgICAvLyAgcGFyYW1zOlxuICAgIC8vICAgICAgbG9nZ2VkT2JqZWN0OiB7T2JqZWN0fSB0aGUgbG9nIG9iamVjdCB0byBsb2dcbiAgICAvLyAgICAgIG9wdGlvbnMgOiB7T2JqZWN0fSB0aGUgbG9nZ2VyIG9wdGlvbnNcbiAgICAvL1xuICAgIC8vIFNldHVwIG1lc3NhZ2UgZm9yIGNvbnNvbGUgb3V0cHV0XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gIFRoZSBmaW5hbCBtZXNzYWdlIHdpbGwgbG9vayBsaWtlOiBcbiAgICAvLyAgICAgIFsgZ3JvdXAgXSAgICAgIG1lc3NhZ2UgXG4gICAgLy8gICAgICBtZXRhIGluZm8gKGZ1bmN0aW9uIGNhbGxlciwgdGltZSwgZmlsZSBpbmZvKVxuICAgIC8vXG4gICAgdmFyIGNvbnNvbGVNZXNzYWdlID0gXCJcIjtcbiAgICBpZih0aGlzLnNob3dDb2xvcnMpe1xuICAgICAgICBjb25zb2xlTWVzc2FnZSArPSBcIiVjXCI7XG4gICAgfVxuXG4gICAgdmFyIGk7XG5cbiAgICAvLyBTZXR1cCBmaW5hbCBsb2cgbWVzc2FnZSBmb3JtYXQsIGRlcGVuZGluZyBvbiBpZiBpdCdzIGEgYnJvd3NlciBvciBub3RcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb25zb2xlTWVzc2FnZSArPVxuICAgICAgICBcIlsgXCIgK1xuICAgICAgICAgICAgbG9nZ2VkT2JqZWN0Lmdyb3VwICsgJyAnICtcbiAgICAgICAgXCIgXSBcXHRcIjtcblxuICAgIC8vIE5PVEU6IFVzZSB0aGUgZnVsbCBzdHlsZWRNZXNzYWdlIHByb3BlcnR5XG4gICAgY29uc29sZU1lc3NhZ2UgKz0gbG9nZ2VkT2JqZWN0Lm1lc3NhZ2UgKyAnIFxcdCc7XG5cbiAgICAvLyBhZGQgbGluZSBicmVhayB0byBjb25zb2xlIG1lc3NhZ2VzIGlmIHNldFxuICAgIGlmKHRoaXMuYWRkTGluZUJyZWFrKXtcbiAgICAgICAgY29uc29sZU1lc3NhZ2UgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgZmluYWwgbG9nIGFycmF5IHRvIGNhbGwgY29uc29sZS5sb2cgd2l0aFxuICAgIHZhciB0b0xvZ0FycmF5ID0gW107XG4gICAgdG9Mb2dBcnJheS5wdXNoKGNvbnNvbGVNZXNzYWdlKTtcblxuICAgIGlmKHRoaXMuc2hvd0NvbG9ycyl7XG4gICAgICAgIHRvTG9nQXJyYXkucHVzaCh0aGlzLmdldENvbG9yKGxvZ2dlZE9iamVjdC5ncm91cCkpO1xuICAgIH1cbiAgICB0b0xvZ0FycmF5ID0gdG9Mb2dBcnJheS5jb25jYXQobG9nZ2VkT2JqZWN0Lm9yaWdpbmFsQXJncyk7XG5cbiAgICAvLyBMb2cgaXRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgdG9Mb2dBcnJheSApO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIExvZyBtZXRhIGluZm8/XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBtZXRhQ29uc29sZU1lc3NhZ2UgPSAnJztcbiAgICB2YXIgbWV0YUxvZ0FycmF5ID0gW107XG5cbiAgICBpZih0aGlzLnNob3dNZXRhKXtcbiAgICAgICAgLy8gcHVzaCBzdHlsZSBmb3IgbWV0YSBpZiB0aGVyZSBpcyBtZXRhXG4gICAgICAgIGlmKHRoaXMuc2hvd0NvbG9ycyl7XG4gICAgICAgICAgICBtZXRhQ29uc29sZU1lc3NhZ2UgKz0gJyVjJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEpTT04gdGltZXN0YW1wXG4gICAgICAgIG1ldGFDb25zb2xlTWVzc2FnZSArPSBuZXcgRGF0ZSgpLnRvSlNPTigpICsgJyBcXHQgXFx0ICc7XG5cbiAgICAgICAgLy8gU2hvdyB0aGUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvblxuICAgICAgICBpZihsb2dnZWRPYmplY3QubWV0YS5jYWxsZXIpe1xuICAgICAgICAgICAgbWV0YUNvbnNvbGVNZXNzYWdlICs9ICdjYWxsZXI6ICcgKyBsb2dnZWRPYmplY3QubWV0YS5jYWxsZXIgKyAnIFxcdCBcXHQgJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBub2RlLCBsb2cgbGluZSBudW1iZXIgYW5kIGZpbGVuYW1lXG4gICAgICAgIGlmKGxvZ2dlZE9iamVjdC5tZXRhLmZpbGUgJiYgbG9nZ2VkT2JqZWN0Lm1ldGEubGluZSApe1xuICAgICAgICAgICAgbWV0YUNvbnNvbGVNZXNzYWdlICs9IGxvZ2dlZE9iamVjdC5tZXRhLmZpbGUgK1xuICAgICAgICAgICAgICAgICc6JyArIGxvZ2dlZE9iamVjdC5tZXRhLmxpbmUgK1xuICAgICAgICAgICAgICAgICc6JyArIGxvZ2dlZE9iamVjdC5tZXRhLmNvbHVtbiArXG4gICAgICAgICAgICAgICAgJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLnNob3dNZXRhICYmIHRoaXMuc2hvd1N0YWNrVHJhY2UgJiYgbG9nZ2VkT2JqZWN0Lm1ldGEudHJhY2Upe1xuICAgICAgICAvLyBTaG93IGZ1bGwgc3RhY2sgdHJhY2UgaWYgc2V0XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIG1ldGFDb25zb2xlTWVzc2FnZSArPSAnXFxuJyArXG4gICAgICAgICAgICAnKFN0YWNrIFRyYWNlKScgK1xuICAgICAgICAgICAgJ1xcbic7XG5cbiAgICAgICAgLy8gU2tpcCB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgc3RhY2sgKHRoaXMgZnVuY3Rpb24pXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxvZ2dlZE9iamVjdC5tZXRhLnRyYWNlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIG1ldGFDb25zb2xlTWVzc2FnZSArPSAnXFx0JyArXG4gICAgICAgICAgICAgICAgbG9nZ2VkT2JqZWN0Lm1ldGEudHJhY2VbaV0gKyAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHB1c2ggc3R5bGUgZm9yIG1ldGEgaWYgdGhlcmUgaXMgbWV0YVxuICAgIGlmKHRoaXMuc2hvd01ldGEgJiYgdGhpcy5zaG93Q29sb3JzKXtcbiAgICAgICAgbWV0YUxvZ0FycmF5LnB1c2gobWV0YUNvbnNvbGVNZXNzYWdlKTtcbiAgICAgICAgbWV0YUxvZ0FycmF5LnB1c2goTUVUQV9TVFlMRSk7XG4gICAgfVxuXG4gICAgaWYobWV0YUxvZ0FycmF5Lmxlbmd0aCA+IDApe1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBtZXRhTG9nQXJyYXkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRDb25zb2xlO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEhpc3RvcnlcbiAqICAgICAgTG9ncyB0byBjb25zb2xlLCBidXQganVzdCBvdXRwdXRzIHJhdyBKU09OXG4gKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuZnVuY3Rpb24gVHJhbnNwb3J0SGlzdG9yeSAoIG9wdGlvbnMgKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuZ3JvdXBzRW5hYmxlZCA9IG9wdGlvbnMuZ3JvdXBzRW5hYmxlZDtcbiAgICB0aGlzLmdyb3Vwc0Rpc2FibGVkID0gb3B0aW9ucy5ncm91cHNEaXNhYmxlZDtcblxuICAgIC8vIFN0b3JlICpldmVyeXRoaW5nKj9cbiAgICB0aGlzLnN0b3JlRXZlcnl0aGluZyA9IGZhbHNlO1xuICAgIGlmKG9wdGlvbnMuc3RvcmVFdmVyeXRoaW5nID09PSB0cnVlKXtcbiAgICAgICAgdGhpcy5zdG9yZUV2ZXJ5dGhpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIEFsc28sIGxvZyAqZXZlcnl0aGluZypcbiAgICAgICAgdGhpcy5ncm91cHNFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTZXQgaGlzdG9yeSBzaXplIHBlciBsb2cgZ3JvdXBcbiAgICAvLyAgTk9URTogaWYgaGlzdG9yeVNpemUgaXMgMCBvciBmYWxzZSwgaXQgaGFzIG5vIGxpbWl0XG4gICAgdGhpcy5oaXN0b3J5U2l6ZSA9IG9wdGlvbnMuaGlzdG9yeVNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaGlzdG9yeVNpemUgOiAyMDA7XG5cbiAgICAvLyBIaXN0b3J5IG9iamVjdFxuICAgIHRoaXMuaGlzdG9yeSA9IHt9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIFByb3RvdHlwZSBwcm9wZXJ0aWVzIChBbGwgdGhlc2UgbXVzdCBleGlzdCB0byBiZSBhIHZhbGlkIHRyYW5zcG9ydClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5UcmFuc3BvcnRIaXN0b3J5LnByb3RvdHlwZS5uYW1lID0gJ0hpc3RvcnknO1xuXG5UcmFuc3BvcnRIaXN0b3J5LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiB0cmFuc3BvcnRIaXN0b3J5TG9nKCBsb2dnZWRPYmplY3QgKXtcbiAgICAvLyBsb2dcbiAgICAvLyAgTG9ncyBhIHBhc3NlZCBvYmplY3QgdG8gdGhlIGNvbnNvbGVcbiAgICAvL1xuICAgIC8vICBwYXJhbXM6XG4gICAgLy8gICAgICBsb2dnZWRPYmplY3Q6IHtPYmplY3R9IHRoZSBsb2cgb2JqZWN0IHRvIGxvZ1xuICAgIC8vICAgICAgb3B0aW9ucyA6IHtPYmplY3R9IHRoZSBsb2dnZXIgb3B0aW9uc1xuICAgIC8vXG4gICAgLy8gU2V0dXAgbWVzc2FnZSBmb3IgY29uc29sZSBvdXRwdXRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzdG9yZSB0aGUga2V5IGJ5IHRoZSBmaXJzdCByb290IGdyb3VwXG4gICAgdmFyIGdyb3VwID0gbG9nZ2VkT2JqZWN0Lmdyb3VwLnNwbGl0KCc6JylbMF07XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIG1lc3NhZ2VcbiAgICBpZih0aGlzLmhpc3RvcnlbZ3JvdXBdID09PSB1bmRlZmluZWQpe1xuICAgICAgICB0aGlzLmhpc3RvcnlbZ3JvdXBdID0gW107XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgdGhlIGtleSBieSB0aGUgZmlyc3Qgcm9vdCBncm91cFxuICAgIHRoaXMuaGlzdG9yeVtncm91cF0ucHVzaChsb2dnZWRPYmplY3QpO1xuXG4gICAgLy8gVHJpbSBoaXN0b3J5XG4gICAgaWYodGhpcy5oaXN0b3J5U2l6ZSA+IDAgJiYgXG4gICAgICAgdGhpcy5oaXN0b3J5W2dyb3VwXS5sZW5ndGggPiB0aGlzLmhpc3RvcnlTaXplXG4gICAgKXtcbiAgICAgICAgdGhpcy5oaXN0b3J5W2dyb3VwXS5zaGlmdCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRIaXN0b3J5O1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIFRyYW5zcG9ydHNcbiAqICAgICAgVHJhbnNwb3J0cyBpcyBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdHJhbnNwb3J0cyB0aGUgbG9nZ2VyIHVzZXNcbiAqICAgICAgdG8gb3V0cHV0IGxvZ3NcbiAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5mdW5jdGlvbiBUcmFuc3BvcnRzICgpe1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSBCcmFnaSB0byBrZWVwIHRyYWNrIG9mIHdoYXQgdGhlIGN1cnJlbnRseVxuICAgIC8vIGVuYWJsZWQgdHJhbnNwb3J0cyB0byBiZSB1c2VkIGFyZVxuICAgIFxuICAgIHRoaXMuX3RyYW5zcG9ydHMgPSB7fTtcblxuICAgIC8vIENvbnRhaW5zIGEgY291bnQgb2YgIyBvZiB0cmFuc3BvcnRzIGJ5IHR5cGVcbiAgICB0aGlzLl90cmFuc3BvcnRDb3VudCA9IHt9O1xuICAgIFxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGFjY2Vzc1xuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5UcmFuc3BvcnRzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoIHRyYW5zcG9ydE5hbWUgKXtcbiAgICAvLyBSZXR1cm5zIGEgdHJhbnNwb3J0IG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBpbiBuYW1lXG4gICAgdmFyIHJldHVybmVkVHJhbnNwb3J0T2JqZWN0cyA9IG5ldyBBcnJheSgpO1xuXG4gICAgZm9yKHZhciBrZXkgaW4gdGhpcy5fdHJhbnNwb3J0cyl7XG4gICAgICAgIC8vIElmIHRoZSBuYW1lIGlzIHBhcnQgb2Ygb2YgdGhlIGtleSwgcmVtb3ZlIGl0XG4gICAgICAgIGlmKGtleS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodHJhbnNwb3J0TmFtZS50b0xvd2VyQ2FzZSgpKSA+IC0xKXtcbiAgICAgICAgICAgIHJldHVybmVkVHJhbnNwb3J0T2JqZWN0cy5wdXNoKHRoaXMuX3RyYW5zcG9ydHNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm5lZFRyYW5zcG9ydE9iamVjdHMucHJvcGVydHkgPSBmdW5jdGlvbiB0cmFuc3BvcnRQcm9wZXJ0eSgga2V5T3JPYmplY3QsIHZhbHVlICl7XG4gICAgICAgIC8vIEFsbG93IGAucHJvcGVydHkoKWAgdG8gYmUgY2FsbGVkLCB3aGljaCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBcbiAgICAgICAgLy8gdmFsdWVzIGlmIGp1c3QgdGhlIGBrZXlPck9iamVjdGAgaXMgcGFzc2VkIGluLiBJZiBgdmFsdWVgIGlzIGFsc28gcGFzc2VkIGluIFxuICAgICAgICAvLyBhcyBhIHN0cmluZywgaXQgd2lsbCBzZXQgYWxsIHJldHVybmVkIHRyYW5zcG9ydHMncyBrZXkgdG8gdGhhdCB2YWx1ZVxuICAgICAgICAvL1xuICAgICAgICAvLyBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0eSBrZXlzIGFuZCB2YWx1ZXMgY2FuIGFsc28gYmUgcGFzc2VkIGluXG4gICAgICAgIC8vIGFzIHRoZSBmaXJzdCBhbmQgb25seSBhcmd1bWVudCB0byBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGV4YW1wbGUgY2FsbHM6IC5wcm9wZXJ0eSggJ3Nob3dNZXRhJywgdHJ1ZSApO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAucHJvcGVydHkoIHtzaG93TWV0YTogdHJ1ZX0gKTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICBpZih0eXBlb2Yga2V5T3JPYmplY3QgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgLy8gR2V0dGVyIGNhbGxlZC4gY2FsbGVkIGxpa2UgYC5wcm9wZXJ0eSgnc2hvd01ldGEnKTtgXG4gICAgICAgICAgICB2YXIgdmFscyA9IFtdO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTxsZW47IGkrKyl7IFxuICAgICAgICAgICAgICAgIHZhbHMucHVzaCh0aGlzW2ldW2tleU9yT2JqZWN0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFscztcblxuICAgICAgICB9IFxuICAgICAgICBlbHNlIGlmKCB0eXBlb2Yga2V5T3JPYmplY3QgPT09ICdzdHJpbmcnICYmIHZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIC8vIFNldHRlciBjYWxsZWQuIGNhbGxlZCBsaWtlIGAucHJvcGVydHkoJ3Nob3dNZXRhJywgdHJ1ZSk7YFxuICAgICAgICAgICAgZm9yKGk9MDsgaTxsZW47IGkrKyl7IFxuICAgICAgICAgICAgICAgIHRoaXNbaV1ba2V5T3JPYmplY3RdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiggdHlwZW9mIGtleU9yT2JqZWN0ID09PSAnb2JqZWN0JyApe1xuICAgICAgICAgICAgLy8gT2JqZWN0IHBhc3NlZCBpbiBsaWtlIGAucHJvcGVydHkoIHtzaG93TWV0YTogdHJ1ZX0gKWBcbiAgICAgICAgICAgIGZvcihpPTA7IGk8bGVuOyBpKyspeyBcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBrZXlOYW1lIGluIGtleU9yT2JqZWN0ICl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV1ba2V5TmFtZV0gPSBrZXlPck9iamVjdFtrZXlOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJldHVybmVkVHJhbnNwb3J0T2JqZWN0cztcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gQWRkIC8gUmVtb3ZlXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblRyYW5zcG9ydHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCggdHJhbnNwb3J0ICl7XG4gICAgLy8gVGFrZXMgaW4gYSB0cmFuc3BvcnQgb2JqZWN0IGFuZCBhZGRzIGl0IHRvIHRoZSB0cmFuc3BvcnQgb2JqZWN0LlxuICAgIC8vICBJZiBhIHRyYW5zcG9ydCBvYmplY3QgYWxyZWFkeSBleGlzdHMgKGUuZy4sIGlmIHRoZXJlIGFyZSB0d28gXCJGaWxlXCJcbiAgICAvLyAgdHJhbnNwb3J0cyBhbHJlYWR5KSwgdGhlIHRyYW5zcG9ydCBuYW1lIHdpbGwgYmUgdHJhbnNwb3J0Lm5hbWUgKyBudW1iZXJcblxuICAgIGlmKHRoaXMuX3RyYW5zcG9ydENvdW50W3RyYW5zcG9ydC5uYW1lXSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgLy8gVHJhbnNwb3J0IGRvZXMgbm90IHlldCBleGlzdFxuICAgICAgICB0aGlzLl90cmFuc3BvcnRDb3VudFt0cmFuc3BvcnQubmFtZV0gPSAxO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzW3RyYW5zcG9ydC5uYW1lXSA9IHRyYW5zcG9ydDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUcmFuc3BvcnQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0Q291bnRbdHJhbnNwb3J0Lm5hbWVdICs9IDE7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHNbdHJhbnNwb3J0Lm5hbWUgKyAnJyArICh0aGlzLl90cmFuc3BvcnRDb3VudFt0cmFuc3BvcnQubmFtZV0gLSAxKV0gPSB0cmFuc3BvcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc3BvcnRzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoIHRyYW5zcG9ydE5hbWUsIGluZGV4ICl7XG4gICAgLy8gVGFrZXMgaW4gdGhlIG5hbWUgb2YgYSB0cmFuc3BvcnQgKGUuZy4sIENvbnNvbGUpIGFuZCBhbiBvcHRpb25hbCBpbmRleC5cbiAgICAvLyBJZiBubyBpbmRleCBpcyBwYXNzZWQgaW4sIGFsbCB0cmFuc3BvcnRzIHRoYXQgbWF0Y2ggdGhlIG5hbWUgd2lsbCBiZSBcbiAgICAvLyByZW1vdmVkLiBJZiBhbiBpbmRleCBpcyBwYXNzZWQgaW4sIG9ubHkgdGhlIGluZGV4IHdpbGwgYmUgcmVtb3ZlZC4gZS5nLixcbiAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIGBGaWxlYCB0cmFuc3BvcnRzLCBwYXNzZWQgaW4gaW5kZXggYDFgIHdpbGwgcmVtb3ZlIHRoZVxuICAgIC8vIHNlY29uZCBmaWxlIHRyYW5zcG9ydFxuXG4gICAgdHJhbnNwb3J0TmFtZSA9IHRyYW5zcG9ydE5hbWU7XG4gICAgLy8gaWYgYSB0cmFuc3BvcnQgb2JqZWN0IHdhcyBwYXNzZWQgaW4sIHJlbW92ZSB0aGUgdHJhbnNwb3J0IGJ5IG5hbWVcbiAgICBpZih0cmFuc3BvcnROYW1lLm5hbWUpeyB0cmFuc3BvcnROYW1lID0gdHJhbnNwb3J0TmFtZS5uYW1lOyB9XG5cbiAgICBmb3IodmFyIGtleSBpbiB0aGlzLl90cmFuc3BvcnRzKXtcbiAgICAgICAgaWYoaW5kZXggIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZigodHJhbnNwb3J0TmFtZSArICcnICsgaW5kZXgpID09PSBrZXkpe1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc3BvcnRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmFtZSBpcyBwYXJ0IG9mIG9mIHRoZSBrZXksIHJlbW92ZSBpdFxuICAgICAgICAgICAgaWYoa2V5LmluZGV4T2YodHJhbnNwb3J0TmFtZSkgPiAtMSl7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RyYW5zcG9ydHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuVHJhbnNwb3J0cy5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSAoKXtcbiAgICAvLyBSZW1vdmVzIGFsbCB0cmFuc3BvcnRzXG4gICAgZm9yKHZhciBrZXkgaW4gdGhpcy5fdHJhbnNwb3J0cyl7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc3BvcnRzW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydHM7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogaW5kZXguanNcbiAqICAgICAgRXhwb3J0cyBhbGwgYXZhaWxhYmxlIHRyYW5zcG9ydHNcbiAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5tb2R1bGUuZXhwb3J0cy5Db25zb2xlID0gcmVxdWlyZSgnLi9Db25zb2xlJyk7XG5tb2R1bGUuZXhwb3J0cy5IaXN0b3J5ID0gcmVxdWlyZSgnLi9IaXN0b3J5Jyk7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIHtcbiAgICAgICAgXCJyYXdcIjogXCJkaWNlLmpzQF4wLjguMFwiLFxuICAgICAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgICAgIFwiZXNjYXBlZE5hbWVcIjogXCJkaWNlLmpzXCIsXG4gICAgICAgIFwibmFtZVwiOiBcImRpY2UuanNcIixcbiAgICAgICAgXCJyYXdTcGVjXCI6IFwiXjAuOC4wXCIsXG4gICAgICAgIFwic3BlY1wiOiBcIj49MC44LjAgPDAuOS4wXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInJhbmdlXCJcbiAgICAgIH0sXG4gICAgICBcIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWFcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcImRpY2UuanNAPj0wLjguMCA8MC45LjBcIixcbiAgXCJfaWRcIjogXCJkaWNlLmpzQDAuOC4wXCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIvZGljZS5qc1wiLFxuICBcIl9ub2RlVmVyc2lvblwiOiBcIjAuMTIuN1wiLFxuICBcIl9ucG1Vc2VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJsb3JkbnVsbFwiLFxuICAgIFwiZW1haWxcIjogXCJtaWNhaHdAbG9yZG51bGwuY29tXCJcbiAgfSxcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjIuMTIuMVwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJyYXdcIjogXCJkaWNlLmpzQF4wLjguMFwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcImVzY2FwZWROYW1lXCI6IFwiZGljZS5qc1wiLFxuICAgIFwibmFtZVwiOiBcImRpY2UuanNcIixcbiAgICBcInJhd1NwZWNcIjogXCJeMC44LjBcIixcbiAgICBcInNwZWNcIjogXCI+PTAuOC4wIDwwLjkuMFwiLFxuICAgIFwidHlwZVwiOiBcInJhbmdlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9kaWNlLmpzLy0vZGljZS5qcy0wLjguMC50Z3pcIixcbiAgXCJfc2hhc3VtXCI6IFwiMTcxMmQyYzk3ZDMzNTcyZGJiOTljMDI1NTJlMzdiNTA0ZjJmMzNjMFwiLFxuICBcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG4gIFwiX3NwZWNcIjogXCJkaWNlLmpzQF4wLjguMFwiLFxuICBcIl93aGVyZVwiOiBcIi9Vc2Vycy9zZWl5cmlhL0dpdEh1Yi9Sb2d1YXRoaWFcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIk1pY2FoIFdhcnJlblwiLFxuICAgIFwidXJsXCI6IFwiTG9yZCBOdWxsXCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9sb3JkbnVsbC9kaWNlLmpzL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBwYXJzZXIgYW5kIGV2YWx1YXRvciBmb3IgYSB1c2VmdWwgcnBnIGRpY2Ugc3ludGF4LlwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJicm93c2VyaWZ5XCI6IFwifjExLjAuMVwiLFxuICAgIFwiamFzbWluZS1ub2RlXCI6IFwifjEuMTQuNVwiLFxuICAgIFwia2FybWFcIjogXCJ+MC4xMC44XCIsXG4gICAgXCJrYXJtYS1jaHJvbWUtbGF1bmNoZXJcIjogXCJ+MC4xLjFcIixcbiAgICBcImthcm1hLWNvZmZlZS1wcmVwcm9jZXNzb3JcIjogXCJ+MC4xLjFcIixcbiAgICBcImthcm1hLWZpcmVmb3gtbGF1bmNoZXJcIjogXCJ+MC4xLjJcIixcbiAgICBcImthcm1hLWh0bWwyanMtcHJlcHJvY2Vzc29yXCI6IFwifjAuMS4wXCIsXG4gICAgXCJrYXJtYS1qYXNtaW5lXCI6IFwifjAuMS41XCIsXG4gICAgXCJrYXJtYS1waGFudG9tanMtbGF1bmNoZXJcIjogXCJ+MC4xLjFcIixcbiAgICBcImthcm1hLXJlcXVpcmVqc1wiOiBcIn4wLjIuMFwiLFxuICAgIFwia2FybWEtc2NyaXB0LWxhdW5jaGVyXCI6IFwifjAuMS4wXCIsXG4gICAgXCJwZWdqc1wiOiBcIn4wLjkuMFwiLFxuICAgIFwicmVxdWlyZWpzXCI6IFwifjIuMS45XCJcbiAgfSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwidGVzdHNcIlxuICB9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiMTcxMmQyYzk3ZDMzNTcyZGJiOTljMDI1NTJlMzdiNTA0ZjJmMzNjMFwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2RpY2UuanMvLS9kaWNlLmpzLTAuOC4wLnRnelwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcImMzMjZmMTJkMDZlNDdjNjM1YWZiYTY4MWFkNTRhNDNkZWIwMTkwODJcIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9sb3JkbnVsbC9kaWNlLmpzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwicnBnXCIsXG4gICAgXCJkaWNlXCIsXG4gICAgXCJwYXJzZXJcIixcbiAgICBcInJvbGxcIixcbiAgICBcInBlZ1wiXG4gIF0sXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJzcmMvZGljZS5qc1wiLFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJsb3JkbnVsbFwiLFxuICAgICAgXCJlbWFpbFwiOiBcIm1pY2Fod0Bsb3JkbnVsbC5jb21cIlxuICAgIH1cbiAgXSxcbiAgXCJuYW1lXCI6IFwiZGljZS5qc1wiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vbG9yZG51bGwvZGljZS5qcy5naXRcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwidGVzdFwiOiBcIm1ha2UgdGVzdFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjAuOC4wXCJcbn1cbiIsInZhciBkaWNlID0ge1xuXHRwYXJzZTogcmVxdWlyZSgnLi9wYXJzZXInKS5wYXJzZSxcblx0ZXZhbDogcmVxdWlyZSgnLi9ldmFsdWF0ZScpLmV2YWwsXG5cdHZlcnNpb246IHJlcXVpcmUoJy4uL3BhY2thZ2UnKS52ZXJzaW9uXG59O1xuXG5mdW5jdGlvbiByb2xsKHN0ciwgc2NvcGUpe1xuXHR2YXIgcGFyc2VkID0gZGljZS5wYXJzZShzdHIpO1xuXHR2YXIgZXZhbGVkID0gZGljZS5ldmFsKHBhcnNlZCwgc2NvcGUpO1xuXHRyZXR1cm4gZXZhbGVkO1xufTtcblxuZGljZS5yb2xsID0gcm9sbDtcblxuZGljZS5zdGF0aXN0aWNzID0gZnVuY3Rpb24oc3RyLCBzY29wZSwgc2FtcGxlcyl7XG5cdGlmKHR5cGVvZihzY29wZSkgPT0gXCJudW1iZXJcIil7XG5cdFx0c2FtcGxlcyA9IHNjb3BlO1xuXHRcdHNjb3BlID0ge307XG5cdH1cblx0c2NvcGUgPSBzY29wZSB8fCB7fTtcblx0c2FtcGxlcyA9IHNhbXBsZXMgfHwgMTAwMDtcblx0dmFyIHJlc3VsdFNldCA9IFtdO1xuXHR2YXIgaTtcblx0Zm9yKGkgPSAwOyBpIDwgc2FtcGxlczsgaSsrKXtcblx0XHRyZXN1bHRTZXQucHVzaChyb2xsKHN0ciwgc2NvcGUpKTtcblx0fVxuXHR2YXIgbWVhbiA9IHJlc3VsdFNldC5yZWR1Y2UoZnVuY3Rpb24obiwgYWNjKXsgcmV0dXJuIG4gKyBhY2M7IH0sIDApIC8gc2FtcGxlcztcblx0dmFyIG1pbiA9IHJlc3VsdFNldC5yZWR1Y2UoZnVuY3Rpb24obiwgYWNjKXsgcmV0dXJuIG4gPCBhY2MgPyBuIDogYWNjOyB9LCByZXN1bHRTZXRbMF0pO1xuXHR2YXIgbWF4ID0gcmVzdWx0U2V0LnJlZHVjZShmdW5jdGlvbihuLCBhY2MpeyByZXR1cm4gbiA+IGFjYyA/IG4gOiBhY2M7IH0sIHJlc3VsdFNldFswXSk7XG5cdHJldHVybiB7XG5cdFx0J3Jlc3VsdHMnOiByZXN1bHRTZXQsXG5cdFx0J21lYW4nOiBtZWFuLFxuXHRcdCdtaW4nOiBwYXJzZUludChtaW4udG9GaXhlZCgpKSxcblx0XHQnbWF4JzogcGFyc2VJbnQobWF4LnRvRml4ZWQoKSlcblx0fTtcbn07XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeV9leHByZXNzaW9uKGV2YWxlZF9vcCl7XG5cdHZhciBzdWIgPSBzdHJpbmdpZnkoZXZhbGVkX29wLmV4cHJlc3Npb24pO1xuXHR2YXIgcHJlZml4ID0gZXZhbGVkX29wLm9wWzBdO1xuXHRpZihwcmVmaXggPT09ICdwJyl7XG5cdFx0cHJlZml4ID0gJyc7XG5cdH1cblx0XG5cdHJldHVybiBwcmVmaXggKyBcIiggXCIgKyBzdWIgKyBcIiApXCI7XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlfb3AoZXZhbGVkX29wKXtcblx0dmFyIHJzID0gc3RyaW5naWZ5KGV2YWxlZF9vcC5yaWdodFNpZGUpO1xuXHR2YXIgbHMgPSBzdHJpbmdpZnkoZXZhbGVkX29wLmxlZnRTaWRlKTtcblx0cmV0dXJuIHJzICsgJyAnICsgZXZhbGVkX29wLm9wICsgJyAnICsgbHM7XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlfcm9sbHMoZXZhbGVkX3JvbGwpe1xuXHR2YXIgbWluU3RyID0gZXZhbGVkX3JvbGwubWluID4gMSA/IGV2YWxlZF9yb2xsLm1pbiArICcuLicgOiAnJztcblx0dmFyIHByZWFtYmxlID0gZXZhbGVkX3JvbGwueCArIGV2YWxlZF9yb2xsLm1vZGUgKyBtaW5TdHIgKyBldmFsZWRfcm9sbC5tYXggKyAnOlsnO1xuXHRyZXR1cm4gcHJlYW1ibGUgKyBldmFsZWRfcm9sbC5yb2xscy5qb2luKCcsICcpICsgJ10nO1xufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KGV2YWxlZCl7XG5cdGlmKGV2YWxlZC5leHByZXNzaW9uKXtcblx0XHRyZXR1cm4gc3RyaW5naWZ5X2V4cHJlc3Npb24oZXZhbGVkKTtcblx0fVxuXG5cdGlmKGV2YWxlZC5vcCl7XG5cdFx0cmV0dXJuIHN0cmluZ2lmeV9vcChldmFsZWQpO1xuXHR9XG5cblx0aWYoZXZhbGVkLnJvbGxzKXtcblx0XHRyZXR1cm4gc3RyaW5naWZ5X3JvbGxzKGV2YWxlZCk7XG5cdH1cblxuXHRyZXR1cm4gZXZhbGVkLnRvU3RyaW5nKCk7XG59O1xuXG5kaWNlLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxudmFyIGs7XG5mb3IoayBpbiBkaWNlKXtcbiAgICBleHBvcnRzW2tdID0gZGljZVtrXTtcbn1cblxucmV0dXJuIGRpY2U7XG4iLCJcbmZ1bmN0aW9uIG1ha2VTZXEoZW5kSW5kZXgpe1xuXHR2YXIgc2VxID0gW107XG5cdHNlcVtlbmRJbmRleF0gPSB0cnVlO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc2VxLmxlbmd0aDsgaSsrKXtcblx0XHRzZXFbaV0gPSB0cnVlO1xuXHR9XG5cdHJldHVybiBzZXE7XG59O1xuXG52YXIgb3BzID0ge1xuXG5cdCdzdGF0aWMnOiBmdW5jdGlvbigpe1xuXHRcdHZhciBvdXRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gb3V0VmFsdWU7XG5cdFx0fTtcblx0fSxcblxuXHQnbG9va3VwJzogZnVuY3Rpb24oKXtcblx0XHR2YXIgdmFyaWFibGVOYW1lID0gdGhpcy52YWx1ZTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc2NvcGUpe1xuXHRcdFx0cmV0dXJuIHNjb3BlW3ZhcmlhYmxlTmFtZV07XG5cdFx0fVxuXHR9LFxuXG5cdCdmbG9vcic6IGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc2NvcGUpe1xuXHRcdFx0dmFyIGZsb29yYWJsZSA9IHZhbHVlKHNjb3BlKTtcblx0XHRcdHZhciB0b3RzID0gbmV3IE51bWJlcihNYXRoLmZsb29yKGZsb29yYWJsZSkpO1xuXHRcdFx0dG90cy5vcCA9ICdmbG9vcic7XG5cdFx0XHR0b3RzLmV4cHJlc3Npb24gPSBmbG9vcmFibGU7XG5cdFx0XHRyZXR1cm4gdG90cztcblx0XHR9XG5cdH0sXG5cblx0J2NlaWwnOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHNjb3BlKXtcblx0XHRcdHZhciBjZWlsYWJsZSA9IHZhbHVlKHNjb3BlKTtcblx0XHRcdHZhciB0b3RzID0gbmV3IE51bWJlcihNYXRoLmNlaWwoY2VpbGFibGUpKTtcblx0XHRcdHRvdHMub3AgPSAnY2VpbCc7XG5cdFx0XHR0b3RzLmV4cHJlc3Npb24gPSBjZWlsYWJsZTtcblx0XHRcdHJldHVybiB0b3RzO1xuXHRcdH1cblx0fSxcblxuXHQncm91bmQnOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHNjb3BlKXtcblx0XHRcdHZhciByb3VuZGFibGUgPSB2YWx1ZShzY29wZSk7XG5cdFx0XHR2YXIgdG90cyA9IG5ldyBOdW1iZXIoTWF0aC5yb3VuZChyb3VuZGFibGUpKTtcblx0XHRcdHRvdHMub3AgPSAncm91bmQnO1xuXHRcdFx0dG90cy5leHByZXNzaW9uID0gcm91bmRhYmxlO1xuXHRcdFx0cmV0dXJuIHRvdHM7XG5cdFx0fVxuXHR9LFxuXG5cdCdkJzogZnVuY3Rpb24obnVtUm9sbHMsIG1pbk1heCl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHNjb3BlKXtcblx0XHRcdHZhciB4ID0gbnVtUm9sbHMoc2NvcGUpO1xuXHRcdFx0dmFyIHNlcSA9IG1ha2VTZXEoeCAtIDEpO1xuXHRcdFx0dmFyIG91dE1pbiwgb3V0TWF4O1xuXHRcdFx0dmFyIHJvbGxlZCA9IHNlcS5tYXAoZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFyIHJvbGxlZFJldCA9IG1pbk1heChzY29wZSk7XG5cdFx0XHRcdG91dE1pbiA9IHJvbGxlZFJldC5taW47XG5cdFx0XHRcdG91dE1heCA9IHJvbGxlZFJldC5tYXg7XG5cdFx0XHRcdHJldHVybiByb2xsZWRSZXQ7XG5cdFx0XHR9KTtcblx0XHRcdHZhciBvdXQgPSByb2xsZWQucmVkdWNlKGZ1bmN0aW9uKHN1bSwgdmFsKXtcblx0XHRcdFx0cmV0dXJuIHN1bSArIHZhbDtcblx0XHRcdH0sIDApO1xuXHRcdFx0b3V0ID0gbmV3IE51bWJlcihvdXQpO1xuXHRcdFx0b3V0LnJvbGxzID0gcm9sbGVkO1xuXHRcdFx0b3V0Lm1pbiA9IG91dE1pbjtcblx0XHRcdG91dC5tYXggPSBvdXRNYXg7XG5cdFx0XHRvdXQueCA9IHg7XG5cdFx0XHRvdXQubW9kZSA9ICdkJztcblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fTtcblx0fSxcblxuXHQndyc6IGZ1bmN0aW9uKG51bVJvbGxzLCBtaW5NYXgpe1xuXHRcdHJldHVybiBmdW5jdGlvbihzY29wZSl7XG5cdFx0XHR2YXIgeCA9IG51bVJvbGxzKHNjb3BlKTtcblx0XHRcdHZhciBzZXEgPSBtYWtlU2VxKHggLSAxKTtcblx0XHRcdHZhciBvdXRNaW4sIG91dE1heDtcblx0XHRcdHZhciByb2xsZWQgPSBzZXEubWFwKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBsYXN0Um9sbGVkID0gbWluTWF4KHNjb3BlKTtcblx0XHRcdFx0dmFyIHdpbGRyb2xsZWQgPSAwO1xuXHRcdFx0XHRvdXRNaW4gPSBtaW5NYXgubWluO1xuXHRcdFx0XHRvdXRNYXggPSBtaW5NYXgubWF4O1xuXHRcdFx0XHRpZihtaW5NYXgubWluID09PSBtaW5NYXgubWF4KXtcblx0XHRcdFx0XHRyZXR1cm4gbGFzdFJvbGxlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZShsYXN0Um9sbGVkID09PSBtaW5NYXgubWF4KXtcblx0XHRcdFx0XHR3aWxkcm9sbGVkICs9IGxhc3RSb2xsZWQ7XG5cdFx0XHRcdFx0bGFzdFJvbGxlZCA9IG1pbU1heChzY29wZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHdpbGRyb2xsZWQ7XG5cdFx0XHR9KTtcblx0XHRcdHZhciBvdXQgPSByb2xsZWQucmVkdWNlKGZ1bmN0aW9uKHN1bSwgdmFsKXtcblx0XHRcdFx0cmV0dXJuIHN1bSArIHZhbDtcblx0XHRcdH0sIDApO1xuXHRcdFx0b3V0ID0gbmV3IE51bWJlcihvdXQpO1xuXHRcdFx0b3V0LnJvbGxzID0gcm9sbGVkO1xuXHRcdFx0b3V0Lm1pbiA9IG91dE1pbjtcblx0XHRcdG91dC5tYXggPSBvdXRNYXg7XG5cdFx0XHRvdXQueCA9IHg7XG5cdFx0XHRvdXQubW9kZSA9ICd3Jztcblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fTtcblx0fSxcblxuXHQncmFuZG9tJzogZnVuY3Rpb24obWluRnVuLCBtYXhGdW4pe1xuXHRcdHJldHVybiBmdW5jdGlvbihzY29wZSl7XG5cdFx0XHR2YXIgcmF3UmFuZG9tID0gTWF0aC5yYW5kb20oKTtcblx0XHRcdHZhciBtYXggPSBtYXhGdW4oc2NvcGUpO1xuXHRcdFx0dmFyIG1pbiA9IG1pbkZ1bihzY29wZSk7XG5cdFx0XHR2YXIgZGlmZiA9IG1heCAtIG1pbjtcblx0XHRcdHZhciByYXdSYW5kb20gPSBkaWZmICogcmF3UmFuZG9tO1xuXHRcdFx0dmFyIHJuZE51bWJlciA9IE1hdGgucm91bmQocmF3UmFuZG9tICsgbWluKTtcblx0XHRcdHJuZE51bWJlciA9IG5ldyBOdW1iZXIocm5kTnVtYmVyKTtcblx0XHRcdHJuZE51bWJlci5taW4gPSBtaW47XG5cdFx0XHRybmROdW1iZXIubWF4ID0gbWF4O1xuXHRcdFx0cmV0dXJuIHJuZE51bWJlcjtcblx0XHR9O1xuXHR9LFxuXG5cdCcrJzogZnVuY3Rpb24odjEsIHYyKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc2NvcGUpe1xuXHRcdFx0dmFyIHJpZ2h0U2lkZSA9IHYxKHNjb3BlKTtcblx0XHRcdHZhciBsZWZ0U2lkZSA9IHYyKHNjb3BlKTtcblx0XHRcdHZhciBzdW0gPSByaWdodFNpZGUgKyBsZWZ0U2lkZTtcblx0XHRcdHN1bSA9IG5ldyBOdW1iZXIoc3VtKTtcblx0XHRcdHN1bS5vcCA9ICcrJztcblx0XHRcdHN1bS5yaWdodFNpZGUgPSByaWdodFNpZGU7XG5cdFx0XHRzdW0ubGVmdFNpZGUgPSBsZWZ0U2lkZTtcblx0XHRcdHJldHVybiBzdW07XG5cdFx0fTtcblx0fSxcblxuXHQnLSc6IGZ1bmN0aW9uKHYxLCB2Mil7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHNjb3BlKXtcblx0XHRcdHZhciByaWdodFNpZGUgPSB2MShzY29wZSk7XG5cdFx0XHR2YXIgbGVmdFNpZGUgPSB2MihzY29wZSk7XG5cdFx0XHR2YXIgc3VtID0gcmlnaHRTaWRlIC0gbGVmdFNpZGU7XG5cdFx0XHRzdW0gPSBuZXcgTnVtYmVyKHN1bSk7XG5cdFx0XHRzdW0ub3AgPSAnLSc7XG5cdFx0XHRzdW0ucmlnaHRTaWRlID0gcmlnaHRTaWRlO1xuXHRcdFx0c3VtLmxlZnRTaWRlID0gbGVmdFNpZGU7XG5cdFx0XHRyZXR1cm4gc3VtO1xuXHRcdH07XG5cdH0sXG5cblx0JyonOiBmdW5jdGlvbih2MSwgdjIpe1xuXHRcdHJldHVybiBmdW5jdGlvbihzY29wZSl7XG5cdFx0XHR2YXIgcmlnaHRTaWRlID0gdjEoc2NvcGUpO1xuXHRcdFx0dmFyIGxlZnRTaWRlID0gdjIoc2NvcGUpO1xuXHRcdFx0dmFyIHRvdHMgPSByaWdodFNpZGUgKiBsZWZ0U2lkZTtcblx0XHRcdHRvdHMgPSBuZXcgTnVtYmVyKHRvdHMpO1xuXHRcdFx0dG90cy5vcCA9ICcqJztcblx0XHRcdHRvdHMucmlnaHRTaWRlID0gcmlnaHRTaWRlO1xuXHRcdFx0dG90cy5sZWZ0U2lkZSA9IGxlZnRTaWRlO1xuXHRcdFx0cmV0dXJuIHRvdHM7XG5cdFx0fTtcblx0fSxcblxuXHQnLyc6IGZ1bmN0aW9uKHYxLCB2Mil7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHNjb3BlKXtcblx0XHRcdHZhciByaWdodFNpZGUgPSB2MShzY29wZSk7XG5cdFx0XHR2YXIgbGVmdFNpZGUgPSB2MihzY29wZSk7XG5cdFx0XHR2YXIgdG90cyA9IHJpZ2h0U2lkZSAvIGxlZnRTaWRlO1xuXHRcdFx0dG90cyA9IG5ldyBOdW1iZXIodG90cyk7XG5cdFx0XHR0b3RzLm9wID0gJy8nO1xuXHRcdFx0dG90cy5yaWdodFNpZGUgPSByaWdodFNpZGU7XG5cdFx0XHR0b3RzLmxlZnRTaWRlID0gbGVmdFNpZGU7XG5cdFx0XHRyZXR1cm4gdG90cztcblx0XHR9O1xuXHR9LFxuXG5cdCdwYXJlbl9leHByZXNzJzogZnVuY3Rpb24ob3Ape1xuXHRcdHJldHVybiBmdW5jdGlvbihzY29wZSl7XG5cdFx0XHR2YXIgdG90cyA9IG9wKHNjb3BlKTtcblx0XHRcdG91dHRvdHMgPSBuZXcgTnVtYmVyKHRvdHMpO1xuXHRcdFx0b3V0dG90cy5vcCA9ICdwYXJlbl9leHByZXNzJztcblx0XHRcdG91dHRvdHMuZXhwcmVzc2lvbiA9IHRvdHM7XG5cdFx0XHRyZXR1cm4gb3V0dG90cztcblx0XHR9O1xuXHR9XG5cbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVfb3BzKGFyZ3Mpe1xuXHRhcmdzID0gYXJncyB8fCBbXTtcblx0cmV0dXJuIGFyZ3MubWFwKHJlc29sdmVfb3ApO1xufTtcblxuZnVuY3Rpb24gcmVzb2x2ZV9vcChvcE9iail7XG5cdHZhciBzdWJBcmdzID0gcmVzb2x2ZV9vcHMob3BPYmouYXJncyk7XG5cdHJldHVybiBvcHNbb3BPYmoub3BdLmFwcGx5KG9wT2JqLCBzdWJBcmdzKTtcbn07XG5cblxuZXhwb3J0cy5ldmFsID0gZnVuY3Rpb24ocGFyc2VkLCBzY29wZSl7XG5cdHNjb3BlID0gc2NvcGUgfHwge307XG5cdHZhciBvcHMgPSByZXNvbHZlX29wKHBhcnNlZClcblx0cmV0dXJuIG9wcyhzY29wZSk7XG5cblx0Lyp2YXIgYWNjID0ge3N1bTogMCwgbW9kZTogXCIrXCIsIHJvbGxzOiBbXSwgJ3Njb3BlJzpzY29wZX1cblx0dmFyIHJlZHVjZWQgPSBwYXJzZWQucmVkdWNlKHJlZHVjZVRoZW1Cb25lcywgYWNjKTtcblx0cmV0dXJuIHtzdW06IHJlZHVjZWQuc3VtLCByb2xsczogcmVkdWNlZC5yb2xsc307Ki9cbn1cblxuZXhwb3J0cy5vcHMgPSBvcHM7XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuOS4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMub3JnL1xuICAgKi9cblxuICBmdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkge1xuICAgIGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICAgIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgICB0aGlzLm1lc3NhZ2UgID0gbWVzc2FnZTtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xuXG4gICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBwZWckU3ludGF4RXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHBlZyRzdWJjbGFzcyhwZWckU3ludGF4RXJyb3IsIEVycm9yKTtcblxuICBmdW5jdGlvbiBwZWckcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIHBhcnNlciAgPSB0aGlzLFxuXG4gICAgICAgIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb25zID0geyBzdGFydDogcGVnJHBhcnNlc3RhcnQgfSxcbiAgICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uICA9IHBlZyRwYXJzZXN0YXJ0LFxuXG4gICAgICAgIHBlZyRjMCA9IGZ1bmN0aW9uKHYxLCBvcCwgdjIpIHsgcmV0dXJuIHsnb3AnOm9wLCBhcmdzOiBbdjEsIHYyXSB9OyB9LFxuICAgICAgICBwZWckYzEgPSBmdW5jdGlvbihvdXQpIHsgcmV0dXJuIG91dDsgfSxcbiAgICAgICAgcGVnJGMyID0gXCIoXCIsXG4gICAgICAgIHBlZyRjMyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIihcIiwgZGVzY3JpcHRpb246IFwiXFxcIihcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0ID0gXCIpXCIsXG4gICAgICAgIHBlZyRjNSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIilcIiwgZGVzY3JpcHRpb246IFwiXFxcIilcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM2ID0gZnVuY3Rpb24ocm9sbHMpIHsgcmV0dXJuIHsnb3AnOidwYXJlbl9leHByZXNzJywgYXJnczogW3JvbGxzXX0gfSxcbiAgICAgICAgcGVnJGM3ID0gXCIqXCIsXG4gICAgICAgIHBlZyRjOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIipcIiwgZGVzY3JpcHRpb246IFwiXFxcIipcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM5ID0gZnVuY3Rpb24oKSB7IHJldHVybiAnKic7IH0sXG4gICAgICAgIHBlZyRjMTAgPSBcIi9cIixcbiAgICAgICAgcGVnJGMxMSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi9cIiwgZGVzY3JpcHRpb246IFwiXFxcIi9cXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJy8nOyB9LFxuICAgICAgICBwZWckYzEzID0gZnVuY3Rpb24odjEsIG9wLCB2MikgeyByZXR1cm4geydvcCc6b3AsIGFyZ3M6W3YxLCB2Ml0gfTsgfSxcbiAgICAgICAgcGVnJGMxNCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0sXG4gICAgICAgIHBlZyRjMTUgPSBmdW5jdGlvbihwYXJlbikgeyByZXR1cm4gcGFyZW47IH0sXG4gICAgICAgIHBlZyRjMTYgPSBmdW5jdGlvbih2MSwgb3AsIHYyKSB7IHJldHVybiB7J29wJzpvcCwgYXJnczpbdjEsIHYyXX07IH0sXG4gICAgICAgIHBlZyRjMTcgPSBmdW5jdGlvbihvcCkgeyByZXR1cm4gb3A7IH0sXG4gICAgICAgIHBlZyRjMTggPSBcIitcIixcbiAgICAgICAgcGVnJGMxOSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIitcIiwgZGVzY3JpcHRpb246IFwiXFxcIitcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMyMCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIrXCI7IH0sXG4gICAgICAgIHBlZyRjMjEgPSBcIi1cIixcbiAgICAgICAgcGVnJGMyMiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi1cIiwgZGVzY3JpcHRpb246IFwiXFxcIi1cXFwiXCIgfSxcbiAgICAgICAgcGVnJGMyMyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCItXCI7IH0sXG4gICAgICAgIHBlZyRjMjQgPSBmdW5jdGlvbih4LCBtb2RlLCBtbSkgeyByZXR1cm4geydvcCc6bW9kZSwgJ2FyZ3MnOlt4LCBtbV19IH0sXG4gICAgICAgIHBlZyRjMjUgPSBmdW5jdGlvbihtb2RlLCBtbSkgeyByZXR1cm4geydvcCc6bW9kZSwgJ2FyZ3MnOlt7J29wJzonc3RhdGljJywgJ3ZhbHVlJzoxfSwgbW1dfTsgfSxcbiAgICAgICAgcGVnJGMyNiA9IGZ1bmN0aW9uKG1tKSB7IHJldHVybiB7ICdvcCc6J2QnLCAnYXJncyc6WyB7J29wJzonc3RhdGljJywgJ3ZhbHVlJzoxfSwgbW1dfTsgfSxcbiAgICAgICAgcGVnJGMyNyA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH0sXG4gICAgICAgIHBlZyRjMjggPSBcImRcIixcbiAgICAgICAgcGVnJGMyOSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImRcIiwgZGVzY3JpcHRpb246IFwiXFxcImRcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzMCA9IFwid1wiLFxuICAgICAgICBwZWckYzMxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwid1wiLCBkZXNjcmlwdGlvbjogXCJcXFwid1xcXCJcIiB9LFxuICAgICAgICBwZWckYzMyID0gZnVuY3Rpb24obW0pIHsgcmV0dXJuIG1tOyB9LFxuICAgICAgICBwZWckYzMzID0gZnVuY3Rpb24obWF4KSB7IHJldHVybiB7J29wJzoncmFuZG9tJywgJ2FyZ3MnOlt7J29wJzonc3RhdGljJywgJ2FyZ3MnOltdLCAndmFsdWUnOjF9LCBtYXhdfTsgfSxcbiAgICAgICAgcGVnJGMzNCA9IFwiLi5cIixcbiAgICAgICAgcGVnJGMzNSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi4uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIuLlxcXCJcIiB9LFxuICAgICAgICBwZWckYzM2ID0gZnVuY3Rpb24obWluLCBtYXgpIHsgcmV0dXJuIHsnb3AnOidyYW5kb20nLCAnYXJncyc6W21pbiwgbWF4XX07IH0sXG4gICAgICAgIHBlZyRjMzcgPSAvXlsgXS8sXG4gICAgICAgIHBlZyRjMzggPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyBdXCIsIGRlc2NyaXB0aW9uOiBcIlsgXVwiIH0sXG4gICAgICAgIHBlZyRjMzkgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIFx0XHRyZXR1cm4geydvcCc6ICdzdGF0aWMnLCB2YWx1ZTogaX07XG4gICAgICAgIFx0fSxcbiAgICAgICAgcGVnJGM0MCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgXHRcdHJldHVybiBsO1xuICAgICAgICBcdH0sXG4gICAgICAgIHBlZyRjNDEgPSBmdW5jdGlvbihmLCB2KSB7XG4gICAgICAgIFx0XHRyZXR1cm4geydvcCc6ZiwgYXJnczpbdl19O1xuICAgICAgICBcdH0sXG4gICAgICAgIHBlZyRjNDIgPSBmdW5jdGlvbihmLCBleCkge1xuICAgICAgICAgICAgcmV0dXJuIHsnb3AnOmYsIGFyZ3M6ZXguYXJnc307XG4gICAgICAgIFx0fSxcbiAgICAgICAgcGVnJGM0MyA9IFwiZlwiLFxuICAgICAgICBwZWckYzQ0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZlxcXCJcIiB9LFxuICAgICAgICBwZWckYzQ1ID0gZnVuY3Rpb24oKSB7IHJldHVybiAnZmxvb3InOyB9LFxuICAgICAgICBwZWckYzQ2ID0gXCJyXCIsXG4gICAgICAgIHBlZyRjNDcgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNDggPSBmdW5jdGlvbigpIHsgcmV0dXJuICdyb3VuZCc7IH0sXG4gICAgICAgIHBlZyRjNDkgPSBcImNcIixcbiAgICAgICAgcGVnJGM1MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImNcIiwgZGVzY3JpcHRpb246IFwiXFxcImNcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1MSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2NlaWwnOyB9LFxuICAgICAgICBwZWckYzUyID0gZnVuY3Rpb24odikgeyByZXR1cm4geydvcCc6J2xvb2t1cCcsICd2YWx1ZSc6dn07IH0sXG4gICAgICAgIHBlZyRjNTMgPSBcIltcIixcbiAgICAgICAgcGVnJGM1NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIltcIiwgZGVzY3JpcHRpb246IFwiXFxcIltcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1NSA9IC9eW2EtekEtWiAwLTldLyxcbiAgICAgICAgcGVnJGM1NiA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aIDAtOV1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWiAwLTldXCIgfSxcbiAgICAgICAgcGVnJGM1NyA9IFwiXVwiLFxuICAgICAgICBwZWckYzU4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXVxcXCJcIiB9LFxuICAgICAgICBwZWckYzU5ID0gZnVuY3Rpb24odmFybmFtZSkgeyByZXR1cm4gdmFybmFtZS5qb2luKFwiXCIpOyB9LFxuICAgICAgICBwZWckYzYwID0geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBcImludGVnZXJcIiB9LFxuICAgICAgICBwZWckYzYxID0gL15bMC05XS8sXG4gICAgICAgIHBlZyRjNjIgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtOV1cIiwgZGVzY3JpcHRpb246IFwiWzAtOV1cIiB9LFxuICAgICAgICBwZWckYzYzID0gZnVuY3Rpb24oZGlnaXRzKSB7IHJldHVybiBwYXJzZUludChkaWdpdHMuam9pbihcIlwiKSwgMTApOyB9LFxuICAgICAgICBwZWckYzY0ID0gZnVuY3Rpb24oZGlnaXRzKSB7IHJldHVybiBwYXJzZUludChkaWdpdHMuam9pbihcIlwiKSwgMTApICogLTE7IH0sXG5cbiAgICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgICBwZWckc2F2ZWRQb3MgICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRwb3NEZXRhaWxzQ2FjaGUgID0gW3sgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH1dLFxuICAgICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgID0gW10sXG4gICAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCxcblxuICAgICAgICBwZWckcmVzdWx0O1xuXG4gICAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgICAgfVxuXG4gICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXh0KCkge1xuICAgICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZyhwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24oXG4gICAgICAgIG51bGwsXG4gICAgICAgIFt7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH1dLFxuICAgICAgICBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyksXG4gICAgICAgIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBudWxsLFxuICAgICAgICBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyksXG4gICAgICAgIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgICAgdmFyIGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc10sXG4gICAgICAgICAgcCwgY2g7XG5cbiAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcCA9IHBvcyAtIDE7XG4gICAgICAgIHdoaWxlICghcGVnJHBvc0RldGFpbHNDYWNoZVtwXSkge1xuICAgICAgICAgIHAtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3BdO1xuICAgICAgICBkZXRhaWxzID0ge1xuICAgICAgICAgIGxpbmU6ICAgZGV0YWlscy5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZGV0YWlscy5jb2x1bW4sXG4gICAgICAgICAgc2VlbkNSOiBkZXRhaWxzLnNlZW5DUlxuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChwIDwgcG9zKSB7XG4gICAgICAgICAgY2ggPSBpbnB1dC5jaGFyQXQocCk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBpZiAoIWRldGFpbHMuc2VlbkNSKSB7IGRldGFpbHMubGluZSsrOyB9XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxyXCIgfHwgY2ggPT09IFwiXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcdTIwMjlcIikge1xuICAgICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHArKztcbiAgICAgICAgfVxuXG4gICAgICAgIHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXSA9IGRldGFpbHM7XG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRjb21wdXRlTG9jYXRpb24oc3RhcnRQb3MsIGVuZFBvcykge1xuICAgICAgdmFyIHN0YXJ0UG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhzdGFydFBvcyksXG4gICAgICAgICAgZW5kUG9zRGV0YWlscyAgID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKGVuZFBvcyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcbiAgICAgICAgICBsaW5lOiAgIHN0YXJ0UG9zRGV0YWlscy5saW5lLFxuICAgICAgICAgIGNvbHVtbjogc3RhcnRQb3NEZXRhaWxzLmNvbHVtblxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICBvZmZzZXQ6IGVuZFBvcyxcbiAgICAgICAgICBsaW5lOiAgIGVuZFBvc0RldGFpbHMubGluZSxcbiAgICAgICAgICBjb2x1bW46IGVuZFBvc0RldGFpbHMuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQpIHtcbiAgICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgICB9XG5cbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCkge1xuICAgICAgICB2YXIgaSA9IDE7XG5cbiAgICAgICAgZXhwZWN0ZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgaWYgKGEuZGVzY3JpcHRpb24gPCBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChhLmRlc2NyaXB0aW9uID4gYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRbaSAtIDFdID09PSBleHBlY3RlZFtpXSkge1xuICAgICAgICAgICAgZXhwZWN0ZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHtcbiAgICAgICAgZnVuY3Rpb24gc3RyaW5nRXNjYXBlKHMpIHtcbiAgICAgICAgICBmdW5jdGlvbiBoZXgoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH1cblxuICAgICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAgICdcXFxcXFxcXCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgICAgJ1xcXFxcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgICAnXFxcXHQnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAgICdcXFxcbicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxmL2csICAgJ1xcXFxmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgICAnXFxcXHInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEVcXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg4MC1cXHhGRl0vZywgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MDEwMC1cXHUwRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTEwMDAtXFx1RkZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1JyAgKyBoZXgoY2gpOyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBlY3RlZERlc2NzID0gbmV3IEFycmF5KGV4cGVjdGVkLmxlbmd0aCksXG4gICAgICAgICAgICBleHBlY3RlZERlc2MsIGZvdW5kRGVzYywgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBleHBlY3RlZERlc2NzW2ldID0gZXhwZWN0ZWRbaV0uZGVzY3JpcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RlZERlc2MgPSBleHBlY3RlZC5sZW5ndGggPiAxXG4gICAgICAgICAgPyBleHBlY3RlZERlc2NzLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICAgKyBcIiBvciBcIlxuICAgICAgICAgICAgICArIGV4cGVjdGVkRGVzY3NbZXhwZWN0ZWQubGVuZ3RoIC0gMV1cbiAgICAgICAgICA6IGV4cGVjdGVkRGVzY3NbMF07XG5cbiAgICAgICAgZm91bmREZXNjID0gZm91bmQgPyBcIlxcXCJcIiArIHN0cmluZ0VzY2FwZShmb3VuZCkgKyBcIlxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7XG5cbiAgICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBleHBlY3RlZERlc2MgKyBcIiBidXQgXCIgKyBmb3VuZERlc2MgKyBcIiBmb3VuZC5cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKFxuICAgICAgICBtZXNzYWdlICE9PSBudWxsID8gbWVzc2FnZSA6IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgZm91bmQsXG4gICAgICAgIGxvY2F0aW9uXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXN0YXJ0KCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBzMCA9IHBlZyRwYXJzZWRpY2Vyb2xscygpO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZGljZXJvbGxzKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VtdWx0aXBsaWNhdGlvblNlcSgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlYWRkaXRpb25PcCgpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZWFkZGl0aW9uU2VxKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMwKHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZWFkZGl0aW9uU2VxKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMxKHMxKTtcbiAgICAgICAgfVxuICAgICAgICBzMCA9IHMxO1xuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlcGFyZW5FeHByZXNzKCk7XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMxKHMxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlcGFyZW5FeHByZXNzKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICAgIHMxID0gcGVnJGMyO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMyk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZXdzKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlZGljZXJvbGxzKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZXdzKCk7XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJGM0O1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM2KHMzKTtcbiAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtdWx0aXBsaWNhdGlvbk9wKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDIpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjNztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZXdzKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGM5KCk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nykge1xuICAgICAgICAgICAgczIgPSBwZWckYzEwO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzExKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzEyKCk7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtdWx0aXBsaWNhdGlvblNlcSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlZGljZXJvbGwoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZW11bHRpcGxpY2F0aW9uT3AoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VtdWx0aXBsaWNhdGlvblNlcSgpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjMTMoczEsIHMyLCBzMyk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlcGFyZW5FeHByZXNzKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlbXVsdGlwbGljYXRpb25PcCgpO1xuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBwZWckcGFyc2VtdWx0aXBsaWNhdGlvblNlcSgpO1xuICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMTMoczEsIHMyLCBzMyk7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VkaWNlcm9sbCgpO1xuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjMTQoczEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlcGFyZW5FeHByZXNzKCk7XG4gICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMxNShzMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlYWRkaXRpb25TZXEoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZW11bHRpcGxpY2F0aW9uU2VxKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VhZGRpdGlvbk9wKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlYWRkaXRpb25TZXEoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzE2KHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZW11bHRpcGxpY2F0aW9uU2VxKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMxNyhzMSk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZXBhcmVuRXhwcmVzcygpO1xuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjMTcoczEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VhZGRpdGlvbk9wKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDMpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMTg7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE5KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzIwKCk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NSkge1xuICAgICAgICAgICAgczIgPSBwZWckYzIxO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIyKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzIzKCk7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VkaWNlcm9sbCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlaW50dmFsKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2Vyb2xsbW9kZSgpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZW1heWJlX21pbm1heCgpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjMjQoczEsIHMyLCBzMyk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlcm9sbG1vZGUoKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VtYXliZV9taW5tYXgoKTtcbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzI1KHMxLCBzMik7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlbWlubWF4KCk7XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMyNihzMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgczEgPSBwZWckcGFyc2VpbnR2YWwoKTtcbiAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzI3KHMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vyb2xsbW9kZSgpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMDApIHtcbiAgICAgICAgczAgPSBwZWckYzI4O1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjkpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTkpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjMzA7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMxKTsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtYXliZV9taW5tYXgoKSB7XG4gICAgICB2YXIgczAsIHMxO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VtaW5tYXgoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzMyKHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VpbnR2YWwoKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzMzKHMxKTtcbiAgICAgICAgfVxuICAgICAgICBzMCA9IHMxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbWlubWF4KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VpbnR2YWwoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGMzNCkge1xuICAgICAgICAgIHMyID0gcGVnJGMzNDtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzUpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VpbnR2YWwoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzM2KHMxLCBzMyk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNld3MoKSB7XG4gICAgICB2YXIgczAsIHMxO1xuXG4gICAgICBzMCA9IFtdO1xuICAgICAgaWYgKHBlZyRjMzcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzOCk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMC5wdXNoKHMxKTtcbiAgICAgICAgaWYgKHBlZyRjMzcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzgpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWludHZhbCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VpbnRlZ2VyKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMzOShzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlbG9va3VwKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM0MChzMSk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZW1hdGhpdCgpO1xuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIgPSBwZWckcGFyc2Vsb29rdXAoKTtcbiAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzQxKHMxLCBzMik7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlbWF0aGl0KCk7XG4gICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VwYXJlbkV4cHJlc3MoKTtcbiAgICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckYzQyKHMxLCBzMik7XG4gICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbWF0aGl0KCkge1xuICAgICAgdmFyIHMwLCBzMTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTAyKSB7XG4gICAgICAgIHMxID0gcGVnJGM0MztcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjNDUoKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjNDY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ3KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM0OCgpO1xuICAgICAgICB9XG4gICAgICAgIHMwID0gczE7XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5OSkge1xuICAgICAgICAgICAgczEgPSBwZWckYzQ5O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUwKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzUxKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWxvb2t1cCgpIHtcbiAgICAgIHZhciBzMCwgczE7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZXZhcmlhYmxlKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM1MihzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNldmFyaWFibGUoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XG4gICAgICAgIHMxID0gcGVnJGM1MztcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIGlmIChwZWckYzU1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgICBpZiAocGVnJGM1NS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgICAgczMgPSBwZWckYzU3O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU4KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzU5KHMyKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VpbnRlZ2VyKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgaWYgKHBlZyRjNjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Mik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBpZiAocGVnJGM2MS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjIpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM2MyhzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDUpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMjE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gW107XG4gICAgICAgICAgaWYgKHBlZyRjNjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYyKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgICAgaWYgKHBlZyRjNjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjIpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzY0KHMyKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2MCk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwZWckcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBwZWckZmFpbCh7IHR5cGU6IFwiZW5kXCIsIGRlc2NyaXB0aW9uOiBcImVuZCBvZiBpbnB1dFwiIH0pO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24oXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQsXG4gICAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBlZyRtYXhGYWlsUG9zKSA6IG51bGwsXG4gICAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoXG4gICAgICAgICAgPyBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRtYXhGYWlsUG9zLCBwZWckbWF4RmFpbFBvcyArIDEpXG4gICAgICAgICAgOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRtYXhGYWlsUG9zLCBwZWckbWF4RmFpbFBvcylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBTeW50YXhFcnJvcjogcGVnJFN5bnRheEVycm9yLFxuICAgIHBhcnNlOiAgICAgICBwZWckcGFyc2VcbiAgfTtcbn0pKCk7XG4iLCIvKiFcbiAqIEV2ZW50RW1pdHRlcjJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWoxbngvRXZlbnRFbWl0dGVyMlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMyBoaWoxbnhcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuOyFmdW5jdGlvbih1bmRlZmluZWQpIHtcblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5IDogZnVuY3Rpb24gX2lzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH07XG4gIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBpZiAodGhpcy5fY29uZikge1xuICAgICAgY29uZmlndXJlLmNhbGwodGhpcywgdGhpcy5fY29uZik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlKGNvbmYpIHtcbiAgICBpZiAoY29uZikge1xuXG4gICAgICB0aGlzLl9jb25mID0gY29uZjtcblxuICAgICAgY29uZi5kZWxpbWl0ZXIgJiYgKHRoaXMuZGVsaW1pdGVyID0gY29uZi5kZWxpbWl0ZXIpO1xuICAgICAgY29uZi5tYXhMaXN0ZW5lcnMgJiYgKHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBjb25mLm1heExpc3RlbmVycyk7XG4gICAgICBjb25mLndpbGRjYXJkICYmICh0aGlzLndpbGRjYXJkID0gY29uZi53aWxkY2FyZCk7XG4gICAgICBjb25mLm5ld0xpc3RlbmVyICYmICh0aGlzLm5ld0xpc3RlbmVyID0gY29uZi5uZXdMaXN0ZW5lcik7XG5cbiAgICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJUcmVlID0ge307XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGNvbmYpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB0aGlzLm5ld0xpc3RlbmVyID0gZmFsc2U7XG4gICAgY29uZmlndXJlLmNhbGwodGhpcywgY29uZik7XG4gIH1cblxuICAvL1xuICAvLyBBdHRlbnRpb24sIGZ1bmN0aW9uIHJldHVybiB0eXBlIG5vdyBpcyBhcnJheSwgYWx3YXlzICFcbiAgLy8gSXQgaGFzIHplcm8gZWxlbWVudHMgaWYgbm8gYW55IG1hdGNoZXMgZm91bmQgYW5kIG9uZSBvciBtb3JlXG4gIC8vIGVsZW1lbnRzIChsZWFmcykgaWYgdGhlcmUgYXJlIG1hdGNoZXNcbiAgLy9cbiAgZnVuY3Rpb24gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlLCBpKSB7XG4gICAgaWYgKCF0cmVlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBsaXN0ZW5lcnM9W10sIGxlYWYsIGxlbiwgYnJhbmNoLCB4VHJlZSwgeHhUcmVlLCBpc29sYXRlZEJyYW5jaCwgZW5kUmVhY2hlZCxcbiAgICAgICAgdHlwZUxlbmd0aCA9IHR5cGUubGVuZ3RoLCBjdXJyZW50VHlwZSA9IHR5cGVbaV0sIG5leHRUeXBlID0gdHlwZVtpKzFdO1xuICAgIGlmIChpID09PSB0eXBlTGVuZ3RoICYmIHRyZWUuX2xpc3RlbmVycykge1xuICAgICAgLy9cbiAgICAgIC8vIElmIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50KHMpIGxpc3QgYW5kIHRoZSB0cmVlIGhhcyBsaXN0ZW5lcnNcbiAgICAgIC8vIGludm9rZSB0aG9zZSBsaXN0ZW5lcnMuXG4gICAgICAvL1xuICAgICAgaWYgKHR5cGVvZiB0cmVlLl9saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaCh0cmVlLl9saXN0ZW5lcnMpO1xuICAgICAgICByZXR1cm4gW3RyZWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZWFmID0gMCwgbGVuID0gdHJlZS5fbGlzdGVuZXJzLmxlbmd0aDsgbGVhZiA8IGxlbjsgbGVhZisrKSB7XG4gICAgICAgICAgaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaCh0cmVlLl9saXN0ZW5lcnNbbGVhZl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdHJlZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChjdXJyZW50VHlwZSA9PT0gJyonIHx8IGN1cnJlbnRUeXBlID09PSAnKionKSB8fCB0cmVlW2N1cnJlbnRUeXBlXSkge1xuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBldmVudCBlbWl0dGVkIGlzICcqJyBhdCB0aGlzIHBhcnRcbiAgICAgIC8vIG9yIHRoZXJlIGlzIGEgY29uY3JldGUgbWF0Y2ggYXQgdGhpcyBwYXRjaFxuICAgICAgLy9cbiAgICAgIGlmIChjdXJyZW50VHlwZSA9PT0gJyonKSB7XG4gICAgICAgIGZvciAoYnJhbmNoIGluIHRyZWUpIHtcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycgJiYgdHJlZS5oYXNPd25Qcm9wZXJ0eShicmFuY2gpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpKzEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSBpZihjdXJyZW50VHlwZSA9PT0gJyoqJykge1xuICAgICAgICBlbmRSZWFjaGVkID0gKGkrMSA9PT0gdHlwZUxlbmd0aCB8fCAoaSsyID09PSB0eXBlTGVuZ3RoICYmIG5leHRUeXBlID09PSAnKicpKTtcbiAgICAgICAgaWYoZW5kUmVhY2hlZCAmJiB0cmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAvLyBUaGUgbmV4dCBlbGVtZW50IGhhcyBhIF9saXN0ZW5lcnMsIGFkZCBpdCB0byB0aGUgaGFuZGxlcnMuXG4gICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWUsIHR5cGVMZW5ndGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoYnJhbmNoIGluIHRyZWUpIHtcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycgJiYgdHJlZS5oYXNPd25Qcm9wZXJ0eShicmFuY2gpKSB7XG4gICAgICAgICAgICBpZihicmFuY2ggPT09ICcqJyB8fCBicmFuY2ggPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgaWYodHJlZVticmFuY2hdLl9saXN0ZW5lcnMgJiYgIWVuZFJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCB0eXBlTGVuZ3RoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGJyYW5jaCA9PT0gbmV4dFR5cGUpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSsyKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBObyBtYXRjaCBvbiB0aGlzIG9uZSwgc2hpZnQgaW50byB0aGUgdHJlZSBidXQgbm90IGluIHRoZSB0eXBlIGFycmF5LlxuICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2N1cnJlbnRUeXBlXSwgaSsxKSk7XG4gICAgfVxuXG4gICAgeFRyZWUgPSB0cmVlWycqJ107XG4gICAgaWYgKHhUcmVlKSB7XG4gICAgICAvL1xuICAgICAgLy8gSWYgdGhlIGxpc3RlbmVyIHRyZWUgd2lsbCBhbGxvdyBhbnkgbWF0Y2ggZm9yIHRoaXMgcGFydCxcbiAgICAgIC8vIHRoZW4gcmVjdXJzaXZlbHkgZXhwbG9yZSBhbGwgYnJhbmNoZXMgb2YgdGhlIHRyZWVcbiAgICAgIC8vXG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHhUcmVlLCBpKzEpO1xuICAgIH1cblxuICAgIHh4VHJlZSA9IHRyZWVbJyoqJ107XG4gICAgaWYoeHhUcmVlKSB7XG4gICAgICBpZihpIDwgdHlwZUxlbmd0aCkge1xuICAgICAgICBpZih4eFRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBsaXN0ZW5lciBvbiBhICcqKicsIGl0IHdpbGwgY2F0Y2ggYWxsLCBzbyBhZGQgaXRzIGhhbmRsZXIuXG4gICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWUsIHR5cGVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgYXJyYXlzIG9mIG1hdGNoaW5nIG5leHQgYnJhbmNoZXMgYW5kIG90aGVycy5cbiAgICAgICAgZm9yKGJyYW5jaCBpbiB4eFRyZWUpIHtcbiAgICAgICAgICBpZihicmFuY2ggIT09ICdfbGlzdGVuZXJzJyAmJiB4eFRyZWUuaGFzT3duUHJvcGVydHkoYnJhbmNoKSkge1xuICAgICAgICAgICAgaWYoYnJhbmNoID09PSBuZXh0VHlwZSkge1xuICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBuZXh0IGVsZW1lbnQgd2lsbCBtYXRjaCwgc28ganVtcCB0d2ljZS5cbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbYnJhbmNoXSwgaSsyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihicmFuY2ggPT09IGN1cnJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgIC8vIEN1cnJlbnQgbm9kZSBtYXRjaGVzLCBtb3ZlIGludG8gdGhlIHRyZWUuXG4gICAgICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlW2JyYW5jaF0sIGkrMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc29sYXRlZEJyYW5jaCA9IHt9O1xuICAgICAgICAgICAgICBpc29sYXRlZEJyYW5jaFticmFuY2hdID0geHhUcmVlW2JyYW5jaF07XG4gICAgICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeyAnKionOiBpc29sYXRlZEJyYW5jaCB9LCBpKzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKHh4VHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIGFuZCBzdGlsbCBvbiBhICcqKidcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWUsIHR5cGVMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmKHh4VHJlZVsnKiddICYmIHh4VHJlZVsnKiddLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbJyonXSwgdHlwZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RlbmVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdyb3dMaXN0ZW5lclRyZWUodHlwZSwgbGlzdGVuZXIpIHtcblxuICAgIHR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcblxuICAgIC8vXG4gICAgLy8gTG9va3MgZm9yIHR3byBjb25zZWN1dGl2ZSAnKionLCBpZiBzbywgZG9uJ3QgYWRkIHRoZSBldmVudCBhdCBhbGwuXG4gICAgLy9cbiAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSB0eXBlLmxlbmd0aDsgaSsxIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmKHR5cGVbaV0gPT09ICcqKicgJiYgdHlwZVtpKzFdID09PSAnKionKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJlZSA9IHRoaXMubGlzdGVuZXJUcmVlO1xuICAgIHZhciBuYW1lID0gdHlwZS5zaGlmdCgpO1xuXG4gICAgd2hpbGUgKG5hbWUpIHtcblxuICAgICAgaWYgKCF0cmVlW25hbWVdKSB7XG4gICAgICAgIHRyZWVbbmFtZV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgdHJlZSA9IHRyZWVbbmFtZV07XG5cbiAgICAgIGlmICh0eXBlLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgIGlmICghdHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgdHJlZS5fbGlzdGVuZXJzID0gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0eXBlb2YgdHJlZS5fbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdHJlZS5fbGlzdGVuZXJzID0gW3RyZWUuX2xpc3RlbmVycywgbGlzdGVuZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkodHJlZS5fbGlzdGVuZXJzKSkge1xuXG4gICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICAgICAgaWYgKCF0cmVlLl9saXN0ZW5lcnMud2FybmVkKSB7XG5cbiAgICAgICAgICAgIHZhciBtID0gZGVmYXVsdE1heExpc3RlbmVycztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBtID0gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG0gPiAwICYmIHRyZWUuX2xpc3RlbmVycy5sZW5ndGggPiBtKSB7XG5cbiAgICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLndhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy5sZW5ndGgpO1xuICAgICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbmFtZSA9IHR5cGUuc2hpZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4gIC8vIDEwIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaFxuICAvLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbiAgLy9cbiAgLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4gIC8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZGVsaW1pdGVyID0gJy4nO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG4gICAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG4gICAgaWYgKCF0aGlzLl9jb25mKSB0aGlzLl9jb25mID0ge307XG4gICAgdGhpcy5fY29uZi5tYXhMaXN0ZW5lcnMgPSBuO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnQgPSAnJztcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgICB0aGlzLm1hbnkoZXZlbnQsIDEsIGZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm1hbnkgPSBmdW5jdGlvbihldmVudCwgdHRsLCBmbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFueSBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoLS10dGwgPT09IDApIHtcbiAgICAgICAgc2VsZi5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbGlzdGVuZXIuX29yaWdpbiA9IGZuO1xuXG4gICAgdGhpcy5vbihldmVudCwgbGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XG5cbiAgICBpZiAodHlwZSA9PT0gJ25ld0xpc3RlbmVyJyAmJiAhdGhpcy5uZXdMaXN0ZW5lcikge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIHRoZSAqX2FsbCogZnVuY3Rpb25zIGFuZCBpbnZva2UgdGhlbS5cbiAgICBpZiAodGhpcy5fYWxsKSB7XG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGw7IGkrKykgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5fYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgdGhpcy5fYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuXG4gICAgICBpZiAoIXRoaXMuX2FsbCAmJlxuICAgICAgICAhdGhpcy5fZXZlbnRzLmVycm9yICYmXG4gICAgICAgICEodGhpcy53aWxkY2FyZCAmJiB0aGlzLmxpc3RlbmVyVHJlZS5lcnJvcikpIHtcblxuICAgICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBhcmd1bWVudHNbMV07IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcjtcblxuICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIGhhbmRsZXIgPSBbXTtcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlciwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gc2xvd2VyXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbDsgaSsrKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGw7IGkrKykgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHx8ICEhdGhpcy5fYWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX2FsbDtcbiAgICB9XG5cbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbkFueSh0eXBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb24gb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICBncm93TGlzdGVuZXJUcmVlLmNhbGwodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHtcbiAgICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIGVsc2UgaWYodHlwZW9mIHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG5cbiAgICAgICAgdmFyIG0gPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBtID0gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuXG4gICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25BbnkgPSBmdW5jdGlvbihmbikge1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbkFueSBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYoIXRoaXMuX2FsbCkge1xuICAgICAgdGhpcy5fYWxsID0gW107XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmdW5jdGlvbiB0byB0aGUgZXZlbnQgbGlzdGVuZXIgY29sbGVjdGlvbi5cbiAgICB0aGlzLl9hbGwucHVzaChmbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMsbGVhZnM9W107XG5cbiAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcbiAgICAgIGxlYWZzID0gc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgbnVsbCwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcbiAgICAgIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgbGVhZnMucHVzaCh7X2xpc3RlbmVyczpoYW5kbGVyc30pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlMZWFmPTA7IGlMZWFmPGxlYWZzLmxlbmd0aDsgaUxlYWYrKykge1xuICAgICAgdmFyIGxlYWYgPSBsZWFmc1tpTGVhZl07XG4gICAgICBoYW5kbGVycyA9IGxlYWYuX2xpc3RlbmVycztcbiAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYW5kbGVyc1tpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAgIChoYW5kbGVyc1tpXS5saXN0ZW5lciAmJiBoYW5kbGVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHx8XG4gICAgICAgICAgICAoaGFuZGxlcnNbaV0uX29yaWdpbiAmJiBoYW5kbGVyc1tpXS5fb3JpZ2luID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICBsZWFmLl9saXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaGFuZGxlcnMgPT09IGxpc3RlbmVyIHx8XG4gICAgICAgIChoYW5kbGVycy5saXN0ZW5lciAmJiBoYW5kbGVycy5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHx8XG4gICAgICAgIChoYW5kbGVycy5fb3JpZ2luICYmIGhhbmRsZXJzLl9vcmlnaW4gPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgICAgZGVsZXRlIGxlYWYuX2xpc3RlbmVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmZBbnkgPSBmdW5jdGlvbihmbikge1xuICAgIHZhciBpID0gMCwgbCA9IDAsIGZucztcbiAgICBpZiAoZm4gJiYgdGhpcy5fYWxsICYmIHRoaXMuX2FsbC5sZW5ndGggPiAwKSB7XG4gICAgICBmbnMgPSB0aGlzLl9hbGw7XG4gICAgICBmb3IoaSA9IDAsIGwgPSBmbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmKGZuID09PSBmbnNbaV0pIHtcbiAgICAgICAgICBmbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FsbCA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmY7XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICF0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XG4gICAgICB2YXIgbGVhZnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBudWxsLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuXG4gICAgICBmb3IgKHZhciBpTGVhZj0wOyBpTGVhZjxsZWFmcy5sZW5ndGg7IGlMZWFmKyspIHtcbiAgICAgICAgdmFyIGxlYWYgPSBsZWFmc1tpTGVhZl07XG4gICAgICAgIGxlYWYuX2xpc3RlbmVycyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXJzLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuICAgICAgcmV0dXJuIGhhbmRsZXJzO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gICAgaWYgKCFpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzQW55ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZih0aGlzLl9hbGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICB9O1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBleHBvcnRzLkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWwuXG4gICAgd2luZG93LkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7XG4gIH1cbn0oKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIGxvZGFzaCAzLjEwLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLWQgLW8gLi9pbmRleC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzMuMTAuMSc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3Igd3JhcHBlciBtZXRhZGF0YS4gKi9cbiAgdmFyIEJJTkRfRkxBRyA9IDEsXG4gICAgICBCSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIENVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgQ1VSUllfRkxBRyA9IDgsXG4gICAgICBDVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBQQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFBBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBSRUFSR19GTEFHID0gMjU2O1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgd2hlbiBhIGZ1bmN0aW9uIGJlY29tZXMgaG90LiAqL1xuICB2YXIgSE9UX0NPVU5UID0gMTUwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOXwjOTYpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIidgXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXG5cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXG5cXFxcXXxcXFxcLikqPylcXDIpXFxdL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wYXR0ZXJucylcbiAgICogYW5kIHRob3NlIG91dGxpbmVkIGJ5IFtgRXNjYXBlUmVnRXhwUGF0dGVybmBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWVzY2FwZXJlZ2V4cHBhdHRlcm4pLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhcnMgPSAvXls6ISxdfFtcXFxcXiQuKis/KClbXFxde318XFwvXXwoXlswLTlhLWZBLUZucnR1dnhdKXwoW1xcblxcclxcdTIwMjhcXHUyMDI5XSkvZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhcnMgPSBSZWdFeHAocmVSZWdFeHBDaGFycy5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuICovXG4gIHZhciByZUNvbWJvTWFyayA9IC9bXFx1MDMwMC1cXHUwMzZmXFx1ZmUyMC1cXHVmZTIzXS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS4gKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVIYXNIZXhQcmVmaXggPSAvXjBbeFhdLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluMSA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZVxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIHRvIGNyZWF0ZSBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlV29yZHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVwcGVyID0gJ1tBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVdJyxcbiAgICAgICAgbG93ZXIgPSAnW2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZl0rJztcblxuICAgIHJldHVybiBSZWdFeHAodXBwZXIgKyAnKyg/PScgKyB1cHBlciArIGxvd2VyICsgJyl8JyArIHVwcGVyICsgJz8nICsgbG93ZXIgKyAnfCcgKyB1cHBlciArICcrfFswLTldKycsICdnJyk7XG4gIH0oKSk7XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdBcnJheUJ1ZmZlcicsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hdGgnLCAnTnVtYmVyJyxcbiAgICAnT2JqZWN0JywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJyxcbiAgICAncGFyc2VGbG9hdCcsICdwYXJzZUludCcsICdzZXRUaW1lb3V0JywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW21hcFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNDJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZUMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICdgJzogJyYjOTY7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIixcbiAgICAnJiM5NjsnOiAnYCdcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YC4gKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHJlZ2V4ZXMuICovXG4gIHZhciByZWdleHBFc2NhcGVzID0ge1xuICAgICcwJzogJ3gzMCcsICcxJzogJ3gzMScsICcyJzogJ3gzMicsICczJzogJ3gzMycsICc0JzogJ3gzNCcsXG4gICAgJzUnOiAneDM1JywgJzYnOiAneDM2JywgJzcnOiAneDM3JywgJzgnOiAneDM4JywgJzknOiAneDM5JyxcbiAgICAnQSc6ICd4NDEnLCAnQic6ICd4NDInLCAnQyc6ICd4NDMnLCAnRCc6ICd4NDQnLCAnRSc6ICd4NDUnLCAnRic6ICd4NDYnLFxuICAgICdhJzogJ3g2MScsICdiJzogJ3g2MicsICdjJzogJ3g2MycsICdkJzogJ3g2NCcsICdlJzogJ3g2NScsICdmJzogJ3g2NicsXG4gICAgJ24nOiAneDZlJywgJ3InOiAneDcyJywgJ3QnOiAneDc0JywgJ3UnOiAneDc1JywgJ3YnOiAneDc2JywgJ3gnOiAneDc4J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGB3aW5kb3dgLiAqL1xuICB2YXIgZnJlZVdpbmRvdyA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyAmJiB3aW5kb3cuT2JqZWN0ICYmIHdpbmRvdztcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKipcbiAgICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGB0aGlzYCB2YWx1ZSBpcyB1c2VkIGlmIGl0J3MgdGhlIGdsb2JhbCBvYmplY3QgdG8gYXZvaWQgR3JlYXNlbW9ua2V5J3NcbiAgICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gICAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpcyAmJiB0aGlzLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXM7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBjb21wYXJlQXNjZW5kaW5nYCB3aGljaCBjb21wYXJlcyB2YWx1ZXMgYW5kXG4gICAqIHNvcnRzIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyIHdpdGhvdXQgZ3VhcmFudGVlaW5nIGEgc3RhYmxlIHNvcnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgdmFyIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzVW5kZWYgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlO1xuXG4gICAgICB2YXIgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgb3RoSXNVbmRlZiA9IG90aGVyID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXI7XG5cbiAgICAgIGlmICgodmFsdWUgPiBvdGhlciAmJiAhb3RoSXNOdWxsKSB8fCAhdmFsSXNSZWZsZXhpdmUgfHxcbiAgICAgICAgICAodmFsSXNOdWxsICYmICFvdGhJc1VuZGVmICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICh2YWxJc1VuZGVmICYmIG90aElzUmVmbGV4aXZlKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmICgodmFsdWUgPCBvdGhlciAmJiAhdmFsSXNOdWxsKSB8fCAhb3RoSXNSZWZsZXhpdmUgfHxcbiAgICAgICAgICAob3RoSXNOdWxsICYmICF2YWxJc1VuZGVmICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgIChvdGhJc1VuZGVmICYmIHZhbElzUmVmbGV4aXZlKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGJpbmFyeSBzZWFyY2hlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNGdW5jdGlvbmAgd2l0aG91dCBzdXBwb3J0IGZvciBlbnZpcm9ubWVudHNcbiAgICogd2l0aCBpbmNvcnJlY3QgYHR5cGVvZmAgcmVzdWx0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIEF2b2lkIGEgQ2hha3JhIEpJVCBidWcgaW4gY29tcGF0aWJpbGl0eSBtb2RlcyBvZiBJRSAxMS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2lzc3Vlcy8xNjIxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgaWYgaXQncyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgICogZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiAodmFsdWUgKyAnJyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUxlZnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzIFRoZSBjaGFyYWN0ZXJzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0xlZnRJbmRleChzdHJpbmcsIGNoYXJzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjaGFycy5pbmRleE9mKHN0cmluZy5jaGFyQXQoaW5kZXgpKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltUmlnaHRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyXG4gICAqIG9mIGBzdHJpbmdgIHRoYXQgaXMgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnMgVGhlIGNoYXJhY3RlcnMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNSaWdodEluZGV4KHN0cmluZywgY2hhcnMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5zb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uIGFuZCBzdGFibGVcbiAgICogc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBiYXNlQ29tcGFyZUFzY2VuZGluZyhvYmplY3QuY3JpdGVyaWEsIG90aGVyLmNyaXRlcmlhKSB8fCAob2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5T3JkZXJgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAqXG4gICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgKiBhIHZhbHVlIGlzIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgaWYgaXRzIGNvcnJlc3BvbmRpbmcgb3JkZXIgaXMgXCJhc2NcIiwgYW5kXG4gICAqIGRlc2NlbmRpbmcgaWYgXCJkZXNjXCIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAqICgob3JkZXIgPT09ICdhc2MnIHx8IG9yZGVyID09PSB0cnVlKSA/IDEgOiAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBkZWJ1cnJMZXR0ZXIobGV0dGVyKSB7XG4gICAgcmV0dXJuIGRlYnVycmVkTGV0dGVyc1tsZXR0ZXJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKGNocikge1xuICAgIHJldHVybiBodG1sRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlUmVnRXhwYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHJlZ2V4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYWRpbmdDaGFyIFRoZSBjYXB0dXJlIGdyb3VwIGZvciBhIGxlYWRpbmcgY2hhcmFjdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2hpdGVzcGFjZUNoYXIgVGhlIGNhcHR1cmUgZ3JvdXAgZm9yIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcihjaHIsIGxlYWRpbmdDaGFyLCB3aGl0ZXNwYWNlQ2hhcikge1xuICAgIGlmIChsZWFkaW5nQ2hhcikge1xuICAgICAgY2hyID0gcmVnZXhwRXNjYXBlc1tjaHJdO1xuICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZUNoYXIpIHtcbiAgICAgIGNociA9IHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgICB9XG4gICAgcmV0dXJuICdcXFxcJyArIGNocjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgTmFOYCBpcyBmb3VuZCBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIGBOYU5gLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDAgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgdmFyIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKG90aGVyICE9PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdHJpbW1lZExlZnRJbmRleGAgYW5kIGB0cmltbWVkUmlnaHRJbmRleGAgdG8gZGV0ZXJtaW5lIGlmIGFcbiAgICogY2hhcmFjdGVyIGNvZGUgaXMgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJDb2RlIFRoZSBjaGFyYWN0ZXIgY29kZSB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGNoYXJDb2RlYCBpcyB3aGl0ZXNwYWNlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc1NwYWNlKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuICgoY2hhckNvZGUgPD0gMTYwICYmIChjaGFyQ29kZSA+PSA5ICYmIGNoYXJDb2RlIDw9IDEzKSB8fCBjaGFyQ29kZSA9PSAzMiB8fCBjaGFyQ29kZSA9PSAxNjApIHx8IGNoYXJDb2RlID09IDU3NjAgfHwgY2hhckNvZGUgPT0gNjE1OCB8fFxuICAgICAgKGNoYXJDb2RlID49IDgxOTIgJiYgKGNoYXJDb2RlIDw9IDgyMDIgfHwgY2hhckNvZGUgPT0gODIzMiB8fCBjaGFyQ29kZSA9PSA4MjMzIHx8IGNoYXJDb2RlID09IDgyMzkgfHwgY2hhckNvZGUgPT0gODI4NyB8fCBjaGFyQ29kZSA9PSAxMjI4OCB8fCBjaGFyQ29kZSA9PSA2NTI3OSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCBvcHRpbWl6ZWQgZm9yIHNvcnRlZCBhcnJheXMgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBzZWVuLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgaWYgKCFpbmRleCB8fCBzZWVuICE9PSBjb21wdXRlZCkge1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1MZWZ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZVxuICAgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZExlZnRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGlzU3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVJpZ2h0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBpc1NwYWNlKHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIoY2hyKSB7XG4gICAgcmV0dXJuIGh0bWxVbmVzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIHVzaW5nIGBjb250ZXh0YCB0byBtb2NrIGBEYXRlI2dldFRpbWVgIHVzZSBpbiBgXy5ub3dgXG4gICAqIHZhciBtb2NrID0gXy5ydW5JbkNvbnRleHQoe1xuICAgKiAgICdEYXRlJzogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4geyAnZ2V0VGltZSc6IGdldFRpbWVNb2NrIH07XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gb3IgY3JlYXRpbmcgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanNcbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgLy8gQXZvaWQgaXNzdWVzIHdpdGggc29tZSBFUzMgZW52aXJvbm1lbnRzIHRoYXQgYXR0ZW1wdCB0byB1c2UgdmFsdWVzLCBuYW1lZFxuICAgIC8vIGFmdGVyIGJ1aWx0LWluIGNvbnN0cnVjdG9ycyBsaWtlIGBPYmplY3RgLCBmb3IgdGhlIGNyZWF0aW9uIG9mIGxpdGVyYWxzLlxuICAgIC8vIEVTNSBjbGVhcnMgdGhpcyB1cCBieSBzdGF0aW5nIHRoYXQgbGl0ZXJhbHMgbXVzdCB1c2UgYnVpbHQtaW4gY29uc3RydWN0b3JzLlxuICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBjb250ZXh0ID0gY29udGV4dCA/IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpIDogcm9vdDtcblxuICAgIC8qKiBOYXRpdmUgY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgTnVtYmVyID0gY29udGV4dC5OdW1iZXIsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBzdHJpbmdQcm90byA9IFN0cmluZy5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheUJ1ZmZlciA9IGNvbnRleHQuQXJyYXlCdWZmZXIsXG4gICAgICAgIGNsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBwYXJzZUZsb2F0ID0gY29udGV4dC5wYXJzZUZsb2F0LFxuICAgICAgICBwb3cgPSBNYXRoLnBvdyxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgc2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKTtcblxuICAgIC8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKSxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVJc0FycmF5ID0gZ2V0TmF0aXZlKEFycmF5LCAnaXNBcnJheScpLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUtleXMgPSBnZXROYXRpdmUoT2JqZWN0LCAna2V5cycpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IGdldE5hdGl2ZShEYXRlLCAnbm93JyksXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciBgLUluZmluaXR5YCBhbmQgYEluZmluaXR5YC4gKi9cbiAgICB2YXIgTkVHQVRJVkVfSU5GSU5JVFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgIFBPU0lUSVZFX0lORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAgICAgKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgY2hhaW5pbmcuXG4gICAgICogTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLCBhbmQgZnVuY3Rpb25zIGNhblxuICAgICAqIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZSBvciBtYXkgcmV0dXJuIGFcbiAgICAgKiBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gcmV0dXJuaW5nIHRoZSB1bndyYXBwZWRcbiAgICAgKiB2YWx1ZS4gRXhwbGljaXQgY2hhaW5pbmcgbWF5IGJlIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLiBUaGUgZXhlY3V0aW9uIG9mXG4gICAgICogY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGV4ZWN1dGlvbiBpcyBkZWZlcnJlZCB1bnRpbCBgXyN2YWx1ZWBcbiAgICAgKiBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uIFNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiBzdHJhdGVneSB3aGljaCBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBjYW4gaGVscFxuICAgICAqIHRvIGF2b2lkIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCBncmVhdGx5IHJlZHVjZSB0aGVcbiAgICAgKiBudW1iZXIgb2YgaXRlcmF0ZWUgZXhlY3V0aW9ucy5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsXG4gICAgICogYGZpcnN0YCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcGx1Y2tgLCBgcmVqZWN0YCwgYHJlc3RgLCBgcmV2ZXJzZWAsXG4gICAgICogYHNsaWNlYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0b0FycmF5YCxcbiAgICAgKiBhbmQgYHdoZXJlYFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGF0YCwgYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsXG4gICAgICogYGNhbGxiYWNrYCwgYGNoYWluYCwgYGNodW5rYCwgYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25zdGFudGAsXG4gICAgICogYGNvdW50QnlgLCBgY3JlYXRlYCwgYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsXG4gICAgICogYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFJpZ2h0V2hpbGVgLFxuICAgICAqIGBkcm9wV2hpbGVgLCBgZmlsbGAsIGBmaWx0ZXJgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsXG4gICAgICogYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCwgYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCxcbiAgICAgKiBgZnVuY3Rpb25zYCwgYGdyb3VwQnlgLCBgaW5kZXhCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnZlcnRgLFxuICAgICAqIGBpbnZva2VgLCBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLFxuICAgICAqIGBtYXRjaGVzUHJvcGVydHlgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLFxuICAgICAqIGBtb2RBcmdzYCwgYG5lZ2F0ZWAsIGBvbWl0YCwgYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLFxuICAgICAqIGBwYXJ0aXRpb25gLCBgcGlja2AsIGBwbGFudGAsIGBwbHVja2AsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLFxuICAgICAqIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByZWFyZ2AsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmVzdFBhcmFtYCxcbiAgICAgKiBgcmV2ZXJzZWAsIGBzZXRgLCBgc2h1ZmZsZWAsIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzb3J0QnlBbGxgLFxuICAgICAqIGBzb3J0QnlPcmRlcmAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCxcbiAgICAgKiBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRpbWVzYCwgYHRvQXJyYXlgLCBgdG9QbGFpbk9iamVjdGAsXG4gICAgICogYHRyYW5zZm9ybWAsIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgemlwYCwgYHppcE9iamVjdGAsIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbG9uZWAsIGBjbG9uZURlZXBgLFxuICAgICAqIGBkZWJ1cnJgLCBgZW5kc1dpdGhgLCBgZXNjYXBlYCwgYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaW5kV2hlcmVgLCBgZmlyc3RgLFxuICAgICAqIGBmbG9vcmAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCxcbiAgICAgKiBgaW5SYW5nZWAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICAgKiBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgIGBpc0Z1bmN0aW9uYCwgYGlzTWF0Y2hgLFxuICAgICAqIGBpc05hdGl2ZWAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsXG4gICAgICogYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsXG4gICAgICogYGxhc3RgLCBgbGFzdEluZGV4T2ZgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtaW5gLCBgbm9Db25mbGljdGAsIGBub29wYCxcbiAgICAgKiBgbm93YCwgYHBhZGAsIGBwYWRMZWZ0YCwgYHBhZFJpZ2h0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZExhc3RJbmRleGAsIGBzdGFydENhc2VgLFxuICAgICAqIGBzdGFydHNXaXRoYCwgYHN1bWAsIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1MZWZ0YCwgYHRyaW1SaWdodGAsIGB0cnVuY2AsXG4gICAgICogYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZCBgc2FtcGxlYCB3aWxsIHJldHVybiBhIHdyYXBwZWQgdmFsdWUgd2hlbiBgbmAgaXMgcHJvdmlkZWQsXG4gICAgICogb3RoZXJ3aXNlIGFuIHVud3JhcHBlZCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgbikge1xuICAgICAqICAgcmV0dXJuIHRvdGFsICsgbjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX19jaGFpbl9fJykgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGFsbCBjaGFpbmluZyB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBjaGFpbmluZyBmb3IgYWxsIHdyYXBwZXIgbWV0aG9kcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYWN0aW9ucz1bXV0gQWN0aW9ucyB0byBwZWZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsLCBhY3Rpb25zKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gYWN0aW9ucyB8fCBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgZW52aXJvbm1lbnQgZmVhdHVyZSBmbGFncy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHZhciBzdXBwb3J0ID0gbG9kYXNoLnN1cHBvcnQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlXG4gICAgICogYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGFycmF5Q29weSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBhcnJheUNvcHkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGFycmF5Q29weSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCBhcnJMZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIHx8IChhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKChpc1JpZ2h0ICYmIGlzQXJyKSA/IGFycmF5LnJldmVyc2UoKSA6IGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbmFtZSBDYWNoZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZSgpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcERlbGV0ZShrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2FjaGVkIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGtleSA9PSAnX19wcm90b19fJyA/IHVuZGVmaW5lZCA6IHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBIYXMoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICE9ICdfX3Byb3RvX18nICYmIGhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX2RhdGFfXywga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB2YWx1ZWAgdG8gYGtleWAgb2YgdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgIT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFfX1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICAgICAgdGhpcy5kYXRhID0geyAnaGFzaCc6IG5hdGl2ZUNyZWF0ZShudWxsKSwgJ3NldCc6IG5ldyBTZXQgfTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0aGlzLnB1c2godmFsdWVzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjYWNoZWAgbWltaWNraW5nIHRoZSByZXR1cm4gc2lnbmF0dXJlIG9mXG4gICAgICogYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBjYWNoZS5kYXRhLFxuICAgICAgICAgIHJlc3VsdCA9ICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNPYmplY3QodmFsdWUpKSA/IGRhdGEuc2V0Lmhhcyh2YWx1ZSkgOiBkYXRhLmhhc2hbdmFsdWVdO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID8gMCA6IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHB1c2hcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YS5zZXQuYWRkKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuaGFzaFt2YWx1ZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgam9pbmluZyBgYXJyYXlgIHdpdGggYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGpvaW4uXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGpvaW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5Q29uY2F0KGFycmF5LCBvdGhlcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gLTEsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCArIG90aExlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytvdGhJbmRleCA8IG90aExlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXgrK10gPSBvdGhlcltvdGhJbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUNvcHkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUV4dHJlbXVtYCBmb3IgYXJyYXlzIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IGV4VmFsdWUgVGhlIGluaXRpYWwgZXh0cmVtdW0gdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yLCBleFZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgY29tcHV0ZWQgPSBleFZhbHVlLFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gK2l0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWBcbiAgICAgKiAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKGluaXRGcm9tQXJyYXkgJiYgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YFxuICAgICAqICBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGluaXRGcm9tQXJyYXkgJiYgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnN1bWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0ICs9ICtpdGVyYXRlZShhcnJheVtsZW5ndGhdKSB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdFZhbHVlIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VWYWx1ZSBUaGUgc291cmNlIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVZhbHVlIDogb2JqZWN0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25gIHVzZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnbkRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCBpZ25vcmVzXG4gICAgICogaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlcyB3aGVuIGNoZWNraW5nIGlmIGEgcHJvcGVydHkgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIG9iamVjdCBhbmQgc291cmNlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk93bkRlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIHJldHVybiAob2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpXG4gICAgICAgID8gc291cmNlVmFsdWVcbiAgICAgICAgOiBvYmplY3RWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uYXNzaWduYCBmb3IgY3VzdG9taXppbmcgYXNzaWduZWQgdmFsdWVzIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZywgbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYFxuICAgICAqIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyKHZhbHVlLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSB8fFxuICAgICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUNvcHkoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RyaW5nIGNvbGxlY3Rpb25zXG4gICAgICogYW5kIGluZGl2aWR1YWwga2V5IGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyBvciBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChjb2xsZWN0aW9uLCBwcm9wcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNOaWwgPSBjb2xsZWN0aW9uID09IG51bGwsXG4gICAgICAgICAgaXNBcnIgPSAhaXNOaWwgJiYgaXNBcnJheUxpa2UoY29sbGVjdGlvbiksXG4gICAgICAgICAgbGVuZ3RoID0gaXNBcnIgPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocHJvcHNMZW5ndGgpO1xuXG4gICAgICB3aGlsZSgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGlzSW5kZXgoa2V5LCBsZW5ndGgpID8gY29sbGVjdGlvbltrZXldIDogdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpc05pbCA/IHVuZGVmaW5lZCA6IGNvbGxlY3Rpb25ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb3B5KHNvdXJjZSwgcHJvcHMsIG9iamVjdCkge1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2FsbGJhY2tgIHdoaWNoIHN1cHBvcnRzIHNwZWNpZnlpbmcgdGhlXG4gICAgICogbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzQXJnID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IGZ1bmNcbiAgICAgICAgICA6IGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhmdW5jKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzQXJnID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBwcm9wZXJ0eShmdW5jKVxuICAgICAgICA6IGJhc2VNYXRjaGVzUHJvcGVydHkoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IGB2YWx1ZWAgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCkgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBhcnJheUNvcHkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnO1xuXG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVhYmxlVGFnc1t0YWddXG4gICAgICAgICAgICA/IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcClcbiAgICAgICAgICAgIDogKG9iamVjdCA/IHZhbHVlIDoge30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyBjbG9uZS5cbiAgICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHt9O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBhbiBpbmRleFxuICAgICAqIG9mIHdoZXJlIHRvIHNsaWNlIHRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgVGhlIGFyZ3VtZW50cyBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGlmZmVyZW5jZWAgd2hpY2ggYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgY2FjaGUgPSAoaXNDb21tb24gJiYgdmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSA/IGNyZWF0ZUNhY2hlKHZhbHVlcykgOiBudWxsLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSwgMCkgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZXh0cmVtdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2ggdmFsdWVcbiAgICAgKiBpbiBgY29sbGVjdGlvbmAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWUgaXMgcmFua2VkLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBleFZhbHVlIFRoZSBpbml0aWFsIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IsIGV4VmFsdWUpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGV4VmFsdWUsXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3VycmVudCA9ICtpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZCkgfHwgKGN1cnJlbnQgPT09IGV4VmFsdWUgJiYgY3VycmVudCA9PT0gcmVzdWx0KSkge1xuICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6ICgrZW5kIHx8IDApO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6IChlbmQgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB3aGlsZSAoc3RhcnQgPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRgLCBgXy5maW5kTGFzdGAsIGBfLmZpbmRLZXlgLCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcsIHdoaWNoIGl0ZXJhdGVzXG4gICAgICogb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0S2V5XSBTcGVjaWZ5IHJldHVybmluZyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50XG4gICAgICogIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYywgcmV0S2V5KSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmV0S2V5ID8ga2V5IDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBhZGRlZCBzdXBwb3J0IGZvciByZXN0cmljdGluZ1xuICAgICAqIGZsYXR0ZW5pbmcgYW5kIHNwZWNpZnlpbmcgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYXJyYXlzLWxpa2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc0RlZXAsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICAoaXNTdHJpY3QgfHwgaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgaXNEZWVwLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvckluYCBhbmQgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzXG4gICAgICogb3ZlciBgb2JqZWN0YCBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3JcbiAgICAgKiBlYWNoIHByb3BlcnR5LiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHlcbiAgICAgKiByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9ySW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSB0aG9zZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmplY3Rba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBzdHJpbmcgcGF0aHNcbiAgICAgKiBhbmQgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoS2V5XSBUaGUga2V5IHJlcHJlc2VudGF0aW9uIG9mIHBhdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoLCBwYXRoS2V5KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGhLZXkgIT09IHVuZGVmaW5lZCAmJiBwYXRoS2V5IGluIHRvT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcGF0aCA9IFtwYXRoS2V5XTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RbcGF0aFtpbmRleCsrXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2l0aG91dCBzdXBwb3J0IGZvciBgdGhpc2AgYmluZGluZ1xuICAgICAqIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgICAgIGlmICghb2JqSXNBcnIpIHtcbiAgICAgICAgb2JqVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgICAgICBpZiAob2JqVGFnID09IGFyZ3NUYWcpIHtcbiAgICAgICAgICBvYmpUYWcgPSBvYmplY3RUYWc7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgICAgIG9iaklzQXJyID0gaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb3RoSXNBcnIpIHtcbiAgICAgICAgb3RoVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvdGhlcik7XG4gICAgICAgIGlmIChvdGhUYWcgPT0gYXJnc1RhZykge1xuICAgICAgICAgIG90aFRhZyA9IG9iamVjdFRhZztcbiAgICAgICAgfSBlbHNlIGlmIChvdGhUYWcgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgb3RoSXNBcnIgPSBpc1R5cGVkQXJyYXkob3RoZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmICEob2JqSXNBcnIgfHwgb2JqSXNPYmopKSB7XG4gICAgICAgIHJldHVybiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTG9vc2UpIHtcbiAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCwgb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRldGVjdGluZyBjaXJjdWxhciByZWZlcmVuY2VzIHNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI0pPLlxuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIGBvYmplY3RgIGFuZCBgb3RoZXJgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgIHN0YWNrQS5wdXNoKG9iamVjdCk7XG4gICAgICBzdGFja0IucHVzaChvdGhlcik7XG5cbiAgICAgIHZhciByZXN1bHQgPSAob2JqSXNBcnIgPyBlcXVhbEFycmF5cyA6IGVxdWFsT2JqZWN0cykob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG5cbiAgICAgIHN0YWNrQS5wb3AoKTtcbiAgICAgIHN0YWNrQi5wb3AoKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVyeSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCB0cnVlKSA6IHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICB2YXIga2V5ID0gbWF0Y2hEYXRhWzBdWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaERhdGFbMF1bMV07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHZhbHVlICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gdG9PYmplY3Qob2JqZWN0KSkpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBtYXRjaERhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXMgbm90IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHBhdGgpLFxuICAgICAgICAgIGlzQ29tbW9uID0gaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSxcbiAgICAgICAgICBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG5cbiAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gcGF0aEtleTtcbiAgICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICAgICAgaWYgKChpc0FyciB8fCAhaXNDb21tb24pICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXkgPSBsYXN0KHBhdGgpO1xuICAgICAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZVxuICAgICAgICAgID8gKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBvYmplY3QpKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9iamVjdFtrZXldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcbiAgICAgKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIGlzU3JjQXJyID0gaXNBcnJheUxpa2Uoc291cmNlKSAmJiAoaXNBcnJheShzb3VyY2UpIHx8IGlzVHlwZWRBcnJheShzb3VyY2UpKSxcbiAgICAgICAgICBwcm9wcyA9IGlzU3JjQXJyID8gdW5kZWZpbmVkIDoga2V5cyhzb3VyY2UpO1xuXG4gICAgICBhcnJheUVhY2gocHJvcHMgfHwgc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0TGlrZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpc0NvbW1vbiA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChyZXN1bHQgIT09IHVuZGVmaW5lZCB8fCAoaXNTcmNBcnIgJiYgIShrZXkgaW4gb2JqZWN0KSkpICYmXG4gICAgICAgICAgICAgIChpc0NvbW1vbiB8fCAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gc3JjVmFsdWUpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHN0YWNrQltsZW5ndGhdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgcmVzdWx0ID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZShzcmNWYWx1ZSkgJiYgKGlzQXJyYXkoc3JjVmFsdWUpIHx8IGlzVHlwZWRBcnJheShzcmNWYWx1ZSkpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogKGlzQXJyYXlMaWtlKHZhbHVlKSA/IGFycmF5Q29weSh2YWx1ZSkgOiBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXNBcmd1bWVudHModmFsdWUpXG4gICAgICAgICAgICA/IHRvUGxhaW5PYmplY3QodmFsdWUpXG4gICAgICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlXG4gICAgICAvLyBpdCB3aXRoIGl0cyBtZXJnZWQgdmFsdWUuXG4gICAgICBzdGFja0EucHVzaChzcmNWYWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIG9iamVjdFtrZXldID0gbWVyZ2VGdW5jKHJlc3VsdCwgc3JjVmFsdWUsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHZhciBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG4gICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgsIHBhdGhLZXkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4IGFyZ3VtZW50cyBhbmQgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChpbmRleCAhPSBwcmV2aW91cyAmJiBpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAgICAgKiBhbmQgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBtaW4gKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICAgKiB1c2luZyB0aGUgcHJvdmlkZWQgYGVhY2hGdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbml0RnJvbUNvbGxlY3Rpb24gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50XG4gICAgICogIG9mIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQ29sbGVjdGlvbiwgZWFjaEZ1bmMpIHtcbiAgICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRGcm9tQ29sbGVjdGlvblxuICAgICAgICAgID8gKGluaXRGcm9tQ29sbGVjdGlvbiA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3AgZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogKCtlbmQgfHwgMCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZVxuICAgICAqIHRoZSBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeU9yZGVyYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFuW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0QnlPcmRlcihjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgdmFyIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2soKSxcbiAgICAgICAgICBpbmRleCA9IC0xO1xuXG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7IHJldHVybiBjYWxsYmFjayhpdGVyYXRlZSk7IH0pO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7IHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7IH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVN1bShjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ICs9ICtpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHx8IDA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgaXNMYXJnZSA9IGlzQ29tbW9uICYmIGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFLFxuICAgICAgICAgIHNlZW4gPSBpc0xhcmdlID8gY3JlYXRlQ2FjaGUoKSA6IG51bGwsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNDb21tb24gJiYgdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIDApIDwgMCkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZSB8fCBpc0xhcmdlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICAgKiBvZiBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRyb3BSaWdodFdoaWxlYCwgYF8uZHJvcFdoaWxlYCwgYF8udGFrZVJpZ2h0V2hpbGVgLFxuICAgICAqIGFuZCBgXy50YWtlV2hpbGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFjdGlvbnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1tpbmRleF07XG4gICAgICAgIHJlc3VsdCA9IGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmICgocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpICYmIGNvbXB1dGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmluYXJ5SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGludm9rZXMgYGl0ZXJhdGVlYCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzVW5kZWYgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgaXNEZWYgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQ7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IGlzUmVmbGV4aXZlIHx8IHJldEhpZ2hlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gaXNSZWZsZXhpdmUgJiYgaXNEZWYgJiYgKHJldEhpZ2hlc3QgfHwgY29tcHV0ZWQgIT0gbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZikge1xuICAgICAgICAgIHNldExvdyA9IGlzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IGlzRGVmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wdXRlZCA9PSBudWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUNhbGxiYWNrYCB3aGljaCBvbmx5IHN1cHBvcnRzIGB0aGlzYCBiaW5kaW5nXG4gICAgICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBnaXZlbiBhcnJheSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpLFxuICAgICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShyZXN1bHQpO1xuXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKSB7XG4gICAgICB2YXIgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpIHtcbiAgICAgIHZhciBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShhcmdzTGVuZ3RoICsgcmlnaHRMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmNvdW50QnlgLCBgXy5ncm91cEJ5YCwgYF8uaW5kZXhCeWAsIG9yIGBfLnBhcnRpdGlvbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgYWNjdW11bGF0b3Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdGhlIGFjY3VtdWxhdG9yIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcbiAgICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmFzc2lnbmAsIGBfLmRlZmF1bHRzYCwgb3IgYF8ubWVyZ2VgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAyID8gc291cmNlc1tsZW5ndGggLSAyXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDUpO1xuICAgICAgICAgIGxlbmd0aCAtPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nID8gdGhpc0FyZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZW5ndGggLT0gKGN1c3RvbWl6ZXIgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuICAgICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSB0b09iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSB0b09iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmRXcmFwcGVyKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBTZXRgIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgbmV3IGNhY2hlIG9iamVjdCBpZiBgU2V0YCBpcyBzdXBwb3J0ZWQsIGVsc2UgYG51bGxgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKHZhbHVlcykge1xuICAgICAgcmV0dXJuIChuYXRpdmVDcmVhdGUgJiYgU2V0KSA/IG5ldyBTZXRDYWNoZSh2YWx1ZXMpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBjb21wb3VuZCB3b3JkcyBvdXQgb2YgdGhlIHdvcmRzIGluIGFcbiAgICAgKiBnaXZlbiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBhcnJheSA9IHdvcmRzKGRlYnVycihzdHJpbmcpKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2socmVzdWx0LCBhcnJheVtpbmRleF0sIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yV3JhcHBlcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLlxuICAgICAgICAvLyBTZWUgaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyBUaGUgY3VycnkgYml0IGZsYWcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZmxhZykge1xuICAgICAgZnVuY3Rpb24gY3VycnlGdW5jKGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgYXJpdHksIGd1YXJkKSkge1xuICAgICAgICAgIGFyaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwcGVyKGZ1bmMsIGZsYWcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5RnVuYy5wbGFjZWhvbGRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyeUZ1bmM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmRlZmF1bHRzYCBvciBgXy5kZWZhdWx0c0RlZXBgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlZmF1bHRzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRzKGFzc2lnbmVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gcmVzdFBhcmFtKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKGN1c3RvbWl6ZXIpO1xuICAgICAgICByZXR1cm4gYXNzaWduZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5tYXhgIG9yIGBfLm1pbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBleFZhbHVlIFRoZSBpbml0aWFsIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGV4dHJlbXVtIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4dHJlbXVtKGNvbXBhcmF0b3IsIGV4VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgaWYgKGl0ZXJhdGVlLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYXJyYXlFeHRyZW11bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgY29tcGFyYXRvciwgZXhWYWx1ZSk7XG4gICAgICAgICAgaWYgKCEoY29sbGVjdGlvbi5sZW5ndGggJiYgcmVzdWx0ID09PSBleFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VFeHRyZW11bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgY29tcGFyYXRvciwgZXhWYWx1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gYmFzZUZpbmRJbmRleChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBjb2xsZWN0aW9uW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kSW5kZXhgIG9yIGBfLmZpbmRMYXN0SW5kZXhgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmRJbmRleChmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRLZXlgIG9yIGBfLmZpbmRMYXN0S2V5YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmRLZXkob2JqZWN0RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIHJldHVybiBiYXNlRmluZChvYmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0RnVuYywgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3cmFwcGVyLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAwLFxuICAgICAgICAgICAgZnVuY3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd3JhcHBlciAmJiBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1ICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgd3JhcHBlciA9IG5ldyBMb2Rhc2hXcmFwcGVyKFtdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gLTEgOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiYgZGF0YVsxXSA9PSAoQVJZX0ZMQUcgfCBDVVJSWV9GTEFHIHwgUEFSVElBTF9GTEFHIHwgUkVBUkdfRkxBRykgJiYgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMSkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSkgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckVhY2hgIG9yIGBfLmZvckVhY2hSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnID09PSB1bmRlZmluZWQgJiYgaXNBcnJheShjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGFycmF5RnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSlcbiAgICAgICAgICA6IGVhY2hGdW5jKGNvbGxlY3Rpb24sIGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckluYCBvciBgXy5mb3JJblJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvckluKG9iamVjdEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0ZWUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdEZ1bmMob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JPd25gIG9yIGBfLmZvck93blJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvck93bihvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdGVlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RGdW5jKG9iamVjdCwgaXRlcmF0ZWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLm1hcEtleXNgIG9yIGBfLm1hcFZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTWFwS2V5c10gU3BlY2lmeSBtYXBwaW5nIGtleXMgaW5zdGVhZCBvZiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWFwIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE1hcHBlcihpc01hcEtleXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIHZhciBtYXBwZWQgPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgICAgIGtleSA9IGlzTWFwS2V5cyA/IG1hcHBlZCA6IGtleTtcbiAgICAgICAgICB2YWx1ZSA9IGlzTWFwS2V5cyA/IHZhbHVlIDogbWFwcGVkO1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnBhZExlZnRgIG9yIGBfLnBhZFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IHBhZGRpbmcgZnJvbSB0aGUgcmlnaHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZERpcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIHJldHVybiAoZnJvbVJpZ2h0ID8gc3RyaW5nIDogJycpICsgY3JlYXRlUGFkZGluZyhzdHJpbmcsIGxlbmd0aCwgY2hhcnMpICsgKGZyb21SaWdodCA/ICcnIDogc3RyaW5nKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnBhcnRpYWxgIG9yIGBfLnBhcnRpYWxSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyBUaGUgcGFydGlhbCBiaXQgZmxhZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZmxhZykge1xuICAgICAgdmFyIHBhcnRpYWxGdW5jID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIHBhcnRpYWxGdW5jLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgZmxhZywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJ0aWFsRnVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnJlZHVjZWAgb3IgYF8ucmVkdWNlUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBpbml0RnJvbUFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgIHJldHVybiAodHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgdGhpc0FyZyA9PT0gdW5kZWZpbmVkICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBhcnJheUZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KVxuICAgICAgICAgIDogYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgNCksIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5LCBlYWNoRnVuYyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy4gU2VlIGBjcmVhdGVXcmFwcGVyYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBBUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBCSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgQ1VSUllfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgQ1VSUllfQk9VTkRfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5UmlnaHQgPSBiaXRtYXNrICYgQ1VSUllfUklHSFRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIC8vIEF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCB1c2UgZGlzcXVhbGlmeWluZyBvcHRpbWl6YXRpb25zIGJ5XG4gICAgICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCB0byBvdGhlciBmdW5jdGlvbnMuXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyeSB8fCBpc0N1cnJ5UmlnaHQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSB3cmFwcGVyLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICBhcmdzSG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgIGxlbmd0aCAtPSBhcmdzSG9sZGVycy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJnUG9zID0gYXJnUG9zID8gYXJyYXlDb3B5KGFyZ1BvcykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmV3QXJpdHkgPSBuYXRpdmVNYXgoYXJpdHkgLSBsZW5ndGgsIDApLFxuICAgICAgICAgICAgICAgIG5ld3NIb2xkZXJzID0gaXNDdXJyeSA/IGFyZ3NIb2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBhcmdzSG9sZGVycyxcbiAgICAgICAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBhcmdzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogYXJncztcblxuICAgICAgICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFBBUlRJQUxfRkxBRyA6IFBBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFBBUlRJQUxfUklHSFRfRkxBRyA6IFBBUlRJQUxfRkxBRyk7XG5cbiAgICAgICAgICAgIGlmICghaXNDdXJyeUJvdW5kKSB7XG4gICAgICAgICAgICAgIGJpdG1hc2sgJj0gfihCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdzSG9sZGVycywgbmV3UGFydGlhbHNSaWdodCwgbmV3SG9sZGVyc1JpZ2h0LCBuZXdBcmdQb3MsIGFyeSwgbmV3QXJpdHldLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZFdyYXBwZXIuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcblxuICAgICAgICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIHRoZSBnaXZlbiBgbGVuZ3RoYC5cbiAgICAgKiBUaGUgYGNoYXJzYCBzdHJpbmcgaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY3JlYXRlIHBhZGRpbmcgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBsZW5ndGggPSArbGVuZ3RoO1xuXG4gICAgICBpZiAoc3RyTGVuZ3RoID49IGxlbmd0aCB8fCAhbmF0aXZlSXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgcGFkTGVuZ3RoID0gbGVuZ3RoIC0gc3RyTGVuZ3RoO1xuICAgICAgY2hhcnMgPSBjaGFycyA9PSBudWxsID8gJyAnIDogKGNoYXJzICsgJycpO1xuICAgICAgcmV0dXJuIHJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChwYWRMZW5ndGggLyBjaGFycy5sZW5ndGgpKS5zbGljZSgwLCBwYWRMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogdGhlIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcHBlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBCSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuICAgICAgICAvLyBjb252ZXJ0aW5nIGl0IHRvIGFuIGFycmF5IGJlZm9yZSBwcm92aWRpbmcgaXQgYGZ1bmNgLlxuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmNlaWxgLCBgXy5mbG9vcmAsIG9yIGBfLnJvdW5kYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gMCA6ICgrcHJlY2lzaW9uIHx8IDApO1xuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgcHJlY2lzaW9uID0gcG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICAgIHJldHVybiBmdW5jKG51bWJlciAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnNvcnRlZEluZGV4YCBvciBgXy5zb3J0ZWRMYXN0SW5kZXhgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW5kZXggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU29ydGVkSW5kZXgocmV0SGlnaGVzdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUpO1xuICAgICAgICByZXR1cm4gKGl0ZXJhdGVlID09IG51bGwgJiYgY2FsbGJhY2sgPT09IGJhc2VDYWxsYmFjaylcbiAgICAgICAgICA/IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdClcbiAgICAgICAgICA6IGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBjYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMSksIHJldEhpZ2hlc3QpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy5cbiAgICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAgICogICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogICAyNTYgLSBgXy5hcnlgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oUEFSVElBTF9GTEFHIHwgUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGVuZ3RoIC09IChob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwKTtcbiAgICAgIGlmIChiaXRtYXNrICYgUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKSxcbiAgICAgICAgICBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eV07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbOV0gPSBhcml0eSA9PSBudWxsXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiAobmF0aXZlTWF4KGFyaXR5IC0gbGVuZ3RoLCAwKSB8fCAwKTtcblxuICAgICAgaWYgKGJpdG1hc2sgPT0gQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kV3JhcHBlcihuZXdEYXRhWzBdLCBuZXdEYXRhWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKEJJTkRfRkxBRyB8IFBBUlRJQUxfRkxBRykpICYmICFuZXdEYXRhWzRdLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBhcnJheXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNMb29zZSAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdLFxuICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoaXNMb29zZSA/IG90aFZhbHVlIDogYXJyVmFsdWUsIGlzTG9vc2UgPyBhcnJWYWx1ZSA6IG90aFZhbHVlLCBpbmRleCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoaXNMb29zZSkge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcpIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbC5cbiAgICAgICAgICByZXR1cm4gK29iamVjdCA9PSArb3RoZXI7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIFRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbC5cbiAgICAgICAgICByZXR1cm4gKG9iamVjdCAhPSArb2JqZWN0KVxuICAgICAgICAgICAgPyBvdGhlciAhPSArb3RoZXJcbiAgICAgICAgICAgIDogb2JqZWN0ID09ICtvdGhlcjtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncyBwcmltaXRpdmVzIGFuZCBzdHJpbmdcbiAgICAgICAgICAvLyBvYmplY3RzIGFzIGVxdWFsLiBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc0xvb3NlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzTG9vc2UgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNraXBDdG9yID0gaXNMb29zZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihpc0xvb3NlID8gb3RoVmFsdWUgOiBvYmpWYWx1ZSwgaXNMb29zZT8gb2JqVmFsdWUgOiBvdGhWYWx1ZSwga2V5KSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWQgPyBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikgOiByZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmICghc2tpcEN0b3IpIHtcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcImNhbGxiYWNrXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5jYWxsYmFja2AgbWV0aG9kIGlzXG4gICAgICogY3VzdG9taXplZCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICogdGhlIGBiYXNlQ2FsbGJhY2tgIGZ1bmN0aW9uLiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRoZSBjaG9zZW4gZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmQgaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5jYWxsYmFjayB8fCBjYWxsYmFjaztcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gY2FsbGJhY2sgPyBiYXNlQ2FsbGJhY2sgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJnQ291bnQgPyByZXN1bHQoZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLm5hbWUsXG4gICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VJbmRleE9mYCBmdW5jdGlvbi4gSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0aGUgY2hvc2VuIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxudW1iZXJ9IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaW5kZXhPZiB8fCBpbmRleE9mO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpbmRleE9mID8gYmFzZUluZGV4T2YgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbiA/IHJlc3VsdChjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAgICAgKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBwYWlycyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVuZ3RoXVsyXSA9IGlzU3RyaWN0Q29tcGFyYWJsZShyZXN1bHRbbGVuZ3RoXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgICAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgICAgICBDdG9yID0gT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlckNsb25lKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKGlzRGVlcCA/IGJ1ZmZlckNsb25lKGJ1ZmZlcikgOiBidWZmZXIsIG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QubGVuZ3RoKTtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yKG9iamVjdC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhvYmplY3QpKTtcbiAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gb2JqZWN0Lmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgIWlzS2V5KHBhdGgsIG9iamVjdCkpIHtcbiAgICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICAgICAgcGF0aCA9IGxhc3QocGF0aCk7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3BhdGhdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KSkge1xuICAgICAgICB2YXIgb3RoZXIgPSBvYmplY3RbaW5kZXhdO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gKHZhbHVlID09PSBvdGhlcikgOiAob3RoZXIgIT09IG90aGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAoKHR5cGUgPT0gJ3N0cmluZycgJiYgcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSkgfHwgdHlwZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiByZXN1bHQgfHwgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIHRvT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKTtcbiAgICAgIGlmICghKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcbiAgICAgIGlmIChmdW5jID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShvdGhlcik7XG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgcmVxdWlyZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kIGBfLnJlYXJnYFxuICAgICAqIGF1Z21lbnQgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlIGV4ZWN1dGVkIGltcG9ydGFudCxcbiAgICAgKiBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlXG4gICAgICogY29tbW9uIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgQVJZX0ZMQUc7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKHNyY0JpdG1hc2sgPT0gQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBDVVJSWV9GTEFHKSB8fFxuICAgICAgICAoc3JjQml0bWFzayA9PSBBUllfRkxBRyAmJiBiaXRtYXNrID09IFJFQVJHX0ZMQUcgJiYgZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSB8fFxuICAgICAgICAoc3JjQml0bWFzayA9PSAoQVJZX0ZMQUcgfCBSRUFSR19GTEFHKSAmJiBiaXRtYXNrID09IENVUlJZX0ZMQUcpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBCSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSAoYml0bWFzayAmIEJJTkRfRkxBRykgPyAwIDogQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogYXJyYXlDb3B5KHZhbHVlKTtcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogYXJyYXlDb3B5KHNvdXJjZVs0XSk7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IGFycmF5Q29weSh2YWx1ZSk7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IGFycmF5Q29weShzb3VyY2VbNl0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkYXRhWzddID0gYXJyYXlDb3B5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBBUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3RWYWx1ZSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVZhbHVlIDogbWVyZ2Uob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBtZXJnZURlZmF1bHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucGlja2Agd2hpY2ggcGlja3MgYG9iamVjdGAgcHJvcGVydGllcyBzcGVjaWZpZWRcbiAgICAgKiBieSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5QXJyYXkob2JqZWN0LCBwcm9wcykge1xuICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnBpY2tgIHdoaWNoIHBpY2tzIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWBcbiAgICAgKiByZXR1cm5zIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnlDYWxsYmFjayhvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgYmFzZUZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gYXJyYXlDb3B5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eSBmdW5jdGlvblxuICAgICAqIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZSBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVNldERhdGEoa2V5LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzSW4ob2JqZWN0KSxcbiAgICAgICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gICAgICB2YXIgYWxsb3dJbmRleGVzID0gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoKGFsbG93SW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXktbGlrZSBvYmplY3QgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIG9iamVjdCBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gcHJvcGVydHkgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VUb1N0cmluZyh2YWx1ZSkucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgcmV0dXJuIHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlclxuICAgICAgICA/IHdyYXBwZXIuY2xvbmUoKVxuICAgICAgICA6IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fLCBhcnJheUNvcHkod3JhcHBlci5fX2FjdGlvbnNfXykpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGNvbGxlY3Rpb25gIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBjb250YWluaW5nIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KG5hdGl2ZUZsb29yKHNpemUpIHx8IDEsIDEpO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXJcbiAgICAgKiBwcm92aWRlZCBhcnJheXMgdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXlzIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzXSwgWzQsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGlzT2JqZWN0TGlrZShhcnJheSkgJiYgaXNBcnJheUxpa2UoYXJyYXkpKVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIGZhbHNlLCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICBuID0gbGVuZ3RoIC0gKCtuIHx8IDApO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOF0sICcqJywgMSwgMik7XG4gICAgICogLy8gPT4gWzQsICcqJywgOF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLnVzZXIgPT0gJ2Jhcm5leSc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgZmluZEluZGV4ID0gY3JlYXRlRmluZEluZGV4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLnVzZXIgPT0gJ3BlYmJsZXMnO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdEluZGV4ID0gY3JlYXRlRmluZEluZGV4KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGhlYWRcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheS4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIHRoZSBhcnJheSBpcyByZWN1cnNpdmVseVxuICAgICAqIGZsYXR0ZW5lZCwgb3RoZXJ3aXNlIGl0IGlzIG9ubHkgZmxhdHRlbmVkIGEgc2luZ2xlIGxldmVsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBmbGF0dGVuLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgMywgWzRdXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgaXNEZWVwYFxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIDMsIFs0XV1dLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc0RlZXAsIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc0RlZXAsIGd1YXJkKSkge1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlY3Vyc2l2ZWx5IGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgMywgWzRdXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0XG4gICAgICogZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgc29ydGVkIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgXG4gICAgICogcGVyZm9ybXMgYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWBcbiAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGZyb21JbmRleGBcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBwZXJmb3JtaW5nIGEgYmluYXJ5IHNlYXJjaFxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApIDogZnJvbUluZGV4O1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAodmFsdWUgPT09IHZhbHVlID8gKHZhbHVlID09PSBhcnJheVtpbmRleF0pIDogKGFycmF5W2luZGV4XSAhPT0gYXJyYXlbaW5kZXhdKSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICByZXR1cm4gZHJvcFJpZ2h0KGFycmF5LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIG9mIHRoZSBwcm92aWRlZFxuICAgICAqIGFycmF5cyB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5c1tvdGhJbmRleF0gPSBpc0FycmF5TGlrZSh2YWx1ZSA9IGFycmF5c1tvdGhJbmRleF0pID8gdmFsdWUgOiBbXTtcbiAgICAgICAgY2FjaGVzW290aEluZGV4XSA9IChpc0NvbW1vbiAmJiB2YWx1ZS5sZW5ndGggPj0gMTIwKSA/IGNyZWF0ZUNhY2hlKG90aEluZGV4ICYmIHZhbHVlKSA6IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSBhcnJheXNbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKChzZWVuID8gY2FjaGVJbmRleE9mKHNlZW4sIHZhbHVlKSA6IGluZGV4T2YocmVzdWx0LCB2YWx1ZSwgMCkpIDwgMCkge1xuICAgICAgICAgIHZhciBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJyYXlzW290aEluZGV4XSwgdmFsdWUsIDApKSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbVxuICAgICAqICBvciBgdHJ1ZWAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBmcm9tSW5kZXhgXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHBlcmZvcm1pbmcgYSBiaW5hcnkgc2VhcmNoXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IG5hdGl2ZU1pbihmcm9tSW5kZXggfHwgMCwgbGVuZ3RoIC0gMSkpICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIHZhciBvdGhlciA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXhPZk5hTihhcnJheSwgaW5kZXgsIHRydWUpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCAxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcnJheSA9IGFyZ3NbMF07XG5cbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1tpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSkgPiAtMSkge1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5kZXhlcyBhbmQgcmV0dXJuc1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBpbmRleGVzIG9yIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZSxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbNSwgMTAsIDE1LCAyMF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5wdWxsQXQoYXJyYXksIDEsIDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFs1LCAxNV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMTAsIDIwXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIGluZGV4ZXMgPSBiYXNlRmxhdHRlbihpbmRleGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzLnNvcnQoYmFzZUNvbXBhcmVBc2NlbmRpbmcpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gZHJvcChhcnJheSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlXG4gICAgICogbGlzdHMgaW4gSUUgPCA5IGFuZCB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkXG4gICAgICogYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLiBJZiBhbiBpdGVyYXRlZVxuICAgICAqIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzQsIDQsIDUsIDVdLCA1KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHsgJ2RhdGEnOiB7ICd0aGlydHknOiAzMCwgJ2ZvcnR5JzogNDAsICdmaWZ0eSc6IDUwIH0gfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm9ydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5kYXRhW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRJbmRleCA9IGNyZWF0ZVNvcnRlZEluZGV4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA0LCA1LCA1XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRMYXN0SW5kZXggPSBjcmVhdGVTb3J0ZWRJbmRleCh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIG4gPSBsZW5ndGggLSAoK24gfHwgMCk7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2V9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsxLCAyXSwgWzQsIDJdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCA0XVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIGZhbHNlLCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBpc1NvcnRlZGAgcGVyZm9ybXMgYSBmYXN0ZXIgc2VhcmNoIGFsZ29yaXRobVxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLiBJZiBhbiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIGZvclxuICAgICAqIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB1bmlxdWVuZXNzXG4gICAgICogaXMgY29tcHV0ZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW5pcXVlXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWRdIFNwZWNpZnkgdGhlIGFycmF5IGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgaXNTb3J0ZWRgXG4gICAgICogXy51bmlxKFsxLCAxLCAyXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhbiBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIF8udW5pcShbMSwgMi41LCAxLjUsIDJdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NvcnRlZCAhPSBudWxsICYmIHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpc0FyZyA9IGl0ZXJhdGVlO1xuICAgICAgICBpdGVyYXRlZSA9IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc1NvcnRlZCwgdGhpc0FyZykgPyB1bmRlZmluZWQgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWxsYmFjayA9IGdldENhbGxiYWNrKCk7XG4gICAgICBpZiAoIShpdGVyYXRlZSA9PSBudWxsICYmIGNhbGxiYWNrID09PSBiYXNlQ2FsbGJhY2spKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gY2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpc1NvcnRlZCAmJiBnZXRJbmRleE9mKCkgPT0gYmFzZUluZGV4T2YpXG4gICAgICAgID8gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpXG4gICAgICAgIDogYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gaXRlcmF0ZWUgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KTtcbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZShncm91cCwgaXRlcmF0ZWUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGUgW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDJdLCBbNCwgMl0pO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5TGlrZShhcnJheSkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgICA/IGFycmF5UHVzaChiYXNlRGlmZmVyZW5jZShyZXN1bHQsIGFycmF5KSwgYmFzZURpZmZlcmVuY2UoYXJyYXksIHJlc3VsdCkpXG4gICAgICAgICAgICA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ID8gYmFzZVVuaXEocmVzdWx0KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlIHNlY29uZCBlbGVtZW50c1xuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IHJlc3RQYXJhbSh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5wYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIGZyb20gYXJyYXlzXG4gICAgICogb2YgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy4gUHJvdmlkZSBlaXRoZXIgYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LFxuICAgICAqIGUuZy4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYCBvciB0d28gYXJyYXlzLCBvbmUgb2YgcHJvcGVydHkgbmFtZXNcbiAgICAgKiBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFtbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgNDBdXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcyA/IHByb3BzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGlmIChsZW5ndGggJiYgIXZhbHVlcyAmJiAhaXNBcnJheShwcm9wc1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGl0ZXJhdGVlIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDIgPyBhcnJheXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgdGhpc0FyZyA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxlbmd0aCAtPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWUgPSAobGVuZ3RoID4gMSAmJiB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nKSA/ICgtLWxlbmd0aCwgdGhpc0FyZykgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlLCB0aGlzQXJnKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW5pbmcgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF8uY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgICAgcmV0dXJuIGNoci51c2VyICsgJyBpcyAnICsgY2hyLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvciBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2ZcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gaW4gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zXG4gICAgICogb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvciwgdGhpc0FyZykge1xuICAgICAgaW50ZXJjZXB0b3IuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvci5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGV4cGxpY2l0IG1ldGhvZCBjaGFpbmluZyBvbiB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKHVzZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKHVzZXJzKS5jaGFpbigpXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluZWQgc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgam9pbmluZyBhIHdyYXBwZWQgYXJyYXkgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQG5hbWUgY29uY2F0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5jb25jYXQoMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyh3cmFwcGVkLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJDb25jYXQgPSByZXN0UGFyYW0oZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSBiYXNlRmxhdHRlbih2YWx1ZXMpO1xuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXlDb25jYXQoaXNBcnJheShhcnJheSkgPyBhcnJheSA6IFt0b09iamVjdChhcnJheSldLCB2YWx1ZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluZWQgc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5wb3codmFsdWUsIDIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0gWzMsIDRdO1xuICAgICAqIHZhciBvdGhlcldyYXBwZWQgPSB3cmFwcGVkLnBsYW50KG90aGVyKTtcbiAgICAgKlxuICAgICAqIG90aGVyV3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgd3JhcHBlZCBhcnJheSBzbyB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG5cbiAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAod3JhcHBlZCAmJiB3cmFwcGVkLl9fZGlyX18gPCAwKSA/IHZhbHVlIDogdmFsdWUucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgcmVzdWx0IG9mIGNvZXJjaW5nIHRoZSB1bndyYXBwZWQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29lcmNlZCBzdHJpbmcgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gKHRoaXMudmFsdWUoKSArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW5lZCBzZXF1ZW5jZSB0byBleHRyYWN0IHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHJ1biwgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXlzLCBvciBpbmRleGVzLFxuICAgICAqIG9mIGBjb2xsZWN0aW9uYC4gS2V5cyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIGtleXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdfHN0cmluZ3xzdHJpbmdbXSl9IFtwcm9wc10gVGhlIHByb3BlcnR5IG5hbWVzXG4gICAgICogIG9yIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcGljaywgc3BlY2lmaWVkIGluZGl2aWR1YWxseSBvciBpbiBhcnJheXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnXSwgWzAsIDJdKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddLCAwLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICB2YXIgYXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBiYXNlQXQoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4ocHJvcHMpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIE1hdGguZmxvb3Iobik7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gKytyZXN1bHRba2V5XSA6IChyZXN1bHRba2V5XSA9IDEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbGxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHNlbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFs0LCA1LCA2XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzQsIDZdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkZXRlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChiYXNlRWFjaCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoYmFzZUVhY2hSaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgYW5kIHRoZVxuICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGhhcyBlcXVpdmFsZW50IHByb3BlcnR5XG4gICAgICogdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRm9yIGNvbXBhcmluZyBhIHNpbmdsZVxuICAgICAqIG93biBvciBpbmhlcml0ZWQgcHJvcGVydHkgdmFsdWUgc2VlIGBfLm1hdGNoZXNQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChfLmZpbmRXaGVyZSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChfLmZpbmRXaGVyZSh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kV2hlcmUoY29sbGVjdGlvbiwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZmluZChjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseVxuICAgICAqIGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIiBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyXSkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhuKTtcbiAgICAgKiB9KS52YWx1ZSgpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIGxlZnQgdG8gcmlnaHQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihuLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKG4sIGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlLWtleSBwYWlyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9yRWFjaCA9IGNyZWF0ZUZvckVhY2goYXJyYXlFYWNoLCBiYXNlRWFjaCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDJdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obikge1xuICAgICAqICAgY29uc29sZS5sb2cobik7XG4gICAgICogfSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUgZnJvbSByaWdodCB0byBsZWZ0IGFuZCByZXR1cm5zIHRoZSBhcnJheVxuICAgICAqL1xuICAgIHZhciBmb3JFYWNoUmlnaHQgPSBjcmVhdGVGb3JFYWNoKGFycmF5RWFjaFJpZ2h0LCBiYXNlRWFjaFJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIHRoZSBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0XG4gICAgICogZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb250YWlucywgaW5jbHVkZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgbWF0Y2hpbmcgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ3BlYmJsZXMnLCAnZWInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGdldExlbmd0aChjb2xsZWN0aW9uKSA6IDA7XG4gICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwodGFyZ2V0LCBmcm9tSW5kZXgsIGd1YXJkKSkpIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IChmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHR5cGVvZiBjb2xsZWN0aW9uID09ICdzdHJpbmcnIHx8ICFpc0FycmF5KGNvbGxlY3Rpb24pICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgZ2V0SW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGtleURhdGEgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2JqZWN0LmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZyb21DaGFyQ29kZShvYmplY3QuY29kZSk7XG4gICAgICogfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0IGlzXG4gICAgICogaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGlzUHJvcCA9IGlzS2V5KHBhdGgpLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gcGF0aCA6ICgoaXNQcm9wICYmIHZhbHVlICE9IG51bGwpID8gdmFsdWVbcGF0aF0gOiB1bmRlZmluZWQpO1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBmdW5jID8gZnVuYy5hcHBseSh2YWx1ZSwgYXJncykgOiBpbnZva2VQYXRoKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoXG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjYWxsYmFja2AsIGBjaHVua2AsIGBjbG9uZWAsIGBjcmVhdGVgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsXG4gICAgICogYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCwgYGZpbGxgLCBgZmxhdHRlbmAsIGBpbnZlcnRgLCBgbWF4YCwgYG1pbmAsXG4gICAgICogYHBhcnNlSW50YCwgYHNsaWNlYCwgYHNvcnRCeWAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0ZW1wbGF0ZWAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUxlZnRgLCBgdHJpbVJpZ2h0YCwgYHRydW5jYCwgYHJhbmRvbWAsIGByYW5nZWAsIGBzYW1wbGVgLCBgc29tZWAsXG4gICAgICogYHN1bWAsIGB1bmlxYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB0aW1lc1RocmVlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbMSwgMl0sIHRpbWVzVGhyZWUpO1xuICAgICAqIC8vID0+IFszLCA2XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDEsICdiJzogMiB9LCB0aW1lc1RocmVlKTtcbiAgICAgKiAvLyA9PiBbMywgNl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB3aGlsZSB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kXG4gICAgICogdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbihbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbWzEsIDNdLCBbMl1dXG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbihbMS4yLCAyLjMsIDMuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pICUgMjtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbWzEuMiwgMy40XSwgWzIuM11dXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVyID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgIHJldHVybiBfLnBsdWNrKGFycmF5LCAndXNlcicpO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KSwgbWFwcGVyKTtcbiAgICAgKiAvLyA9PiBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCBtYXBwZXIpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpLCBtYXBwZXIpO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBwYXRoYCBmcm9tIGFsbCBlbGVtZW50cyBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHBsdWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBsdWNrKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJJbmRleCA9IF8uaW5kZXhCeSh1c2VycywgJ3VzZXInKTtcbiAgICAgKiBfLnBsdWNrKHVzZXJJbmRleCwgJ2FnZScpO1xuICAgICAqIC8vID0+IFszNiwgNDBdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGx1Y2soY29sbGVjdGlvbiwgcGF0aCkge1xuICAgICAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBwcm9wZXJ0eShwYXRoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYHNvcnRCeUFsbGAsXG4gICAgICogYW5kIGBzb3J0QnlPcmRlcmBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24odG90YWwsIG4pIHtcbiAgICAgKiAgIHJldHVybiB0b3RhbCArIG47XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihyZXN1bHQsIG4sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBuICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciByZWR1Y2UgPSBjcmVhdGVSZWR1Y2UoYXJyYXlSZWR1Y2UsIGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIHZhciByZWR1Y2VSaWdodCA9IGNyZWF0ZVJlZHVjZShhcnJheVJlZHVjZVJpZ2h0LCBiYXNlRWFjaFJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gc2FtcGxlKHMpLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA+IDAgPyBjb2xsZWN0aW9uW2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdG9BcnJheShjb2xsZWN0aW9uKSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIG4gPSBuYXRpdmVNaW4obiA8IDAgPyAwIDogKCtuIHx8IDApLCBsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0W3JhbmRdO1xuXG4gICAgICAgIHJlc3VsdFtyYW5kXSA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2FtcGxlKGNvbGxlY3Rpb24sIFBPU0lUSVZFX0lORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGdldExlbmd0aChjb2xsZWN0aW9uKSA6IDA7XG4gICAgICByZXR1cm4gaXNMZW5ndGgobGVuZ3RoKSA/IGxlbmd0aCA6IGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGEgcGFzc2luZyB2YWx1ZSBhbmQgZG9lcyBub3QgaXRlcmF0ZVxuICAgICAqIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGlzIG1ldGhvZCBwZXJmb3Jtc1xuICAgICAqIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZiBlcXVhbCBlbGVtZW50cy5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLnNpbihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuc2luKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uc29ydEJ5KHVzZXJzLCAndXNlcicpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgY29tcGFyZUFzY2VuZGluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGNhbiBzb3J0IGJ5IG11bHRpcGxlIGl0ZXJhdGVlc1xuICAgICAqIG9yIHByb3BlcnR5IG5hbWVzLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYW4gaXRlcmF0ZWUgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW118T2JqZWN0fE9iamVjdFtdfHN0cmluZ3xzdHJpbmdbXSl9IGl0ZXJhdGVlc1xuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnksIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHZhbHVlcyBvciBhcnJheXMgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MiB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeUFsbCh1c2VycywgWyd1c2VyJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQyXSwgWydmcmVkJywgNDhdXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0QnlBbGwodXNlcnMsICd1c2VyJywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihjaHIuYWdlIC8gMTApO1xuICAgICAqIH0pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0Ml1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeUFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGd1YXJkID0gaXRlcmF0ZWVzWzJdO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgaXRlcmF0ZWVzLmxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcyksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5QWxsYCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGVcbiAgICAgKiBzb3J0IG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGxcbiAgICAgKiB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgYSB2YWx1ZSBpcyBzb3J0ZWQgaW5cbiAgICAgKiBhc2NlbmRpbmcgb3JkZXIgaWYgaXRzIGNvcnJlc3BvbmRpbmcgb3JkZXIgaXMgXCJhc2NcIiwgYW5kIGRlc2NlbmRpbmcgaWYgXCJkZXNjXCIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGFuIGl0ZXJhdGVlIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQyIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlclxuICAgICAqIF8ubWFwKF8uc29ydEJ5T3JkZXIodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSkge1xuICAgICAgICBvcmRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgYW5kIHRoZVxuICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlLCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiBfLnBsdWNrKF8ud2hlcmUodXNlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAgICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gbmF0aXZlTm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0IGlzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0ZW1wID0gbjtcbiAgICAgICAgICBuID0gZnVuYztcbiAgICAgICAgICBmdW5jID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSBuYXRpdmVJc0Zpbml0ZShuID0gK24pID8gbiA6IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIGBuYCBhcmd1bWVudHMgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIG4sIGd1YXJkKSkge1xuICAgICAgICBuID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG5hdGl2ZU1heCgrbiB8fCAwLCAwKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIEFSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0IGlzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoJyNhZGQnKS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gYWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0ZW1wID0gbjtcbiAgICAgICAgICBuID0gZnVuYztcbiAgICAgICAgICBmdW5jID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGVcbiAgICAgKiBib3VuZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgYmluZC5wbGFjZWhvbGRlcik7XG4gICAgICAgIGJpdG1hc2sgfD0gUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCBlbnVtZXJhYmxlIGZ1bmN0aW9uXG4gICAgICogcHJvcGVydGllcywgb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIGFyZSBib3VuZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbbWV0aG9kTmFtZXNdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIHRoZSBlbGVtZW50IGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBtZXRob2ROYW1lcyA9IG1ldGhvZE5hbWVzLmxlbmd0aCA/IGJhc2VGbGF0dGVuKG1ldGhvZE5hbWVzKSA6IGZ1bmN0aW9ucyhvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2ROYW1lc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgQklORF9GTEFHLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIGFuZCBwcmVwZW5kc1xuICAgICAqIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cbiAgICAgKiBTZWUgW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGJpbmRLZXkucGxhY2Vob2xkZXIpO1xuICAgICAgICBiaXRtYXNrIHw9IFBBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogY2FsbGVkIGVpdGhlciBpbnZva2VzIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYWxsIGBmdW5jYCBhcmd1bWVudHNcbiAgICAgKiBoYXZlIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgb2YgdGhlXG4gICAgICogcmVtYWluaW5nIGBmdW5jYCBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkXG4gICAgICogaWYgYGZ1bmMubGVuZ3RoYCBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciBjdXJyeSA9IGNyZWF0ZUN1cnJ5KENVUlJZX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciBjdXJyeVJpZ2h0ID0gY3JlYXRlQ3VycnkoQ1VSUllfUklHSFRfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBpbnZvY2F0aW9ucy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3RcbiAgICAgKiBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cDovL2RydXBhbG1vdGlvbi5jb20vYXJ0aWNsZS9kZWJvdW5jZS1hbmQtdGhyb3R0bGUtdmlzdWFsLWV4cGxhbmF0aW9uKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmVcbiAgICAgKiAgZGVsYXllZCBiZWZvcmUgaXQgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIGludm9rZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcbiAgICAgKiAgICdtYXhXYWl0JzogMTAwMFxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGNhbmNlbCBhIGRlYm91bmNlZCBjYWxsXG4gICAgICogdmFyIHRvZG9DaGFuZ2VzID0gXy5kZWJvdW5jZShiYXRjaExvZywgMTAwMCk7XG4gICAgICogT2JqZWN0Lm9ic2VydmUobW9kZWxzLnRvZG8sIHRvZG9DaGFuZ2VzKTtcbiAgICAgKlxuICAgICAqIE9iamVjdC5vYnNlcnZlKG1vZGVscywgZnVuY3Rpb24oY2hhbmdlcykge1xuICAgICAqICAgaWYgKF8uZmluZChjaGFuZ2VzLCB7ICd1c2VyJzogJ3RvZG8nLCAndHlwZSc6ICdkZWxldGUnfSkpIHtcbiAgICAgKiAgICAgdG9kb0NoYW5nZXMuY2FuY2VsKCk7XG4gICAgICogICB9XG4gICAgICogfSwgWydkZWxldGUnXSk7XG4gICAgICpcbiAgICAgKiAvLyAuLi5hdCBzb21lIHBvaW50IGBtb2RlbHMudG9kb2AgaXMgY2hhbmdlZFxuICAgICAqIG1vZGVscy50b2RvLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICpcbiAgICAgKiAvLyAuLi5iZWZvcmUgMSBzZWNvbmQgaGFzIHBhc3NlZCBgbW9kZWxzLnRvZG9gIGlzIGRlbGV0ZWRcbiAgICAgKiAvLyB3aGljaCBjYW5jZWxzIHRoZSBkZWJvdW5jZWQgYHRvZG9DaGFuZ2VzYCBjYWxsXG4gICAgICogZGVsZXRlIG1vZGVscy50b2RvO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB3YWl0IDwgMCA/IDAgOiAoK3dhaXQgfHwgMCk7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIG5hdGl2ZU1heCgrb3B0aW9ucy5tYXhXYWl0IHx8IDAsIHdhaXQpO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxlZCA9IDA7XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcGxldGUoaXNDYWxsZWQsIGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgICAgY29tcGxldGUodHJhaWxpbmdDYWxsLCBtYXhUaW1lb3V0SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXhEZWxheWVkKCkge1xuICAgICAgICBjb21wbGV0ZSh0cmFpbGluZywgdGltZW91dElkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gbWF4V2FpdDtcblxuICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQobWF4RGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmIHRpbWVvdXRJZCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vIGxvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgb3IgbW9yZSBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBsb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZFxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBwcm92aWRlZFxuICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KF8uYWRkLCBzcXVhcmUpO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBiYWNrZmxvdywgY29tcG9zZVxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoc3F1YXJlLCBfLmFkZCk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIGNvZXJjZWQgdG8gYSBzdHJpbmcgYW5kIHVzZWQgYXMgdGhlXG4gICAgICogY2FjaGUga2V5LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGUgW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXppbmcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1cHBlckNhc2UgPSBfLm1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gc3RyaW5nLnRvVXBwZXJDYXNlKCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB1cHBlckNhc2UoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdXBwZXJDYXNlLmNhY2hlLnNldCgnZnJlZCcsICdCQVJORVknKTtcbiAgICAgKiB1cHBlckNhc2UoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnQkFSTkVZJ1xuICAgICAqXG4gICAgICogLy8gcmVwbGFjaW5nIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2Jhcm5leScgfTtcbiAgICAgKiB2YXIgaWRlbnRpdHkgPSBfLm1lbW9pemUoXy5pZGVudGl0eSk7XG4gICAgICpcbiAgICAgKiBpZGVudGl0eShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIGlkZW50aXR5KG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICogdmFyIGlkZW50aXR5ID0gXy5tZW1vaXplKF8uaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogaWRlbnRpdHkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBpZGVudGl0eShvdGhlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyBtZW1vaXplLkNhY2hlO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJ1bnMgZWFjaCBhcmd1bWVudCB0aHJvdWdoIGEgY29ycmVzcG9uZGluZ1xuICAgICAqIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zXSBUaGUgZnVuY3Rpb25zIHRvIHRyYW5zZm9ybVxuICAgICAqIGFyZ3VtZW50cywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgZnVuY3Rpb25zIG9yIGFycmF5cyBvZiBmdW5jdGlvbnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG1vZGRlZCA9IF8ubW9kQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIHNxdWFyZSwgZG91YmxlZCk7XG4gICAgICpcbiAgICAgKiBtb2RkZWQoMSwgMik7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICpcbiAgICAgKiBtb2RkZWQoNSwgMTApO1xuICAgICAqIC8vID0+IFsyNSwgMjBdXG4gICAgICovXG4gICAgdmFyIG1vZEFyZ3MgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9IGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMpO1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgIWFycmF5RXZlcnkodHJhbnNmb3JtcywgYmFzZUlzRnVuY3Rpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XShhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjYWxsLiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gYGluaXRpYWxpemVgIGludm9rZXMgYGNyZWF0ZUFwcGxpY2F0aW9uYCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdFxuICAgICAqIGl0IGRvZXMgKipub3QqKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGNyZWF0ZVBhcnRpYWwoUEFSVElBTF9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gY3JlYXRlUGFydGlhbChQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcyxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgMiwgMCwgMSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiB2YXIgbWFwID0gXy5yZWFyZyhfLm1hcCwgWzEsIDBdKTtcbiAgICAgKiBtYXAoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gKiAzO1xuICAgICAqIH0sIFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIFJFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGJhc2VGbGF0dGVuKGluZGV4ZXMpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0UGFyYW0oZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0UGFyYW0oZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6ICgrc3RhcnQgfHwgMCksIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHN0YXJ0KSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCByZXN0KTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgcmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2UgW2BGdW5jdGlvbiNhcHBseWBdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC4zKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL1NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGEgUHJvbWlzZVxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJyYXkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgaW52b2NhdGlvbnMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGVcbiAgICAgKiB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGVcbiAgICAgKiBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHA6Ly9kcnVwYWxtb3Rpb24uY29tL2FydGljbGUvZGVib3VuY2UtYW5kLXRocm90dGxlLXZpc3VhbC1leHBsYW5hdGlvbilcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZ1xuICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIGludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBjYW5jZWwgYSB0cmFpbGluZyB0aHJvdHRsZWQgY2FsbFxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7ICdsZWFkaW5nJzogbGVhZGluZywgJ21heFdhaXQnOiArd2FpdCwgJ3RyYWlsaW5nJzogdHJhaWxpbmcgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgd3JhcHBlciA9IHdyYXBwZXIgPT0gbnVsbCA/IGlkZW50aXR5IDogd3JhcHBlcjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIFBBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBbdmFsdWVdLCBbXSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCBuZXN0ZWQgb2JqZWN0cyBhcmUgY2xvbmVkLFxuICAgICAqIG90aGVyd2lzZSB0aGV5IGFyZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKS5cbiAgICAgKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICAgICAqIGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy4gQW5cbiAgICAgKiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoIGFzIGZ1bmN0aW9ucywgRE9NIG5vZGVzLFxuICAgICAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZSh1c2Vycyk7XG4gICAgICogc2hhbGxvd1swXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKHVzZXJzLCB0cnVlKTtcbiAgICAgKiBkZWVwWzBdID09PSB1c2Vyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGVsID0gXy5jbG9uZShkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGVsID09PSBkb2N1bWVudC5ib2R5XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBlbC5ub2RlTmFtZVxuICAgICAqIC8vID0+IEJPRFlcbiAgICAgKiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgaWYgKGlzRGVlcCAmJiB0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyKSkge1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBpc0RlZXAgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzQXJnID0gY3VzdG9taXplcjtcbiAgICAgICAgY3VzdG9taXplciA9IGlzRGVlcDtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSkpXG4gICAgICAgIDogYmFzZUNsb25lKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gICAgICogdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZ1xuICAgICAqIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKS5cbiAgICAgKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICAgICAqIGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy4gQW5cbiAgICAgKiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoIGFzIGZ1bmN0aW9ucywgRE9NIG5vZGVzLFxuICAgICAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcCh1c2Vycyk7XG4gICAgICogZGVlcFswXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBlbCA9PT0gZG9jdW1lbnQuYm9keVxuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogZWwubm9kZU5hbWVcbiAgICAgKiAvLyA9PiBCT0RZXG4gICAgICogZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSkpXG4gICAgICAgIDogYmFzZUNsb25lKHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGd0ZSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiAhIXZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgZW1wdHkgdW5sZXNzIGl0IGlzIGFuXG4gICAgICogYGFyZ3VtZW50c2Agb2JqZWN0LCBhcnJheSwgc3RyaW5nLCBvciBqUXVlcnktbGlrZSBjb2xsZWN0aW9uIHdpdGggYSBsZW5ndGhcbiAgICAgKiBncmVhdGVyIHRoYW4gYDBgIG9yIGFuIG9iamVjdCB3aXRoIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFrZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2RcbiAgICAgKiBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIG90aGVyIFssIGluZGV4fGtleV0pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAgICAgKiBhcmUgKipub3QqKiBzdXBwb3J0ZWQuIFByb3ZpZGUgYSBjdXN0b21pemVyIGZ1bmN0aW9uIHRvIGV4dGVuZCBzdXBwb3J0XG4gICAgICogZm9yIGNvbXBhcmluZyBvdGhlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZXFcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIG90aGVyID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogb2JqZWN0ID09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwoYXJyYXksIG90aGVyLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIGlmIChfLmV2ZXJ5KFt2YWx1ZSwgb3RoZXJdLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eaCg/Oml8ZWxsbykkLykpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAzKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuICByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBlcnJvclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzZmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMTApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoT2JqZWN0KDEwKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gICAgICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0byBkZXRlcm1pbmUgaWZcbiAgICAgKiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkXG4gICAgICogaXQgaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgb3RoZXIsIGluZGV4fGtleSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIHByb3BlcnRpZXMgb2YgYXJyYXlzLCBib29sZWFucyxcbiAgICAgKiBgRGF0ZWAgb2JqZWN0cywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmRcbiAgICAgKiBzdXBwb3J0IGZvciBjb21wYXJpbmcgb3RoZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIF8uZXZlcnkoW3ZhbHVlLCBvdGhlcl0sIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgL15oKD86aXxlbGxvKSQvKSB8fCB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDMpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIG5vdCB0aGUgc2FtZSBhcyBbYGlzTmFOYF0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjQpXG4gICAgICogd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmUgY2xhc3NpZmllZFxuICAgICAqIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCc4LjQnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhc3N1bWVzIG9iamVjdHMgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3JcbiAgICAgKiBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvcjtcblxuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igbm9uIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICBpZiAoIShpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZyAmJiAhaXNBcmd1bWVudHModmFsdWUpKSB8fFxuICAgICAgICAgICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NvbnN0cnVjdG9yJykgJiYgKEN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhKEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElFIDwgOSBpdGVyYXRlcyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuIElmIHRoZSBmaXJzdFxuICAgICAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAgICAgLy8gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgYmFzZUZvckluKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGx0ZSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7XG4gICAgICogfSgxLCAyLCAzKSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlID8gZ2V0TGVuZ3RoKHZhbHVlKSA6IDA7XG4gICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlDb3B5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvcHkodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAgICAgKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmaXZlIGFyZ3VtZW50czogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICd1c2VyJzogJ2ZyZWQnIH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2RhdGEnOiBbeyAnYWdlJzogMzYgfSwgeyAnYWdlJzogNDAgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZSh1c2VycywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnZGF0YSc6IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlciwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShhKSkge1xuICAgICAqICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90J10gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGJhc2VNZXJnZSk7XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czpcbiAgICAgKiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDQwIH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKHZhbHVlKSA/IG90aGVyIDogdmFsdWU7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gY3VzdG9taXplclxuICAgICAgICA/IGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpXG4gICAgICAgIDogYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMsIGd1YXJkKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gICAgICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVEZWZhdWx0cyhhc3NpZ24sIGFzc2lnbkRlZmF1bHRzKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAndXNlcic6IHsgJ25hbWUnOiAnYmFybmV5JyB9IH0sIHsgJ3VzZXInOiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogMzYgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSB9XG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gY3JlYXRlRGVmYXVsdHMobWVyZ2UsIG1lcmdlRGVmYXVsdHMpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kS2V5ID0gY3JlYXRlRmluZEtleShiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgYHBlYmJsZXNgIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3RLZXkgPSBjcmVhdGVGaW5kS2V5KGJhc2VGb3JPd25SaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgaW52b2tpbmdcbiAgICAgKiBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdhJywgJ2InLCBhbmQgJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gY3JlYXRlRm9ySW4oYmFzZUZvcik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYycsICdiJywgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JJbiBgIGxvZ3MgJ2EnLCAnYicsIGFuZCAnYydcbiAgICAgKi9cbiAgICB2YXIgZm9ySW5SaWdodCA9IGNyZWF0ZUZvckluKGJhc2VGb3JSaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGludm9raW5nIGBpdGVyYXRlZWBcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2EnIGFuZCAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duID0gY3JlYXRlRm9yT3duKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYicgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIGFuZCAnYidcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duUmlnaHQgPSBjcmVhdGVGb3JPd24oYmFzZUZvck93blJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBtZXRob2RzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FmdGVyJywgJ2FyeScsICdhc3NpZ24nLCAuLi5dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgdXNlZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHRvUGF0aChwYXRoKSwgcGF0aCArICcnKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IHsgJ2MnOiAzIH0gfSB9O1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwYXRoKTtcbiAgICAgIGlmICghcmVzdWx0ICYmICFpc0tleShwYXRoKSkge1xuICAgICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IGxhc3QocGF0aCk7XG4gICAgICAgIHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgfHwgKGlzTGVuZ3RoKG9iamVjdC5sZW5ndGgpICYmIGlzSW5kZXgocGF0aCwgb2JqZWN0Lmxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGUgcHJvcGVydHlcbiAgICAgKiBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMgdW5sZXNzIGBtdWx0aVZhbHVlYCBpcyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aVZhbHVlXSBBbGxvdyBtdWx0aXBsZSB2YWx1ZXMgcGVyIGtleS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggYG11bHRpVmFsdWVgXG4gICAgICogXy5pbnZlcnQob2JqZWN0LCB0cnVlKTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCwgbXVsdGlWYWx1ZSwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChvYmplY3QsIG11bHRpVmFsdWUsIGd1YXJkKSkge1xuICAgICAgICBtdWx0aVZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICAgICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gICAgICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCBgaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgdmFyIG1hcEtleXMgPSBjcmVhdGVPYmplY3RNYXBwZXIodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgbWFwVmFsdWVzID0gY3JlYXRlT2JqZWN0TWFwcGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcmVkaWNhdGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gb21pdCwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHByb3BzKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wc1swXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGJhc2VGbGF0dGVuKHByb3BzKSwgU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHBpY2tCeUFycmF5KG9iamVjdCwgYmFzZURpZmZlcmVuY2Uoa2V5c0luKG9iamVjdCksIHByb3BzKSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJlZGljYXRlID0gYmluZENhbGxiYWNrKHByb3BzWzBdLCBwcm9wc1sxXSwgMyk7XG4gICAgICByZXR1cm4gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiB0aGUga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCxcbiAgICAgKiBlLmcuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuIFByb3BlcnR5XG4gICAgICogbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2YgcHJvcGVydHlcbiAgICAgKiBuYW1lcy4gSWYgYHByZWRpY2F0ZWAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBgb2JqZWN0YFxuICAgICAqIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcmVkaWNhdGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCAndXNlcicpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgXy5pc1N0cmluZyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgcHJvcHNbMF0gPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgYmluZENhbGxiYWNrKHByb3BzWzBdLCBwcm9wc1sxXSwgMykpXG4gICAgICAgIDogcGlja0J5QXJyYXkob2JqZWN0LCBiYXNlRmxhdHRlbihwcm9wcykpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gICAgICogaXQgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmQgaXRzIHJlc3VsdFxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2EuYi5jJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtwYXRoXTtcbiAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgIWlzS2V5KHBhdGgsIG9iamVjdCkpIHtcbiAgICAgICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgICAgIG9iamVjdCA9IHBhdGgubGVuZ3RoID09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbbGFzdChwYXRoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihyZXN1bHQpID8gcmVzdWx0LmNhbGwob2JqZWN0KSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgb24gYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGBcbiAgICAgKiBkb2VzIG5vdCBleGlzdCBpdCBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBhdWdtZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAneFswXS55LnonLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgcGF0aEtleSA9IChwYXRoICsgJycpO1xuICAgICAgcGF0aCA9IChvYmplY3RbcGF0aEtleV0gIT0gbnVsbCB8fCBpc0tleShwYXRoLCBvYmplY3QpKSA/IFtwYXRoS2V5XSA6IHRvUGF0aChwYXRoKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG5lc3RlZCkpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBuZXN0ZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmVzdGVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbmVzdGVkW2tleV0gPSBpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd24gZW51bWVyYWJsZVxuICAgICAqIHByb3BlcnRpZXMgdGhyb3VnaCBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvbiBwb3RlbnRpYWxseSBtdXRhdGluZ1xuICAgICAqIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnNcbiAgICAgKiBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24ocmVzdWx0LCBuLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbiAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KTtcblxuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnJheShvYmplY3QpID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKGlzRnVuY3Rpb24oQ3RvcikgPyBDdG9yLnByb3RvdHlwZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQgaXQgaXMgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZSh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gK2VuZCB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiB2YWx1ZSA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgaXMgcmV0dXJuZWQuXG4gICAgICogSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50XG4gICAgICogbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgaXNJdGVyYXRlZUNhbGwobWluLCBtYXgsIGZsb2F0aW5nKSkge1xuICAgICAgICBtYXggPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmIChub01heCAmJiB0eXBlb2YgbWluID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1heCA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1heDtcbiAgICAgICAgICBub01heCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub01pbiAmJiBub01heCkge1xuICAgICAgICBtYXggPSAxO1xuICAgICAgICBub01heCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbWluID0gK21pbiB8fCAwO1xuICAgICAgaWYgKG5vTWF4KSB7XG4gICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heCA9ICttYXggfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBtaW4gJSAxIHx8IG1heCAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihtaW4gKyAocmFuZCAqIChtYXggLSBtaW4gKyBwYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAod29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDYXBpdGFsaXplcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIChzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZyBbbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIHRvIGJhc2ljIGxhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluMSwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9ICh0YXJnZXQgKyAnJyk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogbmF0aXZlTWluKHBvc2l0aW9uIDwgMCA/IDAgOiAoK3Bvc2l0aW9uIHx8IDApLCBsZW5ndGgpO1xuXG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLmluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgXCInXCIsIGFuZCBcIlxcYFwiLCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbCBjaGFyYWN0ZXJzXG4gICAgICogdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogU2VlIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEJhY2t0aWNrcyBhcmUgZXNjYXBlZCBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyIDwgOSwgdGhleSBjYW4gYnJlYWsgb3V0XG4gICAgICogb2YgYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLiBTZWUgWyM1OV0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzU5KSxcbiAgICAgKiBbIzEwMl0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwMiksIFsjMTA4XShodHRwczovL2h0bWw1c2VjLm9yZy8jMTA4KSwgYW5kXG4gICAgICogWyMxMzNdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMzMpIG9mIHRoZSBbSFRNTDUgU2VjdXJpdHkgQ2hlYXRzaGVldF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZylcbiAgICAgKiB0byByZWR1Y2UgWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIC8vIFJlc2V0IGBsYXN0SW5kZXhgIGJlY2F1c2UgaW4gSUUgPCA5IGBTdHJpbmcjcmVwbGFjZWAgZG9lcyBub3QuXG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXFxcIiwgXCIvXCIsIFwiXlwiLCBcIiRcIiwgXCIuXCIsIFwifFwiLCBcIj9cIixcbiAgICAgKiBcIipcIiwgXCIrXCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiBhbmQgXCJ9XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6XFwvXFwvbG9kYXNoXFwuY29tXFwvXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFycy50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFycywgZXNjYXBlUmVnRXhwQ2hhcilcbiAgICAgICAgOiAoc3RyaW5nIHx8ICcoPzopJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9ICtsZW5ndGg7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKHN0ckxlbmd0aCA+PSBsZW5ndGggfHwgIW5hdGl2ZUlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDIsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IG5hdGl2ZUZsb29yKG1pZCksXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBuYXRpdmVDZWlsKG1pZCk7XG5cbiAgICAgIGNoYXJzID0gY3JlYXRlUGFkZGluZygnJywgcmlnaHRMZW5ndGgsIGNoYXJzKTtcbiAgICAgIHJldHVybiBjaGFycy5zbGljZSgwLCBsZWZ0TGVuZ3RoKSArIHN0cmluZyArIGNoYXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgdmFyIHBhZExlZnQgPSBjcmVhdGVQYWREaXIoKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRSaWdodCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIHZhciBwYWRSaWdodCA9IGNyZWF0ZVBhZERpcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLFxuICAgICAqIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGUgW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNFKVxuICAgICAqIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgRVMzIGZvciBgcGFyc2VJbnRgLlxuICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHRyaW0gbGVhZGluZyA8Qk9NPiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxMDkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgcmFkaXgsIGd1YXJkKSA6IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRyaW0oc3RyaW5nKTtcbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChzdHJpbmcsIHJhZGl4IHx8IChyZUhhc0hleFByZWZpeC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgbiA9ICtuO1xuICAgICAgaWYgKG4gPCAxIHx8ICFzdHJpbmcgfHwgIW5hdGl2ZUlzRmluaXRlKG4pKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xuICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArICh3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IG5hdGl2ZU1pbihwb3NpdGlvbiA8IDAgPyAwIDogKCtwb3NpdGlvbiB8fCAwKSwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBzdHJpbmcubGFzdEluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgcHJvdmlkZWQgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZV0gVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGVdIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbb3RoZXJPcHRpb25zXSBFbmFibGVzIHRoZSBsZWdhY3kgYG9wdGlvbnNgIHBhcmFtIHNpZ25hdHVyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgRVMgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYFxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBvdGhlck9wdGlvbnMpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb24gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKG90aGVyT3B0aW9ucyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIG90aGVyT3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IG90aGVyT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbldpdGgoYmFzZUFzc2lnbih7fSwgb3RoZXJPcHRpb25zIHx8IG9wdGlvbnMpLCBzZXR0aW5ncywgYXNzaWduT3duRGVmYXVsdHMpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbldpdGgoYmFzZUFzc2lnbih7fSwgb3B0aW9ucy5pbXBvcnRzKSwgc2V0dGluZ3MuaW1wb3J0cywgYXNzaWduT3duRGVmYXVsdHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKCdzb3VyY2VVUkwnIGluIG9wdGlvbnNcbiAgICAgICAgICA/IG9wdGlvbnMuc291cmNlVVJMXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGU7XG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICAgICAodmFyaWFibGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAgICAgKGlzRXNjYXBpbmdcbiAgICAgICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICAgICAgOiAnJ1xuICAgICAgICApICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSkuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgY2hhcnMgPSAoY2hhcnMgKyAnJyk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKGNoYXJzTGVmdEluZGV4KHN0cmluZywgY2hhcnMpLCBjaGFyc1JpZ2h0SW5kZXgoc3RyaW5nLCBjaGFycykgKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1MZWZ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltTGVmdCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltTGVmdChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UodHJpbW1lZExlZnRJbmRleChzdHJpbmcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCAoY2hhcnMgKyAnJykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltUmlnaHQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1SaWdodCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltUmlnaHQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgY2hhcnNSaWdodEluZGV4KHN0cmluZywgKGNoYXJzICsgJycpKSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3Qgb3IgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIDI0KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmMoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/ICgrb3B0aW9ucy5sZW5ndGggfHwgMCkgOiBsZW5ndGg7XG4gICAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSArb3B0aW9ucyB8fCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChsZW5ndGggPj0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIG9taXNzaW9uLmxlbmd0aDtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIG5ld0VuZCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCAocmVGbGFncy5leGVjKHNlcGFyYXRvcikgfHwgJycpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PSBudWxsID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IsIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYCYjMzk7YCwgYW5kIGAmIzk2O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsIEhUTUxcbiAgICAgKiBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSkge1xuICAgICAgICBwYXR0ZXJuID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4gfHwgcmVXb3JkcykgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnNcbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lIHRoZVxuICAgICAqIGNyZWF0ZWQgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgXG4gICAgICogaXMgYW4gb2JqZWN0IHRoZSBjcmVhdGVkIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW5cbiAgICAgKiB0aGUgZXF1aXZhbGVudCBvYmplY3QgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBpdGVyYXRlZVxuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBfLmNhbGxiYWNrID0gXy53cmFwKF8uY2FsbGJhY2ssIGZ1bmN0aW9uKGNhbGxiYWNrLCBmdW5jLCB0aGlzQXJnKSB7XG4gICAgICogICB2YXIgbWF0Y2ggPSAvXiguKz8pX18oW2dsXXQpKC4rKSQvLmV4ZWMoZnVuYyk7XG4gICAgICogICBpZiAoIW1hdGNoKSB7XG4gICAgICogICAgIHJldHVybiBjYWxsYmFjayhmdW5jLCB0aGlzQXJnKTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgICAgcmV0dXJuIG1hdGNoWzJdID09ICdndCdcbiAgICAgKiAgICAgICA/IG9iamVjdFttYXRjaFsxXV0gPiBtYXRjaFszXVxuICAgICAqICAgICAgIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWdlX19ndDM2Jyk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgdGhpc0FyZywgZ3VhcmQpKSB7XG4gICAgICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKGZ1bmMpXG4gICAgICAgID8gbWF0Y2hlcyhmdW5jKVxuICAgICAgICA6IGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGdldHRlcigpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICogYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZvciBjb21wYXJpbmcgYSBzaW5nbGVcbiAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5tYXRjaGVzKHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgb24gYSBnaXZlblxuICAgICAqIG9iamVjdCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBfLm1hdGNoZXNQcm9wZXJ0eSgndXNlcicsICdmcmVkJykpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvbiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IF8uY29uc3RhbnQoMikgfSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiBfLmNvbnN0YW50KDEpIH0gfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmIuYycpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKF8uc29ydEJ5KG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJywgJ2MnXSkpLCAnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gcmVzdFBhcmFtKGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9uIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlIG9iamVjdCB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24gdGhlbiBtZXRob2RzIGFyZSBhZGRlZCB0b1xuICAgICAqIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIHRoZSBmdW5jdGlvbnMgYWRkZWRcbiAgICAgKiAgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNPYmogPSBpc09iamVjdChzb3VyY2UpLFxuICAgICAgICAgICAgcHJvcHMgPSBpc09iaiA/IGtleXMoc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1ldGhvZE5hbWVzID0gKHByb3BzICYmIHByb3BzLmxlbmd0aCkgPyBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICghKG1ldGhvZE5hbWVzID8gbWV0aG9kTmFtZXMubGVuZ3RoIDogaXNPYmopKSB7XG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGhvZE5hbWVzKSB7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVzW2luZGV4XSxcbiAgICAgICAgICAgIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG5cbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSAoZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGFycmF5Q29weSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfShmdW5jKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB1bmRlZmluZWRgIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIF8ubm9vcChvYmplY3QpID09PSB1bmRlZmluZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGF0IGBwYXRoYCBvbiBhXG4gICAgICogZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IDIgfSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiAxIH0gfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYi5jJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5wbHVjayhfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJywgJ2MnXSkpLCAnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkocGF0aCkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCB0b1BhdGgocGF0aCksIHBhdGggKyAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkIGl0IGlzXG4gICAgICogc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC4gSWYgYGVuZGAgaXMgbGVzcyB0aGFuIGBzdGFydGBcbiAgICAgKiBhIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIG51bWJlcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgaWYgKHN0ZXAgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6ICgrc3RlcCB8fCAwKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSArZW5kIHx8IDA7XG4gICAgICB9XG4gICAgICAvLyBVc2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlcy5cbiAgICAgIC8vIFNlZSBodHRwczovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9uIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAgICogb2YgZWFjaCBpbnZvY2F0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkaWNlUm9sbHMgPSBfLnRpbWVzKDMsIF8ucGFydGlhbChfLnJhbmRvbSwgMSwgNiwgZmFsc2UpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikge1xuICAgICAqICAgbWFnZS5jYXN0U3BlbGwobik7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gaW52b2tlcyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzIHdpdGggYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHRoaXMuY2FzdChuKTtcbiAgICAgKiB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGludm9rZXMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBuID0gbmF0aXZlRmxvb3Iobik7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgdG8gYXZvaWQgYSBKU0MgSklUIGJ1ZyBpbiBTYWZhcmkgOFxuICAgICAgLy8gd2hlcmUgYEFycmF5KDApYCBpcyB0cmVhdGVkIGFzIGBBcnJheSgxKWAuXG4gICAgICBpZiAobiA8IDEgfHwgIW5hdGl2ZUlzRmluaXRlKG4pKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSk7XG5cbiAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpZiAoaW5kZXggPCBNQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIGJhc2VUb1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gKCthdWdlbmQgfHwgMCkgKyAoK2FkZGVuZCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGBuYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGBuYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBlbXB0eSBvciBmYWxzZXlcbiAgICAgKiBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiAtSW5maW5pdHlcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKi9cbiAgICB2YXIgbWF4ID0gY3JlYXRlRXh0cmVtdW0oZ3QsIE5FR0FUSVZFX0lORklOSVRZKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgZW1wdHkgb3IgZmFsc2V5XG4gICAgICogYEluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5taW4odXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2U7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbih1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICB2YXIgbWluID0gY3JlYXRlRXh0cmVtdW0obHQsIFBPU0lUSVZFX0lORklOSVRZKTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYG5gIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDZdKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqXG4gICAgICogXy5zdW0oeyAnYSc6IDQsICdiJzogNiB9KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICduJzogNCB9LFxuICAgICAqICAgeyAnbic6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnN1bShvYmplY3RzLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgIHJldHVybiBvYmplY3QubjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnN1bShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBpdGVyYXRlZS5sZW5ndGggPT0gMVxuICAgICAgICA/IGFycmF5U3VtKGlzQXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKSwgaXRlcmF0ZWUpXG4gICAgICAgIDogYmFzZVN1bShjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgTWFwYCBjYWNoZS5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcEhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwU2V0O1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgYFNldGAgY2FjaGUuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBjYWNoZVB1c2g7XG5cbiAgICAvLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5tb2RBcmdzID0gbW9kQXJncztcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLnBhaXJzID0gcGFpcnM7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBsdWNrID0gcGx1Y2s7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJlc3RQYXJhbSA9IHJlc3RQYXJhbTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0QnlBbGwgPSBzb3J0QnlBbGw7XG4gICAgbG9kYXNoLnNvcnRCeU9yZGVyID0gc29ydEJ5T3JkZXI7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmJhY2tmbG93ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5jb21wb3NlID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gY2FsbGJhY2s7XG4gICAgbG9kYXNoLm1ldGhvZHMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLm9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICAgIGxvZGFzaC50YWlsID0gcmVzdDtcbiAgICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmRXaGVyZTtcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZExlZnQgPSBwYWRMZWZ0O1xuICAgIGxvZGFzaC5wYWRSaWdodCA9IHBhZFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUxlZnQgPSB0cmltTGVmdDtcbiAgICBsb2Rhc2gudHJpbVJpZ2h0ID0gdHJpbVJpZ2h0O1xuICAgIGxvZGFzaC50cnVuYyA9IHRydW5jO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmFsbCA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5hbnkgPSBzb21lO1xuICAgIGxvZGFzaC5jb250YWlucyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5lcSA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5oZWFkID0gZmlyc3Q7XG4gICAgbG9kYXNoLmluY2x1ZGUgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5qZWN0ID0gcmVkdWNlO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgZmFsc2UpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIGxvZGFzaC5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24obikge1xuICAgICAgaWYgKCF0aGlzLl9fY2hhaW5fXyAmJiBuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc2FtcGxlKHZhbHVlLCBuKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgICAgaWYgKGZpbHRlcmVkICYmICFpbmRleCkge1xuICAgICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4gPT0gbnVsbCA/IDEgOiBuYXRpdmVNYXgobmF0aXZlRmxvb3IobikgfHwgMCwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4ocmVzdWx0Ll9fdGFrZUNvdW50X18sIG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7ICdzaXplJzogbiwgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJykgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgIT0gTEFaWV9NQVBfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7ICdpdGVyYXRlZSc6IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKSwgJ3R5cGUnOiB0eXBlIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5maXJzdGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2ZpcnN0JywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8ucmVzdGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICdyZXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8ucGx1Y2tgIGFuZCBgXy53aGVyZWAuXG4gICAgYXJyYXlFYWNoKFsncGx1Y2snLCAnd2hlcmUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBvcGVyYXRpb25OYW1lID0gaW5kZXggPyAnZmlsdGVyJyA6ICdtYXAnLFxuICAgICAgICAgIGNyZWF0ZUNhbGxiYWNrID0gaW5kZXggPyBiYXNlTWF0Y2hlcyA6IHByb3BlcnR5O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpc1tvcGVyYXRpb25OYW1lXShjcmVhdGVDYWxsYmFjayh2YWx1ZSkpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gKCtlbmQgfHwgMCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSwgdGhpc0FyZykucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShQT1NJVElWRV9JTkZJTklUWSk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmZpcnN0fGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW3JldFVud3JhcHBlZCA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IHJldFVud3JhcHBlZCA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXRVbndyYXBwZWQgJiYgY2hhaW5BbGwpXG4gICAgICAgICAgICA/IGxvZGFzaEZ1bmModmFsdWUsIDEpWzBdXG4gICAgICAgICAgICA6IGxvZGFzaEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhY3Rpb24gPSB7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsKSB7XG4gICAgICAgICAgaWYgKG9ubHlMYXp5KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKGFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvZGFzaEZ1bmMuY2FsbCh1bmRlZmluZWQsIHRoaXMudmFsdWUoKSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ2pvaW4nLCAncG9wJywgJ3B1c2gnLCAncmVwbGFjZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICdzcGxpdCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gKC9eKD86cmVwbGFjZXxzcGxpdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gc3RyaW5nUHJvdG8gOiBhcnJheVByb3RvKVttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmpvaW58cG9wfHJlcGxhY2V8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLnZhbHVlKCksIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBmdW5jdGlvbiBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUsXG4gICAgICAgICAgICBuYW1lcyA9IHJlYWxOYW1lc1trZXldIHx8IChyZWFsTmFtZXNba2V5XSA9IFtdKTtcblxuICAgICAgICBuYW1lcy5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkV3JhcHBlcih1bmRlZmluZWQsIEJJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3sgJ25hbWUnOiAnd3JhcHBlcicsICdmdW5jJzogdW5kZWZpbmVkIH1dO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgbGF6eSB3cmFwcGVyLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbmluZyBmdW5jdGlvbnMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25jYXQgPSB3cmFwcGVyQ29uY2F0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b1N0cmluZyA9IHdyYXBwZXJUb1N0cmluZztcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJ1biA9IGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbiBhbGlhc2VzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuY29sbGVjdCA9IGxvZGFzaC5wcm90b3R5cGUubWFwO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuaGVhZCA9IGxvZGFzaC5wcm90b3R5cGUuZmlyc3Q7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5zZWxlY3QgPSBsb2Rhc2gucHJvdG90eXBlLmZpbHRlcjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRhaWwgPSBsb2Rhc2gucHJvdG90eXBlLnJlc3Q7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIGxvZGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCB0byBhdm9pZFxuICAgIC8vIGVycm9ycyBpbiBjYXNlcyB3aGVyZSBsb2Rhc2ggaXMgbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBhbmQgbm90IGludGVuZGVkXG4gICAgLy8gYXMgYW4gQU1EIG1vZHVsZS4gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yXG4gICAgLy8gbW9yZSBkZXRhaWxzLlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0LlxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzIG9yIFJpbmdvSlMuXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICB9XG4gICAgLy8gRXhwb3J0IGZvciBSaGlubyB3aXRoIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciBhIGJyb3dzZXIgb3IgUmhpbm8uXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKlxuXHRUaGlzIGlzIHJvdC5qcywgdGhlIFJPZ3VlbGlrZSBUb29sa2l0IGluIEphdmFTY3JpcHQuXG5cdFZlcnNpb24gMC42fmRldiwgZ2VuZXJhdGVkIG9uIFR1ZSBNYXIgIDMgMTE6NDI6NTAgQ0VUIDIwMTUuXG4qL1xuLyoqXG4gKiBBZGQgb2JqZWN0cyBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuICovXG53aW5kb3cgPSBnbG9iYWw7XG5kb2N1bWVudCA9IHtcblx0Ym9keToge1xuXHRcdGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkge30sXG5cdFx0c2Nyb2xsTGVmdDogMCxcblx0XHRzY3JvbGxUb3A6IDBcblx0fSxcblx0Y3JlYXRlRWxlbWVudDogZnVuY3Rpb24odHlwZSkge1xuXHRcdHZhciBjYW52YXM7XG5cdFx0cmV0dXJuIGNhbnZhcyA9IHtcblx0XHRcdGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByZWN0O1xuXHRcdFx0XHRyZXR1cm4gcmVjdCA9IHtcblx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdHRvcDogMFxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGdldENvbnRleHQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0dmFyIGNvbnRleHQ7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0ID0ge1xuXHRcdFx0XHRcdF90ZXJtY29sb3I6IG51bGwsXG5cdFx0XHRcdFx0YmVnaW5QYXRoOiBmdW5jdGlvbigpIHt9LFxuXHRcdFx0XHRcdGNhbnZhczogY2FudmFzLFxuXHRcdFx0XHRcdGRyYXdJbWFnZTogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSkge30sXG5cdFx0XHRcdFx0ZmlsbDogZnVuY3Rpb24oKSB7fSxcblx0XHRcdFx0XHRmaWxsUmVjdDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fdGVybWNvbG9yICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjbGVhckNtZCA9IHRoaXMuX3Rlcm1jb2xvci5jbGVhclRvQW5zaSh0aGlzLmZpbGxTdHlsZSk7XG5cdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNsZWFyQ21kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZpbGxTdHlsZTogXCIjMDAwXCIsXG5cdFx0XHRcdFx0ZmlsbFRleHQ6IGZ1bmN0aW9uKGNocywgeCwgeSkge30sXG5cdFx0XHRcdFx0Zm9udDogXCJtb25vc3BhY2VcIixcblx0XHRcdFx0XHRsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHt9LFxuXHRcdFx0XHRcdG1lYXN1cmVUZXh0OiBmdW5jdGlvbihjaCkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdDtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQgPSB7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAxMlxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1vdmVUbzogZnVuY3Rpb24oeCwgeSkge30sXG5cdFx0XHRcdFx0dGV4dEFsaWduOiBcImNlbnRlclwiLFxuXHRcdFx0XHRcdHRleHRCYXNlbGluZTogXCJtaWRkbGVcIlxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGhlaWdodDogMCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGxlZnQ6IFwiMTAwcHhcIixcblx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0dG9wOiBcIjEwMHB4XCIsXG5cdFx0XHRcdHZpc2liaWxpdHk6IFwiaGlkZGVuXCJcblx0XHRcdH0sXG5cdFx0XHR3aWR0aDogMFxuXHRcdH07XG5cdH0sXG5cdGRvY3VtZW50RWxlbWVudDoge1xuXHRcdHNjcm9sbExlZnQ6IDAsXG5cdFx0c2Nyb2xsVG9wOiAwXG5cdH1cbn07XG4vKipcbiAqIEBuYW1lc3BhY2UgVG9wLWxldmVsIFJPVCBuYW1lc3BhY2VcbiAqL1xudmFyIFJPVCA9IHtcblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sfSBJcyByb3QuanMgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlcj9cblx0ICovXG5cdGlzU3VwcG9ydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0ICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKTtcblx0fSxcblxuXHQvKiogRGVmYXVsdCB3aXRoIGZvciBkaXNwbGF5IGFuZCBtYXAgZ2VuZXJhdG9ycyAqL1xuXHRERUZBVUxUX1dJRFRIOiA4MCxcblx0LyoqIERlZmF1bHQgaGVpZ2h0IGZvciBkaXNwbGF5IGFuZCBtYXAgZ2VuZXJhdG9ycyAqL1xuXHRERUZBVUxUX0hFSUdIVDogMjUsXG5cblx0LyoqIERpcmVjdGlvbmFsIGNvbnN0YW50cy4gT3JkZXJpbmcgaXMgaW1wb3J0YW50ISAqL1xuXHRESVJTOiB7XG5cdFx0XCI0XCI6IFtcblx0XHRcdFsgMCwgLTFdLFxuXHRcdFx0WyAxLCAgMF0sXG5cdFx0XHRbIDAsICAxXSxcblx0XHRcdFstMSwgIDBdXG5cdFx0XSxcblx0XHRcIjhcIjogW1xuXHRcdFx0WyAwLCAtMV0sXG5cdFx0XHRbIDEsIC0xXSxcblx0XHRcdFsgMSwgIDBdLFxuXHRcdFx0WyAxLCAgMV0sXG5cdFx0XHRbIDAsICAxXSxcblx0XHRcdFstMSwgIDFdLFxuXHRcdFx0Wy0xLCAgMF0sXG5cdFx0XHRbLTEsIC0xXVxuXHRcdF0sXG5cdFx0XCI2XCI6IFtcblx0XHRcdFstMSwgLTFdLFxuXHRcdFx0WyAxLCAtMV0sXG5cdFx0XHRbIDIsICAwXSxcblx0XHRcdFsgMSwgIDFdLFxuXHRcdFx0Wy0xLCAgMV0sXG5cdFx0XHRbLTIsICAwXVxuXHRcdF1cblx0fSxcblxuXHQvKiogQ2FuY2VsIGtleS4gKi9cblx0VktfQ0FOQ0VMOiAzLCBcblx0LyoqIEhlbHAga2V5LiAqL1xuXHRWS19IRUxQOiA2LCBcblx0LyoqIEJhY2tzcGFjZSBrZXkuICovXG5cdFZLX0JBQ0tfU1BBQ0U6IDgsIFxuXHQvKiogVGFiIGtleS4gKi9cblx0VktfVEFCOiA5LCBcblx0LyoqIDUga2V5IG9uIE51bXBhZCB3aGVuIE51bUxvY2sgaXMgdW5sb2NrZWQuIE9yIG9uIE1hYywgY2xlYXIga2V5IHdoaWNoIGlzIHBvc2l0aW9uZWQgYXQgTnVtTG9jayBrZXkuICovXG5cdFZLX0NMRUFSOiAxMiwgXG5cdC8qKiBSZXR1cm4vZW50ZXIga2V5IG9uIHRoZSBtYWluIGtleWJvYXJkLiAqL1xuXHRWS19SRVRVUk46IDEzLCBcblx0LyoqIFJlc2VydmVkLCBidXQgbm90IHVzZWQuICovXG5cdFZLX0VOVEVSOiAxNCwgXG5cdC8qKiBTaGlmdCBrZXkuICovXG5cdFZLX1NISUZUOiAxNiwgXG5cdC8qKiBDb250cm9sIGtleS4gKi9cblx0VktfQ09OVFJPTDogMTcsIFxuXHQvKiogQWx0IChPcHRpb24gb24gTWFjKSBrZXkuICovXG5cdFZLX0FMVDogMTgsIFxuXHQvKiogUGF1c2Uga2V5LiAqL1xuXHRWS19QQVVTRTogMTksIFxuXHQvKiogQ2FwcyBsb2NrLiAqL1xuXHRWS19DQVBTX0xPQ0s6IDIwLCBcblx0LyoqIEVzY2FwZSBrZXkuICovXG5cdFZLX0VTQ0FQRTogMjcsIFxuXHQvKiogU3BhY2UgYmFyLiAqL1xuXHRWS19TUEFDRTogMzIsIFxuXHQvKiogUGFnZSBVcCBrZXkuICovXG5cdFZLX1BBR0VfVVA6IDMzLCBcblx0LyoqIFBhZ2UgRG93biBrZXkuICovXG5cdFZLX1BBR0VfRE9XTjogMzQsIFxuXHQvKiogRW5kIGtleS4gKi9cblx0VktfRU5EOiAzNSwgXG5cdC8qKiBIb21lIGtleS4gKi9cblx0VktfSE9NRTogMzYsIFxuXHQvKiogTGVmdCBhcnJvdy4gKi9cblx0VktfTEVGVDogMzcsIFxuXHQvKiogVXAgYXJyb3cuICovXG5cdFZLX1VQOiAzOCwgXG5cdC8qKiBSaWdodCBhcnJvdy4gKi9cblx0VktfUklHSFQ6IDM5LCBcblx0LyoqIERvd24gYXJyb3cuICovXG5cdFZLX0RPV046IDQwLCBcblx0LyoqIFByaW50IFNjcmVlbiBrZXkuICovXG5cdFZLX1BSSU5UU0NSRUVOOiA0NCwgXG5cdC8qKiBJbnMoZXJ0KSBrZXkuICovXG5cdFZLX0lOU0VSVDogNDUsIFxuXHQvKiogRGVsKGV0ZSkga2V5LiAqL1xuXHRWS19ERUxFVEU6IDQ2LCBcblx0LyoqKi9cblx0VktfMDogNDgsXG5cdC8qKiovXG5cdFZLXzE6IDQ5LFxuXHQvKioqL1xuXHRWS18yOiA1MCxcblx0LyoqKi9cblx0VktfMzogNTEsXG5cdC8qKiovXG5cdFZLXzQ6IDUyLFxuXHQvKioqL1xuXHRWS181OiA1Myxcblx0LyoqKi9cblx0VktfNjogNTQsXG5cdC8qKiovXG5cdFZLXzc6IDU1LFxuXHQvKioqL1xuXHRWS184OiA1Nixcblx0LyoqKi9cblx0VktfOTogNTcsXG5cdC8qKiBDb2xvbiAoOikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0NPTE9OOiA1OCwgXG5cdC8qKiBTZW1pY29sb24gKDspIGtleS4gKi9cblx0VktfU0VNSUNPTE9OOiA1OSwgXG5cdC8qKiBMZXNzLXRoYW4gKDwpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19MRVNTX1RIQU46IDYwLCBcblx0LyoqIEVxdWFscyAoPSkga2V5LiAqL1xuXHRWS19FUVVBTFM6IDYxLCBcblx0LyoqIEdyZWF0ZXItdGhhbiAoPikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0dSRUFURVJfVEhBTjogNjIsIFxuXHQvKiogUXVlc3Rpb24gbWFyayAoPykga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX1FVRVNUSU9OX01BUks6IDYzLCBcblx0LyoqIEF0bWFyayAoQCkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0FUOiA2NCwgXG5cdC8qKiovXG5cdFZLX0E6IDY1LFxuXHQvKioqL1xuXHRWS19COiA2Nixcblx0LyoqKi9cblx0VktfQzogNjcsXG5cdC8qKiovXG5cdFZLX0Q6IDY4LFxuXHQvKioqL1xuXHRWS19FOiA2OSxcblx0LyoqKi9cblx0VktfRjogNzAsXG5cdC8qKiovXG5cdFZLX0c6IDcxLFxuXHQvKioqL1xuXHRWS19IOiA3Mixcblx0LyoqKi9cblx0VktfSTogNzMsXG5cdC8qKiovXG5cdFZLX0o6IDc0LFxuXHQvKioqL1xuXHRWS19LOiA3NSxcblx0LyoqKi9cblx0VktfTDogNzYsXG5cdC8qKiovXG5cdFZLX006IDc3LFxuXHQvKioqL1xuXHRWS19OOiA3OCxcblx0LyoqKi9cblx0VktfTzogNzksXG5cdC8qKiovXG5cdFZLX1A6IDgwLFxuXHQvKioqL1xuXHRWS19ROiA4MSxcblx0LyoqKi9cblx0VktfUjogODIsXG5cdC8qKiovXG5cdFZLX1M6IDgzLFxuXHQvKioqL1xuXHRWS19UOiA4NCxcblx0LyoqKi9cblx0VktfVTogODUsXG5cdC8qKiovXG5cdFZLX1Y6IDg2LFxuXHQvKioqL1xuXHRWS19XOiA4Nyxcblx0LyoqKi9cblx0VktfWDogODgsXG5cdC8qKiovXG5cdFZLX1k6IDg5LFxuXHQvKioqL1xuXHRWS19aOiA5MCxcblx0LyoqKi9cblx0VktfQ09OVEVYVF9NRU5VOiA5Myxcblx0LyoqIDAgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19OVU1QQUQwOiA5NiwgXG5cdC8qKiAxIG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfTlVNUEFEMTogOTcsIFxuXHQvKiogMiBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX05VTVBBRDI6IDk4LCBcblx0LyoqIDMgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19OVU1QQUQzOiA5OSwgXG5cdC8qKiA0IG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfTlVNUEFENDogMTAwLCBcblx0LyoqIDUgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19OVU1QQUQ1OiAxMDEsIFxuXHQvKiogNiBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX05VTVBBRDY6IDEwMiwgXG5cdC8qKiA3IG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfTlVNUEFENzogMTAzLCBcblx0LyoqIDggb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19OVU1QQUQ4OiAxMDQsIFxuXHQvKiogOSBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX05VTVBBRDk6IDEwNSwgXG5cdC8qKiAqIG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfTVVMVElQTFk6IDEwNixcblx0LyoqICsgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19BREQ6IDEwNywgXG5cdC8qKiovXG5cdFZLX1NFUEFSQVRPUjogMTA4LFxuXHQvKiogLSBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX1NVQlRSQUNUOiAxMDksIFxuXHQvKiogRGVjaW1hbCBwb2ludCBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX0RFQ0lNQUw6IDExMCwgXG5cdC8qKiAvIG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfRElWSURFOiAxMTEsIFxuXHQvKiogRjEga2V5LiAqL1xuXHRWS19GMTogMTEyLCBcblx0LyoqIEYyIGtleS4gKi9cblx0VktfRjI6IDExMywgXG5cdC8qKiBGMyBrZXkuICovXG5cdFZLX0YzOiAxMTQsIFxuXHQvKiogRjQga2V5LiAqL1xuXHRWS19GNDogMTE1LCBcblx0LyoqIEY1IGtleS4gKi9cblx0VktfRjU6IDExNiwgXG5cdC8qKiBGNiBrZXkuICovXG5cdFZLX0Y2OiAxMTcsIFxuXHQvKiogRjcga2V5LiAqL1xuXHRWS19GNzogMTE4LCBcblx0LyoqIEY4IGtleS4gKi9cblx0VktfRjg6IDExOSwgXG5cdC8qKiBGOSBrZXkuICovXG5cdFZLX0Y5OiAxMjAsIFxuXHQvKiogRjEwIGtleS4gKi9cblx0VktfRjEwOiAxMjEsIFxuXHQvKiogRjExIGtleS4gKi9cblx0VktfRjExOiAxMjIsIFxuXHQvKiogRjEyIGtleS4gKi9cblx0VktfRjEyOiAxMjMsIFxuXHQvKiogRjEzIGtleS4gKi9cblx0VktfRjEzOiAxMjQsIFxuXHQvKiogRjE0IGtleS4gKi9cblx0VktfRjE0OiAxMjUsIFxuXHQvKiogRjE1IGtleS4gKi9cblx0VktfRjE1OiAxMjYsIFxuXHQvKiogRjE2IGtleS4gKi9cblx0VktfRjE2OiAxMjcsIFxuXHQvKiogRjE3IGtleS4gKi9cblx0VktfRjE3OiAxMjgsIFxuXHQvKiogRjE4IGtleS4gKi9cblx0VktfRjE4OiAxMjksIFxuXHQvKiogRjE5IGtleS4gKi9cblx0VktfRjE5OiAxMzAsIFxuXHQvKiogRjIwIGtleS4gKi9cblx0VktfRjIwOiAxMzEsIFxuXHQvKiogRjIxIGtleS4gKi9cblx0VktfRjIxOiAxMzIsIFxuXHQvKiogRjIyIGtleS4gKi9cblx0VktfRjIyOiAxMzMsIFxuXHQvKiogRjIzIGtleS4gKi9cblx0VktfRjIzOiAxMzQsIFxuXHQvKiogRjI0IGtleS4gKi9cblx0VktfRjI0OiAxMzUsIFxuXHQvKiogTnVtIExvY2sga2V5LiAqL1xuXHRWS19OVU1fTE9DSzogMTQ0LCBcblx0LyoqIFNjcm9sbCBMb2NrIGtleS4gKi9cblx0VktfU0NST0xMX0xPQ0s6IDE0NSwgXG5cdC8qKiBDaXJjdW1mbGV4ICheKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfQ0lSQ1VNRkxFWDogMTYwLCBcblx0LyoqIEV4Y2xhbWF0aW9uICghKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfRVhDTEFNQVRJT046IDE2MSwgXG5cdC8qKiBEb3VibGUgcXVvdGUgKCkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0RPVUJMRV9RVU9URTogMTYyLCBcblx0LyoqIEhhc2ggKCMpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19IQVNIOiAxNjMsIFxuXHQvKiogRG9sbGFyIHNpZ24gKCQpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19ET0xMQVI6IDE2NCwgXG5cdC8qKiBQZXJjZW50ICglKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfUEVSQ0VOVDogMTY1LCBcblx0LyoqIEFtcGVyc2FuZCAoJikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0FNUEVSU0FORDogMTY2LCBcblx0LyoqIFVuZGVyc2NvcmUgKF8pIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19VTkRFUlNDT1JFOiAxNjcsIFxuXHQvKiogT3BlbiBwYXJlbnRoZXNpcyAoKCkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX09QRU5fUEFSRU46IDE2OCwgXG5cdC8qKiBDbG9zZSBwYXJlbnRoZXNpcyAoKSkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0NMT1NFX1BBUkVOOiAxNjksIFxuXHQvKiBBc3RlcmlzayAoKikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0FTVEVSSVNLOiAxNzAsXG5cdC8qKiBQbHVzICgrKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfUExVUzogMTcxLCBcblx0LyoqIFBpcGUgKHwpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19QSVBFOiAxNzIsIFxuXHQvKiogSHlwaGVuLVVTL2RvY3MvTWludXMgKC0pIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19IWVBIRU5fTUlOVVM6IDE3MywgXG5cdC8qKiBPcGVuIGN1cmx5IGJyYWNrZXQgKHspIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19PUEVOX0NVUkxZX0JSQUNLRVQ6IDE3NCwgXG5cdC8qKiBDbG9zZSBjdXJseSBicmFja2V0ICh9KSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfQ0xPU0VfQ1VSTFlfQlJBQ0tFVDogMTc1LCBcblx0LyoqIFRpbGRlICh+KSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfVElMREU6IDE3NiwgXG5cdC8qKiBDb21tYSAoLCkga2V5LiAqL1xuXHRWS19DT01NQTogMTg4LCBcblx0LyoqIFBlcmlvZCAoLikga2V5LiAqL1xuXHRWS19QRVJJT0Q6IDE5MCwgXG5cdC8qKiBTbGFzaCAoLykga2V5LiAqL1xuXHRWS19TTEFTSDogMTkxLCBcblx0LyoqIEJhY2sgdGljayAoYCkga2V5LiAqL1xuXHRWS19CQUNLX1FVT1RFOiAxOTIsIFxuXHQvKiogT3BlbiBzcXVhcmUgYnJhY2tldCAoWykga2V5LiAqL1xuXHRWS19PUEVOX0JSQUNLRVQ6IDIxOSwgXG5cdC8qKiBCYWNrIHNsYXNoIChcXCkga2V5LiAqL1xuXHRWS19CQUNLX1NMQVNIOiAyMjAsIFxuXHQvKiogQ2xvc2Ugc3F1YXJlIGJyYWNrZXQgKF0pIGtleS4gKi9cblx0VktfQ0xPU0VfQlJBQ0tFVDogMjIxLCBcblx0LyoqIFF1b3RlICgnJycpIGtleS4gKi9cblx0VktfUVVPVEU6IDIyMiwgXG5cdC8qKiBNZXRhIGtleSBvbiBMaW51eCwgQ29tbWFuZCBrZXkgb24gTWFjLiAqL1xuXHRWS19NRVRBOiAyMjQsIFxuXHQvKiogQWx0R3Iga2V5IG9uIExpbnV4LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0FMVEdSOiAyMjUsIFxuXHQvKiogV2luZG93cyBsb2dvIGtleSBvbiBXaW5kb3dzLiBPciBTdXBlciBvciBIeXBlciBrZXkgb24gTGludXguIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfV0lOOiA5MSwgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfS0FOQTogMjEsIFxuXHQvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovXG5cdFZLX0hBTkdVTDogMjEsIFxuXHQvKiog6Iux5pWwIGtleSBvbiBKYXBhbmVzZSBNYWMga2V5Ym9hcmQuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfRUlTVTogMjIsIFxuXHQvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovXG5cdFZLX0pVTkpBOiAyMywgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfRklOQUw6IDI0LCBcblx0LyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqL1xuXHRWS19IQU5KQTogMjUsIFxuXHQvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovXG5cdFZLX0tBTkpJOiAyNSwgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfQ09OVkVSVDogMjgsIFxuXHQvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovXG5cdFZLX05PTkNPTlZFUlQ6IDI5LCBcblx0LyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqL1xuXHRWS19BQ0NFUFQ6IDMwLCBcblx0LyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqL1xuXHRWS19NT0RFQ0hBTkdFOiAzMSwgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfU0VMRUNUOiA0MSwgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfUFJJTlQ6IDQyLCBcblx0LyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqL1xuXHRWS19FWEVDVVRFOiA0MywgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC5cdCAqL1xuXHRWS19TTEVFUDogOTUgXG59O1xuLyoqXG4gKiBAbmFtZXNwYWNlXG4gKiBDb250YWlucyB0ZXh0IHRva2VuaXphdGlvbiBhbmQgYnJlYWtpbmcgcm91dGluZXNcbiAqL1xuUk9ULlRleHQgPSB7XG5cdFJFX0NPTE9SUzogLyUoW2JjXSl7KFtefV0qKX0vZyxcblxuXHQvKiB0b2tlbiB0eXBlcyAqL1xuXHRUWVBFX1RFWFQ6XHRcdDAsXG5cdFRZUEVfTkVXTElORTpcdDEsXG5cdFRZUEVfRkc6XHRcdDIsXG5cdFRZUEVfQkc6XHRcdDMsXG5cblx0LyoqXG5cdCAqIE1lYXN1cmUgc2l6ZSBvZiBhIHJlc3VsdGluZyB0ZXh0IGJsb2NrXG5cdCAqL1xuXHRtZWFzdXJlOiBmdW5jdGlvbihzdHIsIG1heFdpZHRoKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHt3aWR0aDowLCBoZWlnaHQ6MX07XG5cdFx0dmFyIHRva2VucyA9IHRoaXMudG9rZW5pemUoc3RyLCBtYXhXaWR0aCk7XG5cdFx0dmFyIGxpbmVXaWR0aCA9IDA7XG5cblx0XHRmb3IgKHZhciBpPTA7aTx0b2tlbnMubGVuZ3RoO2krKykge1xuXHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXHRcdFx0c3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdFx0XHRcdGNhc2UgdGhpcy5UWVBFX1RFWFQ6XG5cdFx0XHRcdFx0bGluZVdpZHRoICs9IHRva2VuLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSB0aGlzLlRZUEVfTkVXTElORTpcblx0XHRcdFx0XHRyZXN1bHQuaGVpZ2h0Kys7XG5cdFx0XHRcdFx0cmVzdWx0LndpZHRoID0gTWF0aC5tYXgocmVzdWx0LndpZHRoLCBsaW5lV2lkdGgpO1xuXHRcdFx0XHRcdGxpbmVXaWR0aCA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXN1bHQud2lkdGggPSBNYXRoLm1heChyZXN1bHQud2lkdGgsIGxpbmVXaWR0aCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHN0cmluZyB0byBhIHNlcmllcyBvZiBhIGZvcm1hdHRpbmcgY29tbWFuZHNcblx0ICovXG5cdHRva2VuaXplOiBmdW5jdGlvbihzdHIsIG1heFdpZHRoKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdFx0LyogZmlyc3QgdG9rZW5pemF0aW9uIHBhc3MgLSBzcGxpdCB0ZXh0cyBhbmQgY29sb3IgZm9ybWF0dGluZyBjb21tYW5kcyAqL1xuXHRcdHZhciBvZmZzZXQgPSAwO1xuXHRcdHN0ci5yZXBsYWNlKHRoaXMuUkVfQ09MT1JTLCBmdW5jdGlvbihtYXRjaCwgdHlwZSwgbmFtZSwgaW5kZXgpIHtcblx0XHRcdC8qIHN0cmluZyBiZWZvcmUgKi9cblx0XHRcdHZhciBwYXJ0ID0gc3RyLnN1YnN0cmluZyhvZmZzZXQsIGluZGV4KTtcblx0XHRcdGlmIChwYXJ0Lmxlbmd0aCkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCh7XG5cdFx0XHRcdFx0dHlwZTogUk9ULlRleHQuVFlQRV9URVhULFxuXHRcdFx0XHRcdHZhbHVlOiBwYXJ0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBjb2xvciBjb21tYW5kICovXG5cdFx0XHRyZXN1bHQucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICh0eXBlID09IFwiY1wiID8gUk9ULlRleHQuVFlQRV9GRyA6IFJPVC5UZXh0LlRZUEVfQkcpLFxuXHRcdFx0XHR2YWx1ZTogbmFtZS50cmltKClcblx0XHRcdH0pO1xuXG5cdFx0XHRvZmZzZXQgPSBpbmRleCArIG1hdGNoLmxlbmd0aDtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH0pO1xuXG5cdFx0LyogbGFzdCByZW1haW5pbmcgcGFydCAqL1xuXHRcdHZhciBwYXJ0ID0gc3RyLnN1YnN0cmluZyhvZmZzZXQpO1xuXHRcdGlmIChwYXJ0Lmxlbmd0aCkge1xuXHRcdFx0cmVzdWx0LnB1c2goe1xuXHRcdFx0XHR0eXBlOiBST1QuVGV4dC5UWVBFX1RFWFQsXG5cdFx0XHRcdHZhbHVlOiBwYXJ0XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fYnJlYWtMaW5lcyhyZXN1bHQsIG1heFdpZHRoKTtcblx0fSxcblxuXHQvKiBpbnNlcnQgbGluZSBicmVha3MgaW50byBmaXJzdC1wYXNzIHRva2VuaXplZCBkYXRhICovXG5cdF9icmVha0xpbmVzOiBmdW5jdGlvbih0b2tlbnMsIG1heFdpZHRoKSB7XG5cdFx0aWYgKCFtYXhXaWR0aCkgeyBtYXhXaWR0aCA9IEluZmluaXR5OyB9O1xuXG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBsaW5lTGVuZ3RoID0gMDtcblx0XHR2YXIgbGFzdFRva2VuV2l0aFNwYWNlID0gLTE7XG5cblx0XHR3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHsgLyogdGFrZSBhbGwgdGV4dCB0b2tlbnMsIHJlbW92ZSBzcGFjZSwgYXBwbHkgbGluZWJyZWFrcyAqL1xuXHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXHRcdFx0aWYgKHRva2VuLnR5cGUgPT0gUk9ULlRleHQuVFlQRV9ORVdMSU5FKSB7IC8qIHJlc2V0ICovXG5cdFx0XHRcdGxpbmVMZW5ndGggPSAwOyBcblx0XHRcdFx0bGFzdFRva2VuV2l0aFNwYWNlID0gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAodG9rZW4udHlwZSAhPSBST1QuVGV4dC5UWVBFX1RFWFQpIHsgLyogc2tpcCBub24tdGV4dCB0b2tlbnMgKi9cblx0XHRcdFx0aSsrO1xuXHRcdFx0XHRjb250aW51ZTsgXG5cdFx0XHR9XG5cblx0XHRcdC8qIHJlbW92ZSBzcGFjZXMgYXQgdGhlIGJlZ2lubmluZyBvZiBsaW5lICovXG5cdFx0XHR3aGlsZSAobGluZUxlbmd0aCA9PSAwICYmIHRva2VuLnZhbHVlLmNoYXJBdCgwKSA9PSBcIiBcIikgeyB0b2tlbi52YWx1ZSA9IHRva2VuLnZhbHVlLnN1YnN0cmluZygxKTsgfVxuXG5cdFx0XHQvKiBmb3JjZWQgbmV3bGluZT8gaW5zZXJ0IHR3byBuZXcgdG9rZW5zIGFmdGVyIHRoaXMgb25lICovXG5cdFx0XHR2YXIgaW5kZXggPSB0b2tlbi52YWx1ZS5pbmRleE9mKFwiXFxuXCIpO1xuXHRcdFx0aWYgKGluZGV4ICE9IC0xKSB7IFxuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IHRoaXMuX2JyZWFrSW5zaWRlVG9rZW4odG9rZW5zLCBpLCBpbmRleCwgdHJ1ZSk7IFxuXG5cdFx0XHRcdC8qIGlmIHRoZXJlIGFyZSBzcGFjZXMgYXQgdGhlIGVuZCwgd2UgbXVzdCByZW1vdmUgdGhlbSAod2UgZG8gbm90IHdhbnQgdGhlIGxpbmUgdG9vIGxvbmcpICovXG5cdFx0XHRcdHZhciBhcnIgPSB0b2tlbi52YWx1ZS5zcGxpdChcIlwiKTtcblx0XHRcdFx0d2hpbGUgKGFyclthcnIubGVuZ3RoLTFdID09IFwiIFwiKSB7IGFyci5wb3AoKTsgfVxuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IGFyci5qb2luKFwiXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiB0b2tlbiBkZWdlbmVyYXRlZD8gKi9cblx0XHRcdGlmICghdG9rZW4udmFsdWUubGVuZ3RoKSB7XG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGluZUxlbmd0aCArIHRva2VuLnZhbHVlLmxlbmd0aCA+IG1heFdpZHRoKSB7IC8qIGxpbmUgdG9vIGxvbmcsIGZpbmQgYSBzdWl0YWJsZSBicmVha2luZyBzcG90ICovXG5cblx0XHRcdFx0LyogaXMgaXQgcG9zc2libGUgdG8gYnJlYWsgd2l0aGluIHRoaXMgdG9rZW4/ICovXG5cdFx0XHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdFx0XHR3aGlsZSAoMSkge1xuXHRcdFx0XHRcdHZhciBuZXh0SW5kZXggPSB0b2tlbi52YWx1ZS5pbmRleE9mKFwiIFwiLCBpbmRleCsxKTtcblx0XHRcdFx0XHRpZiAobmV4dEluZGV4ID09IC0xKSB7IGJyZWFrOyB9XG5cdFx0XHRcdFx0aWYgKGxpbmVMZW5ndGggKyBuZXh0SW5kZXggPiBtYXhXaWR0aCkgeyBicmVhazsgfVxuXHRcdFx0XHRcdGluZGV4ID0gbmV4dEluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGluZGV4ICE9IC0xKSB7IC8qIGJyZWFrIGF0IHNwYWNlIHdpdGhpbiB0aGlzIG9uZSAqL1xuXHRcdFx0XHRcdHRva2VuLnZhbHVlID0gdGhpcy5fYnJlYWtJbnNpZGVUb2tlbih0b2tlbnMsIGksIGluZGV4LCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChsYXN0VG9rZW5XaXRoU3BhY2UgIT0gLTEpIHsgLyogaXMgdGhlcmUgYSBwcmV2aW91cyB0b2tlbiB3aGVyZSBhIGJyZWFrIGNhbiBvY2N1cj8gKi9cblx0XHRcdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbbGFzdFRva2VuV2l0aFNwYWNlXTtcblx0XHRcdFx0XHR2YXIgYnJlYWtJbmRleCA9IHRva2VuLnZhbHVlLmxhc3RJbmRleE9mKFwiIFwiKTtcblx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IHRoaXMuX2JyZWFrSW5zaWRlVG9rZW4odG9rZW5zLCBsYXN0VG9rZW5XaXRoU3BhY2UsIGJyZWFrSW5kZXgsIHRydWUpO1xuXHRcdFx0XHRcdGkgPSBsYXN0VG9rZW5XaXRoU3BhY2U7XG5cdFx0XHRcdH0gZWxzZSB7IC8qIGZvcmNlIGJyZWFrIGluIHRoaXMgdG9rZW4gKi9cblx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IHRoaXMuX2JyZWFrSW5zaWRlVG9rZW4odG9rZW5zLCBpLCBtYXhXaWR0aC1saW5lTGVuZ3RoLCBmYWxzZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHsgLyogbGluZSBub3QgbG9uZywgY29udGludWUgKi9cblx0XHRcdFx0bGluZUxlbmd0aCArPSB0b2tlbi52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdGlmICh0b2tlbi52YWx1ZS5pbmRleE9mKFwiIFwiKSAhPSAtMSkgeyBsYXN0VG9rZW5XaXRoU3BhY2UgPSBpOyB9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGkrKzsgLyogYWR2YW5jZSB0byBuZXh0IHRva2VuICovXG5cdFx0fVxuXG5cblx0XHR0b2tlbnMucHVzaCh7dHlwZTogUk9ULlRleHQuVFlQRV9ORVdMSU5FfSk7IC8qIGluc2VydCBmYWtlIG5ld2xpbmUgdG8gZml4IHRoZSBsYXN0IHRleHQgbGluZSAqL1xuXG5cdFx0LyogcmVtb3ZlIHRyYWlsaW5nIHNwYWNlIGZyb20gdGV4dCB0b2tlbnMgYmVmb3JlIG5ld2xpbmVzICovXG5cdFx0dmFyIGxhc3RUZXh0VG9rZW4gPSBudWxsO1xuXHRcdGZvciAodmFyIGk9MDtpPHRva2Vucy5sZW5ndGg7aSsrKSB7XG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cdFx0XHRzd2l0Y2ggKHRva2VuLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBST1QuVGV4dC5UWVBFX1RFWFQ6IGxhc3RUZXh0VG9rZW4gPSB0b2tlbjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgUk9ULlRleHQuVFlQRV9ORVdMSU5FOiBcblx0XHRcdFx0XHRpZiAobGFzdFRleHRUb2tlbikgeyAvKiByZW1vdmUgdHJhaWxpbmcgc3BhY2UgKi9cblx0XHRcdFx0XHRcdHZhciBhcnIgPSBsYXN0VGV4dFRva2VuLnZhbHVlLnNwbGl0KFwiXCIpO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGFyclthcnIubGVuZ3RoLTFdID09IFwiIFwiKSB7IGFyci5wb3AoKTsgfVxuXHRcdFx0XHRcdFx0bGFzdFRleHRUb2tlbi52YWx1ZSA9IGFyci5qb2luKFwiXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYXN0VGV4dFRva2VuID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG9rZW5zLnBvcCgpOyAvKiByZW1vdmUgZmFrZSB0b2tlbiAqL1xuXG5cdFx0cmV0dXJuIHRva2Vucztcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIG5ldyB0b2tlbnMgYW5kIGluc2VydCB0aGVtIGludG8gdGhlIHN0cmVhbVxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0b2tlbnNcblx0ICogQHBhcmFtIHtpbnR9IHRva2VuSW5kZXggVG9rZW4gYmVpbmcgcHJvY2Vzc2VkXG5cdCAqIEBwYXJhbSB7aW50fSBicmVha0luZGV4IEluZGV4IHdpdGhpbiBjdXJyZW50IHRva2VuJ3MgdmFsdWVcblx0ICogQHBhcmFtIHtib29sfSByZW1vdmVCcmVha0NoYXIgRG8gd2Ugd2FudCB0byByZW1vdmUgdGhlIGJyZWFraW5nIGNoYXJhY3Rlcj9cblx0ICogQHJldHVybnMge3N0cmluZ30gcmVtYWluaW5nIHVuYnJva2VuIHRva2VuIHZhbHVlXG5cdCAqL1xuXHRfYnJlYWtJbnNpZGVUb2tlbjogZnVuY3Rpb24odG9rZW5zLCB0b2tlbkluZGV4LCBicmVha0luZGV4LCByZW1vdmVCcmVha0NoYXIpIHtcblx0XHR2YXIgbmV3QnJlYWtUb2tlbiA9IHtcblx0XHRcdHR5cGU6IFJPVC5UZXh0LlRZUEVfTkVXTElORVxuXHRcdH1cblx0XHR2YXIgbmV3VGV4dFRva2VuID0ge1xuXHRcdFx0dHlwZTogUk9ULlRleHQuVFlQRV9URVhULFxuXHRcdFx0dmFsdWU6IHRva2Vuc1t0b2tlbkluZGV4XS52YWx1ZS5zdWJzdHJpbmcoYnJlYWtJbmRleCArIChyZW1vdmVCcmVha0NoYXIgPyAxIDogMCkpXG5cdFx0fVxuXHRcdHRva2Vucy5zcGxpY2UodG9rZW5JbmRleCsxLCAwLCBuZXdCcmVha1Rva2VuLCBuZXdUZXh0VG9rZW4pO1xuXHRcdHJldHVybiB0b2tlbnNbdG9rZW5JbmRleF0udmFsdWUuc3Vic3RyaW5nKDAsIGJyZWFrSW5kZXgpO1xuXHR9XG59XG4vKipcbiAqIEByZXR1cm5zIHthbnl9IFJhbmRvbWx5IHBpY2tlZCBpdGVtLCBudWxsIHdoZW4gbGVuZ3RoPTBcbiAqL1xuQXJyYXkucHJvdG90eXBlLnJhbmRvbSA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHJldHVybiB0aGlzW01hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkgKiB0aGlzLmxlbmd0aCldO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHthcnJheX0gTmV3IGFycmF5IHdpdGggcmFuZG9taXplZCBpdGVtc1xuICogRklYTUUgZGVzdHJveXMgdGhpcyFcbiAqL1xuQXJyYXkucHJvdG90eXBlLnJhbmRvbWl6ZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHdoaWxlICh0aGlzLmxlbmd0aCkge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZih0aGlzLnJhbmRvbSgpKTtcblx0XHRyZXN1bHQucHVzaCh0aGlzLnNwbGljZShpbmRleCwgMSlbMF0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEFsd2F5cyBwb3NpdGl2ZSBtb2R1bHVzXG4gKiBAcGFyYW0ge2ludH0gbiBNb2R1bHVzXG4gKiBAcmV0dXJucyB7aW50fSB0aGlzIG1vZHVsbyBuXG4gKi9cbk51bWJlci5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24obikge1xuXHRyZXR1cm4gKCh0aGlzJW4pK24pJW47XG59XG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZpcnN0IGxldHRlciBjYXBpdGFsaXplZFxuICovXG5TdHJpbmcucHJvdG90eXBlLmNhcGl0YWxpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aGlzLnN1YnN0cmluZygxKTtcbn1cblxuLyoqIFxuICogTGVmdCBwYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcmFjdGVyPVwiMFwiXVxuICogQHBhcmFtIHtpbnR9IFtjb3VudD0yXVxuICovXG5TdHJpbmcucHJvdG90eXBlLmxwYWQgPSBmdW5jdGlvbihjaGFyYWN0ZXIsIGNvdW50KSB7XG5cdHZhciBjaCA9IGNoYXJhY3RlciB8fCBcIjBcIjtcblx0dmFyIGNudCA9IGNvdW50IHx8IDI7XG5cblx0dmFyIHMgPSBcIlwiO1xuXHR3aGlsZSAocy5sZW5ndGggPCAoY250IC0gdGhpcy5sZW5ndGgpKSB7IHMgKz0gY2g7IH1cblx0cyA9IHMuc3Vic3RyaW5nKDAsIGNudC10aGlzLmxlbmd0aCk7XG5cdHJldHVybiBzK3RoaXM7XG59XG5cbi8qKiBcbiAqIFJpZ2h0IHBhZFxuICogQHBhcmFtIHtzdHJpbmd9IFtjaGFyYWN0ZXI9XCIwXCJdXG4gKiBAcGFyYW0ge2ludH0gW2NvdW50PTJdXG4gKi9cblN0cmluZy5wcm90b3R5cGUucnBhZCA9IGZ1bmN0aW9uKGNoYXJhY3RlciwgY291bnQpIHtcblx0dmFyIGNoID0gY2hhcmFjdGVyIHx8IFwiMFwiO1xuXHR2YXIgY250ID0gY291bnQgfHwgMjtcblxuXHR2YXIgcyA9IFwiXCI7XG5cdHdoaWxlIChzLmxlbmd0aCA8IChjbnQgLSB0aGlzLmxlbmd0aCkpIHsgcyArPSBjaDsgfVxuXHRzID0gcy5zdWJzdHJpbmcoMCwgY250LXRoaXMubGVuZ3RoKTtcblx0cmV0dXJuIHRoaXMrcztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBzdHJpbmcgaW4gYSBmbGV4aWJsZSB3YXkuIFNjYW5zIGZvciAlcyBzdHJpbmdzIGFuZCByZXBsYWNlcyB0aGVtIHdpdGggYXJndW1lbnRzLiBMaXN0IG9mIHBhdHRlcm5zIGlzIG1vZGlmaWFibGUgdmlhIFN0cmluZy5mb3JtYXQubWFwLlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlXG4gKiBAcGFyYW0ge2FueX0gW2FyZ3ZdXG4gKi9cblN0cmluZy5mb3JtYXQgPSBmdW5jdGlvbih0ZW1wbGF0ZSkge1xuXHR2YXIgbWFwID0gU3RyaW5nLmZvcm1hdC5tYXA7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHR2YXIgcmVwbGFjZXIgPSBmdW5jdGlvbihtYXRjaCwgZ3JvdXAxLCBncm91cDIsIGluZGV4KSB7XG5cdFx0aWYgKHRlbXBsYXRlLmNoYXJBdChpbmRleC0xKSA9PSBcIiVcIikgeyByZXR1cm4gbWF0Y2guc3Vic3RyaW5nKDEpOyB9XG5cdFx0aWYgKCFhcmdzLmxlbmd0aCkgeyByZXR1cm4gbWF0Y2g7IH1cblx0XHR2YXIgb2JqID0gYXJnc1swXTtcblxuXHRcdHZhciBncm91cCA9IGdyb3VwMSB8fCBncm91cDI7XG5cdFx0dmFyIHBhcnRzID0gZ3JvdXAuc3BsaXQoXCIsXCIpO1xuXHRcdHZhciBuYW1lID0gcGFydHMuc2hpZnQoKTtcblx0XHR2YXIgbWV0aG9kID0gbWFwW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0aWYgKCFtZXRob2QpIHsgcmV0dXJuIG1hdGNoOyB9XG5cblx0XHR2YXIgb2JqID0gYXJncy5zaGlmdCgpO1xuXHRcdHZhciByZXBsYWNlZCA9IG9ialttZXRob2RdLmFwcGx5KG9iaiwgcGFydHMpO1xuXG5cdFx0dmFyIGZpcnN0ID0gbmFtZS5jaGFyQXQoMCk7XG5cdFx0aWYgKGZpcnN0ICE9IGZpcnN0LnRvTG93ZXJDYXNlKCkpIHsgcmVwbGFjZWQgPSByZXBsYWNlZC5jYXBpdGFsaXplKCk7IH1cblxuXHRcdHJldHVybiByZXBsYWNlZDtcblx0fVxuXHRyZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvJSg/OihbYS16XSspfCg/OnsoW159XSspfSkpL2dpLCByZXBsYWNlcik7XG59XG5cblN0cmluZy5mb3JtYXQubWFwID0ge1xuXHRcInNcIjogXCJ0b1N0cmluZ1wiXG59XG5cbi8qKlxuICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gU3RyaW5nLmZvcm1hdCh0aGlzKVxuICovXG5TdHJpbmcucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdGFyZ3MudW5zaGlmdCh0aGlzKTtcblx0cmV0dXJuIFN0cmluZy5mb3JtYXQuYXBwbHkoU3RyaW5nLCBhcmdzKTtcbn1cblxuaWYgKCFPYmplY3QuY3JlYXRlKSB7ICBcblx0LyoqXG5cdCAqIEVTNSBPYmplY3QuY3JlYXRlXG5cdCAqL1xuXHRPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24obykgeyAgXG5cdFx0dmFyIHRtcCA9IGZ1bmN0aW9uKCkge307XG5cdFx0dG1wLnByb3RvdHlwZSA9IG87XG5cdFx0cmV0dXJuIG5ldyB0bXAoKTtcblx0fTsgIFxufSAgXG4vKipcbiAqIFNldHMgcHJvdG90eXBlIG9mIHRoaXMgZnVuY3Rpb24gdG8gYW4gaW5zdGFuY2Ugb2YgcGFyZW50IGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXJlbnRcbiAqL1xuRnVuY3Rpb24ucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKHBhcmVudCkge1xuXHR0aGlzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG5cdHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdGhpcztcblx0cmV0dXJuIHRoaXM7XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHR8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuXHRcdHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgZnVuY3Rpb24oY2IpIHsgcmV0dXJuIHNldFRpbWVvdXQoY2IsIDEwMDAvNjApOyB9O1xuXG5cdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XG5cdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZVxuXHRcdHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7IH07XG59XG4vKipcbiAqIEBjbGFzcyBWaXN1YWwgbWFwIGRpc3BsYXlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy53aWR0aD1ST1QuREVGQVVMVF9XSURUSF1cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5oZWlnaHQ9Uk9ULkRFRkFVTFRfSEVJR0hUXVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmZvbnRTaXplPTE1XVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZvbnRGYW1pbHk9XCJtb25vc3BhY2VcIl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mb250U3R5bGU9XCJcIl0gYm9sZC9pdGFsaWMvbm9uZS9ib3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmc9XCIjY2NjXCJdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmc9XCIjMDAwXCJdXG4gKiBAcGFyYW0ge2Zsb2F0fSBbb3B0aW9ucy5zcGFjaW5nPTFdXG4gKiBAcGFyYW0ge2Zsb2F0fSBbb3B0aW9ucy5ib3JkZXI9MF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYXlvdXQ9XCJyZWN0XCJdXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMudGlsZVdpZHRoPTMyXVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnRpbGVIZWlnaHQ9MzJdXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudGlsZU1hcD17fV1cbiAqIEBwYXJhbSB7aW1hZ2V9IFtvcHRpb25zLnRpbGVTZXQ9bnVsbF1cbiAqIEBwYXJhbSB7aW1hZ2V9IFtvcHRpb25zLnRpbGVDb2xvcml6ZT1mYWxzZV1cbiAqL1xuUk9ULkRpc3BsYXkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHR0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0dGhpcy5fZGF0YSA9IHt9O1xuXHR0aGlzLl9kaXJ0eSA9IGZhbHNlOyAvKiBmYWxzZSA9IG5vdGhpbmcsIHRydWUgPSBhbGwsIG9iamVjdCA9IGRpcnR5IGNlbGxzICovXG5cdHRoaXMuX29wdGlvbnMgPSB7fTtcblx0dGhpcy5fYmFja2VuZCA9IG51bGw7XG5cdFxuXHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0d2lkdGg6IFJPVC5ERUZBVUxUX1dJRFRILFxuXHRcdGhlaWdodDogUk9ULkRFRkFVTFRfSEVJR0hULFxuXHRcdHRyYW5zcG9zZTogZmFsc2UsXG5cdFx0bGF5b3V0OiBcInJlY3RcIixcblx0XHRmb250U2l6ZTogMTUsXG5cdFx0c3BhY2luZzogMSxcblx0XHRib3JkZXI6IDAsXG5cdFx0Zm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcblx0XHRmb250U3R5bGU6IFwiXCIsXG5cdFx0Zmc6IFwiI2NjY1wiLFxuXHRcdGJnOiBcIiMwMDBcIixcblx0XHR0aWxlV2lkdGg6IDMyLFxuXHRcdHRpbGVIZWlnaHQ6IDMyLFxuXHRcdHRpbGVNYXA6IHt9LFxuXHRcdHRpbGVTZXQ6IG51bGwsXG5cdFx0dGlsZUNvbG9yaXplOiBmYWxzZSxcblx0XHR0ZXJtQ29sb3I6IFwieHRlcm1cIlxuXHR9O1xuXHRmb3IgKHZhciBwIGluIG9wdGlvbnMpIHsgZGVmYXVsdE9wdGlvbnNbcF0gPSBvcHRpb25zW3BdOyB9XG5cdHRoaXMuc2V0T3B0aW9ucyhkZWZhdWx0T3B0aW9ucyk7XG5cdHRoaXMuREVCVUcgPSB0aGlzLkRFQlVHLmJpbmQodGhpcyk7XG5cblx0dGhpcy5fdGljayA9IHRoaXMuX3RpY2suYmluZCh0aGlzKTtcblx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xufVxuXG4vKipcbiAqIERlYnVnIGhlbHBlciwgaWRlYWwgYXMgYSBtYXAgZ2VuZXJhdG9yIGNhbGxiYWNrLiBBbHdheXMgYm91bmQgdG8gdGhpcy5cbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHBhcmFtIHtpbnR9IHdoYXRcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLkRFQlVHID0gZnVuY3Rpb24oeCwgeSwgd2hhdCkge1xuXHR2YXIgY29sb3JzID0gW3RoaXMuX29wdGlvbnMuYmcsIHRoaXMuX29wdGlvbnMuZmddO1xuXHR0aGlzLmRyYXcoeCwgeSwgbnVsbCwgbnVsbCwgY29sb3JzW3doYXQgJSBjb2xvcnMubGVuZ3RoXSk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHdob2xlIGRpc3BsYXkgKGNvdmVyIGl0IHdpdGggYmFja2dyb3VuZCBjb2xvcilcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX2RhdGEgPSB7fTtcblx0dGhpcy5fZGlydHkgPSB0cnVlO1xufVxuXG4vKipcbiAqIEBzZWUgUk9ULkRpc3BsYXlcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdGZvciAodmFyIHAgaW4gb3B0aW9ucykgeyB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsgfVxuXHRpZiAob3B0aW9ucy53aWR0aCB8fCBvcHRpb25zLmhlaWdodCB8fCBvcHRpb25zLmZvbnRTaXplIHx8IG9wdGlvbnMuZm9udEZhbWlseSB8fCBvcHRpb25zLnNwYWNpbmcgfHwgb3B0aW9ucy5sYXlvdXQpIHtcblx0XHRpZiAob3B0aW9ucy5sYXlvdXQpIHsgXG5cdFx0XHR0aGlzLl9iYWNrZW5kID0gbmV3IFJPVC5EaXNwbGF5W29wdGlvbnMubGF5b3V0LmNhcGl0YWxpemUoKV0odGhpcy5fY29udGV4dCk7XG5cdFx0fVxuXG5cdFx0dmFyIGZvbnQgPSAodGhpcy5fb3B0aW9ucy5mb250U3R5bGUgPyB0aGlzLl9vcHRpb25zLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIikgKyB0aGlzLl9vcHRpb25zLmZvbnRTaXplICsgXCJweCBcIiArIHRoaXMuX29wdGlvbnMuZm9udEZhbWlseTtcblx0XHR0aGlzLl9jb250ZXh0LmZvbnQgPSBmb250O1xuXHRcdHRoaXMuX2JhY2tlbmQuY29tcHV0ZSh0aGlzLl9vcHRpb25zKTtcblx0XHR0aGlzLl9jb250ZXh0LmZvbnQgPSBmb250O1xuXHRcdHRoaXMuX2NvbnRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHR0aGlzLl9jb250ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFJldHVybnMgY3VycmVudGx5IHNldCBvcHRpb25zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBDdXJyZW50IG9wdGlvbnMgb2JqZWN0IFxuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5fb3B0aW9ucztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSBvZiB0aGlzIGRpc3BsYXlcbiAqIEByZXR1cm5zIHtub2RlfSBET00gbm9kZVxuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9jb250ZXh0LmNhbnZhcztcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXhpbXVtIHdpZHRoL2hlaWdodCB0byBmaXQgaW50byBhIHNldCBvZiBnaXZlbiBjb25zdHJhaW50c1xuICogQHBhcmFtIHtpbnR9IGF2YWlsV2lkdGggTWF4aW11bSBhbGxvd2VkIHBpeGVsIHdpZHRoXG4gKiBAcGFyYW0ge2ludH0gYXZhaWxIZWlnaHQgTWF4aW11bSBhbGxvd2VkIHBpeGVsIGhlaWdodFxuICogQHJldHVybnMge2ludFsyXX0gY2VsbFdpZHRoLGNlbGxIZWlnaHRcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcblx0cmV0dXJuIHRoaXMuX2JhY2tlbmQuY29tcHV0ZVNpemUoYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQsIHRoaXMuX29wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIG1heGltdW0gZm9udCBzaXplIHRvIGZpdCBpbnRvIGEgc2V0IG9mIGdpdmVuIGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge2ludH0gYXZhaWxXaWR0aCBNYXhpbXVtIGFsbG93ZWQgcGl4ZWwgd2lkdGhcbiAqIEBwYXJhbSB7aW50fSBhdmFpbEhlaWdodCBNYXhpbXVtIGFsbG93ZWQgcGl4ZWwgaGVpZ2h0XG4gKiBAcmV0dXJucyB7aW50fSBmb250U2l6ZVxuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuY29tcHV0ZUZvbnRTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcblx0cmV0dXJuIHRoaXMuX2JhY2tlbmQuY29tcHV0ZUZvbnRTaXplKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0LCB0aGlzLl9vcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgRE9NIGV2ZW50IChtb3VzZSBvciB0b3VjaCkgdG8gbWFwIGNvb3JkaW5hdGVzLiBVc2VzIGZpcnN0IHRvdWNoIGZvciBtdWx0aS10b3VjaC5cbiAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnRcbiAqIEByZXR1cm5zIHtpbnRbMl19IC0xIGZvciB2YWx1ZXMgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gKi9cblJPVC5EaXNwbGF5LnByb3RvdHlwZS5ldmVudFRvUG9zaXRpb24gPSBmdW5jdGlvbihlKSB7XG5cdGlmIChlLnRvdWNoZXMpIHtcblx0XHR2YXIgeCA9IGUudG91Y2hlc1swXS5jbGllbnRYO1xuXHRcdHZhciB5ID0gZS50b3VjaGVzWzBdLmNsaWVudFk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHggPSBlLmNsaWVudFg7XG5cdFx0dmFyIHkgPSBlLmNsaWVudFk7XG5cdH1cblxuXHR2YXIgcmVjdCA9IHRoaXMuX2NvbnRleHQuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHR4IC09IHJlY3QubGVmdDtcblx0eSAtPSByZWN0LnRvcDtcblx0XG5cdGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID49IHRoaXMuX2NvbnRleHQuY2FudmFzLndpZHRoIHx8IHkgPj0gdGhpcy5fY29udGV4dC5jYW52YXMuaGVpZ2h0KSB7IHJldHVybiBbLTEsIC0xXTsgfVxuXG5cdHJldHVybiB0aGlzLl9iYWNrZW5kLmV2ZW50VG9Qb3NpdGlvbih4LCB5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ludH0geFxuICogQHBhcmFtIHtpbnR9IHlcbiAqIEBwYXJhbSB7c3RyaW5nIHx8IHN0cmluZ1tdfSBjaCBPbmUgb3IgbW9yZSBjaGFycyAod2lsbCBiZSBvdmVybGFwcGluZyB0aGVtc2VsdmVzKVxuICogQHBhcmFtIHtzdHJpbmd9IFtmZ10gZm9yZWdyb3VuZCBjb2xvclxuICogQHBhcmFtIHtzdHJpbmd9IFtiZ10gYmFja2dyb3VuZCBjb2xvclxuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHgsIHksIGNoLCBmZywgYmcpIHtcblx0aWYgKCFmZykgeyBmZyA9IHRoaXMuX29wdGlvbnMuZmc7IH1cblx0aWYgKCFiZykgeyBiZyA9IHRoaXMuX29wdGlvbnMuYmc7IH1cblx0dGhpcy5fZGF0YVt4K1wiLFwiK3ldID0gW3gsIHksIGNoLCBmZywgYmddO1xuXHRcblx0aWYgKHRoaXMuX2RpcnR5ID09PSB0cnVlKSB7IHJldHVybjsgfSAvKiB3aWxsIGFscmVhZHkgcmVkcmF3IGV2ZXJ5dGhpbmcgKi9cblx0aWYgKCF0aGlzLl9kaXJ0eSkgeyB0aGlzLl9kaXJ0eSA9IHt9OyB9IC8qIGZpcnN0ISAqL1xuXHR0aGlzLl9kaXJ0eVt4K1wiLFwiK3ldID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEcmF3cyBhIHRleHQgYXQgZ2l2ZW4gcG9zaXRpb24uIE9wdGlvbmFsbHkgd3JhcHMgYXQgYSBtYXhpbXVtIGxlbmd0aC4gQ3VycmVudGx5IGRvZXMgbm90IHdvcmsgd2l0aCBoZXggbGF5b3V0LlxuICogQHBhcmFtIHtpbnR9IHhcbiAqIEBwYXJhbSB7aW50fSB5XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBNYXkgY29udGFpbiBjb2xvci9iYWNrZ3JvdW5kIGZvcm1hdCBzcGVjaWZpZXJzLCAlY3tuYW1lfS8lYntuYW1lfSwgYm90aCBvcHRpb25hbC4gJWN7fS8lYnt9IHJlc2V0cyB0byBkZWZhdWx0LlxuICogQHBhcmFtIHtpbnR9IFttYXhXaWR0aF0gd3JhcCBhdCB3aGF0IHdpZHRoP1xuICogQHJldHVybnMge2ludH0gbGluZXMgZHJhd25cbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLmRyYXdUZXh0ID0gZnVuY3Rpb24oeCwgeSwgdGV4dCwgbWF4V2lkdGgpIHtcblx0dmFyIGZnID0gbnVsbDtcblx0dmFyIGJnID0gbnVsbDtcblx0dmFyIGN4ID0geDtcblx0dmFyIGN5ID0geTtcblx0dmFyIGxpbmVzID0gMTtcblx0aWYgKCFtYXhXaWR0aCkgeyBtYXhXaWR0aCA9IHRoaXMuX29wdGlvbnMud2lkdGgteDsgfVxuXG5cdHZhciB0b2tlbnMgPSBST1QuVGV4dC50b2tlbml6ZSh0ZXh0LCBtYXhXaWR0aCk7XG5cblx0d2hpbGUgKHRva2Vucy5sZW5ndGgpIHsgLyogaW50ZXJwcmV0IHRva2VuaXplZCBvcGNvZGUgc3RyZWFtICovXG5cdFx0dmFyIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0c3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdFx0XHRjYXNlIFJPVC5UZXh0LlRZUEVfVEVYVDpcblx0XHRcdFx0dmFyIGlzU3BhY2UgPSBpc1ByZXZTcGFjZSA9IGlzRnVsbFdpZHRoID0gaXNQcmV2RnVsbFdpZHRoID0gZmFsc2U7XG5cdFx0XHRcdGZvciAodmFyIGk9MDtpPHRva2VuLnZhbHVlLmxlbmd0aDtpKyspIHtcblx0XHRcdFx0XHR2YXIgY2MgPSB0b2tlbi52YWx1ZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0XHRcdHZhciBjID0gdG9rZW4udmFsdWUuY2hhckF0KGkpO1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB0byBgdHJ1ZWAgd2hlbiB0aGUgY3VycmVudCBjaGFyIGlzIGZ1bGwtd2lkdGguXG5cdFx0XHRcdFx0aXNGdWxsV2lkdGggPSAoY2MgPiAweGZmICYmIGNjIDwgMHhmZjYxKSB8fCAoY2MgPiAweGZmZGMgJiYgY2MgPCAweGZmZTgpICYmIGNjID4gMHhmZmVlO1xuXHRcdFx0XHRcdC8vIEN1cnJlbnQgY2hhciBpcyBzcGFjZSwgd2hhdGV2ZXIgZnVsbC13aWR0aCBvciBoYWxmLXdpZHRoIGJvdGggYXJlIE9LLlxuXHRcdFx0XHRcdGlzU3BhY2UgPSAoYy5jaGFyQ29kZUF0KDApID09IDB4MjAgfHwgYy5jaGFyQ29kZUF0KDApID09IDB4MzAwMCk7XG5cdFx0XHRcdFx0Ly8gVGhlIHByZXZpb3VzIGNoYXIgaXMgZnVsbC13aWR0aCBhbmRcblx0XHRcdFx0XHQvLyBjdXJyZW50IGNoYXIgaXMgbmV0aGVyIGhhbGYtd2lkdGggbm9yIGEgc3BhY2UuXG5cdFx0XHRcdFx0aWYgKGlzUHJldkZ1bGxXaWR0aCAmJiAhaXNGdWxsV2lkdGggJiYgIWlzU3BhY2UpIHsgY3grKzsgfSAvLyBhZGQgYW4gZXh0cmEgcG9zaXRpb25cblx0XHRcdFx0XHQvLyBUaGUgY3VycmVudCBjaGFyIGlzIGZ1bGwtd2lkdGggYW5kXG5cdFx0XHRcdFx0Ly8gdGhlIHByZXZpb3VzIGNoYXIgaXMgbm90IGEgc3BhY2UuXG5cdFx0XHRcdFx0aWYoaXNGdWxsV2lkdGggJiYgIWlzUHJldlNwYWNlKSB7IGN4Kys7IH0gLy8gYWRkIGFuIGV4dHJhIHBvc2l0aW9uXG5cdFx0XHRcdFx0dGhpcy5kcmF3KGN4KyssIGN5LCBjLCBmZywgYmcpO1xuXHRcdFx0XHRcdGlzUHJldlNwYWNlID0gaXNTcGFjZTtcblx0XHRcdFx0XHRpc1ByZXZGdWxsV2lkdGggPSBpc0Z1bGxXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUk9ULlRleHQuVFlQRV9GRzpcblx0XHRcdFx0ZmcgPSB0b2tlbi52YWx1ZSB8fCBudWxsO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUk9ULlRleHQuVFlQRV9CRzpcblx0XHRcdFx0YmcgPSB0b2tlbi52YWx1ZSB8fCBudWxsO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUk9ULlRleHQuVFlQRV9ORVdMSU5FOlxuXHRcdFx0XHRjeCA9IHg7XG5cdFx0XHRcdGN5Kys7XG5cdFx0XHRcdGxpbmVzKytcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBsaW5lcztcbn1cblxuLyoqXG4gKiBUaW1lciB0aWNrOiB1cGRhdGUgZGlydHkgcGFydHNcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24oKSB7XG5cdHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcblxuXHRpZiAoIXRoaXMuX2RpcnR5KSB7IHJldHVybjsgfVxuXG5cdGlmICh0aGlzLl9kaXJ0eSA9PT0gdHJ1ZSkgeyAvKiBkcmF3IGFsbCAqL1xuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fb3B0aW9ucy5iZztcblx0XHR0aGlzLl9jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMuX2NvbnRleHQuY2FudmFzLndpZHRoLCB0aGlzLl9jb250ZXh0LmNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZGF0YSkgeyAvKiByZWRyYXcgY2FjaGVkIGRhdGEgKi9cblx0XHRcdHRoaXMuX2RyYXcoaWQsIGZhbHNlKTtcblx0XHR9XG5cblx0fSBlbHNlIHsgLyogZHJhdyBvbmx5IGRpcnR5ICovXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX2RpcnR5KSB7XG5cdFx0XHR0aGlzLl9kcmF3KGtleSwgdHJ1ZSk7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5fZGlydHkgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFdoYXQgdG8gZHJhd1xuICogQHBhcmFtIHtib29sfSBjbGVhckJlZm9yZSBJcyBpdCBuZWNlc3NhcnkgdG8gY2xlYW4gYmVmb3JlP1xuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbihrZXksIGNsZWFyQmVmb3JlKSB7XG5cdHZhciBkYXRhID0gdGhpcy5fZGF0YVtrZXldO1xuXHRpZiAoZGF0YVs0XSAhPSB0aGlzLl9vcHRpb25zLmJnKSB7IGNsZWFyQmVmb3JlID0gdHJ1ZTsgfVxuXG5cdHRoaXMuX2JhY2tlbmQuZHJhdyhkYXRhLCBjbGVhckJlZm9yZSk7XG59XG4vKipcbiAqIEBjbGFzcyBBYnN0cmFjdCBkaXNwbGF5IGJhY2tlbmQgbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5ST1QuRGlzcGxheS5CYWNrZW5kID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbn1cblxuUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGRhdGEsIGNsZWFyQmVmb3JlKSB7XG59XG5cblJPVC5EaXNwbGF5LkJhY2tlbmQucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcbn1cblxuUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuY29tcHV0ZUZvbnRTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcbn1cblxuUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuZXZlbnRUb1Bvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xufVxuLyoqXG4gKiBAY2xhc3MgUmVjdGFuZ3VsYXIgYmFja2VuZFxuICogQHByaXZhdGVcbiAqL1xuUk9ULkRpc3BsYXkuUmVjdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0Uk9ULkRpc3BsYXkuQmFja2VuZC5jYWxsKHRoaXMsIGNvbnRleHQpO1xuXHRcblx0dGhpcy5fc3BhY2luZ1ggPSAwO1xuXHR0aGlzLl9zcGFjaW5nWSA9IDA7XG5cdHRoaXMuX2NhbnZhc0NhY2hlID0ge307XG5cdHRoaXMuX29wdGlvbnMgPSB7fTtcbn1cblJPVC5EaXNwbGF5LlJlY3QuZXh0ZW5kKFJPVC5EaXNwbGF5LkJhY2tlbmQpO1xuXG5ST1QuRGlzcGxheS5SZWN0LmNhY2hlID0gZmFsc2U7XG5cblJPVC5EaXNwbGF5LlJlY3QucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHRoaXMuX2NhbnZhc0NhY2hlID0ge307XG5cdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG5cdHZhciBjaGFyV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChcIldcIikud2lkdGgpO1xuXHR0aGlzLl9zcGFjaW5nWCA9IE1hdGguY2VpbChvcHRpb25zLnNwYWNpbmcgKiBjaGFyV2lkdGgpO1xuXHR0aGlzLl9zcGFjaW5nWSA9IE1hdGguY2VpbChvcHRpb25zLnNwYWNpbmcgKiBvcHRpb25zLmZvbnRTaXplKTtcblx0dGhpcy5fY29udGV4dC5jYW52YXMud2lkdGggPSBvcHRpb25zLndpZHRoICogdGhpcy5fc3BhY2luZ1g7XG5cdHRoaXMuX2NvbnRleHQuY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICogdGhpcy5fc3BhY2luZ1k7XG59XG5cblJPVC5EaXNwbGF5LlJlY3QucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihkYXRhLCBjbGVhckJlZm9yZSkge1xuXHRpZiAodGhpcy5jb25zdHJ1Y3Rvci5jYWNoZSkge1xuXHRcdHRoaXMuX2RyYXdXaXRoQ2FjaGUoZGF0YSwgY2xlYXJCZWZvcmUpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX2RyYXdOb0NhY2hlKGRhdGEsIGNsZWFyQmVmb3JlKTtcblx0fVxufVxuXG5ST1QuRGlzcGxheS5SZWN0LnByb3RvdHlwZS5fZHJhd1dpdGhDYWNoZSA9IGZ1bmN0aW9uKGRhdGEsIGNsZWFyQmVmb3JlKSB7XG5cdHZhciB4ID0gZGF0YVswXTtcblx0dmFyIHkgPSBkYXRhWzFdO1xuXHR2YXIgY2ggPSBkYXRhWzJdO1xuXHR2YXIgZmcgPSBkYXRhWzNdO1xuXHR2YXIgYmcgPSBkYXRhWzRdO1xuXG5cdHZhciBoYXNoID0gXCJcIitjaCtmZytiZztcblx0aWYgKGhhc2ggaW4gdGhpcy5fY2FudmFzQ2FjaGUpIHtcblx0XHR2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzQ2FjaGVbaGFzaF07XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGIgPSB0aGlzLl9vcHRpb25zLmJvcmRlcjtcblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjYW52YXMud2lkdGggPSB0aGlzLl9zcGFjaW5nWDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gdGhpcy5fc3BhY2luZ1k7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IGJnO1xuXHRcdGN0eC5maWxsUmVjdChiLCBiLCBjYW52YXMud2lkdGgtYiwgY2FudmFzLmhlaWdodC1iKTtcblx0XHRcblx0XHRpZiAoY2gpIHtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBmZztcblx0XHRcdGN0eC5mb250ID0gdGhpcy5fY29udGV4dC5mb250O1xuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblxuXHRcdFx0dmFyIGNoYXJzID0gW10uY29uY2F0KGNoKTtcblx0XHRcdGZvciAodmFyIGk9MDtpPGNoYXJzLmxlbmd0aDtpKyspIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGNoYXJzW2ldLCB0aGlzLl9zcGFjaW5nWC8yLCB0aGlzLl9zcGFjaW5nWS8yKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY2FudmFzQ2FjaGVbaGFzaF0gPSBjYW52YXM7XG5cdH1cblx0XG5cdHRoaXMuX2NvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgeCp0aGlzLl9zcGFjaW5nWCwgeSp0aGlzLl9zcGFjaW5nWSk7XG59XG5cblJPVC5EaXNwbGF5LlJlY3QucHJvdG90eXBlLl9kcmF3Tm9DYWNoZSA9IGZ1bmN0aW9uKGRhdGEsIGNsZWFyQmVmb3JlKSB7XG5cdHZhciB4ID0gZGF0YVswXTtcblx0dmFyIHkgPSBkYXRhWzFdO1xuXHR2YXIgY2ggPSBkYXRhWzJdO1xuXHR2YXIgZmcgPSBkYXRhWzNdO1xuXHR2YXIgYmcgPSBkYXRhWzRdO1xuXG5cdGlmIChjbGVhckJlZm9yZSkgeyBcblx0XHR2YXIgYiA9IHRoaXMuX29wdGlvbnMuYm9yZGVyO1xuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gYmc7XG5cdFx0dGhpcy5fY29udGV4dC5maWxsUmVjdCh4KnRoaXMuX3NwYWNpbmdYICsgYiwgeSp0aGlzLl9zcGFjaW5nWSArIGIsIHRoaXMuX3NwYWNpbmdYIC0gYiwgdGhpcy5fc3BhY2luZ1kgLSBiKTtcblx0fVxuXHRcblx0aWYgKCFjaCkgeyByZXR1cm47IH1cblxuXHR0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IGZnO1xuXG5cdHZhciBjaGFycyA9IFtdLmNvbmNhdChjaCk7XG5cdGZvciAodmFyIGk9MDtpPGNoYXJzLmxlbmd0aDtpKyspIHtcblx0XHR0aGlzLl9jb250ZXh0LmZpbGxUZXh0KGNoYXJzW2ldLCAoeCswLjUpICogdGhpcy5fc3BhY2luZ1gsICh5KzAuNSkgKiB0aGlzLl9zcGFjaW5nWSk7XG5cdH1cbn1cblxuUk9ULkRpc3BsYXkuUmVjdC5wcm90b3R5cGUuY29tcHV0ZVNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkge1xuXHR2YXIgd2lkdGggPSBNYXRoLmZsb29yKGF2YWlsV2lkdGggLyB0aGlzLl9zcGFjaW5nWCk7XG5cdHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKGF2YWlsSGVpZ2h0IC8gdGhpcy5fc3BhY2luZ1kpO1xuXHRyZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xufVxuXG5ST1QuRGlzcGxheS5SZWN0LnByb3RvdHlwZS5jb21wdXRlRm9udFNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkge1xuXHR2YXIgYm94V2lkdGggPSBNYXRoLmZsb29yKGF2YWlsV2lkdGggLyB0aGlzLl9vcHRpb25zLndpZHRoKTtcblx0dmFyIGJveEhlaWdodCA9IE1hdGguZmxvb3IoYXZhaWxIZWlnaHQgLyB0aGlzLl9vcHRpb25zLmhlaWdodCk7XG5cblx0LyogY29tcHV0ZSBjaGFyIHJhdGlvICovXG5cdHZhciBvbGRGb250ID0gdGhpcy5fY29udGV4dC5mb250O1xuXHR0aGlzLl9jb250ZXh0LmZvbnQgPSBcIjEwMHB4IFwiICsgdGhpcy5fb3B0aW9ucy5mb250RmFtaWx5O1xuXHR2YXIgd2lkdGggPSBNYXRoLmNlaWwodGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChcIldcIikud2lkdGgpO1xuXHR0aGlzLl9jb250ZXh0LmZvbnQgPSBvbGRGb250O1xuXHR2YXIgcmF0aW8gPSB3aWR0aCAvIDEwMDtcblx0XHRcblx0dmFyIHdpZHRoRnJhY3Rpb24gPSByYXRpbyAqIGJveEhlaWdodCAvIGJveFdpZHRoO1xuXHRpZiAod2lkdGhGcmFjdGlvbiA+IDEpIHsgLyogdG9vIHdpZGUgd2l0aCBjdXJyZW50IGFzcGVjdCByYXRpbyAqL1xuXHRcdGJveEhlaWdodCA9IE1hdGguZmxvb3IoYm94SGVpZ2h0IC8gd2lkdGhGcmFjdGlvbik7XG5cdH1cblx0cmV0dXJuIE1hdGguZmxvb3IoYm94SGVpZ2h0IC8gdGhpcy5fb3B0aW9ucy5zcGFjaW5nKTtcbn1cblxuUk9ULkRpc3BsYXkuUmVjdC5wcm90b3R5cGUuZXZlbnRUb1Bvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuXHRyZXR1cm4gW01hdGguZmxvb3IoeC90aGlzLl9zcGFjaW5nWCksIE1hdGguZmxvb3IoeS90aGlzLl9zcGFjaW5nWSldO1xufVxuLyoqXG4gKiBAY2xhc3MgSGV4YWdvbmFsIGJhY2tlbmRcbiAqIEBwcml2YXRlXG4gKi9cblJPVC5EaXNwbGF5LkhleCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0Uk9ULkRpc3BsYXkuQmFja2VuZC5jYWxsKHRoaXMsIGNvbnRleHQpO1xuXG5cdHRoaXMuX3NwYWNpbmdYID0gMDtcblx0dGhpcy5fc3BhY2luZ1kgPSAwO1xuXHR0aGlzLl9oZXhTaXplID0gMDtcblx0dGhpcy5fb3B0aW9ucyA9IHt9O1xufVxuUk9ULkRpc3BsYXkuSGV4LmV4dGVuZChST1QuRGlzcGxheS5CYWNrZW5kKTtcblxuUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblxuXHQvKiBGSVhNRSBjaGFyIHNpemUgY29tcHV0YXRpb24gZG9lcyBub3QgcmVzcGVjdCB0cmFuc3Bvc2VkIGhleGVzICovXG5cdHZhciBjaGFyV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChcIldcIikud2lkdGgpO1xuXHR0aGlzLl9oZXhTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnNwYWNpbmcgKiAob3B0aW9ucy5mb250U2l6ZSArIGNoYXJXaWR0aC9NYXRoLnNxcnQoMykpIC8gMik7XG5cdHRoaXMuX3NwYWNpbmdYID0gdGhpcy5faGV4U2l6ZSAqIE1hdGguc3FydCgzKSAvIDI7XG5cdHRoaXMuX3NwYWNpbmdZID0gdGhpcy5faGV4U2l6ZSAqIDEuNTtcblxuXHRpZiAob3B0aW9ucy50cmFuc3Bvc2UpIHtcblx0XHR2YXIgeHByb3AgPSBcImhlaWdodFwiO1xuXHRcdHZhciB5cHJvcCA9IFwid2lkdGhcIjtcblx0fSBlbHNlIHtcblx0XHR2YXIgeHByb3AgPSBcIndpZHRoXCI7XG5cdFx0dmFyIHlwcm9wID0gXCJoZWlnaHRcIjtcblx0fVxuXHR0aGlzLl9jb250ZXh0LmNhbnZhc1t4cHJvcF0gPSBNYXRoLmNlaWwoIChvcHRpb25zLndpZHRoICsgMSkgKiB0aGlzLl9zcGFjaW5nWCApO1xuXHR0aGlzLl9jb250ZXh0LmNhbnZhc1t5cHJvcF0gPSBNYXRoLmNlaWwoIChvcHRpb25zLmhlaWdodCAtIDEpICogdGhpcy5fc3BhY2luZ1kgKyAyKnRoaXMuX2hleFNpemUgKTtcbn1cblxuUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZGF0YSwgY2xlYXJCZWZvcmUpIHtcblx0dmFyIHggPSBkYXRhWzBdO1xuXHR2YXIgeSA9IGRhdGFbMV07XG5cdHZhciBjaCA9IGRhdGFbMl07XG5cdHZhciBmZyA9IGRhdGFbM107XG5cdHZhciBiZyA9IGRhdGFbNF07XG5cblx0dmFyIHB4ID0gW1xuXHRcdCh4KzEpICogdGhpcy5fc3BhY2luZ1gsXG5cdFx0eSAqIHRoaXMuX3NwYWNpbmdZICsgdGhpcy5faGV4U2l6ZVxuXHRdO1xuXHRpZiAodGhpcy5fb3B0aW9ucy50cmFuc3Bvc2UpIHsgcHgucmV2ZXJzZSgpOyB9XG5cblx0aWYgKGNsZWFyQmVmb3JlKSB7IFxuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gYmc7XG5cdFx0dGhpcy5fZmlsbChweFswXSwgcHhbMV0pO1xuXHR9XG5cdFxuXHRpZiAoIWNoKSB7IHJldHVybjsgfVxuXG5cdHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gZmc7XG5cblx0dmFyIGNoYXJzID0gW10uY29uY2F0KGNoKTtcblx0Zm9yICh2YXIgaT0wO2k8Y2hhcnMubGVuZ3RoO2krKykge1xuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFRleHQoY2hhcnNbaV0sIHB4WzBdLCBweFsxXSk7XG5cdH1cbn1cblxuUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5jb21wdXRlU2l6ZSA9IGZ1bmN0aW9uKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0KSB7XG5cdGlmICh0aGlzLl9vcHRpb25zLnRyYW5zcG9zZSkge1xuXHRcdGF2YWlsV2lkdGggKz0gYXZhaWxIZWlnaHQ7XG5cdFx0YXZhaWxIZWlnaHQgPSBhdmFpbFdpZHRoIC0gYXZhaWxIZWlnaHQ7XG5cdFx0YXZhaWxXaWR0aCAtPSBhdmFpbEhlaWdodDtcblx0fVxuXG5cdHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYXZhaWxXaWR0aCAvIHRoaXMuX3NwYWNpbmdYKSAtIDE7XG5cdHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKChhdmFpbEhlaWdodCAtIDIqdGhpcy5faGV4U2l6ZSkgLyB0aGlzLl9zcGFjaW5nWSArIDEpO1xuXHRyZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xufVxuXG5ST1QuRGlzcGxheS5IZXgucHJvdG90eXBlLmNvbXB1dGVGb250U2l6ZSA9IGZ1bmN0aW9uKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0KSB7XG5cdGlmICh0aGlzLl9vcHRpb25zLnRyYW5zcG9zZSkge1xuXHRcdGF2YWlsV2lkdGggKz0gYXZhaWxIZWlnaHQ7XG5cdFx0YXZhaWxIZWlnaHQgPSBhdmFpbFdpZHRoIC0gYXZhaWxIZWlnaHQ7XG5cdFx0YXZhaWxXaWR0aCAtPSBhdmFpbEhlaWdodDtcblx0fVxuXG5cdHZhciBoZXhTaXplV2lkdGggPSAyKmF2YWlsV2lkdGggLyAoKHRoaXMuX29wdGlvbnMud2lkdGgrMSkgKiBNYXRoLnNxcnQoMykpIC0gMTtcblx0dmFyIGhleFNpemVIZWlnaHQgPSBhdmFpbEhlaWdodCAvICgyICsgMS41Kih0aGlzLl9vcHRpb25zLmhlaWdodC0xKSk7XG5cdHZhciBoZXhTaXplID0gTWF0aC5taW4oaGV4U2l6ZVdpZHRoLCBoZXhTaXplSGVpZ2h0KTtcblxuXHQvKiBjb21wdXRlIGNoYXIgcmF0aW8gKi9cblx0dmFyIG9sZEZvbnQgPSB0aGlzLl9jb250ZXh0LmZvbnQ7XG5cdHRoaXMuX2NvbnRleHQuZm9udCA9IFwiMTAwcHggXCIgKyB0aGlzLl9vcHRpb25zLmZvbnRGYW1pbHk7XG5cdHZhciB3aWR0aCA9IE1hdGguY2VpbCh0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KFwiV1wiKS53aWR0aCk7XG5cdHRoaXMuX2NvbnRleHQuZm9udCA9IG9sZEZvbnQ7XG5cdHZhciByYXRpbyA9IHdpZHRoIC8gMTAwO1xuXG5cdGhleFNpemUgPSBNYXRoLmZsb29yKGhleFNpemUpKzE7IC8qIGNsb3Nlc3QgbGFyZ2VyIGhleFNpemUgKi9cblxuXHQvKiBGSVhNRSBjaGFyIHNpemUgY29tcHV0YXRpb24gZG9lcyBub3QgcmVzcGVjdCB0cmFuc3Bvc2VkIGhleGVzICovXG5cdHZhciBmb250U2l6ZSA9IDIqaGV4U2l6ZSAvICh0aGlzLl9vcHRpb25zLnNwYWNpbmcgKiAoMSArIHJhdGlvIC8gTWF0aC5zcXJ0KDMpKSk7XG5cblx0LyogY2xvc2VzdCBzbWFsbGVyIGZvbnRTaXplICovXG5cdHJldHVybiBNYXRoLmNlaWwoZm9udFNpemUpLTE7XG59XG5cblJPVC5EaXNwbGF5LkhleC5wcm90b3R5cGUuZXZlbnRUb1Bvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuXHRpZiAodGhpcy5fb3B0aW9ucy50cmFuc3Bvc2UpIHtcblx0XHR4ICs9IHk7XG5cdFx0eSA9IHgteTtcblx0XHR4IC09IHk7XG5cdFx0dmFyIHByb3AgPSBcIndpZHRoXCI7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHByb3AgPSBcImhlaWdodFwiO1xuXHR9XG5cdHZhciBzaXplID0gdGhpcy5fY29udGV4dC5jYW52YXNbcHJvcF0gLyB0aGlzLl9vcHRpb25zW3Byb3BdO1xuXHR5ID0gTWF0aC5mbG9vcih5L3NpemUpO1xuXG5cdGlmICh5Lm1vZCgyKSkgeyAvKiBvZGQgcm93ICovXG5cdFx0eCAtPSB0aGlzLl9zcGFjaW5nWDtcblx0XHR4ID0gMSArIDIqTWF0aC5mbG9vcih4LygyKnRoaXMuX3NwYWNpbmdYKSk7XG5cdH0gZWxzZSB7XG5cdFx0eCA9IDIqTWF0aC5mbG9vcih4LygyKnRoaXMuX3NwYWNpbmdYKSk7XG5cdH1cblx0XG5cdHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGFyZSBwaXhlbCB2YWx1ZXMuIElmIFwidHJhbnNwb3NlZFwiIG1vZGUgaXMgZW5hYmxlZCwgdGhlbiB0aGVzZSB0d28gYXJlIGFscmVhZHkgc3dhcHBlZC5cbiAqL1xuUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5fZmlsbCA9IGZ1bmN0aW9uKGN4LCBjeSkge1xuXHR2YXIgYSA9IHRoaXMuX2hleFNpemU7XG5cdHZhciBiID0gdGhpcy5fb3B0aW9ucy5ib3JkZXI7XG5cdFxuXHR0aGlzLl9jb250ZXh0LmJlZ2luUGF0aCgpO1xuXG5cdGlmICh0aGlzLl9vcHRpb25zLnRyYW5zcG9zZSkge1xuXHRcdHRoaXMuX2NvbnRleHQubW92ZVRvKGN4LWErYixcdGN5KTtcblx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyhjeC1hLzIrYixcdGN5K3RoaXMuX3NwYWNpbmdYLWIpO1xuXHRcdHRoaXMuX2NvbnRleHQubGluZVRvKGN4K2EvMi1iLFx0Y3krdGhpcy5fc3BhY2luZ1gtYik7XG5cdFx0dGhpcy5fY29udGV4dC5saW5lVG8oY3grYS1iLFx0Y3kpO1xuXHRcdHRoaXMuX2NvbnRleHQubGluZVRvKGN4K2EvMi1iLFx0Y3ktdGhpcy5fc3BhY2luZ1grYik7XG5cdFx0dGhpcy5fY29udGV4dC5saW5lVG8oY3gtYS8yK2IsXHRjeS10aGlzLl9zcGFjaW5nWCtiKTtcblx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyhjeC1hK2IsXHRjeSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fY29udGV4dC5tb3ZlVG8oY3gsXHRcdFx0XHRcdGN5LWErYik7XG5cdFx0dGhpcy5fY29udGV4dC5saW5lVG8oY3grdGhpcy5fc3BhY2luZ1gtYixcdGN5LWEvMitiKTtcblx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCt0aGlzLl9zcGFjaW5nWC1iLFx0Y3krYS8yLWIpO1xuXHRcdHRoaXMuX2NvbnRleHQubGluZVRvKGN4LFx0XHRcdFx0XHRjeSthLWIpO1xuXHRcdHRoaXMuX2NvbnRleHQubGluZVRvKGN4LXRoaXMuX3NwYWNpbmdYK2IsXHRjeSthLzItYik7XG5cdFx0dGhpcy5fY29udGV4dC5saW5lVG8oY3gtdGhpcy5fc3BhY2luZ1grYixcdGN5LWEvMitiKTtcblx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCxcdFx0XHRcdFx0Y3ktYStiKTtcblx0fVxuXHR0aGlzLl9jb250ZXh0LmZpbGwoKTtcbn1cbi8qKlxuICogQGNsYXNzIFRpbGUgYmFja2VuZFxuICogQHByaXZhdGVcbiAqL1xuUk9ULkRpc3BsYXkuVGlsZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0Uk9ULkRpc3BsYXkuUmVjdC5jYWxsKHRoaXMsIGNvbnRleHQpO1xuXHRcblx0dGhpcy5fb3B0aW9ucyA9IHt9O1xuXHR0aGlzLl9jb2xvckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG59XG5ST1QuRGlzcGxheS5UaWxlLmV4dGVuZChST1QuRGlzcGxheS5SZWN0KTtcblxuUk9ULkRpc3BsYXkuVGlsZS5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0dGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cdHRoaXMuX2NvbnRleHQuY2FudmFzLndpZHRoID0gb3B0aW9ucy53aWR0aCAqIG9wdGlvbnMudGlsZVdpZHRoO1xuXHR0aGlzLl9jb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCAqIG9wdGlvbnMudGlsZUhlaWdodDtcblx0dGhpcy5fY29sb3JDYW52YXMud2lkdGggPSBvcHRpb25zLnRpbGVXaWR0aDtcblx0dGhpcy5fY29sb3JDYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy50aWxlSGVpZ2h0O1xufVxuXG5ST1QuRGlzcGxheS5UaWxlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZGF0YSwgY2xlYXJCZWZvcmUpIHtcblx0dmFyIHggPSBkYXRhWzBdO1xuXHR2YXIgeSA9IGRhdGFbMV07XG5cdHZhciBjaCA9IGRhdGFbMl07XG5cdHZhciBmZyA9IGRhdGFbM107XG5cdHZhciBiZyA9IGRhdGFbNF07XG5cblx0dmFyIHRpbGVXaWR0aCA9IHRoaXMuX29wdGlvbnMudGlsZVdpZHRoO1xuXHR2YXIgdGlsZUhlaWdodCA9IHRoaXMuX29wdGlvbnMudGlsZUhlaWdodDtcblxuXHRpZiAoY2xlYXJCZWZvcmUpIHtcblx0XHR2YXIgYiA9IHRoaXMuX29wdGlvbnMuYm9yZGVyO1xuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gYmc7XG5cblx0XHRpZiAodGhpcy5fb3B0aW9ucy50aWxlQ29sb3IpIHt0aGlzLl9jb250ZXh0LmNsZWFyUmVjdCh4KnRpbGVXaWR0aCwgeSp0aWxlSGVpZ2h0LCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpO30gZWxzZSB7XG5cdFx0XHR0aGlzLl9jb250ZXh0LmZpbGxSZWN0KHgqdGlsZVdpZHRoLCB5KnRpbGVIZWlnaHQsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCk7XG5cdFx0fVxuXHRcdFxuXHR9XG5cblx0aWYgKCFjaCkgeyByZXR1cm47IH1cblxuXHR2YXIgY2hhcnMgPSBbXS5jb25jYXQoY2gpO1xuXHRmb3IgKHZhciBpPTA7aTxjaGFycy5sZW5ndGg7aSsrKSB7XG5cdFx0dmFyIHRpbGUgPSB0aGlzLl9vcHRpb25zLnRpbGVNYXBbY2hhcnNbaV1dO1xuXHRcdGlmICghdGlsZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDaGFyICdcIiArIGNoYXJzW2ldICsgXCInIG5vdCBmb3VuZCBpbiB0aWxlTWFwXCIpOyB9XG5cdFx0XG5cdFx0aWYgKHRoaXMuX29wdGlvbnMudGlsZUNvbG9yaXplKSB7IC8qIGFwcGx5IGNvbG9yaXphdGlvbiAqL1xuXHRcdFx0dmFyIGNhbnZhcyA9IHRoaXMuX2NvbG9yQ2FudmFzO1xuXHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdFx0Y29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KTtcblxuXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoXG5cdFx0XHRcdHRoaXMuX29wdGlvbnMudGlsZVNldCxcblx0XHRcdFx0dGlsZVswXSwgdGlsZVsxXSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LFxuXHRcdFx0XHQwLCAwLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHRcblx0XHRcdCk7XG5cblx0XHRcdGlmIChmZyAhPSBcInRyYW5zcGFyZW50XCIpIHtcblx0XHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBmZztcblx0XHRcdFx0Y29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1hdG9wXCI7XG5cdFx0XHRcdGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJnICE9IFwidHJhbnNwYXJlbnRcIikge1xuXHRcdFx0XHRjb250ZXh0LmZpbGxTdHlsZSA9IGJnO1xuXHRcdFx0XHRjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tb3ZlclwiO1xuXHRcdFx0XHRjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2NvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgeCp0aWxlV2lkdGgsIHkqdGlsZUhlaWdodCwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KTtcblxuXHRcdH0gZWxzZSB7IC8qIG5vIGNvbG9yaXppbmcsIGVhc3kgKi9cblx0XHRcdHRoaXMuX2NvbnRleHQuZHJhd0ltYWdlKFxuXHRcdFx0XHR0aGlzLl9vcHRpb25zLnRpbGVTZXQsXG5cdFx0XHRcdHRpbGVbMF0sIHRpbGVbMV0sIHRpbGVXaWR0aCwgdGlsZUhlaWdodCxcblx0XHRcdFx0eCp0aWxlV2lkdGgsIHkqdGlsZUhlaWdodCwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufVxuXG5ST1QuRGlzcGxheS5UaWxlLnByb3RvdHlwZS5jb21wdXRlU2l6ZSA9IGZ1bmN0aW9uKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0KSB7XG5cdHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYXZhaWxXaWR0aCAvIHRoaXMuX29wdGlvbnMudGlsZVdpZHRoKTtcblx0dmFyIGhlaWdodCA9IE1hdGguZmxvb3IoYXZhaWxIZWlnaHQgLyB0aGlzLl9vcHRpb25zLnRpbGVIZWlnaHQpO1xuXHRyZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xufVxuXG5ST1QuRGlzcGxheS5UaWxlLnByb3RvdHlwZS5jb21wdXRlRm9udFNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkge1xuXHR2YXIgd2lkdGggPSBNYXRoLmZsb29yKGF2YWlsV2lkdGggLyB0aGlzLl9vcHRpb25zLndpZHRoKTtcblx0dmFyIGhlaWdodCA9IE1hdGguZmxvb3IoYXZhaWxIZWlnaHQgLyB0aGlzLl9vcHRpb25zLmhlaWdodCk7XG5cdHJldHVybiBbd2lkdGgsIGhlaWdodF07XG59XG5cblJPVC5EaXNwbGF5LlRpbGUucHJvdG90eXBlLmV2ZW50VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0cmV0dXJuIFtNYXRoLmZsb29yKHgvdGhpcy5fb3B0aW9ucy50aWxlV2lkdGgpLCBNYXRoLmZsb29yKHkvdGhpcy5fb3B0aW9ucy50aWxlSGVpZ2h0KV07XG59XG4vKipcbiAqIEBuYW1lc3BhY2VcbiAqIFRoaXMgY29kZSBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBBbGVhIGFsZ29yaXRobTsgKEMpIDIwMTAgSm9oYW5uZXMgQmFhZ8O4ZS5cbiAqIEFsZWEgaXMgbGljZW5zZWQgYWNjb3JkaW5nIHRvIHRoZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlLlxuICovXG5ST1QuUk5HID0ge1xuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcn0gXG5cdCAqL1xuXHRnZXRTZWVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VlZDtcblx0fSxcblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZWQgU2VlZCB0aGUgbnVtYmVyIGdlbmVyYXRvclxuXHQgKi9cblx0c2V0U2VlZDogZnVuY3Rpb24oc2VlZCkge1xuXHRcdHNlZWQgPSAoc2VlZCA8IDEgPyAxL3NlZWQgOiBzZWVkKTtcblxuXHRcdHRoaXMuX3NlZWQgPSBzZWVkO1xuXHRcdHRoaXMuX3MwID0gKHNlZWQgPj4+IDApICogdGhpcy5fZnJhYztcblxuXHRcdHNlZWQgPSAoc2VlZCo2OTA2OSArIDEpID4+PiAwO1xuXHRcdHRoaXMuX3MxID0gc2VlZCAqIHRoaXMuX2ZyYWM7XG5cblx0XHRzZWVkID0gKHNlZWQqNjkwNjkgKyAxKSA+Pj4gMDtcblx0XHR0aGlzLl9zMiA9IHNlZWQgKiB0aGlzLl9mcmFjO1xuXG5cdFx0dGhpcy5fYyA9IDE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtmbG9hdH0gUHNldWRvcmFuZG9tIHZhbHVlIFswLDEpLCB1bmlmb3JtbHkgZGlzdHJpYnV0ZWRcblx0ICovXG5cdGdldFVuaWZvcm06IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ID0gMjA5MTYzOSAqIHRoaXMuX3MwICsgdGhpcy5fYyAqIHRoaXMuX2ZyYWM7XG5cdFx0dGhpcy5fczAgPSB0aGlzLl9zMTtcblx0XHR0aGlzLl9zMSA9IHRoaXMuX3MyO1xuXHRcdHRoaXMuX2MgPSB0IHwgMDtcblx0XHR0aGlzLl9zMiA9IHQgLSB0aGlzLl9jO1xuXHRcdHJldHVybiB0aGlzLl9zMjtcblx0fSxcblxuXHQvKipcblx0ICogQHBhcmFtIHtpbnR9IGxvd2VyQm91bmQgVGhlIGxvd2VyIGVuZCBvZiB0aGUgcmFuZ2UgdG8gcmV0dXJuIGEgdmFsdWUgZnJvbSwgaW5jbHVzaXZlXG5cdCAqIEBwYXJhbSB7aW50fSB1cHBlckJvdW5kIFRoZSB1cHBlciBlbmQgb2YgdGhlIHJhbmdlIHRvIHJldHVybiBhIHZhbHVlIGZyb20sIGluY2x1c2l2ZVxuXHQgKiBAcmV0dXJucyB7aW50fSBQc2V1ZG9yYW5kb20gdmFsdWUgW2xvd2VyQm91bmQsIHVwcGVyQm91bmRdLCB1c2luZyBST1QuUk5HLmdldFVuaWZvcm0oKSB0byBkaXN0cmlidXRlIHRoZSB2YWx1ZVxuXHQgKi9cblx0Z2V0VW5pZm9ybUludDogZnVuY3Rpb24obG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuXHRcdHZhciBtYXggPSBNYXRoLm1heChsb3dlckJvdW5kLCB1cHBlckJvdW5kKTtcblx0XHR2YXIgbWluID0gTWF0aC5taW4obG93ZXJCb3VuZCwgdXBwZXJCb3VuZCk7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IodGhpcy5nZXRVbmlmb3JtKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2Zsb2F0fSBbbWVhbj0wXSBNZWFuIHZhbHVlXG5cdCAqIEBwYXJhbSB7ZmxvYXR9IFtzdGRkZXY9MV0gU3RhbmRhcmQgZGV2aWF0aW9uLiB+OTUlIG9mIHRoZSBhYnNvbHV0ZSB2YWx1ZXMgd2lsbCBiZSBsb3dlciB0aGFuIDIqc3RkZGV2LlxuXHQgKiBAcmV0dXJucyB7ZmxvYXR9IEEgbm9ybWFsbHkgZGlzdHJpYnV0ZWQgcHNldWRvcmFuZG9tIHZhbHVlXG5cdCAqL1xuXHRnZXROb3JtYWw6IGZ1bmN0aW9uKG1lYW4sIHN0ZGRldikge1xuXHRcdGRvIHtcblx0XHRcdHZhciB1ID0gMip0aGlzLmdldFVuaWZvcm0oKS0xO1xuXHRcdFx0dmFyIHYgPSAyKnRoaXMuZ2V0VW5pZm9ybSgpLTE7XG5cdFx0XHR2YXIgciA9IHUqdSArIHYqdjtcblx0XHR9IHdoaWxlIChyID4gMSB8fCByID09IDApO1xuXG5cdFx0dmFyIGdhdXNzID0gdSAqIE1hdGguc3FydCgtMipNYXRoLmxvZyhyKS9yKTtcblx0XHRyZXR1cm4gKG1lYW4gfHwgMCkgKyBnYXVzcyooc3RkZGV2IHx8IDEpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7aW50fSBQc2V1ZG9yYW5kb20gdmFsdWUgWzEsMTAwXSBpbmNsdXNpdmUsIHVuaWZvcm1seSBkaXN0cmlidXRlZFxuXHQgKi9cblx0Z2V0UGVyY2VudGFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIDEgKyBNYXRoLmZsb29yKHRoaXMuZ2V0VW5pZm9ybSgpKjEwMCk7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEga2V5PXdoYXRldmVyLCB2YWx1ZT13ZWlnaHQgKHJlbGF0aXZlIHByb2JhYmlsaXR5KVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSB3aGF0ZXZlclxuXHQgKi9cblx0Z2V0V2VpZ2h0ZWRWYWx1ZTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdHZhciBhdmFpbCA9IFtdO1xuXHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaWQgaW4gZGF0YSkge1xuXHRcdFx0dG90YWwgKz0gZGF0YVtpZF07XG5cdFx0fVxuXHRcdHZhciByYW5kb20gPSBNYXRoLmZsb29yKHRoaXMuZ2V0VW5pZm9ybSgpKnRvdGFsKTtcblx0XHRcblx0XHR2YXIgcGFydCA9IDA7XG5cdFx0Zm9yICh2YXIgaWQgaW4gZGF0YSkge1xuXHRcdFx0cGFydCArPSBkYXRhW2lkXTtcblx0XHRcdGlmIChyYW5kb20gPCBwYXJ0KSB7IHJldHVybiBpZDsgfVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IFJORyBzdGF0ZS4gVXNlZnVsIGZvciBzdG9yaW5nIHRoZSBzdGF0ZSBhbmQgcmUtc2V0dGluZyBpdCB2aWEgc2V0U3RhdGUuXG5cdCAqIEByZXR1cm5zIHs/fSBJbnRlcm5hbCBzdGF0ZVxuXHQgKi9cblx0Z2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbdGhpcy5fczAsIHRoaXMuX3MxLCB0aGlzLl9zMiwgdGhpcy5fY107XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBhIHByZXZpb3VzbHkgcmV0cmlldmVkIHN0YXRlLlxuXHQgKiBAcGFyYW0gez99IHN0YXRlXG5cdCAqL1xuXHRzZXRTdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcblx0XHR0aGlzLl9zMCA9IHN0YXRlWzBdO1xuXHRcdHRoaXMuX3MxID0gc3RhdGVbMV07XG5cdFx0dGhpcy5fczIgPSBzdGF0ZVsyXTtcblx0XHR0aGlzLl9jICA9IHN0YXRlWzNdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmVkIFJOR1xuXHQgKi9cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjbG9uZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG5cdFx0Y2xvbmUuc2V0U3RhdGUodGhpcy5nZXRTdGF0ZSgpKTtcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0X3MwOiAwLFxuXHRfczE6IDAsXG5cdF9zMjogMCxcblx0X2M6IDAsXG5cdF9mcmFjOiAyLjMyODMwNjQzNjUzODY5NjNlLTEwIC8qIDJeLTMyICovXG59XG5cblJPVC5STkcuc2V0U2VlZChEYXRlLm5vdygpKTtcbi8qKlxuICogQGNsYXNzIChNYXJrb3YgcHJvY2VzcyktYmFzZWQgc3RyaW5nIGdlbmVyYXRvci4gXG4gKiBDb3BpZWQgZnJvbSBhIDxhIGhyZWY9XCJodHRwOi8vd3d3LnJvZ3VlYmFzaW4ucm9ndWVsaWtlZGV2ZWxvcG1lbnQub3JnL2luZGV4LnBocD90aXRsZT1OYW1lc19mcm9tX2FfaGlnaF9vcmRlcl9NYXJrb3ZfUHJvY2Vzc19hbmRfYV9zaW1wbGlmaWVkX0thdHpfYmFjay1vZmZfc2NoZW1lXCI+Um9ndWVCYXNpbiBhcnRpY2xlPC9hPi4gXG4gKiBPZmZlcnMgY29uZmlndXJhYmxlIG9yZGVyIGFuZCBwcmlvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbH0gW29wdGlvbnMud29yZHM9ZmFsc2VdIFVzZSB3b3JkIG1vZGU/XG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMub3JkZXI9M11cbiAqIEBwYXJhbSB7ZmxvYXR9IFtvcHRpb25zLnByaW9yPTAuMDAxXVxuICovXG5ST1QuU3RyaW5nR2VuZXJhdG9yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHR0aGlzLl9vcHRpb25zID0ge1xuXHRcdHdvcmRzOiBmYWxzZSxcblx0XHRvcmRlcjogMyxcblx0XHRwcmlvcjogMC4wMDFcblx0fVxuXHRmb3IgKHZhciBwIGluIG9wdGlvbnMpIHsgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07IH1cblxuXHR0aGlzLl9ib3VuZGFyeSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7XG5cdHRoaXMuX3N1ZmZpeCA9IHRoaXMuX2JvdW5kYXJ5O1xuXHR0aGlzLl9wcmVmaXggPSBbXTtcblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fb3B0aW9ucy5vcmRlcjtpKyspIHsgdGhpcy5fcHJlZml4LnB1c2godGhpcy5fYm91bmRhcnkpOyB9XG5cblx0dGhpcy5fcHJpb3JWYWx1ZXMgPSB7fTtcblx0dGhpcy5fcHJpb3JWYWx1ZXNbdGhpcy5fYm91bmRhcnldID0gdGhpcy5fb3B0aW9ucy5wcmlvcjtcblxuXHR0aGlzLl9kYXRhID0ge307XG59XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsZWFybmluZyBkYXRhXG4gKi9cblJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX2RhdGEgPSB7fTtcblx0dGhpcy5fcHJpb3JWYWx1ZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBHZW5lcmF0ZWQgc3RyaW5nXG4gKi9cblJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24oKSB7XG5cdHZhciByZXN1bHQgPSBbdGhpcy5fc2FtcGxlKHRoaXMuX3ByZWZpeCldO1xuXHR3aGlsZSAocmVzdWx0W3Jlc3VsdC5sZW5ndGgtMV0gIT0gdGhpcy5fYm91bmRhcnkpIHtcblx0XHRyZXN1bHQucHVzaCh0aGlzLl9zYW1wbGUocmVzdWx0KSk7XG5cdH1cblx0cmV0dXJuIHRoaXMuX2pvaW4ocmVzdWx0LnNsaWNlKDAsIC0xKSk7XG59XG5cbi8qKlxuICogT2JzZXJ2ZSAobGVhcm4pIGEgc3RyaW5nIGZyb20gYSB0cmFpbmluZyBzZXRcbiAqL1xuUk9ULlN0cmluZ0dlbmVyYXRvci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHR2YXIgdG9rZW5zID0gdGhpcy5fc3BsaXQoc3RyaW5nKTtcblxuXHRmb3IgKHZhciBpPTA7IGk8dG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhpcy5fcHJpb3JWYWx1ZXNbdG9rZW5zW2ldXSA9IHRoaXMuX29wdGlvbnMucHJpb3I7XG5cdH1cblxuXHR0b2tlbnMgPSB0aGlzLl9wcmVmaXguY29uY2F0KHRva2VucykuY29uY2F0KHRoaXMuX3N1ZmZpeCk7IC8qIGFkZCBib3VuZGFyeSBzeW1ib2xzICovXG5cblx0Zm9yICh2YXIgaT10aGlzLl9vcHRpb25zLm9yZGVyOyBpPHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjb250ZXh0ID0gdG9rZW5zLnNsaWNlKGktdGhpcy5fb3B0aW9ucy5vcmRlciwgaSk7XG5cdFx0dmFyIGV2ZW50ID0gdG9rZW5zW2ldO1xuXHRcdGZvciAodmFyIGo9MDsgajxjb250ZXh0Lmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgc3ViY29udGV4dCA9IGNvbnRleHQuc2xpY2Uoaik7XG5cdFx0XHR0aGlzLl9vYnNlcnZlRXZlbnQoc3ViY29udGV4dCwgZXZlbnQpO1xuXHRcdH1cblx0fVxufVxuXG5ST1QuU3RyaW5nR2VuZXJhdG9yLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcGFydHMgPSBbXTtcblxuXHR2YXIgcHJpb3JDb3VudCA9IDA7XG5cdGZvciAodmFyIHAgaW4gdGhpcy5fcHJpb3JWYWx1ZXMpIHsgcHJpb3JDb3VudCsrOyB9XG5cdHByaW9yQ291bnQtLTsgLyogYm91bmRhcnkgKi9cblx0cGFydHMucHVzaChcImRpc3RpbmN0IHNhbXBsZXM6IFwiICsgcHJpb3JDb3VudCk7XG5cblx0dmFyIGRhdGFDb3VudCA9IDA7XG5cdHZhciBldmVudENvdW50ID0gMDtcblx0Zm9yICh2YXIgcCBpbiB0aGlzLl9kYXRhKSB7IFxuXHRcdGRhdGFDb3VudCsrOyBcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fZGF0YVtwXSkge1xuXHRcdFx0ZXZlbnRDb3VudCsrO1xuXHRcdH1cblx0fVxuXHRwYXJ0cy5wdXNoKFwiZGljdGlvbmFyeSBzaXplIChjb250ZXh0cyk6IFwiICsgZGF0YUNvdW50KTtcblx0cGFydHMucHVzaChcImRpY3Rpb25hcnkgc2l6ZSAoZXZlbnRzKTogXCIgKyBldmVudENvdW50KTtcblxuXHRyZXR1cm4gcGFydHMuam9pbihcIiwgXCIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5ST1QuU3RyaW5nR2VuZXJhdG9yLnByb3RvdHlwZS5fc3BsaXQgPSBmdW5jdGlvbihzdHIpIHtcblx0cmV0dXJuIHN0ci5zcGxpdCh0aGlzLl9vcHRpb25zLndvcmRzID8gL1xccysvIDogXCJcIik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFxuICovXG5ST1QuU3RyaW5nR2VuZXJhdG9yLnByb3RvdHlwZS5fam9pbiA9IGZ1bmN0aW9uKGFycikge1xuXHRyZXR1cm4gYXJyLmpvaW4odGhpcy5fb3B0aW9ucy53b3JkcyA/IFwiIFwiIDogXCJcIik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gY29udGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKi9cblJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLl9vYnNlcnZlRXZlbnQgPSBmdW5jdGlvbihjb250ZXh0LCBldmVudCkge1xuXHR2YXIga2V5ID0gdGhpcy5fam9pbihjb250ZXh0KTtcblx0aWYgKCEoa2V5IGluIHRoaXMuX2RhdGEpKSB7IHRoaXMuX2RhdGFba2V5XSA9IHt9OyB9XG5cdHZhciBkYXRhID0gdGhpcy5fZGF0YVtrZXldO1xuXG5cdGlmICghKGV2ZW50IGluIGRhdGEpKSB7IGRhdGFbZXZlbnRdID0gMDsgfVxuXHRkYXRhW2V2ZW50XSsrO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5ST1QuU3RyaW5nR2VuZXJhdG9yLnByb3RvdHlwZS5fc2FtcGxlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRjb250ZXh0ID0gdGhpcy5fYmFja29mZihjb250ZXh0KTtcblx0dmFyIGtleSA9IHRoaXMuX2pvaW4oY29udGV4dCk7XG5cdHZhciBkYXRhID0gdGhpcy5fZGF0YVtrZXldO1xuXG5cdHZhciBhdmFpbGFibGUgPSB7fTtcblxuXHRpZiAodGhpcy5fb3B0aW9ucy5wcmlvcikge1xuXHRcdGZvciAodmFyIGV2ZW50IGluIHRoaXMuX3ByaW9yVmFsdWVzKSB7IGF2YWlsYWJsZVtldmVudF0gPSB0aGlzLl9wcmlvclZhbHVlc1tldmVudF07IH1cblx0XHRmb3IgKHZhciBldmVudCBpbiBkYXRhKSB7IGF2YWlsYWJsZVtldmVudF0gKz0gZGF0YVtldmVudF07IH1cblx0fSBlbHNlIHsgXG5cdFx0YXZhaWxhYmxlID0gZGF0YTtcblx0fVxuXG5cdHJldHVybiB0aGlzLl9waWNrUmFuZG9tKGF2YWlsYWJsZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX1cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuUk9ULlN0cmluZ0dlbmVyYXRvci5wcm90b3R5cGUuX2JhY2tvZmYgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdGlmIChjb250ZXh0Lmxlbmd0aCA+IHRoaXMuX29wdGlvbnMub3JkZXIpIHtcblx0XHRjb250ZXh0ID0gY29udGV4dC5zbGljZSgtdGhpcy5fb3B0aW9ucy5vcmRlcik7XG5cdH0gZWxzZSBpZiAoY29udGV4dC5sZW5ndGggPCB0aGlzLl9vcHRpb25zLm9yZGVyKSB7XG5cdFx0Y29udGV4dCA9IHRoaXMuX3ByZWZpeC5zbGljZSgwLCB0aGlzLl9vcHRpb25zLm9yZGVyIC0gY29udGV4dC5sZW5ndGgpLmNvbmNhdChjb250ZXh0KTtcblx0fVxuXG5cdHdoaWxlICghKHRoaXMuX2pvaW4oY29udGV4dCkgaW4gdGhpcy5fZGF0YSkgJiYgY29udGV4dC5sZW5ndGggPiAwKSB7IGNvbnRleHQgPSBjb250ZXh0LnNsaWNlKDEpOyB9XG5cblx0cmV0dXJuIGNvbnRleHQ7XG59XG5cblxuUk9ULlN0cmluZ0dlbmVyYXRvci5wcm90b3R5cGUuX3BpY2tSYW5kb20gPSBmdW5jdGlvbihkYXRhKSB7XG5cdHZhciB0b3RhbCA9IDA7XG5cdFxuXHRmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG5cdFx0dG90YWwgKz0gZGF0YVtpZF07XG5cdH1cblx0dmFyIHJhbmRvbSA9IFJPVC5STkcuZ2V0VW5pZm9ybSgpKnRvdGFsO1xuXHRcblx0dmFyIHBhcnQgPSAwO1xuXHRmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG5cdFx0cGFydCArPSBkYXRhW2lkXTtcblx0XHRpZiAocmFuZG9tIDwgcGFydCkgeyByZXR1cm4gaWQ7IH1cblx0fVxufVxuLyoqXG4gKiBAY2xhc3MgR2VuZXJpYyBldmVudCBxdWV1ZTogc3RvcmVzIGV2ZW50cyBhbmQgcmV0cmlldmVzIHRoZW0gYmFzZWQgb24gdGhlaXIgdGltZVxuICovXG5ST1QuRXZlbnRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl90aW1lID0gMDtcblx0dGhpcy5fZXZlbnRzID0gW107XG5cdHRoaXMuX2V2ZW50VGltZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBFbGFwc2VkIHRpbWVcbiAqL1xuUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX3RpbWU7XG59XG5cbi8qKlxuICogQ2xlYXIgYWxsIHNjaGVkdWxlZCBldmVudHNcbiAqL1xuUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX2V2ZW50cyA9IFtdO1xuXHR0aGlzLl9ldmVudFRpbWVzID0gW107XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7P30gZXZlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gKi9cblJPVC5FdmVudFF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihldmVudCwgdGltZSkge1xuXHR2YXIgaW5kZXggPSB0aGlzLl9ldmVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpPTA7aTx0aGlzLl9ldmVudFRpbWVzLmxlbmd0aDtpKyspIHtcblx0XHRpZiAodGhpcy5fZXZlbnRUaW1lc1tpXSA+IHRpbWUpIHtcblx0XHRcdGluZGV4ID0gaTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMuX2V2ZW50cy5zcGxpY2UoaW5kZXgsIDAsIGV2ZW50KTtcblx0dGhpcy5fZXZlbnRUaW1lcy5zcGxpY2UoaW5kZXgsIDAsIHRpbWUpO1xufVxuXG4vKipcbiAqIExvY2F0ZXMgdGhlIG5lYXJlc3QgZXZlbnQsIGFkdmFuY2VzIHRpbWUgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIHRoYXQgZXZlbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgcXVldWUuXG4gKiBAcmV0dXJucyB7PyB8fCBudWxsfSBUaGUgZXZlbnQgcHJldmlvdXNseSBhZGRlZCBieSBhZGRFdmVudCwgbnVsbCBpZiBubyBldmVudCBhdmFpbGFibGVcbiAqL1xuUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuX2V2ZW50cy5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblxuXHR2YXIgdGltZSA9IHRoaXMuX2V2ZW50VGltZXMuc3BsaWNlKDAsIDEpWzBdO1xuXHRpZiAodGltZSA+IDApIHsgLyogYWR2YW5jZSAqL1xuXHRcdHRoaXMuX3RpbWUgKz0gdGltZTtcblx0XHRmb3IgKHZhciBpPTA7aTx0aGlzLl9ldmVudFRpbWVzLmxlbmd0aDtpKyspIHsgdGhpcy5fZXZlbnRUaW1lc1tpXSAtPSB0aW1lOyB9XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5fZXZlbnRzLnNwbGljZSgwLCAxKVswXTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgcXVldWVcbiAqIEBwYXJhbSB7P30gZXZlbnRcbiAqIEByZXR1cm5zIHtib29sfSBzdWNjZXNzP1xuICovXG5ST1QuRXZlbnRRdWV1ZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0dmFyIGluZGV4ID0gdGhpcy5fZXZlbnRzLmluZGV4T2YoZXZlbnQpO1xuXHRpZiAoaW5kZXggPT0gLTEpIHsgcmV0dXJuIGZhbHNlIH1cblx0dGhpcy5fcmVtb3ZlKGluZGV4KTtcblx0cmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGZyb20gdGhlIHF1ZXVlXG4gKiBAcGFyYW0ge2ludH0gaW5kZXhcbiAqL1xuUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbihpbmRleCkge1xuXHR0aGlzLl9ldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcblx0dGhpcy5fZXZlbnRUaW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xufVxuLyoqXG4gKiBAY2xhc3MgQWJzdHJhY3Qgc2NoZWR1bGVyXG4gKi9cblJPVC5TY2hlZHVsZXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fcXVldWUgPSBuZXcgUk9ULkV2ZW50UXVldWUoKTtcblx0dGhpcy5fcmVwZWF0ID0gW107XG5cdHRoaXMuX2N1cnJlbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgUk9ULkV2ZW50UXVldWUjZ2V0VGltZVxuICovXG5ST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9xdWV1ZS5nZXRUaW1lKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/fSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2x9IHJlcGVhdFxuICovXG5ST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtLCByZXBlYXQpIHtcblx0aWYgKHJlcGVhdCkgeyB0aGlzLl9yZXBlYXQucHVzaChpdGVtKTsgfVxuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgaXRlbXNcbiAqL1xuUk9ULlNjaGVkdWxlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fcXVldWUuY2xlYXIoKTtcblx0dGhpcy5fcmVwZWF0ID0gW107XG5cdHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBwcmV2aW91c2x5IGFkZGVkIGl0ZW1cbiAqIEBwYXJhbSB7P30gaXRlbVxuICogQHJldHVybnMge2Jvb2x9IHN1Y2Nlc3NmdWw/XG4gKi9cblJPVC5TY2hlZHVsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0dmFyIHJlc3VsdCA9IHRoaXMuX3F1ZXVlLnJlbW92ZShpdGVtKTtcblxuXHR2YXIgaW5kZXggPSB0aGlzLl9yZXBlYXQuaW5kZXhPZihpdGVtKTtcblx0aWYgKGluZGV4ICE9IC0xKSB7IHRoaXMuX3JlcGVhdC5zcGxpY2UoaW5kZXgsIDEpOyB9XG5cblx0aWYgKHRoaXMuX2N1cnJlbnQgPT0gaXRlbSkgeyB0aGlzLl9jdXJyZW50ID0gbnVsbDsgfVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogU2NoZWR1bGUgbmV4dCBpdGVtXG4gKiBAcmV0dXJucyB7P31cbiAqL1xuUk9ULlNjaGVkdWxlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9jdXJyZW50ID0gdGhpcy5fcXVldWUuZ2V0KCk7XG5cdHJldHVybiB0aGlzLl9jdXJyZW50O1xufVxuLyoqXG4gKiBAY2xhc3MgU2ltcGxlIGZhaXIgc2NoZWR1bGVyIChyb3VuZC1yb2JpbiBzdHlsZSlcbiAqIEBhdWdtZW50cyBST1QuU2NoZWR1bGVyXG4gKi9cblJPVC5TY2hlZHVsZXIuU2ltcGxlID0gZnVuY3Rpb24oKSB7XG5cdFJPVC5TY2hlZHVsZXIuY2FsbCh0aGlzKTtcbn1cblJPVC5TY2hlZHVsZXIuU2ltcGxlLmV4dGVuZChST1QuU2NoZWR1bGVyKTtcblxuLyoqXG4gKiBAc2VlIFJPVC5TY2hlZHVsZXIjYWRkXG4gKi9cblJPVC5TY2hlZHVsZXIuU2ltcGxlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtLCByZXBlYXQpIHtcblx0dGhpcy5fcXVldWUuYWRkKGl0ZW0sIDApO1xuXHRyZXR1cm4gUk9ULlNjaGVkdWxlci5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgaXRlbSwgcmVwZWF0KTtcbn1cblxuLyoqXG4gKiBAc2VlIFJPVC5TY2hlZHVsZXIjbmV4dFxuICovXG5ST1QuU2NoZWR1bGVyLlNpbXBsZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fY3VycmVudCAmJiB0aGlzLl9yZXBlYXQuaW5kZXhPZih0aGlzLl9jdXJyZW50KSAhPSAtMSkge1xuXHRcdHRoaXMuX3F1ZXVlLmFkZCh0aGlzLl9jdXJyZW50LCAwKTtcblx0fVxuXHRyZXR1cm4gUk9ULlNjaGVkdWxlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMpO1xufVxuLyoqXG4gKiBAY2xhc3MgU3BlZWQtYmFzZWQgc2NoZWR1bGVyXG4gKiBAYXVnbWVudHMgUk9ULlNjaGVkdWxlclxuICovXG5ST1QuU2NoZWR1bGVyLlNwZWVkID0gZnVuY3Rpb24oKSB7XG5cdFJPVC5TY2hlZHVsZXIuY2FsbCh0aGlzKTtcbn1cblJPVC5TY2hlZHVsZXIuU3BlZWQuZXh0ZW5kKFJPVC5TY2hlZHVsZXIpO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGFueXRoaW5nIHdpdGggXCJnZXRTcGVlZFwiIG1ldGhvZFxuICogQHBhcmFtIHtib29sfSByZXBlYXRcbiAqIEBzZWUgUk9ULlNjaGVkdWxlciNhZGRcbiAqL1xuUk9ULlNjaGVkdWxlci5TcGVlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSwgcmVwZWF0KSB7XG5cdHRoaXMuX3F1ZXVlLmFkZChpdGVtLCAxL2l0ZW0uZ2V0U3BlZWQoKSk7XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBpdGVtLCByZXBlYXQpO1xufVxuXG4vKipcbiAqIEBzZWUgUk9ULlNjaGVkdWxlciNuZXh0XG4gKi9cblJPVC5TY2hlZHVsZXIuU3BlZWQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuX2N1cnJlbnQgJiYgdGhpcy5fcmVwZWF0LmluZGV4T2YodGhpcy5fY3VycmVudCkgIT0gLTEpIHtcblx0XHR0aGlzLl9xdWV1ZS5hZGQodGhpcy5fY3VycmVudCwgMS90aGlzLl9jdXJyZW50LmdldFNwZWVkKCkpO1xuXHR9XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcyk7XG59XG4vKipcbiAqIEBjbGFzcyBBY3Rpb24tYmFzZWQgc2NoZWR1bGVyXG4gKiBAYXVnbWVudHMgUk9ULlNjaGVkdWxlclxuICovXG5ST1QuU2NoZWR1bGVyLkFjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRST1QuU2NoZWR1bGVyLmNhbGwodGhpcyk7XG5cdHRoaXMuX2RlZmF1bHREdXJhdGlvbiA9IDE7IC8qIGZvciBuZXdseSBhZGRlZCAqL1xuXHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX2RlZmF1bHREdXJhdGlvbjsgLyogZm9yIHRoaXMuX2N1cnJlbnQgKi9cbn1cblJPVC5TY2hlZHVsZXIuQWN0aW9uLmV4dGVuZChST1QuU2NoZWR1bGVyKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaXRlbVxuICogQHBhcmFtIHtib29sfSByZXBlYXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT0xXVxuICogQHNlZSBST1QuU2NoZWR1bGVyI2FkZFxuICovXG5ST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSwgcmVwZWF0LCB0aW1lKSB7XG5cdHRoaXMuX3F1ZXVlLmFkZChpdGVtLCB0aW1lIHx8IHRoaXMuX2RlZmF1bHREdXJhdGlvbik7XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBpdGVtLCByZXBlYXQpO1xufVxuXG5ST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl9kZWZhdWx0RHVyYXRpb247XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMpO1xufVxuXG5ST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaXRlbSkge1xuXHRpZiAoaXRlbSA9PSB0aGlzLl9jdXJyZW50KSB7IHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fZGVmYXVsdER1cmF0aW9uOyB9XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBpdGVtKTtcbn1cblxuLyoqXG4gKiBAc2VlIFJPVC5TY2hlZHVsZXIjbmV4dFxuICovXG5ST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fY3VycmVudCAmJiB0aGlzLl9yZXBlYXQuaW5kZXhPZih0aGlzLl9jdXJyZW50KSAhPSAtMSkge1xuXHRcdHRoaXMuX3F1ZXVlLmFkZCh0aGlzLl9jdXJyZW50LCB0aGlzLl9kdXJhdGlvbiB8fCB0aGlzLl9kZWZhdWx0RHVyYXRpb24pO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fZGVmYXVsdER1cmF0aW9uO1xuXHR9XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcyk7XG59XG5cbi8qKlxuICogU2V0IGR1cmF0aW9uIGZvciB0aGUgYWN0aXZlIGl0ZW1cbiAqL1xuUk9ULlNjaGVkdWxlci5BY3Rpb24ucHJvdG90eXBlLnNldER1cmF0aW9uID0gZnVuY3Rpb24odGltZSkge1xuXHRpZiAodGhpcy5fY3VycmVudCkgeyB0aGlzLl9kdXJhdGlvbiA9IHRpbWU7IH1cblx0cmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIEBjbGFzcyBBc3luY2hyb25vdXMgbWFpbiBsb29wXG4gKiBAcGFyYW0ge1JPVC5TY2hlZHVsZXJ9IHNjaGVkdWxlclxuICovXG5ST1QuRW5naW5lID0gZnVuY3Rpb24oc2NoZWR1bGVyKSB7XG5cdHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcblx0dGhpcy5fbG9jayA9IDE7XG59XG5cbi8qKlxuICogU3RhcnQgdGhlIG1haW4gbG9vcC4gV2hlbiB0aGlzIGNhbGwgcmV0dXJucywgdGhlIGxvb3AgaXMgbG9ja2VkLlxuICovXG5ST1QuRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy51bmxvY2soKTtcbn1cblxuLyoqXG4gKiBJbnRlcnJ1cHQgdGhlIGVuZ2luZSBieSBhbiBhc3luY2hyb25vdXMgYWN0aW9uXG4gKi9cblJPVC5FbmdpbmUucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fbG9jaysrO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBSZXN1bWUgZXhlY3V0aW9uIChwYXVzZWQgYnkgYSBwcmV2aW91cyBsb2NrKVxuICovXG5ST1QuRW5naW5lLnByb3RvdHlwZS51bmxvY2sgPSBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLl9sb2NrKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1bmxvY2sgdW5sb2NrZWQgZW5naW5lXCIpOyB9XG5cdHRoaXMuX2xvY2stLTtcblxuXHR3aGlsZSAoIXRoaXMuX2xvY2spIHtcblx0XHR2YXIgYWN0b3IgPSB0aGlzLl9zY2hlZHVsZXIubmV4dCgpO1xuXHRcdGlmICghYWN0b3IpIHsgcmV0dXJuIHRoaXMubG9jaygpOyB9IC8qIG5vIGFjdG9ycyAqL1xuXHRcdHZhciByZXN1bHQgPSBhY3Rvci5hY3QoKTtcblx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7IC8qIGFjdG9yIHJldHVybmVkIGEgXCJ0aGVuYWJsZVwiLCBsb29rcyBsaWtlIGEgUHJvbWlzZSAqL1xuXHRcdFx0dGhpcy5sb2NrKCk7XG5cdFx0XHRyZXN1bHQudGhlbih0aGlzLnVubG9jay5iaW5kKHRoaXMpKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cbi8qKlxuICogQGNsYXNzIEJhc2UgbWFwIGdlbmVyYXRvclxuICogQHBhcmFtIHtpbnR9IFt3aWR0aD1ST1QuREVGQVVMVF9XSURUSF1cbiAqIEBwYXJhbSB7aW50fSBbaGVpZ2h0PVJPVC5ERUZBVUxUX0hFSUdIVF1cbiAqL1xuUk9ULk1hcCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0dGhpcy5fd2lkdGggPSB3aWR0aCB8fCBST1QuREVGQVVMVF9XSURUSDtcblx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0IHx8IFJPVC5ERUZBVUxUX0hFSUdIVDtcbn07XG5cblJPVC5NYXAucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7fVxuXG5ST1QuTWFwLnByb3RvdHlwZS5fZmlsbE1hcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHZhciBtYXAgPSBbXTtcblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fd2lkdGg7aSsrKSB7XG5cdFx0bWFwLnB1c2goW10pO1xuXHRcdGZvciAodmFyIGo9MDtqPHRoaXMuX2hlaWdodDtqKyspIHsgbWFwW2ldLnB1c2godmFsdWUpOyB9XG5cdH1cblx0cmV0dXJuIG1hcDtcbn1cbi8qKlxuICogQGNsYXNzIFNpbXBsZSBlbXB0eSByZWN0YW5ndWxhciByb29tXG4gKiBAYXVnbWVudHMgUk9ULk1hcFxuICovXG5ST1QuTWFwLkFyZW5hID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG59XG5ST1QuTWFwLkFyZW5hLmV4dGVuZChST1QuTWFwKTtcblxuUk9ULk1hcC5BcmVuYS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0dmFyIHcgPSB0aGlzLl93aWR0aC0xO1xuXHR2YXIgaCA9IHRoaXMuX2hlaWdodC0xO1xuXHRmb3IgKHZhciBpPTA7aTw9dztpKyspIHtcblx0XHRmb3IgKHZhciBqPTA7ajw9aDtqKyspIHtcblx0XHRcdHZhciBlbXB0eSA9IChpICYmIGogJiYgaTx3ICYmIGo8aCk7XG5cdFx0XHRjYWxsYmFjayhpLCBqLCBlbXB0eSA/IDAgOiAxKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIEBjbGFzcyBSZWN1cnNpdmVseSBkaXZpZGVkIG1hemUsIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF6ZV9nZW5lcmF0aW9uX2FsZ29yaXRobSNSZWN1cnNpdmVfZGl2aXNpb25fbWV0aG9kXG4gKiBAYXVnbWVudHMgUk9ULk1hcFxuICovXG5ST1QuTWFwLkRpdmlkZWRNYXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG5cdHRoaXMuX3N0YWNrID0gW107XG59XG5ST1QuTWFwLkRpdmlkZWRNYXplLmV4dGVuZChST1QuTWFwKTtcblxuUk9ULk1hcC5EaXZpZGVkTWF6ZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0dmFyIHcgPSB0aGlzLl93aWR0aDtcblx0dmFyIGggPSB0aGlzLl9oZWlnaHQ7XG5cdFxuXHR0aGlzLl9tYXAgPSBbXTtcblx0XG5cdGZvciAodmFyIGk9MDtpPHc7aSsrKSB7XG5cdFx0dGhpcy5fbWFwLnB1c2goW10pO1xuXHRcdGZvciAodmFyIGo9MDtqPGg7aisrKSB7XG5cdFx0XHR2YXIgYm9yZGVyID0gKGkgPT0gMCB8fCBqID09IDAgfHwgaSsxID09IHcgfHwgaisxID09IGgpO1xuXHRcdFx0dGhpcy5fbWFwW2ldLnB1c2goYm9yZGVyID8gMSA6IDApO1xuXHRcdH1cblx0fVxuXHRcblx0dGhpcy5fc3RhY2sgPSBbXG5cdFx0WzEsIDEsIHctMiwgaC0yXVxuXHRdO1xuXHR0aGlzLl9wcm9jZXNzKCk7XG5cdFxuXHRmb3IgKHZhciBpPTA7aTx3O2krKykge1xuXHRcdGZvciAodmFyIGo9MDtqPGg7aisrKSB7XG5cdFx0XHRjYWxsYmFjayhpLCBqLCB0aGlzLl9tYXBbaV1bal0pO1xuXHRcdH1cblx0fVxuXHR0aGlzLl9tYXAgPSBudWxsO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUk9ULk1hcC5EaXZpZGVkTWF6ZS5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbigpIHtcblx0d2hpbGUgKHRoaXMuX3N0YWNrLmxlbmd0aCkge1xuXHRcdHZhciByb29tID0gdGhpcy5fc3RhY2suc2hpZnQoKTsgLyogW2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbV0gKi9cblx0XHR0aGlzLl9wYXJ0aXRpb25Sb29tKHJvb20pO1xuXHR9XG59XG5cblJPVC5NYXAuRGl2aWRlZE1hemUucHJvdG90eXBlLl9wYXJ0aXRpb25Sb29tID0gZnVuY3Rpb24ocm9vbSkge1xuXHR2YXIgYXZhaWxYID0gW107XG5cdHZhciBhdmFpbFkgPSBbXTtcblx0XG5cdGZvciAodmFyIGk9cm9vbVswXSsxO2k8cm9vbVsyXTtpKyspIHtcblx0XHR2YXIgdG9wID0gdGhpcy5fbWFwW2ldW3Jvb21bMV0tMV07XG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX21hcFtpXVtyb29tWzNdKzFdO1xuXHRcdGlmICh0b3AgJiYgYm90dG9tICYmICEoaSAlIDIpKSB7IGF2YWlsWC5wdXNoKGkpOyB9XG5cdH1cblx0XG5cdGZvciAodmFyIGo9cm9vbVsxXSsxO2o8cm9vbVszXTtqKyspIHtcblx0XHR2YXIgbGVmdCA9IHRoaXMuX21hcFtyb29tWzBdLTFdW2pdO1xuXHRcdHZhciByaWdodCA9IHRoaXMuX21hcFtyb29tWzJdKzFdW2pdO1xuXHRcdGlmIChsZWZ0ICYmIHJpZ2h0ICYmICEoaiAlIDIpKSB7IGF2YWlsWS5wdXNoKGopOyB9XG5cdH1cblxuXHRpZiAoIWF2YWlsWC5sZW5ndGggfHwgIWF2YWlsWS5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cblx0dmFyIHggPSBhdmFpbFgucmFuZG9tKCk7XG5cdHZhciB5ID0gYXZhaWxZLnJhbmRvbSgpO1xuXHRcblx0dGhpcy5fbWFwW3hdW3ldID0gMTtcblx0XG5cdHZhciB3YWxscyA9IFtdO1xuXHRcblx0dmFyIHcgPSBbXTsgd2FsbHMucHVzaCh3KTsgLyogbGVmdCBwYXJ0ICovXG5cdGZvciAodmFyIGk9cm9vbVswXTsgaTx4OyBpKyspIHsgXG5cdFx0dGhpcy5fbWFwW2ldW3ldID0gMTtcblx0XHR3LnB1c2goW2ksIHldKTsgXG5cdH1cblx0XG5cdHZhciB3ID0gW107IHdhbGxzLnB1c2godyk7IC8qIHJpZ2h0IHBhcnQgKi9cblx0Zm9yICh2YXIgaT14KzE7IGk8PXJvb21bMl07IGkrKykgeyBcblx0XHR0aGlzLl9tYXBbaV1beV0gPSAxO1xuXHRcdHcucHVzaChbaSwgeV0pOyBcblx0fVxuXG5cdHZhciB3ID0gW107IHdhbGxzLnB1c2godyk7IC8qIHRvcCBwYXJ0ICovXG5cdGZvciAodmFyIGo9cm9vbVsxXTsgajx5OyBqKyspIHsgXG5cdFx0dGhpcy5fbWFwW3hdW2pdID0gMTtcblx0XHR3LnB1c2goW3gsIGpdKTsgXG5cdH1cblx0XG5cdHZhciB3ID0gW107IHdhbGxzLnB1c2godyk7IC8qIGJvdHRvbSBwYXJ0ICovXG5cdGZvciAodmFyIGo9eSsxOyBqPD1yb29tWzNdOyBqKyspIHsgXG5cdFx0dGhpcy5fbWFwW3hdW2pdID0gMTtcblx0XHR3LnB1c2goW3gsIGpdKTsgXG5cdH1cblx0XHRcblx0dmFyIHNvbGlkID0gd2FsbHMucmFuZG9tKCk7XG5cdGZvciAodmFyIGk9MDtpPHdhbGxzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgdyA9IHdhbGxzW2ldO1xuXHRcdGlmICh3ID09IHNvbGlkKSB7IGNvbnRpbnVlOyB9XG5cdFx0XG5cdFx0dmFyIGhvbGUgPSB3LnJhbmRvbSgpO1xuXHRcdHRoaXMuX21hcFtob2xlWzBdXVtob2xlWzFdXSA9IDA7XG5cdH1cblxuXHR0aGlzLl9zdGFjay5wdXNoKFtyb29tWzBdLCByb29tWzFdLCB4LTEsIHktMV0pOyAvKiBsZWZ0IHRvcCAqL1xuXHR0aGlzLl9zdGFjay5wdXNoKFt4KzEsIHJvb21bMV0sIHJvb21bMl0sIHktMV0pOyAvKiByaWdodCB0b3AgKi9cblx0dGhpcy5fc3RhY2sucHVzaChbcm9vbVswXSwgeSsxLCB4LTEsIHJvb21bM11dKTsgLyogbGVmdCBib3R0b20gKi9cblx0dGhpcy5fc3RhY2sucHVzaChbeCsxLCB5KzEsIHJvb21bMl0sIHJvb21bM11dKTsgLyogcmlnaHQgYm90dG9tICovXG59XG4vKipcbiAqIEBjbGFzcyBJY2V5J3MgTWF6ZSBnZW5lcmF0b3JcbiAqIFNlZSBodHRwOi8vd3d3LnJvZ3VlYmFzaW4ucm9ndWVsaWtlZGV2ZWxvcG1lbnQub3JnL2luZGV4LnBocD90aXRsZT1TaW1wbGVfbWF6ZSBmb3IgZXhwbGFuYXRpb25cbiAqIEBhdWdtZW50cyBST1QuTWFwXG4gKi9cblJPVC5NYXAuSWNleU1hemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCByZWd1bGFyaXR5KSB7XG5cdFJPVC5NYXAuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcblx0dGhpcy5fcmVndWxhcml0eSA9IHJlZ3VsYXJpdHkgfHwgMDtcbn1cblJPVC5NYXAuSWNleU1hemUuZXh0ZW5kKFJPVC5NYXApO1xuXG5ST1QuTWFwLkljZXlNYXplLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHR2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcblx0dmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblx0XG5cdHZhciBtYXAgPSB0aGlzLl9maWxsTWFwKDEpO1xuXHRcblx0d2lkdGggLT0gKHdpZHRoICUgMiA/IDEgOiAyKTtcblx0aGVpZ2h0IC09IChoZWlnaHQgJSAyID8gMSA6IDIpO1xuXG5cdHZhciBjeCA9IDA7XG5cdHZhciBjeSA9IDA7XG5cdHZhciBueCA9IDA7XG5cdHZhciBueSA9IDA7XG5cblx0dmFyIGRvbmUgPSAwO1xuXHR2YXIgYmxvY2tlZCA9IGZhbHNlO1xuXHR2YXIgZGlycyA9IFtcblx0XHRbMCwgMF0sXG5cdFx0WzAsIDBdLFxuXHRcdFswLCAwXSxcblx0XHRbMCwgMF1cblx0XTtcblx0ZG8ge1xuXHRcdGN4ID0gMSArIDIqTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSood2lkdGgtMSkgLyAyKTtcblx0XHRjeSA9IDEgKyAyKk1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqKGhlaWdodC0xKSAvIDIpO1xuXG5cdFx0aWYgKCFkb25lKSB7IG1hcFtjeF1bY3ldID0gMDsgfVxuXHRcdFxuXHRcdGlmICghbWFwW2N4XVtjeV0pIHtcblx0XHRcdHRoaXMuX3JhbmRvbWl6ZShkaXJzKTtcblx0XHRcdGRvIHtcblx0XHRcdFx0aWYgKE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqKHRoaXMuX3JlZ3VsYXJpdHkrMSkpID09IDApIHsgdGhpcy5fcmFuZG9taXplKGRpcnMpOyB9XG5cdFx0XHRcdGJsb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7aTw0O2krKykge1xuXHRcdFx0XHRcdG54ID0gY3ggKyBkaXJzW2ldWzBdKjI7XG5cdFx0XHRcdFx0bnkgPSBjeSArIGRpcnNbaV1bMV0qMjtcblx0XHRcdFx0XHRpZiAodGhpcy5faXNGcmVlKG1hcCwgbngsIG55LCB3aWR0aCwgaGVpZ2h0KSkge1xuXHRcdFx0XHRcdFx0bWFwW254XVtueV0gPSAwO1xuXHRcdFx0XHRcdFx0bWFwW2N4ICsgZGlyc1tpXVswXV1bY3kgKyBkaXJzW2ldWzFdXSA9IDA7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGN4ID0gbng7XG5cdFx0XHRcdFx0XHRjeSA9IG55O1xuXHRcdFx0XHRcdFx0YmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0ZG9uZSsrO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICghYmxvY2tlZCk7XG5cdFx0fVxuXHR9IHdoaWxlIChkb25lKzEgPCB3aWR0aCpoZWlnaHQvNCk7XG5cdFxuXHRmb3IgKHZhciBpPTA7aTx0aGlzLl93aWR0aDtpKyspIHtcblx0XHRmb3IgKHZhciBqPTA7ajx0aGlzLl9oZWlnaHQ7aisrKSB7XG5cdFx0XHRjYWxsYmFjayhpLCBqLCBtYXBbaV1bal0pO1xuXHRcdH1cblx0fVxuXHR0aGlzLl9tYXAgPSBudWxsO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUk9ULk1hcC5JY2V5TWF6ZS5wcm90b3R5cGUuX3JhbmRvbWl6ZSA9IGZ1bmN0aW9uKGRpcnMpIHtcblx0Zm9yICh2YXIgaT0wO2k8NDtpKyspIHtcblx0XHRkaXJzW2ldWzBdID0gMDtcblx0XHRkaXJzW2ldWzFdID0gMDtcblx0fVxuXHRcblx0c3dpdGNoIChNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpKjQpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0ZGlyc1swXVswXSA9IC0xOyBkaXJzWzFdWzBdID0gMTtcblx0XHRcdGRpcnNbMl1bMV0gPSAtMTsgZGlyc1szXVsxXSA9IDE7XG5cdFx0YnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0ZGlyc1szXVswXSA9IC0xOyBkaXJzWzJdWzBdID0gMTtcblx0XHRcdGRpcnNbMV1bMV0gPSAtMTsgZGlyc1swXVsxXSA9IDE7XG5cdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0ZGlyc1syXVswXSA9IC0xOyBkaXJzWzNdWzBdID0gMTtcblx0XHRcdGRpcnNbMF1bMV0gPSAtMTsgZGlyc1sxXVsxXSA9IDE7XG5cdFx0YnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0ZGlyc1sxXVswXSA9IC0xOyBkaXJzWzBdWzBdID0gMTtcblx0XHRcdGRpcnNbM11bMV0gPSAtMTsgZGlyc1syXVsxXSA9IDE7XG5cdFx0YnJlYWs7XG5cdH1cbn1cblxuUk9ULk1hcC5JY2V5TWF6ZS5wcm90b3R5cGUuX2lzRnJlZSA9IGZ1bmN0aW9uKG1hcCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRpZiAoeCA8IDEgfHwgeSA8IDEgfHwgeCA+PSB3aWR0aCB8fCB5ID49IGhlaWdodCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIG1hcFt4XVt5XTtcbn1cbi8qKlxuICogQGNsYXNzIE1hemUgZ2VuZXJhdG9yIC0gRWxsZXIncyBhbGdvcml0aG1cbiAqIFNlZSBodHRwOi8vaG9tZXBhZ2VzLmN3aS5ubC9+dHJvbXAvbWF6ZS5odG1sIGZvciBleHBsYW5hdGlvblxuICogQGF1Z21lbnRzIFJPVC5NYXBcbiAqL1xuUk9ULk1hcC5FbGxlck1hemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFJPVC5NYXAuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbn1cblJPVC5NYXAuRWxsZXJNYXplLmV4dGVuZChST1QuTWFwKTtcblxuUk9ULk1hcC5FbGxlck1hemUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHZhciBtYXAgPSB0aGlzLl9maWxsTWFwKDEpO1xuXHR2YXIgdyA9IE1hdGguY2VpbCgodGhpcy5fd2lkdGgtMikvMik7XG5cdFxuXHR2YXIgcmFuZCA9IDkvMjQ7XG5cdFxuXHR2YXIgTCA9IFtdO1xuXHR2YXIgUiA9IFtdO1xuXHRcblx0Zm9yICh2YXIgaT0wO2k8dztpKyspIHtcblx0XHRMLnB1c2goaSk7XG5cdFx0Ui5wdXNoKGkpO1xuXHR9XG5cdEwucHVzaCh3LTEpOyAvKiBmYWtlIHN0b3AtYmxvY2sgYXQgdGhlIHJpZ2h0IHNpZGUgKi9cblxuXHRmb3IgKHZhciBqPTE7aiszPHRoaXMuX2hlaWdodDtqKz0yKSB7XG5cdFx0Lyogb25lIHJvdyAqL1xuXHRcdGZvciAodmFyIGk9MDtpPHc7aSsrKSB7XG5cdFx0XHQvKiBjZWxsIGNvb3JkcyAod2lsbCBiZSBhbHdheXMgZW1wdHkpICovXG5cdFx0XHR2YXIgeCA9IDIqaSsxO1xuXHRcdFx0dmFyIHkgPSBqO1xuXHRcdFx0bWFwW3hdW3ldID0gMDtcblx0XHRcdFxuXHRcdFx0LyogcmlnaHQgY29ubmVjdGlvbiAqL1xuXHRcdFx0aWYgKGkgIT0gTFtpKzFdICYmIFJPVC5STkcuZ2V0VW5pZm9ybSgpID4gcmFuZCkge1xuXHRcdFx0XHR0aGlzLl9hZGRUb0xpc3QoaSwgTCwgUik7XG5cdFx0XHRcdG1hcFt4KzFdW3ldID0gMDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogYm90dG9tIGNvbm5lY3Rpb24gKi9cblx0XHRcdGlmIChpICE9IExbaV0gJiYgUk9ULlJORy5nZXRVbmlmb3JtKCkgPiByYW5kKSB7XG5cdFx0XHRcdC8qIHJlbW92ZSBjb25uZWN0aW9uICovXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUZyb21MaXN0KGksIEwsIFIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogY3JlYXRlIGNvbm5lY3Rpb24gKi9cblx0XHRcdFx0bWFwW3hdW3krMV0gPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qIGxhc3Qgcm93ICovXG5cdGZvciAodmFyIGk9MDtpPHc7aSsrKSB7XG5cdFx0LyogY2VsbCBjb29yZHMgKHdpbGwgYmUgYWx3YXlzIGVtcHR5KSAqL1xuXHRcdHZhciB4ID0gMippKzE7XG5cdFx0dmFyIHkgPSBqO1xuXHRcdG1hcFt4XVt5XSA9IDA7XG5cdFx0XG5cdFx0LyogcmlnaHQgY29ubmVjdGlvbiAqL1xuXHRcdGlmIChpICE9IExbaSsxXSAmJiAoaSA9PSBMW2ldIHx8IFJPVC5STkcuZ2V0VW5pZm9ybSgpID4gcmFuZCkpIHtcblx0XHRcdC8qIGRpZyByaWdodCBhbHNvIGlmIHRoZSBjZWxsIGlzIHNlcGFyYXRlZCwgc28gaXQgZ2V0cyBjb25uZWN0ZWQgdG8gdGhlIHJlc3Qgb2YgbWF6ZSAqL1xuXHRcdFx0dGhpcy5fYWRkVG9MaXN0KGksIEwsIFIpO1xuXHRcdFx0bWFwW3grMV1beV0gPSAwO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLl9yZW1vdmVGcm9tTGlzdChpLCBMLCBSKTtcblx0fVxuXHRcblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fd2lkdGg7aSsrKSB7XG5cdFx0Zm9yICh2YXIgaj0wO2o8dGhpcy5faGVpZ2h0O2orKykge1xuXHRcdFx0Y2FsbGJhY2soaSwgaiwgbWFwW2ldW2pdKTtcblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFJlbW92ZSBcImlcIiBmcm9tIGl0cyBsaXN0XG4gKi9cblJPVC5NYXAuRWxsZXJNYXplLnByb3RvdHlwZS5fcmVtb3ZlRnJvbUxpc3QgPSBmdW5jdGlvbihpLCBMLCBSKSB7XG5cdFJbTFtpXV0gPSBSW2ldO1xuXHRMW1JbaV1dID0gTFtpXTtcblx0UltpXSA9IGk7XG5cdExbaV0gPSBpO1xufVxuXG4vKipcbiAqIEpvaW4gbGlzdHMgd2l0aCBcImlcIiBhbmQgXCJpKzFcIlxuICovXG5ST1QuTWFwLkVsbGVyTWF6ZS5wcm90b3R5cGUuX2FkZFRvTGlzdCA9IGZ1bmN0aW9uKGksIEwsIFIpIHtcblx0UltMW2krMV1dID0gUltpXTtcblx0TFtSW2ldXSA9IExbaSsxXTtcblx0UltpXSA9IGkrMTtcblx0TFtpKzFdID0gaTtcbn1cbi8qKlxuICogQGNsYXNzIENlbGx1bGFyIGF1dG9tYXRvbiBtYXAgZ2VuZXJhdG9yXG4gKiBAYXVnbWVudHMgUk9ULk1hcFxuICogQHBhcmFtIHtpbnR9IFt3aWR0aD1ST1QuREVGQVVMVF9XSURUSF1cbiAqIEBwYXJhbSB7aW50fSBbaGVpZ2h0PVJPVC5ERUZBVUxUX0hFSUdIVF1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICogQHBhcmFtIHtpbnRbXX0gW29wdGlvbnMuYm9ybl0gTGlzdCBvZiBuZWlnaGJvciBjb3VudHMgZm9yIGEgbmV3IGNlbGwgdG8gYmUgYm9ybiBpbiBlbXB0eSBzcGFjZVxuICogQHBhcmFtIHtpbnRbXX0gW29wdGlvbnMuc3Vydml2ZV0gTGlzdCBvZiBuZWlnaGJvciBjb3VudHMgZm9yIGFuIGV4aXN0aW5nICBjZWxsIHRvIHN1cnZpdmVcbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy50b3BvbG9neV0gVG9wb2xvZ3kgNCBvciA2IG9yIDhcbiAqL1xuUk9ULk1hcC5DZWxsdWxhciA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcblx0Uk9ULk1hcC5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuXHR0aGlzLl9vcHRpb25zID0ge1xuXHRcdGJvcm46IFs1LCA2LCA3LCA4XSxcblx0XHRzdXJ2aXZlOiBbNCwgNSwgNiwgNywgOF0sXG5cdFx0dG9wb2xvZ3k6IDgsXG5cdFx0Y29ubmVjdGVkOiBmYWxzZVxuXHR9O1xuXHR0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFxuXHR0aGlzLl9kaXJzID0gUk9ULkRJUlNbdGhpcy5fb3B0aW9ucy50b3BvbG9neV07XG5cdHRoaXMuX21hcCA9IHRoaXMuX2ZpbGxNYXAoMCk7XG59XG5ST1QuTWFwLkNlbGx1bGFyLmV4dGVuZChST1QuTWFwKTtcblxuLyoqXG4gKiBGaWxsIHRoZSBtYXAgd2l0aCByYW5kb20gdmFsdWVzXG4gKiBAcGFyYW0ge2Zsb2F0fSBwcm9iYWJpbGl0eSBQcm9iYWJpbGl0eSBmb3IgYSBjZWxsIHRvIGJlY29tZSBhbGl2ZTsgMCA9IGFsbCBlbXB0eSwgMSA9IGFsbCBmdWxsXG4gKi9cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLnJhbmRvbWl6ZSA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5KSB7XG5cdGZvciAodmFyIGk9MDtpPHRoaXMuX3dpZHRoO2krKykge1xuXHRcdGZvciAodmFyIGo9MDtqPHRoaXMuX2hlaWdodDtqKyspIHtcblx0XHRcdHRoaXMuX21hcFtpXVtqXSA9IChST1QuUk5HLmdldFVuaWZvcm0oKSA8IHByb2JhYmlsaXR5ID8gMSA6IDApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGFuZ2Ugb3B0aW9ucy5cbiAqIEBzZWUgUk9ULk1hcC5DZWxsdWxhclxuICovXG5ST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRmb3IgKHZhciBwIGluIG9wdGlvbnMpIHsgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07IH1cbn1cblxuUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcblx0dGhpcy5fbWFwW3hdW3ldID0gdmFsdWU7XG59XG5cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHZhciBuZXdNYXAgPSB0aGlzLl9maWxsTWFwKDApO1xuXHR2YXIgYm9ybiA9IHRoaXMuX29wdGlvbnMuYm9ybjtcblx0dmFyIHN1cnZpdmUgPSB0aGlzLl9vcHRpb25zLnN1cnZpdmU7XG5cblxuXHRmb3IgKHZhciBqPTA7ajx0aGlzLl9oZWlnaHQ7aisrKSB7XG5cdFx0dmFyIHdpZHRoU3RlcCA9IDE7XG5cdFx0dmFyIHdpZHRoU3RhcnQgPSAwO1xuXHRcdGlmICh0aGlzLl9vcHRpb25zLnRvcG9sb2d5ID09IDYpIHsgXG5cdFx0XHR3aWR0aFN0ZXAgPSAyO1xuXHRcdFx0d2lkdGhTdGFydCA9IGolMjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpPXdpZHRoU3RhcnQ7IGk8dGhpcy5fd2lkdGg7IGkrPXdpZHRoU3RlcCkge1xuXG5cdFx0XHR2YXIgY3VyID0gdGhpcy5fbWFwW2ldW2pdO1xuXHRcdFx0dmFyIG5jb3VudCA9IHRoaXMuX2dldE5laWdoYm9ycyhpLCBqKTtcblx0XHRcdFxuXHRcdFx0aWYgKGN1ciAmJiBzdXJ2aXZlLmluZGV4T2YobmNvdW50KSAhPSAtMSkgeyAvKiBzdXJ2aXZlICovXG5cdFx0XHRcdG5ld01hcFtpXVtqXSA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKCFjdXIgJiYgYm9ybi5pbmRleE9mKG5jb3VudCkgIT0gLTEpIHsgLyogYm9ybiAqL1xuXHRcdFx0XHRuZXdNYXBbaV1bal0gPSAxO1xuXHRcdFx0fVx0XHRcdFxuXHRcdH1cblx0fVxuXHRcblx0dGhpcy5fbWFwID0gbmV3TWFwO1xuXG5cdC8vIG9wdGluaWFsbHkgY29ubmVjdCBldmVyeSBzcGFjZVxuXHRpZiAodGhpcy5fb3B0aW9ucy5jb25uZWN0ZWQpIHtcblx0XHR0aGlzLl9jb21wbGV0ZU1hemUoKTtcdFxuXHR9XG5cblx0aWYgKGNhbGxiYWNrKSB7IFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fd2lkdGg7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9oZWlnaHQ7IGorKykge1xuXHRcdFx0XHRjYWxsYmFjayhpLCBqLCBuZXdNYXBbaV1bal0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEdldCBuZWlnaGJvciBjb3VudCBhdCBbaSxqXSBpbiB0aGlzLl9tYXBcbiAqL1xuUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuX2dldE5laWdoYm9ycyA9IGZ1bmN0aW9uKGN4LCBjeSkge1xuXHR2YXIgcmVzdWx0ID0gMDtcblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fZGlycy5sZW5ndGg7aSsrKSB7XG5cdFx0dmFyIGRpciA9IHRoaXMuX2RpcnNbaV07XG5cdFx0dmFyIHggPSBjeCArIGRpclswXTtcblx0XHR2YXIgeSA9IGN5ICsgZGlyWzFdO1xuXHRcdFxuXHRcdGlmICh4IDwgMCB8fCB4ID49IHRoaXMuX3dpZHRoIHx8IHggPCAwIHx8IHkgPj0gdGhpcy5fd2lkdGgpIHsgY29udGludWU7IH1cblx0XHRyZXN1bHQgKz0gKHRoaXMuX21hcFt4XVt5XSA9PSAxID8gMSA6IDApO1xuXHR9XG5cdFxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIE1ha2Ugc3VyZSBldmVyeSBub24td2FsbCBzcGFjZSBpcyBhY2Nlc3NpYmxlLlxuICovXG5ST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5fY29tcGxldGVNYXplID0gZnVuY3Rpb24oKSB7XG5cdHZhciBhbGxGcmVlU3BhY2UgPSBbXTtcblx0dmFyIG5vdENvbm5lY3RlZCA9IHt9O1xuXHQvLyBmaW5kIGFsbCBmcmVlIHNwYWNlXG5cdGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5fd2lkdGg7IHgrKykge1xuXHRcdGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5faGVpZ2h0OyB5KyspIHtcblx0XHRcdGlmICh0aGlzLl9mcmVlU3BhY2UoeCwgeSkpIHtcblx0XHRcdFx0dmFyIHAgPSBbeCwgeV07XG5cdFx0XHRcdG5vdENvbm5lY3RlZFt0aGlzLl9wb2ludEtleShwKV0gPSBwO1xuXHRcdFx0XHRhbGxGcmVlU3BhY2UucHVzaChbeCwgeV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR2YXIgc3RhcnQgPSBhbGxGcmVlU3BhY2VbUk9ULlJORy5nZXRVbmlmb3JtSW50KDAsIGFsbEZyZWVTcGFjZS5sZW5ndGggLSAxKV07XG5cblx0dmFyIGtleSA9IHRoaXMuX3BvaW50S2V5KHN0YXJ0KTtcblx0dmFyIGNvbm5lY3RlZCA9IHt9O1xuXHRjb25uZWN0ZWRba2V5XSA9IHN0YXJ0O1xuXHRkZWxldGUgbm90Q29ubmVjdGVkW2tleV1cblxuXHQvLyBmaW5kIHdoYXQncyBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nIHBvaW50XG5cdHRoaXMuX2ZpbmRDb25uZWN0ZWQoY29ubmVjdGVkLCBub3RDb25uZWN0ZWQsIFtzdGFydF0pO1xuXG5cdHdoaWxlKE9iamVjdC5rZXlzKG5vdENvbm5lY3RlZCkubGVuZ3RoID4gMCkge1xuXG5cdFx0Ly8gZmluZCB0d28gcG9pbnRzIGZyb20gbm90Q29ubmVjdGVkIHRvIGNvbm5lY3RlZFxuXHRcdHZhciBwID0gdGhpcy5fZ2V0RnJvbVRvKGNvbm5lY3RlZCwgbm90Q29ubmVjdGVkKTtcblx0XHR2YXIgZnJvbSA9IHBbMF07IC8vIG5vdENvbm5lY3RlZFxuXHRcdHZhciB0byA9IHBbMV07IC8vIGNvbm5lY3RlZFxuXG5cdFx0Ly8gZmluZCBldmVyeXRoaW5nIGNvbm5lY3RlZCB0byB0aGUgc3RhcnRpbmcgcG9pbnRcblx0XHR2YXIgbG9jYWwgPSB7fTtcblx0XHRsb2NhbFt0aGlzLl9wb2ludEtleShmcm9tKV0gPSBmcm9tO1xuXHRcdHRoaXMuX2ZpbmRDb25uZWN0ZWQobG9jYWwsIG5vdENvbm5lY3RlZCwgW2Zyb21dLCB0cnVlKTtcblxuXHRcdC8vIGNvbm5lY3QgdG8gYSBjb25uZWN0ZWQgc3F1YXJlXG5cdFx0dGhpcy5fdHVubmVsVG9Db25uZWN0ZWQodG8sIGZyb20sIGNvbm5lY3RlZCwgbm90Q29ubmVjdGVkKTtcblxuXHRcdC8vIG5vdyBhbGwgb2YgbG9jYWwgaXMgY29ubmVjdGVkXG5cdFx0Zm9yICh2YXIgayBpbiBsb2NhbCkge1xuXHRcdFx0dmFyIHBwID0gbG9jYWxba107XG5cdFx0XHR0aGlzLl9tYXBbcHBbMF1dW3BwWzFdXSA9IDA7XG5cdFx0XHRjb25uZWN0ZWRba10gPSBwcDtcblx0XHRcdGRlbGV0ZSBub3RDb25uZWN0ZWRba107XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogRmluZCByYW5kb20gcG9pbnRzIHRvIGNvbm5lY3QuIFNlYXJjaCBmb3IgdGhlIGNsb3Nlc3QgcG9pbnQgaW4gdGhlIGxhcmdlciBzcGFjZS4gXG4gKiBUaGlzIGlzIHRvIG1pbmltaXplIHRoZSBsZW5ndGggb2YgdGhlIHBhc3NhZ2Ugd2hpbGUgbWFpbnRhaW5pbmcgZ29vZCBwZXJmb3JtYW5jZS5cbiAqL1xuUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuX2dldEZyb21UbyA9IGZ1bmN0aW9uKGNvbm5lY3RlZCwgbm90Q29ubmVjdGVkKSB7XG5cdHZhciBmcm9tLCB0bywgZDtcblx0dmFyIGNvbm5lY3RlZEtleXMgPSBPYmplY3Qua2V5cyhjb25uZWN0ZWQpO1xuXHR2YXIgbm90Q29ubmVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKG5vdENvbm5lY3RlZCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG5cdFx0aWYgKGNvbm5lY3RlZEtleXMubGVuZ3RoIDwgbm90Q29ubmVjdGVkS2V5cy5sZW5ndGgpIHtcblx0XHRcdHZhciBrZXlzID0gY29ubmVjdGVkS2V5cztcblx0XHRcdHRvID0gY29ubmVjdGVkW2tleXNbUk9ULlJORy5nZXRVbmlmb3JtSW50KDAsIGtleXMubGVuZ3RoIC0gMSldXVxuXHRcdFx0ZnJvbSA9IHRoaXMuX2dldENsb3Nlc3QodG8sIG5vdENvbm5lY3RlZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBrZXlzID0gbm90Q29ubmVjdGVkS2V5cztcblx0XHRcdGZyb20gPSBub3RDb25uZWN0ZWRba2V5c1tST1QuUk5HLmdldFVuaWZvcm1JbnQoMCwga2V5cy5sZW5ndGggLSAxKV1dXG5cdFx0XHR0byA9IHRoaXMuX2dldENsb3Nlc3QoZnJvbSwgY29ubmVjdGVkKTtcblx0XHR9XG5cdFx0ZCA9IChmcm9tWzBdIC0gdG9bMF0pICogKGZyb21bMF0gLSB0b1swXSkgKyAoZnJvbVsxXSAtIHRvWzFdKSAqIChmcm9tWzFdIC0gdG9bMV0pO1xuXHRcdGlmIChkIDwgNjQpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHQvLyBjb25zb2xlLmxvZyhcIj4+PiBjb25uZWN0ZWQ9XCIgKyB0byArIFwiIG5vdENvbm5lY3RlZD1cIiArIGZyb20gKyBcIiBkaXN0PVwiICsgZCk7XG5cdHJldHVybiBbZnJvbSwgdG9dO1xufVxuXG5ST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5fZ2V0Q2xvc2VzdCA9IGZ1bmN0aW9uKHBvaW50LCBzcGFjZSkge1xuXHR2YXIgbWluUG9pbnQgPSBudWxsO1xuXHR2YXIgbWluRGlzdCA9IG51bGw7XG5cdGZvciAoayBpbiBzcGFjZSkge1xuXHRcdHZhciBwID0gc3BhY2Vba107XG5cdFx0dmFyIGQgPSAocFswXSAtIHBvaW50WzBdKSAqIChwWzBdIC0gcG9pbnRbMF0pICsgKHBbMV0gLSBwb2ludFsxXSkgKiAocFsxXSAtIHBvaW50WzFdKTtcblx0XHRpZiAobWluRGlzdCA9PSBudWxsIHx8IGQgPCBtaW5EaXN0KSB7XG5cdFx0XHRtaW5EaXN0ID0gZDtcblx0XHRcdG1pblBvaW50ID0gcDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1pblBvaW50O1xufVxuXG5ST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5fZmluZENvbm5lY3RlZCA9IGZ1bmN0aW9uKGNvbm5lY3RlZCwgbm90Q29ubmVjdGVkLCBzdGFjaywga2VlcE5vdENvbm5lY3RlZCkge1xuXHR3aGlsZShzdGFjay5sZW5ndGggPiAwKSB7XG5cdFx0dmFyIHAgPSBzdGFjay5zcGxpY2UoMCwgMSlbMF07XG5cdFx0dmFyIHRlc3RzID0gW1xuXHRcdFx0W3BbMF0gKyAxLCBwWzFdXSxcblx0XHRcdFtwWzBdIC0gMSwgcFsxXV0sXG5cdFx0XHRbcFswXSwgICAgIHBbMV0gKyAxXSxcblx0XHRcdFtwWzBdLCAgICAgcFsxXSAtIDFdXG5cdFx0XTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRlc3RzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0gdGhpcy5fcG9pbnRLZXkodGVzdHNbaV0pO1xuXHRcdFx0aWYgKGNvbm5lY3RlZFtrZXldID09IG51bGwgJiYgdGhpcy5fZnJlZVNwYWNlKHRlc3RzW2ldWzBdLCB0ZXN0c1tpXVsxXSkpIHtcblx0XHRcdFx0Y29ubmVjdGVkW2tleV0gPSB0ZXN0c1tpXTtcblx0XHRcdFx0aWYgKCFrZWVwTm90Q29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIG5vdENvbm5lY3RlZFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YWNrLnB1c2godGVzdHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5ST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5fdHVubmVsVG9Db25uZWN0ZWQgPSBmdW5jdGlvbih0bywgZnJvbSwgY29ubmVjdGVkLCBub3RDb25uZWN0ZWQpIHtcblx0dmFyIGtleSA9IHRoaXMuX3BvaW50S2V5KGZyb20pO1xuXHR2YXIgYSwgYjtcblx0aWYgKGZyb21bMF0gPCB0b1swXSkge1xuXHRcdGEgPSBmcm9tO1xuXHRcdGIgPSB0bztcblx0fSBlbHNlIHtcblx0XHRhID0gdG87XG5cdFx0YiA9IGZyb207XG5cdH1cblx0Zm9yICh2YXIgeHggPSBhWzBdOyB4eCA8PSBiWzBdOyB4eCsrKSB7XG5cdFx0dGhpcy5fbWFwW3h4XVthWzFdXSA9IDA7XG5cdFx0dmFyIHAgPSBbeHgsIGFbMV1dO1xuXHRcdHZhciBwa2V5ID0gdGhpcy5fcG9pbnRLZXkocCk7XG5cdFx0Y29ubmVjdGVkW3BrZXldID0gcDtcblx0XHRkZWxldGUgbm90Q29ubmVjdGVkW3BrZXldO1xuXHR9XG5cblx0Ly8geCBpcyBub3cgZml4ZWRcblx0dmFyIHggPSBiWzBdO1xuXG5cdGlmIChmcm9tWzFdIDwgdG9bMV0pIHtcblx0XHRhID0gZnJvbTtcblx0XHRiID0gdG87XG5cdH0gZWxzZSB7XG5cdFx0YSA9IHRvO1xuXHRcdGIgPSBmcm9tO1xuXHR9XG5cdGZvciAodmFyIHl5ID0gYVsxXTsgeXkgPCBiWzFdOyB5eSsrKSB7XG5cdFx0dGhpcy5fbWFwW3hdW3l5XSA9IDA7XG5cdFx0dmFyIHAgPSBbeCwgeXldO1xuXHRcdHZhciBwa2V5ID0gdGhpcy5fcG9pbnRLZXkocCk7XG5cdFx0Y29ubmVjdGVkW3BrZXldID0gcDtcblx0XHRkZWxldGUgbm90Q29ubmVjdGVkW3BrZXldO1xuXHR9XG59XG5cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLl9mcmVlU3BhY2UgPSBmdW5jdGlvbih4LCB5KSB7XG5cdHJldHVybiB4ID49IDAgJiYgeCA8IHRoaXMuX3dpZHRoICYmIHkgPj0gMCAmJiB5IDwgdGhpcy5faGVpZ2h0ICYmIHRoaXMuX21hcFt4XVt5XSAhPSAxO1xufVxuXG5ST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5fcG9pbnRLZXkgPSBmdW5jdGlvbihwKSB7XG5cdHJldHVybiBwWzBdICsgXCIuXCIgKyBwWzFdO1xufVxuXG4vKipcbiAqIEBjbGFzcyBEdW5nZW9uIG1hcDogaGFzIHJvb21zIGFuZCBjb3JyaWRvcnNcbiAqIEBhdWdtZW50cyBST1QuTWFwXG4gKi9cblJPVC5NYXAuRHVuZ2VvbiA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0Uk9ULk1hcC5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuXHR0aGlzLl9yb29tcyA9IFtdOyAvKiBsaXN0IG9mIGFsbCByb29tcyAqL1xuXHR0aGlzLl9jb3JyaWRvcnMgPSBbXTtcbn1cblJPVC5NYXAuRHVuZ2Vvbi5leHRlbmQoUk9ULk1hcCk7XG5cbi8qKlxuICogR2V0IGFsbCBnZW5lcmF0ZWQgcm9vbXNcbiAqIEByZXR1cm5zIHtST1QuTWFwLkZlYXR1cmUuUm9vbVtdfVxuICovXG5ST1QuTWFwLkR1bmdlb24ucHJvdG90eXBlLmdldFJvb21zID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9yb29tcztcbn1cblxuLyoqXG4gKiBHZXQgYWxsIGdlbmVyYXRlZCBjb3JyaWRvcnNcbiAqIEByZXR1cm5zIHtST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3JbXX1cbiAqL1xuUk9ULk1hcC5EdW5nZW9uLnByb3RvdHlwZS5nZXRDb3JyaWRvcnMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX2NvcnJpZG9ycztcbn1cbi8qKlxuICogQGNsYXNzIFJhbmRvbSBkdW5nZW9uIGdlbmVyYXRvciB1c2luZyBodW1hbi1saWtlIGRpZ2dpbmcgcGF0dGVybnMuXG4gKiBIZWF2aWx5IGJhc2VkIG9uIE1pa2UgQW5kZXJzb24ncyBpZGVhcyBmcm9tIHRoZSBcIlR5cmFudFwiIGFsZ28sIG1lbnRpb25lZCBhdCBcbiAqIGh0dHA6Ly93d3cucm9ndWViYXNpbi5yb2d1ZWxpa2VkZXZlbG9wbWVudC5vcmcvaW5kZXgucGhwP3RpdGxlPUR1bmdlb24tQnVpbGRpbmdfQWxnb3JpdGhtLlxuICogQGF1Z21lbnRzIFJPVC5NYXAuRHVuZ2VvblxuICovXG5ST1QuTWFwLkRpZ2dlciA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcblx0Uk9ULk1hcC5EdW5nZW9uLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG5cdFxuXHR0aGlzLl9vcHRpb25zID0ge1xuXHRcdHJvb21XaWR0aDogWzMsIDldLCAvKiByb29tIG1pbmltdW0gYW5kIG1heGltdW0gd2lkdGggKi9cblx0XHRyb29tSGVpZ2h0OiBbMywgNV0sIC8qIHJvb20gbWluaW11bSBhbmQgbWF4aW11bSBoZWlnaHQgKi9cblx0XHRjb3JyaWRvckxlbmd0aDogWzMsIDEwXSwgLyogY29ycmlkb3IgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggKi9cblx0XHRkdWdQZXJjZW50YWdlOiAwLjIsIC8qIHdlIHN0b3AgYWZ0ZXIgdGhpcyBwZXJjZW50YWdlIG9mIGxldmVsIGFyZWEgaGFzIGJlZW4gZHVnIG91dCAqL1xuXHRcdHRpbWVMaW1pdDogMTAwMCAvKiB3ZSBzdG9wIGFmdGVyIHRoaXMgbXVjaCB0aW1lIGhhcyBwYXNzZWQgKG1zZWMpICovXG5cdH1cblx0Zm9yICh2YXIgcCBpbiBvcHRpb25zKSB7IHRoaXMuX29wdGlvbnNbcF0gPSBvcHRpb25zW3BdOyB9XG5cdFxuXHR0aGlzLl9mZWF0dXJlcyA9IHtcblx0XHRcIlJvb21cIjogNCxcblx0XHRcIkNvcnJpZG9yXCI6IDRcblx0fVxuXHR0aGlzLl9mZWF0dXJlQXR0ZW1wdHMgPSAyMDsgLyogaG93IG1hbnkgdGltZXMgZG8gd2UgdHJ5IHRvIGNyZWF0ZSBhIGZlYXR1cmUgb24gYSBzdWl0YWJsZSB3YWxsICovXG5cdHRoaXMuX3dhbGxzID0ge307IC8qIHRoZXNlIGFyZSBhdmFpbGFibGUgZm9yIGRpZ2dpbmcgKi9cblx0XG5cdHRoaXMuX2RpZ0NhbGxiYWNrID0gdGhpcy5fZGlnQ2FsbGJhY2suYmluZCh0aGlzKTtcblx0dGhpcy5fY2FuQmVEdWdDYWxsYmFjayA9IHRoaXMuX2NhbkJlRHVnQ2FsbGJhY2suYmluZCh0aGlzKTtcblx0dGhpcy5faXNXYWxsQ2FsbGJhY2sgPSB0aGlzLl9pc1dhbGxDYWxsYmFjay5iaW5kKHRoaXMpO1xuXHR0aGlzLl9wcmlvcml0eVdhbGxDYWxsYmFjayA9IHRoaXMuX3ByaW9yaXR5V2FsbENhbGxiYWNrLmJpbmQodGhpcyk7XG59XG5ST1QuTWFwLkRpZ2dlci5leHRlbmQoUk9ULk1hcC5EdW5nZW9uKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtYXBcbiAqIEBzZWUgUk9ULk1hcCNjcmVhdGVcbiAqL1xuUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHRoaXMuX3Jvb21zID0gW107XG5cdHRoaXMuX2NvcnJpZG9ycyA9IFtdO1xuXHR0aGlzLl9tYXAgPSB0aGlzLl9maWxsTWFwKDEpO1xuXHR0aGlzLl93YWxscyA9IHt9O1xuXHR0aGlzLl9kdWcgPSAwO1xuXHR2YXIgYXJlYSA9ICh0aGlzLl93aWR0aC0yKSAqICh0aGlzLl9oZWlnaHQtMik7XG5cblx0dGhpcy5fZmlyc3RSb29tKCk7XG5cdFxuXHR2YXIgdDEgPSBEYXRlLm5vdygpO1xuXG5cdGRvIHtcblx0XHR2YXIgdDIgPSBEYXRlLm5vdygpO1xuXHRcdGlmICh0MiAtIHQxID4gdGhpcy5fb3B0aW9ucy50aW1lTGltaXQpIHsgYnJlYWs7IH1cblxuXHRcdC8qIGZpbmQgYSBnb29kIHdhbGwgKi9cblx0XHR2YXIgd2FsbCA9IHRoaXMuX2ZpbmRXYWxsKCk7XG5cdFx0aWYgKCF3YWxsKSB7IGJyZWFrOyB9IC8qIG5vIG1vcmUgd2FsbHMgKi9cblx0XHRcblx0XHR2YXIgcGFydHMgPSB3YWxsLnNwbGl0KFwiLFwiKTtcblx0XHR2YXIgeCA9IHBhcnNlSW50KHBhcnRzWzBdKTtcblx0XHR2YXIgeSA9IHBhcnNlSW50KHBhcnRzWzFdKTtcblx0XHR2YXIgZGlyID0gdGhpcy5fZ2V0RGlnZ2luZ0RpcmVjdGlvbih4LCB5KTtcblx0XHRpZiAoIWRpcikgeyBjb250aW51ZTsgfSAvKiB0aGlzIHdhbGwgaXMgbm90IHN1aXRhYmxlICovXG5cdFx0XG4vL1x0XHRjb25zb2xlLmxvZyhcIndhbGxcIiwgeCwgeSk7XG5cblx0XHQvKiB0cnkgYWRkaW5nIGEgZmVhdHVyZSAqL1xuXHRcdHZhciBmZWF0dXJlQXR0ZW1wdHMgPSAwO1xuXHRcdGRvIHtcblx0XHRcdGZlYXR1cmVBdHRlbXB0cysrO1xuXHRcdFx0aWYgKHRoaXMuX3RyeUZlYXR1cmUoeCwgeSwgZGlyWzBdLCBkaXJbMV0pKSB7IC8qIGZlYXR1cmUgYWRkZWQgKi9cblx0XHRcdFx0Ly9pZiAodGhpcy5fcm9vbXMubGVuZ3RoICsgdGhpcy5fY29ycmlkb3JzLmxlbmd0aCA9PSAyKSB7IHRoaXMuX3Jvb21zWzBdLmFkZERvb3IoeCwgeSk7IH0gLyogZmlyc3Qgcm9vbSBvZmljaWFsbHkgaGFzIGRvb3JzICovXG5cdFx0XHRcdHRoaXMuX3JlbW92ZVN1cnJvdW5kaW5nV2FsbHMoeCwgeSk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVN1cnJvdW5kaW5nV2FsbHMoeC1kaXJbMF0sIHktZGlyWzFdKTtcblx0XHRcdFx0YnJlYWs7IFxuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKGZlYXR1cmVBdHRlbXB0cyA8IHRoaXMuX2ZlYXR1cmVBdHRlbXB0cyk7XG5cdFx0XG5cdFx0dmFyIHByaW9yaXR5V2FsbHMgPSAwO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX3dhbGxzKSB7IFxuXHRcdFx0aWYgKHRoaXMuX3dhbGxzW2lkXSA+IDEpIHsgcHJpb3JpdHlXYWxscysrOyB9XG5cdFx0fVxuXG5cdH0gd2hpbGUgKHRoaXMuX2R1Zy9hcmVhIDwgdGhpcy5fb3B0aW9ucy5kdWdQZXJjZW50YWdlIHx8IHByaW9yaXR5V2FsbHMpOyAvKiBmaXhtZSBudW1iZXIgb2YgcHJpb3JpdHkgd2FsbHMgKi9cblxuXHR0aGlzLl9hZGREb29ycygpO1xuXG5cdGlmIChjYWxsYmFjaykge1xuXHRcdGZvciAodmFyIGk9MDtpPHRoaXMuX3dpZHRoO2krKykge1xuXHRcdFx0Zm9yICh2YXIgaj0wO2o8dGhpcy5faGVpZ2h0O2orKykge1xuXHRcdFx0XHRjYWxsYmFjayhpLCBqLCB0aGlzLl9tYXBbaV1bal0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0dGhpcy5fd2FsbHMgPSB7fTtcblx0dGhpcy5fbWFwID0gbnVsbDtcblxuXHRyZXR1cm4gdGhpcztcbn1cblxuUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9kaWdDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG5cdGlmICh2YWx1ZSA9PSAwIHx8IHZhbHVlID09IDIpIHsgLyogZW1wdHkgKi9cblx0XHR0aGlzLl9tYXBbeF1beV0gPSAwO1xuXHRcdHRoaXMuX2R1ZysrO1xuXHR9IGVsc2UgeyAvKiB3YWxsICovXG5cdFx0dGhpcy5fd2FsbHNbeCtcIixcIit5XSA9IDE7XG5cdH1cbn1cblxuUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9pc1dhbGxDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0aWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5fd2lkdGggfHwgeSA+PSB0aGlzLl9oZWlnaHQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiAodGhpcy5fbWFwW3hdW3ldID09IDEpO1xufVxuXG5ST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX2NhbkJlRHVnQ2FsbGJhY2sgPSBmdW5jdGlvbih4LCB5KSB7XG5cdGlmICh4IDwgMSB8fCB5IDwgMSB8fCB4KzEgPj0gdGhpcy5fd2lkdGggfHwgeSsxID49IHRoaXMuX2hlaWdodCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuICh0aGlzLl9tYXBbeF1beV0gPT0gMSk7XG59XG5cblJPVC5NYXAuRGlnZ2VyLnByb3RvdHlwZS5fcHJpb3JpdHlXYWxsQ2FsbGJhY2sgPSBmdW5jdGlvbih4LCB5KSB7XG5cdHRoaXMuX3dhbGxzW3grXCIsXCIreV0gPSAyO1xufVxuXG5ST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX2ZpcnN0Um9vbSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgY3ggPSBNYXRoLmZsb29yKHRoaXMuX3dpZHRoLzIpO1xuXHR2YXIgY3kgPSBNYXRoLmZsb29yKHRoaXMuX2hlaWdodC8yKTtcblx0dmFyIHJvb20gPSBST1QuTWFwLkZlYXR1cmUuUm9vbS5jcmVhdGVSYW5kb21DZW50ZXIoY3gsIGN5LCB0aGlzLl9vcHRpb25zKTtcblx0dGhpcy5fcm9vbXMucHVzaChyb29tKTtcblx0cm9vbS5jcmVhdGUodGhpcy5fZGlnQ2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEdldCBhIHN1aXRhYmxlIHdhbGxcbiAqL1xuUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9maW5kV2FsbCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcHJpbzEgPSBbXTtcblx0dmFyIHByaW8yID0gW107XG5cdGZvciAodmFyIGlkIGluIHRoaXMuX3dhbGxzKSB7XG5cdFx0dmFyIHByaW8gPSB0aGlzLl93YWxsc1tpZF07XG5cdFx0aWYgKHByaW8gPT0gMikgeyBcblx0XHRcdHByaW8yLnB1c2goaWQpOyBcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJpbzEucHVzaChpZCk7XG5cdFx0fVxuXHR9XG5cdFxuXHR2YXIgYXJyID0gKHByaW8yLmxlbmd0aCA/IHByaW8yIDogcHJpbzEpO1xuXHRpZiAoIWFyci5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH0gLyogbm8gd2FsbHMgOi8gKi9cblx0XG5cdHZhciBpZCA9IGFyci5yYW5kb20oKTtcblx0ZGVsZXRlIHRoaXMuX3dhbGxzW2lkXTtcblxuXHRyZXR1cm4gaWQ7XG59XG5cbi8qKlxuICogVHJpZXMgYWRkaW5nIGEgZmVhdHVyZVxuICogQHJldHVybnMge2Jvb2x9IHdhcyB0aGlzIGEgc3VjY2Vzc2Z1bCB0cnk/XG4gKi9cblJPVC5NYXAuRGlnZ2VyLnByb3RvdHlwZS5fdHJ5RmVhdHVyZSA9IGZ1bmN0aW9uKHgsIHksIGR4LCBkeSkge1xuXHR2YXIgZmVhdHVyZSA9IFJPVC5STkcuZ2V0V2VpZ2h0ZWRWYWx1ZSh0aGlzLl9mZWF0dXJlcyk7XG5cdGZlYXR1cmUgPSBST1QuTWFwLkZlYXR1cmVbZmVhdHVyZV0uY3JlYXRlUmFuZG9tQXQoeCwgeSwgZHgsIGR5LCB0aGlzLl9vcHRpb25zKTtcblx0XG5cdGlmICghZmVhdHVyZS5pc1ZhbGlkKHRoaXMuX2lzV2FsbENhbGxiYWNrLCB0aGlzLl9jYW5CZUR1Z0NhbGxiYWNrKSkge1xuLy9cdFx0Y29uc29sZS5sb2coXCJub3QgdmFsaWRcIik7XG4vL1x0XHRmZWF0dXJlLmRlYnVnKCk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxuXHRmZWF0dXJlLmNyZWF0ZSh0aGlzLl9kaWdDYWxsYmFjayk7XG4vL1x0ZmVhdHVyZS5kZWJ1ZygpO1xuXG5cdGlmIChmZWF0dXJlIGluc3RhbmNlb2YgUk9ULk1hcC5GZWF0dXJlLlJvb20pIHsgdGhpcy5fcm9vbXMucHVzaChmZWF0dXJlKTsgfVxuXHRpZiAoZmVhdHVyZSBpbnN0YW5jZW9mIFJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvcikgeyBcblx0XHRmZWF0dXJlLmNyZWF0ZVByaW9yaXR5V2FsbHModGhpcy5fcHJpb3JpdHlXYWxsQ2FsbGJhY2spO1xuXHRcdHRoaXMuX2NvcnJpZG9ycy5wdXNoKGZlYXR1cmUpOyBcblx0fVxuXHRcblx0cmV0dXJuIHRydWU7XG59XG5cblJPVC5NYXAuRGlnZ2VyLnByb3RvdHlwZS5fcmVtb3ZlU3Vycm91bmRpbmdXYWxscyA9IGZ1bmN0aW9uKGN4LCBjeSkge1xuXHR2YXIgZGVsdGFzID0gUk9ULkRJUlNbNF07XG5cblx0Zm9yICh2YXIgaT0wO2k8ZGVsdGFzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgZGVsdGEgPSBkZWx0YXNbaV07XG5cdFx0dmFyIHggPSBjeCArIGRlbHRhWzBdO1xuXHRcdHZhciB5ID0gY3kgKyBkZWx0YVsxXTtcblx0XHRkZWxldGUgdGhpcy5fd2FsbHNbeCtcIixcIit5XTtcblx0XHR2YXIgeCA9IGN4ICsgMipkZWx0YVswXTtcblx0XHR2YXIgeSA9IGN5ICsgMipkZWx0YVsxXTtcblx0XHRkZWxldGUgdGhpcy5fd2FsbHNbeCtcIixcIit5XTtcblx0fVxufVxuXG4vKipcbiAqIFJldHVybnMgdmVjdG9yIGluIFwiZGlnZ2luZ1wiIGRpcmVjdGlvbiwgb3IgZmFsc2UsIGlmIHRoaXMgZG9lcyBub3QgZXhpc3QgKG9yIGlzIG5vdCB1bmlxdWUpXG4gKi9cblJPVC5NYXAuRGlnZ2VyLnByb3RvdHlwZS5fZ2V0RGlnZ2luZ0RpcmVjdGlvbiA9IGZ1bmN0aW9uKGN4LCBjeSkge1xuXHR2YXIgcmVzdWx0ID0gbnVsbDtcblx0dmFyIGRlbHRhcyA9IFJPVC5ESVJTWzRdO1xuXHRcblx0Zm9yICh2YXIgaT0wO2k8ZGVsdGFzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgZGVsdGEgPSBkZWx0YXNbaV07XG5cdFx0dmFyIHggPSBjeCArIGRlbHRhWzBdO1xuXHRcdHZhciB5ID0gY3kgKyBkZWx0YVsxXTtcblx0XHRcblx0XHRpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+PSB0aGlzLl93aWR0aCB8fCB5ID49IHRoaXMuX3dpZHRoKSB7IHJldHVybiBudWxsOyB9XG5cdFx0XG5cdFx0aWYgKCF0aGlzLl9tYXBbeF1beV0pIHsgLyogdGhlcmUgYWxyZWFkeSBpcyBhbm90aGVyIGVtcHR5IG5laWdoYm9yISAqL1xuXHRcdFx0aWYgKHJlc3VsdCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdFx0cmVzdWx0ID0gZGVsdGE7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKiBubyBlbXB0eSBuZWlnaGJvciAqL1xuXHRpZiAoIXJlc3VsdCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcblx0cmV0dXJuIFstcmVzdWx0WzBdLCAtcmVzdWx0WzFdXTtcbn1cblxuLyoqXG4gKiBGaW5kIGVtcHR5IHNwYWNlcyBzdXJyb3VuZGluZyByb29tcywgYW5kIGFwcGx5IGRvb3JzLlxuICovXG5ST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX2FkZERvb3JzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBkYXRhID0gdGhpcy5fbWFwO1xuXHR2YXIgaXNXYWxsQ2FsbGJhY2sgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0cmV0dXJuIChkYXRhW3hdW3ldID09IDEpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vbXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dmFyIHJvb20gPSB0aGlzLl9yb29tc1tpXTtcblx0XHRyb29tLmNsZWFyRG9vcnMoKTtcblx0XHRyb29tLmFkZERvb3JzKGlzV2FsbENhbGxiYWNrKTtcblx0fVxufVxuLyoqXG4gKiBAY2xhc3MgRHVuZ2VvbiBnZW5lcmF0b3Igd2hpY2ggdHJpZXMgdG8gZmlsbCB0aGUgc3BhY2UgZXZlbmx5LiBHZW5lcmF0ZXMgaW5kZXBlbmRlbnQgcm9vbXMgYW5kIHRyaWVzIHRvIGNvbm5lY3QgdGhlbS5cbiAqIEBhdWdtZW50cyBST1QuTWFwLkR1bmdlb25cbiAqL1xuUk9ULk1hcC5Vbmlmb3JtID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuXHRST1QuTWFwLkR1bmdlb24uY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcblxuXHR0aGlzLl9vcHRpb25zID0ge1xuXHRcdHJvb21XaWR0aDogWzMsIDldLCAvKiByb29tIG1pbmltdW0gYW5kIG1heGltdW0gd2lkdGggKi9cblx0XHRyb29tSGVpZ2h0OiBbMywgNV0sIC8qIHJvb20gbWluaW11bSBhbmQgbWF4aW11bSBoZWlnaHQgKi9cblx0XHRyb29tRHVnUGVyY2VudGFnZTogMC4xLCAvKiB3ZSBzdG9wIGFmdGVyIHRoaXMgcGVyY2VudGFnZSBvZiBsZXZlbCBhcmVhIGhhcyBiZWVuIGR1ZyBvdXQgYnkgcm9vbXMgKi9cblx0XHR0aW1lTGltaXQ6IDEwMDAgLyogd2Ugc3RvcCBhZnRlciB0aGlzIG11Y2ggdGltZSBoYXMgcGFzc2VkIChtc2VjKSAqL1xuXHR9XG5cdGZvciAodmFyIHAgaW4gb3B0aW9ucykgeyB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsgfVxuXG5cdHRoaXMuX3Jvb21BdHRlbXB0cyA9IDIwOyAvKiBuZXcgcm9vbSBpcyBjcmVhdGVkIE4tdGltZXMgdW50aWwgaXMgY29uc2lkZXJlZCBhcyBpbXBvc3NpYmxlIHRvIGdlbmVyYXRlICovXG5cdHRoaXMuX2NvcnJpZG9yQXR0ZW1wdHMgPSAyMDsgLyogY29ycmlkb3JzIGFyZSB0cmllZCBOLXRpbWVzIHVudGlsIHRoZSBsZXZlbCBpcyBjb25zaWRlcmVkIGFzIGltcG9zc2libGUgdG8gY29ubmVjdCAqL1xuXG5cdHRoaXMuX2Nvbm5lY3RlZCA9IFtdOyAvKiBsaXN0IG9mIGFscmVhZHkgY29ubmVjdGVkIHJvb21zICovXG5cdHRoaXMuX3VuY29ubmVjdGVkID0gW107IC8qIGxpc3Qgb2YgcmVtYWluaW5nIHVuY29ubmVjdGVkIHJvb21zICovXG5cdFxuXHR0aGlzLl9kaWdDYWxsYmFjayA9IHRoaXMuX2RpZ0NhbGxiYWNrLmJpbmQodGhpcyk7XG5cdHRoaXMuX2NhbkJlRHVnQ2FsbGJhY2sgPSB0aGlzLl9jYW5CZUR1Z0NhbGxiYWNrLmJpbmQodGhpcyk7XG5cdHRoaXMuX2lzV2FsbENhbGxiYWNrID0gdGhpcy5faXNXYWxsQ2FsbGJhY2suYmluZCh0aGlzKTtcbn1cblJPVC5NYXAuVW5pZm9ybS5leHRlbmQoUk9ULk1hcC5EdW5nZW9uKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtYXAuIElmIHRoZSB0aW1lIGxpbWl0IGhhcyBiZWVuIGhpdCwgcmV0dXJucyBudWxsLlxuICogQHNlZSBST1QuTWFwI2NyZWF0ZVxuICovXG5ST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHZhciB0MSA9IERhdGUubm93KCk7XG5cdHdoaWxlICgxKSB7XG5cdFx0dmFyIHQyID0gRGF0ZS5ub3coKTtcblx0XHRpZiAodDIgLSB0MSA+IHRoaXMuX29wdGlvbnMudGltZUxpbWl0KSB7IHJldHVybiBudWxsOyB9IC8qIHRpbWUgbGltaXQhICovXG5cdFxuXHRcdHRoaXMuX21hcCA9IHRoaXMuX2ZpbGxNYXAoMSk7XG5cdFx0dGhpcy5fZHVnID0gMDtcblx0XHR0aGlzLl9yb29tcyA9IFtdO1xuXHRcdHRoaXMuX3VuY29ubmVjdGVkID0gW107XG5cdFx0dGhpcy5fZ2VuZXJhdGVSb29tcygpO1xuXHRcdGlmICh0aGlzLl9yb29tcy5sZW5ndGggPCAyKSB7IGNvbnRpbnVlOyB9XG5cdFx0aWYgKHRoaXMuX2dlbmVyYXRlQ29ycmlkb3JzKCkpIHsgYnJlYWs7IH1cblx0fVxuXHRcblx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fd2lkdGg7aSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqPTA7ajx0aGlzLl9oZWlnaHQ7aisrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGksIGosIHRoaXMuX21hcFtpXVtqXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzdWl0YWJsZSBhbW91bnQgb2Ygcm9vbXNcbiAqL1xuUk9ULk1hcC5Vbmlmb3JtLnByb3RvdHlwZS5fZ2VuZXJhdGVSb29tcyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdyA9IHRoaXMuX3dpZHRoLTI7XG5cdHZhciBoID0gdGhpcy5faGVpZ2h0LTI7XG5cblx0ZG8ge1xuXHRcdHZhciByb29tID0gdGhpcy5fZ2VuZXJhdGVSb29tKCk7XG5cdFx0aWYgKHRoaXMuX2R1Zy8odypoKSA+IHRoaXMuX29wdGlvbnMucm9vbUR1Z1BlcmNlbnRhZ2UpIHsgYnJlYWs7IH0gLyogYWNoaWV2ZWQgcmVxdWVzdGVkIGFtb3VudCBvZiBmcmVlIHNwYWNlICovXG5cdH0gd2hpbGUgKHJvb20pO1xuXG5cdC8qIGVpdGhlciBlbm91Z2ggcm9vbXMsIG9yIG5vdCBhYmxlIHRvIGdlbmVyYXRlIG1vcmUgb2YgdGhlbSA6KSAqL1xufVxuXG4vKipcbiAqIFRyeSB0byBnZW5lcmF0ZSBvbmUgcm9vbVxuICovXG5ST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9nZW5lcmF0ZVJvb20gPSBmdW5jdGlvbigpIHtcblx0dmFyIGNvdW50ID0gMDtcblx0d2hpbGUgKGNvdW50IDwgdGhpcy5fcm9vbUF0dGVtcHRzKSB7XG5cdFx0Y291bnQrKztcblx0XHRcblx0XHR2YXIgcm9vbSA9IFJPVC5NYXAuRmVhdHVyZS5Sb29tLmNyZWF0ZVJhbmRvbSh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCB0aGlzLl9vcHRpb25zKTtcblx0XHRpZiAoIXJvb20uaXNWYWxpZCh0aGlzLl9pc1dhbGxDYWxsYmFjaywgdGhpcy5fY2FuQmVEdWdDYWxsYmFjaykpIHsgY29udGludWU7IH1cblx0XHRcblx0XHRyb29tLmNyZWF0ZSh0aGlzLl9kaWdDYWxsYmFjayk7XG5cdFx0dGhpcy5fcm9vbXMucHVzaChyb29tKTtcblx0XHRyZXR1cm4gcm9vbTtcblx0fSBcblxuXHQvKiBubyByb29tIHdhcyBnZW5lcmF0ZWQgaW4gYSBnaXZlbiBudW1iZXIgb2YgYXR0ZW1wdHMgKi9cblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGNvbm5lY3RvcnMgYmV3ZWVuIHJvb21zXG4gKiBAcmV0dXJucyB7Ym9vbH0gc3VjY2VzcyBXYXMgdGhpcyBhdHRlbXB0IHN1Y2Nlc3NmdWxsP1xuICovXG5ST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9nZW5lcmF0ZUNvcnJpZG9ycyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgY250ID0gMDtcblx0d2hpbGUgKGNudCA8IHRoaXMuX2NvcnJpZG9yQXR0ZW1wdHMpIHtcblx0XHRjbnQrKztcblx0XHR0aGlzLl9jb3JyaWRvcnMgPSBbXTtcblxuXHRcdC8qIGRpZyByb29tcyBpbnRvIGEgY2xlYXIgbWFwICovXG5cdFx0dGhpcy5fbWFwID0gdGhpcy5fZmlsbE1hcCgxKTtcblx0XHRmb3IgKHZhciBpPTA7aTx0aGlzLl9yb29tcy5sZW5ndGg7aSsrKSB7IFxuXHRcdFx0dmFyIHJvb20gPSB0aGlzLl9yb29tc1tpXTtcblx0XHRcdHJvb20uY2xlYXJEb29ycygpO1xuXHRcdFx0cm9vbS5jcmVhdGUodGhpcy5fZGlnQ2FsbGJhY2spOyBcblx0XHR9XG5cblx0XHR0aGlzLl91bmNvbm5lY3RlZCA9IHRoaXMuX3Jvb21zLnNsaWNlKCkucmFuZG9taXplKCk7XG5cdFx0dGhpcy5fY29ubmVjdGVkID0gW107XG5cdFx0aWYgKHRoaXMuX3VuY29ubmVjdGVkLmxlbmd0aCkgeyB0aGlzLl9jb25uZWN0ZWQucHVzaCh0aGlzLl91bmNvbm5lY3RlZC5wb3AoKSk7IH0gLyogZmlyc3Qgb25lIGlzIGFsd2F5cyBjb25uZWN0ZWQgKi9cblx0XHRcblx0XHR3aGlsZSAoMSkge1xuXHRcdFx0LyogMS4gcGljayByYW5kb20gY29ubmVjdGVkIHJvb20gKi9cblx0XHRcdHZhciBjb25uZWN0ZWQgPSB0aGlzLl9jb25uZWN0ZWQucmFuZG9tKCk7XG5cdFx0XHRcblx0XHRcdC8qIDIuIGZpbmQgY2xvc2VzdCB1bmNvbm5lY3RlZCAqL1xuXHRcdFx0dmFyIHJvb20xID0gdGhpcy5fY2xvc2VzdFJvb20odGhpcy5fdW5jb25uZWN0ZWQsIGNvbm5lY3RlZCk7XG5cdFx0XHRcblx0XHRcdC8qIDMuIGNvbm5lY3QgaXQgdG8gY2xvc2VzdCBjb25uZWN0ZWQgKi9cblx0XHRcdHZhciByb29tMiA9IHRoaXMuX2Nsb3Nlc3RSb29tKHRoaXMuX2Nvbm5lY3RlZCwgcm9vbTEpO1xuXHRcdFx0XG5cdFx0XHR2YXIgb2sgPSB0aGlzLl9jb25uZWN0Um9vbXMocm9vbTEsIHJvb20yKTtcblx0XHRcdGlmICghb2spIHsgYnJlYWs7IH0gLyogc3RvcCBjb25uZWN0aW5nLCByZS1zaHVmZmxlICovXG5cdFx0XHRcblx0XHRcdGlmICghdGhpcy5fdW5jb25uZWN0ZWQubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9IC8qIGRvbmU7IG5vIHJvb21zIHJlbWFpbiAqL1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogRm9yIGEgZ2l2ZW4gcm9vbSwgZmluZCB0aGUgY2xvc2VzdCBvbmUgZnJvbSB0aGUgbGlzdFxuICovXG5ST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9jbG9zZXN0Um9vbSA9IGZ1bmN0aW9uKHJvb21zLCByb29tKSB7XG5cdHZhciBkaXN0ID0gSW5maW5pdHk7XG5cdHZhciBjZW50ZXIgPSByb29tLmdldENlbnRlcigpO1xuXHR2YXIgcmVzdWx0ID0gbnVsbDtcblx0XG5cdGZvciAodmFyIGk9MDtpPHJvb21zLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgciA9IHJvb21zW2ldO1xuXHRcdHZhciBjID0gci5nZXRDZW50ZXIoKTtcblx0XHR2YXIgZHggPSBjWzBdLWNlbnRlclswXTtcblx0XHR2YXIgZHkgPSBjWzFdLWNlbnRlclsxXTtcblx0XHR2YXIgZCA9IGR4KmR4K2R5KmR5O1xuXHRcdFxuXHRcdGlmIChkIDwgZGlzdCkge1xuXHRcdFx0ZGlzdCA9IGQ7XG5cdFx0XHRyZXN1bHQgPSByO1xuXHRcdH1cblx0fVxuXHRcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuUk9ULk1hcC5Vbmlmb3JtLnByb3RvdHlwZS5fY29ubmVjdFJvb21zID0gZnVuY3Rpb24ocm9vbTEsIHJvb20yKSB7XG5cdC8qXG5cdFx0cm9vbTEuZGVidWcoKTtcblx0XHRyb29tMi5kZWJ1ZygpO1xuXHQqL1xuXG5cdHZhciBjZW50ZXIxID0gcm9vbTEuZ2V0Q2VudGVyKCk7XG5cdHZhciBjZW50ZXIyID0gcm9vbTIuZ2V0Q2VudGVyKCk7XG5cblx0dmFyIGRpZmZYID0gY2VudGVyMlswXSAtIGNlbnRlcjFbMF07XG5cdHZhciBkaWZmWSA9IGNlbnRlcjJbMV0gLSBjZW50ZXIxWzFdO1xuXG5cdGlmIChNYXRoLmFicyhkaWZmWCkgPCBNYXRoLmFicyhkaWZmWSkpIHsgLyogZmlyc3QgdHJ5IGNvbm5lY3Rpbmcgbm9ydGgtc291dGggd2FsbHMgKi9cblx0XHR2YXIgZGlySW5kZXgxID0gKGRpZmZZID4gMCA/IDIgOiAwKTtcblx0XHR2YXIgZGlySW5kZXgyID0gKGRpckluZGV4MSArIDIpICUgNDtcblx0XHR2YXIgbWluID0gcm9vbTIuZ2V0TGVmdCgpO1xuXHRcdHZhciBtYXggPSByb29tMi5nZXRSaWdodCgpO1xuXHRcdHZhciBpbmRleCA9IDA7XG5cdH0gZWxzZSB7IC8qIGZpcnN0IHRyeSBjb25uZWN0aW5nIGVhc3Qtd2VzdCB3YWxscyAqL1xuXHRcdHZhciBkaXJJbmRleDEgPSAoZGlmZlggPiAwID8gMSA6IDMpO1xuXHRcdHZhciBkaXJJbmRleDIgPSAoZGlySW5kZXgxICsgMikgJSA0O1xuXHRcdHZhciBtaW4gPSByb29tMi5nZXRUb3AoKTtcblx0XHR2YXIgbWF4ID0gcm9vbTIuZ2V0Qm90dG9tKCk7XG5cdFx0dmFyIGluZGV4ID0gMTtcblx0fVxuXG5cdHZhciBzdGFydCA9IHRoaXMuX3BsYWNlSW5XYWxsKHJvb20xLCBkaXJJbmRleDEpOyAvKiBjb3JyaWRvciB3aWxsIHN0YXJ0IGhlcmUgKi9cblx0aWYgKCFzdGFydCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoc3RhcnRbaW5kZXhdID49IG1pbiAmJiBzdGFydFtpbmRleF0gPD0gbWF4KSB7IC8qIHBvc3NpYmxlIHRvIGNvbm5lY3Qgd2l0aCBzdHJhaWdodCBsaW5lIChJLWxpa2UpICovXG5cdFx0dmFyIGVuZCA9IHN0YXJ0LnNsaWNlKCk7XG5cdFx0dmFyIHZhbHVlID0gbnVsbDtcblx0XHRzd2l0Y2ggKGRpckluZGV4Mikge1xuXHRcdFx0Y2FzZSAwOiB2YWx1ZSA9IHJvb20yLmdldFRvcCgpLTE7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB2YWx1ZSA9IHJvb20yLmdldFJpZ2h0KCkrMTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHZhbHVlID0gcm9vbTIuZ2V0Qm90dG9tKCkrMTsgYnJlYWs7XG5cdFx0XHRjYXNlIDM6IHZhbHVlID0gcm9vbTIuZ2V0TGVmdCgpLTE7IGJyZWFrO1xuXHRcdH1cblx0XHRlbmRbKGluZGV4KzEpJTJdID0gdmFsdWU7XG5cdFx0dGhpcy5fZGlnTGluZShbc3RhcnQsIGVuZF0pO1xuXHRcdFxuXHR9IGVsc2UgaWYgKHN0YXJ0W2luZGV4XSA8IG1pbi0xIHx8IHN0YXJ0W2luZGV4XSA+IG1heCsxKSB7IC8qIG5lZWQgdG8gc3dpdGNoIHRhcmdldCB3YWxsIChMLWxpa2UpICovXG5cblx0XHR2YXIgZGlmZiA9IHN0YXJ0W2luZGV4XSAtIGNlbnRlcjJbaW5kZXhdO1xuXHRcdHN3aXRjaCAoZGlySW5kZXgyKSB7XG5cdFx0XHRjYXNlIDA6XG5cdFx0XHRjYXNlIDE6XHR2YXIgcm90YXRpb24gPSAoZGlmZiA8IDAgPyAzIDogMSk7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0Y2FzZSAzOlx0dmFyIHJvdGF0aW9uID0gKGRpZmYgPCAwID8gMSA6IDMpOyBicmVhaztcblx0XHR9XG5cdFx0ZGlySW5kZXgyID0gKGRpckluZGV4MiArIHJvdGF0aW9uKSAlIDQ7XG5cdFx0XG5cdFx0dmFyIGVuZCA9IHRoaXMuX3BsYWNlSW5XYWxsKHJvb20yLCBkaXJJbmRleDIpO1xuXHRcdGlmICghZW5kKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dmFyIG1pZCA9IFswLCAwXTtcblx0XHRtaWRbaW5kZXhdID0gc3RhcnRbaW5kZXhdO1xuXHRcdHZhciBpbmRleDIgPSAoaW5kZXgrMSklMjtcblx0XHRtaWRbaW5kZXgyXSA9IGVuZFtpbmRleDJdO1xuXHRcdHRoaXMuX2RpZ0xpbmUoW3N0YXJ0LCBtaWQsIGVuZF0pO1xuXHRcdFxuXHR9IGVsc2UgeyAvKiB1c2UgY3VycmVudCB3YWxsIHBhaXIsIGJ1dCBhZGp1c3QgdGhlIGxpbmUgaW4gdGhlIG1pZGRsZSAoUy1saWtlKSAqL1xuXHRcblx0XHR2YXIgaW5kZXgyID0gKGluZGV4KzEpJTI7XG5cdFx0dmFyIGVuZCA9IHRoaXMuX3BsYWNlSW5XYWxsKHJvb20yLCBkaXJJbmRleDIpO1xuXHRcdGlmICghZW5kKSB7IHJldHVybjsgfVxuXHRcdHZhciBtaWQgPSBNYXRoLnJvdW5kKChlbmRbaW5kZXgyXSArIHN0YXJ0W2luZGV4Ml0pLzIpO1xuXG5cdFx0dmFyIG1pZDEgPSBbMCwgMF07XG5cdFx0dmFyIG1pZDIgPSBbMCwgMF07XG5cdFx0bWlkMVtpbmRleF0gPSBzdGFydFtpbmRleF07XG5cdFx0bWlkMVtpbmRleDJdID0gbWlkO1xuXHRcdG1pZDJbaW5kZXhdID0gZW5kW2luZGV4XTtcblx0XHRtaWQyW2luZGV4Ml0gPSBtaWQ7XG5cdFx0dGhpcy5fZGlnTGluZShbc3RhcnQsIG1pZDEsIG1pZDIsIGVuZF0pO1xuXHR9XG5cblx0cm9vbTEuYWRkRG9vcihzdGFydFswXSwgc3RhcnRbMV0pO1xuXHRyb29tMi5hZGREb29yKGVuZFswXSwgZW5kWzFdKTtcblx0XG5cdHZhciBpbmRleCA9IHRoaXMuX3VuY29ubmVjdGVkLmluZGV4T2Yocm9vbTEpO1xuXHRpZiAoaW5kZXggIT0gLTEpIHtcblx0XHR0aGlzLl91bmNvbm5lY3RlZC5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdHRoaXMuX2Nvbm5lY3RlZC5wdXNoKHJvb20xKTtcblx0fVxuXG5cdHZhciBpbmRleCA9IHRoaXMuX3VuY29ubmVjdGVkLmluZGV4T2Yocm9vbTIpO1xuXHRpZiAoaW5kZXggIT0gLTEpIHtcblx0XHR0aGlzLl91bmNvbm5lY3RlZC5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdHRoaXMuX2Nvbm5lY3RlZC5wdXNoKHJvb20yKTtcblx0fVxuXHRcblx0cmV0dXJuIHRydWU7XG59XG5cblJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX3BsYWNlSW5XYWxsID0gZnVuY3Rpb24ocm9vbSwgZGlySW5kZXgpIHtcblx0dmFyIHN0YXJ0ID0gWzAsIDBdO1xuXHR2YXIgZGlyID0gWzAsIDBdO1xuXHR2YXIgbGVuZ3RoID0gMDtcblx0XG5cdHN3aXRjaCAoZGlySW5kZXgpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRkaXIgPSBbMSwgMF07XG5cdFx0XHRzdGFydCA9IFtyb29tLmdldExlZnQoKSwgcm9vbS5nZXRUb3AoKS0xXTtcblx0XHRcdGxlbmd0aCA9IHJvb20uZ2V0UmlnaHQoKS1yb29tLmdldExlZnQoKSsxO1xuXHRcdGJyZWFrO1xuXHRcdGNhc2UgMTpcblx0XHRcdGRpciA9IFswLCAxXTtcblx0XHRcdHN0YXJ0ID0gW3Jvb20uZ2V0UmlnaHQoKSsxLCByb29tLmdldFRvcCgpXTtcblx0XHRcdGxlbmd0aCA9IHJvb20uZ2V0Qm90dG9tKCktcm9vbS5nZXRUb3AoKSsxO1xuXHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGRpciA9IFsxLCAwXTtcblx0XHRcdHN0YXJ0ID0gW3Jvb20uZ2V0TGVmdCgpLCByb29tLmdldEJvdHRvbSgpKzFdO1xuXHRcdFx0bGVuZ3RoID0gcm9vbS5nZXRSaWdodCgpLXJvb20uZ2V0TGVmdCgpKzE7XG5cdFx0YnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0ZGlyID0gWzAsIDFdO1xuXHRcdFx0c3RhcnQgPSBbcm9vbS5nZXRMZWZ0KCktMSwgcm9vbS5nZXRUb3AoKV07XG5cdFx0XHRsZW5ndGggPSByb29tLmdldEJvdHRvbSgpLXJvb20uZ2V0VG9wKCkrMTtcblx0XHRicmVhaztcblx0fVxuXHRcblx0dmFyIGF2YWlsID0gW107XG5cdHZhciBsYXN0QmFkSW5kZXggPSAtMjtcblxuXHRmb3IgKHZhciBpPTA7aTxsZW5ndGg7aSsrKSB7XG5cdFx0dmFyIHggPSBzdGFydFswXSArIGkqZGlyWzBdO1xuXHRcdHZhciB5ID0gc3RhcnRbMV0gKyBpKmRpclsxXTtcblx0XHRhdmFpbC5wdXNoKG51bGwpO1xuXHRcdFxuXHRcdHZhciBpc1dhbGwgPSAodGhpcy5fbWFwW3hdW3ldID09IDEpO1xuXHRcdGlmIChpc1dhbGwpIHtcblx0XHRcdGlmIChsYXN0QmFkSW5kZXggIT0gaS0xKSB7IGF2YWlsW2ldID0gW3gsIHldOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxhc3RCYWRJbmRleCA9IGk7XG5cdFx0XHRpZiAoaSkgeyBhdmFpbFtpLTFdID0gbnVsbDsgfVxuXHRcdH1cblx0fVxuXHRcblx0Zm9yICh2YXIgaT1hdmFpbC5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0aWYgKCFhdmFpbFtpXSkgeyBhdmFpbC5zcGxpY2UoaSwgMSk7IH1cblx0fVxuXHRyZXR1cm4gKGF2YWlsLmxlbmd0aCA/IGF2YWlsLnJhbmRvbSgpIDogbnVsbCk7XG59XG5cbi8qKlxuICogRGlnIGEgcG9seWxpbmUuXG4gKi9cblJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2RpZ0xpbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcblx0Zm9yICh2YXIgaT0xO2k8cG9pbnRzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgc3RhcnQgPSBwb2ludHNbaS0xXTtcblx0XHR2YXIgZW5kID0gcG9pbnRzW2ldO1xuXHRcdHZhciBjb3JyaWRvciA9IG5ldyBST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3Ioc3RhcnRbMF0sIHN0YXJ0WzFdLCBlbmRbMF0sIGVuZFsxXSk7XG5cdFx0Y29ycmlkb3IuY3JlYXRlKHRoaXMuX2RpZ0NhbGxiYWNrKTtcblx0XHR0aGlzLl9jb3JyaWRvcnMucHVzaChjb3JyaWRvcik7XG5cdH1cbn1cblxuUk9ULk1hcC5Vbmlmb3JtLnByb3RvdHlwZS5fZGlnQ2FsbGJhY2sgPSBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuXHR0aGlzLl9tYXBbeF1beV0gPSB2YWx1ZTtcblx0aWYgKHZhbHVlID09IDApIHsgdGhpcy5fZHVnKys7IH1cbn1cblxuUk9ULk1hcC5Vbmlmb3JtLnByb3RvdHlwZS5faXNXYWxsQ2FsbGJhY2sgPSBmdW5jdGlvbih4LCB5KSB7XG5cdGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID49IHRoaXMuX3dpZHRoIHx8IHkgPj0gdGhpcy5faGVpZ2h0KSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gKHRoaXMuX21hcFt4XVt5XSA9PSAxKTtcbn1cblxuUk9ULk1hcC5Vbmlmb3JtLnByb3RvdHlwZS5fY2FuQmVEdWdDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0aWYgKHggPCAxIHx8IHkgPCAxIHx8IHgrMSA+PSB0aGlzLl93aWR0aCB8fCB5KzEgPj0gdGhpcy5faGVpZ2h0KSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gKHRoaXMuX21hcFt4XVt5XSA9PSAxKTtcbn1cblxuLyoqXG4gKiBAYXV0aG9yIGh5YWt1Z2VpXG4gKiBAY2xhc3MgRHVuZ2VvbiBnZW5lcmF0b3Igd2hpY2ggdXNlcyB0aGUgXCJvcmdpbmFsXCIgUm9ndWUgZHVuZ2VvbiBnZW5lcmF0aW9uIGFsZ29yaXRobS4gU2VlIGh0dHA6Ly9rdW9pLmNvbS9+a2FtaWthemUvR2FtZURlc2lnbi9hcnQwN19yb2d1ZV9kdW5nZW9uLnBocFxuICogQGF1Z21lbnRzIFJPVC5NYXBcbiAqIEBwYXJhbSB7aW50fSBbd2lkdGg9Uk9ULkRFRkFVTFRfV0lEVEhdXG4gKiBAcGFyYW0ge2ludH0gW2hlaWdodD1ST1QuREVGQVVMVF9IRUlHSFRdXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAqIEBwYXJhbSB7aW50W119IFtvcHRpb25zLmNlbGxXaWR0aD0zXSBOdW1iZXIgb2YgY2VsbHMgdG8gY3JlYXRlIG9uIHRoZSBob3Jpem9udGFsIChudW1iZXIgb2Ygcm9vbXMgaG9yaXpvbnRhbGx5KVxuICogQHBhcmFtIHtpbnRbXX0gW29wdGlvbnMuY2VsbEhlaWdodD0zXSBOdW1iZXIgb2YgY2VsbHMgdG8gY3JlYXRlIG9uIHRoZSB2ZXJ0aWNhbCAobnVtYmVyIG9mIHJvb21zIHZlcnRpY2FsbHkpIFxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnJvb21XaWR0aF0gUm9vbSBtaW4gYW5kIG1heCB3aWR0aCAtIG5vcm1hbGx5IHNldCBhdXRvLW1hZ2ljYWxseSB2aWEgdGhlIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnJvb21IZWlnaHRdIFJvb20gbWluIGFuZCBtYXggaGVpZ2h0IC0gbm9ybWFsbHkgc2V0IGF1dG8tbWFnaWNhbGx5IHZpYSB0aGUgY29uc3RydWN0b3IuIFxuICovXG5ST1QuTWFwLlJvZ3VlID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuXHRST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG5cdFxuXHR0aGlzLl9vcHRpb25zID0ge1xuXHRcdGNlbGxXaWR0aDogMywgIC8vIE5PVEUgdG8gc2VsZiwgdGhlc2UgY291bGQgcHJvYmFibHkgd29yayB0aGUgc2FtZSBhcyB0aGUgcm9vbVdpZHRoL3Jvb20gSGVpZ2h0IHZhbHVlc1xuXHRcdGNlbGxIZWlnaHQ6IDMgIC8vICAgICBpZS4gYXMgYW4gYXJyYXkgd2l0aCBtaW4tbWF4IHZhbHVlcyBmb3IgZWFjaCBkaXJlY3Rpb24uLi4uXG5cdH1cblx0XG5cdGZvciAodmFyIHAgaW4gb3B0aW9ucykgeyB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsgfVxuXHRcblx0Lypcblx0U2V0IHRoZSByb29tIHNpemVzIGFjY29yZGluZyB0byB0aGUgb3Zlci1hbGwgd2lkdGggb2YgdGhlIG1hcCwgXG5cdGFuZCB0aGUgY2VsbCBzaXplcy4gXG5cdCovXG5cdFxuXHRpZiAoIXRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJyb29tV2lkdGhcIikpIHtcblx0XHR0aGlzLl9vcHRpb25zW1wicm9vbVdpZHRoXCJdID0gdGhpcy5fY2FsY3VsYXRlUm9vbVNpemUodGhpcy5fd2lkdGgsIHRoaXMuX29wdGlvbnNbXCJjZWxsV2lkdGhcIl0pO1xuXHR9XG5cdGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eVtcInJvb21IZWlnaHRcIl0pIHtcblx0XHR0aGlzLl9vcHRpb25zW1wicm9vbUhlaWdodFwiXSA9IHRoaXMuX2NhbGN1bGF0ZVJvb21TaXplKHRoaXMuX2hlaWdodCwgdGhpcy5fb3B0aW9uc1tcImNlbGxIZWlnaHRcIl0pO1xuXHR9XG5cdFxufVxuXG5ST1QuTWFwLlJvZ3VlLmV4dGVuZChST1QuTWFwKTsgXG5cbi8qKlxuICogQHNlZSBST1QuTWFwI2NyZWF0ZVxuICovXG5ST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHR0aGlzLm1hcCA9IHRoaXMuX2ZpbGxNYXAoMSk7XG5cdHRoaXMucm9vbXMgPSBbXTtcblx0dGhpcy5jb25uZWN0ZWRDZWxscyA9IFtdO1xuXHRcblx0dGhpcy5faW5pdFJvb21zKCk7XG5cdHRoaXMuX2Nvbm5lY3RSb29tcygpO1xuXHR0aGlzLl9jb25uZWN0VW5jb25uZWN0ZWRSb29tcygpO1xuXHR0aGlzLl9jcmVhdGVSYW5kb21Sb29tQ29ubmVjdGlvbnMoKTtcblx0dGhpcy5fY3JlYXRlUm9vbXMoKTtcblx0dGhpcy5fY3JlYXRlQ29ycmlkb3JzKCk7XG5cdFxuXHRpZiAoY2FsbGJhY2spIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3dpZHRoOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5faGVpZ2h0OyBqKyspIHtcblx0XHRcdFx0Y2FsbGJhY2soaSwgaiwgdGhpcy5tYXBbaV1bal0pOyAgIFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0cmV0dXJuIHRoaXM7XG59XG5cblJPVC5NYXAuUm9ndWUucHJvdG90eXBlLl9nZXRSYW5kb21JbnQgPSBmdW5jdGlvbihtaW4sIG1heCkge1xuXHRyZXR1cm4gTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG59XG5cblJPVC5NYXAuUm9ndWUucHJvdG90eXBlLl9jYWxjdWxhdGVSb29tU2l6ZSA9IGZ1bmN0aW9uKHNpemUsIGNlbGwpIHtcblx0dmFyIG1heCA9IE1hdGguZmxvb3IoKHNpemUvY2VsbCkgKiAwLjgpO1xuXHR2YXIgbWluID0gTWF0aC5mbG9vcigoc2l6ZS9jZWxsKSAqIDAuMjUpO1xuXHRpZiAobWluIDwgMikgbWluID0gMjtcblx0aWYgKG1heCA8IDIpIG1heCA9IDI7XG5cdHJldHVybiBbbWluLCBtYXhdO1xufVxuXG5ST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5faW5pdFJvb21zID0gZnVuY3Rpb24gKCkgeyBcblx0Ly8gY3JlYXRlIHJvb21zIGFycmF5LiBUaGlzIGlzIHRoZSBcImdyaWRcIiBsaXN0IGZyb20gdGhlIGFsZ28uICBcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vcHRpb25zLmNlbGxXaWR0aDsgaSsrKSB7ICBcblx0XHR0aGlzLnJvb21zLnB1c2goW10pO1xuXHRcdGZvcih2YXIgaiA9IDA7IGogPCB0aGlzLl9vcHRpb25zLmNlbGxIZWlnaHQ7IGorKykge1xuXHRcdFx0dGhpcy5yb29tc1tpXS5wdXNoKHtcInhcIjowLCBcInlcIjowLCBcIndpZHRoXCI6MCwgXCJoZWlnaHRcIjowLCBcImNvbm5lY3Rpb25zXCI6W10sIFwiY2VsbHhcIjppLCBcImNlbGx5XCI6an0pO1xuXHRcdH1cblx0fVxufVxuXG5ST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fY29ubmVjdFJvb21zID0gZnVuY3Rpb24oKSB7XG5cdC8vcGljayByYW5kb20gc3RhcnRpbmcgZ3JpZFxuXHR2YXIgY2d4ID0gdGhpcy5fZ2V0UmFuZG9tSW50KDAsIHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoLTEpO1xuXHR2YXIgY2d5ID0gdGhpcy5fZ2V0UmFuZG9tSW50KDAsIHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodC0xKTtcblx0XG5cdHZhciBpZHg7XG5cdHZhciBuY2d4O1xuXHR2YXIgbmNneTtcblx0XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHR2YXIgcm9vbTtcblx0dmFyIG90aGVyUm9vbTtcblx0XG5cdC8vIGZpbmQgIHVuY29ubmVjdGVkIG5laWdoYm91ciBjZWxsc1xuXHRkbyB7XG5cdFxuXHRcdC8vdmFyIGRpclRvQ2hlY2sgPSBbMCwxLDIsMyw0LDUsNiw3XTtcblx0XHR2YXIgZGlyVG9DaGVjayA9IFswLDIsNCw2XTtcblx0XHRkaXJUb0NoZWNrID0gZGlyVG9DaGVjay5yYW5kb21pemUoKTtcblx0XHRcblx0XHRkbyB7XG5cdFx0XHRmb3VuZCA9IGZhbHNlO1xuXHRcdFx0aWR4ID0gZGlyVG9DaGVjay5wb3AoKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRuY2d4ID0gY2d4ICsgUk9ULkRJUlNbOF1baWR4XVswXTtcblx0XHRcdG5jZ3kgPSBjZ3kgKyBST1QuRElSU1s4XVtpZHhdWzFdO1xuXHRcdFx0XG5cdFx0XHRpZihuY2d4IDwgMCB8fCBuY2d4ID49IHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoKSBjb250aW51ZTtcblx0XHRcdGlmKG5jZ3kgPCAwIHx8IG5jZ3kgPj0gdGhpcy5fb3B0aW9ucy5jZWxsSGVpZ2h0KSBjb250aW51ZTtcblx0XHRcdFxuXHRcdFx0cm9vbSA9IHRoaXMucm9vbXNbY2d4XVtjZ3ldO1xuXHRcdFx0XG5cdFx0XHRpZihyb29tW1wiY29ubmVjdGlvbnNcIl0ubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0Ly8gYXMgbG9uZyBhcyB0aGlzIHJvb20gZG9lc24ndCBhbHJlYWR5IGNvb25lY3QgdG8gbWUsIHdlIGFyZSBvayB3aXRoIGl0LiBcblx0XHRcdFx0aWYocm9vbVtcImNvbm5lY3Rpb25zXCJdWzBdWzBdID09IG5jZ3ggJiZcblx0XHRcdFx0cm9vbVtcImNvbm5lY3Rpb25zXCJdWzBdWzFdID09IG5jZ3kpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRvdGhlclJvb20gPSB0aGlzLnJvb21zW25jZ3hdW25jZ3ldO1xuXHRcdFx0XG5cdFx0XHRpZiAob3RoZXJSb29tW1wiY29ubmVjdGlvbnNcIl0ubGVuZ3RoID09IDApIHsgXG5cdFx0XHRcdG90aGVyUm9vbVtcImNvbm5lY3Rpb25zXCJdLnB1c2goW2NneCxjZ3ldKTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuY29ubmVjdGVkQ2VsbHMucHVzaChbbmNneCwgbmNneV0pO1xuXHRcdFx0XHRjZ3ggPSBuY2d4O1xuXHRcdFx0XHRjZ3kgPSBuY2d5O1xuXHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0fSB3aGlsZSAoZGlyVG9DaGVjay5sZW5ndGggPiAwICYmIGZvdW5kID09IGZhbHNlKVxuXHRcdFxuXHR9IHdoaWxlIChkaXJUb0NoZWNrLmxlbmd0aCA+IDApXG5cbn1cblxuUk9ULk1hcC5Sb2d1ZS5wcm90b3R5cGUuX2Nvbm5lY3RVbmNvbm5lY3RlZFJvb21zID0gZnVuY3Rpb24oKSB7XG5cdC8vV2hpbGUgdGhlcmUgYXJlIHVuY29ubmVjdGVkIHJvb21zLCB0cnkgdG8gY29ubmVjdCB0aGVtIHRvIGEgcmFuZG9tIGNvbm5lY3RlZCBuZWlnaGJvciBcblx0Ly8oaWYgYSByb29tIGhhcyBubyBjb25uZWN0ZWQgbmVpZ2hib3JzIHlldCwganVzdCBrZWVwIGN5Y2xpbmcsIHlvdSdsbCBmaWxsIG91dCB0byBpdCBldmVudHVhbGx5KS5cblx0dmFyIGN3ID0gdGhpcy5fb3B0aW9ucy5jZWxsV2lkdGg7XG5cdHZhciBjaCA9IHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodDtcblx0XG5cdHZhciByYW5kb21Db25uZWN0ZWRDZWxsO1xuXHR0aGlzLmNvbm5lY3RlZENlbGxzID0gdGhpcy5jb25uZWN0ZWRDZWxscy5yYW5kb21pemUoKTtcblx0dmFyIHJvb207XG5cdHZhciBvdGhlclJvb207XG5cdHZhciB2YWxpZFJvb207XG5cdFxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoOyBpKyspIHtcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodDsgaisrKSAge1xuXHRcdFx0XHRcblx0XHRcdHJvb20gPSB0aGlzLnJvb21zW2ldW2pdO1xuXHRcdFx0XG5cdFx0XHRpZiAocm9vbVtcImNvbm5lY3Rpb25zXCJdLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdHZhciBkaXJlY3Rpb25zID0gWzAsMiw0LDZdO1xuXHRcdFx0XHRkaXJlY3Rpb25zID0gZGlyZWN0aW9ucy5yYW5kb21pemUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciB2YWxpZFJvb20gPSBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgZGlySWR4ID0gZGlyZWN0aW9ucy5wb3AoKTtcblx0XHRcdFx0XHR2YXIgbmV3SSA9IGkgKyBST1QuRElSU1s4XVtkaXJJZHhdWzBdO1xuXHRcdFx0XHRcdHZhciBuZXdKID0gaiArIFJPVC5ESVJTWzhdW2RpcklkeF1bMV07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG5ld0kgPCAwIHx8IG5ld0kgPj0gY3cgfHwgXG5cdFx0XHRcdFx0bmV3SiA8IDAgfHwgbmV3SiA+PSBjaCkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdG90aGVyUm9vbSA9IHRoaXMucm9vbXNbbmV3SV1bbmV3Sl07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFsaWRSb29tID0gdHJ1ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAob3RoZXJSb29tW1wiY29ubmVjdGlvbnNcIl0ubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IG90aGVyUm9vbVtcImNvbm5lY3Rpb25zXCJdLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRpZihvdGhlclJvb21bXCJjb25uZWN0aW9uc1wiXVtrXVswXSA9PSBpICYmIFxuXHRcdFx0XHRcdFx0b3RoZXJSb29tW1wiY29ubmVjdGlvbnNcIl1ba11bMV0gPT0gaikge1xuXHRcdFx0XHRcdFx0XHR2YWxpZFJvb20gPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICh2YWxpZFJvb20pIGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHR9IHdoaWxlIChkaXJlY3Rpb25zLmxlbmd0aClcblx0XHRcdFx0XG5cdFx0XHRcdGlmKHZhbGlkUm9vbSkgeyBcblx0XHRcdFx0XHRyb29tW1wiY29ubmVjdGlvbnNcIl0ucHVzaCggW290aGVyUm9vbVtcImNlbGx4XCJdLCBvdGhlclJvb21bXCJjZWxseVwiXV0gKTsgIFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiLS0gVW5hYmxlIHRvIGNvbm5lY3Qgcm9vbS5cIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuUk9ULk1hcC5Sb2d1ZS5wcm90b3R5cGUuX2NyZWF0ZVJhbmRvbVJvb21Db25uZWN0aW9ucyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25zKSB7XG5cdC8vIEVtcHR5IGZvciBub3cuIFxufVxuXG5cblJPVC5NYXAuUm9ndWUucHJvdG90eXBlLl9jcmVhdGVSb29tcyA9IGZ1bmN0aW9uKCkge1xuXHQvLyBDcmVhdGUgUm9vbXMgXG5cdFxuXHR2YXIgdyA9IHRoaXMuX3dpZHRoO1xuXHR2YXIgaCA9IHRoaXMuX2hlaWdodDtcblx0XG5cdHZhciBjdyA9IHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoO1xuXHR2YXIgY2ggPSB0aGlzLl9vcHRpb25zLmNlbGxIZWlnaHQ7XG5cdFxuXHR2YXIgY3dwID0gTWF0aC5mbG9vcih0aGlzLl93aWR0aCAvIGN3KTtcblx0dmFyIGNocCA9IE1hdGguZmxvb3IodGhpcy5faGVpZ2h0IC8gY2gpO1xuXHRcblx0dmFyIHJvb213O1xuXHR2YXIgcm9vbWg7XG5cdHZhciByb29tV2lkdGggPSB0aGlzLl9vcHRpb25zW1wicm9vbVdpZHRoXCJdO1xuXHR2YXIgcm9vbUhlaWdodCA9IHRoaXMuX29wdGlvbnNbXCJyb29tSGVpZ2h0XCJdO1xuXHR2YXIgc3g7XG5cdHZhciBzeTtcblx0dmFyIHR4O1xuXHR2YXIgdHk7XG5cdHZhciBvdGhlclJvb207XG5cdFxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGN3OyBpKyspIHtcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNoOyBqKyspIHtcblx0XHRcdHN4ID0gY3dwICogaTtcblx0XHRcdHN5ID0gY2hwICogajtcblx0XHRcdFxuXHRcdFx0aWYgKHN4ID09IDApIHN4ID0gMTtcblx0XHRcdGlmIChzeSA9PSAwKSBzeSA9IDE7XG5cdFx0XHRcblx0XHRcdHJvb213ID0gdGhpcy5fZ2V0UmFuZG9tSW50KHJvb21XaWR0aFswXSwgcm9vbVdpZHRoWzFdKTtcblx0XHRcdHJvb21oID0gdGhpcy5fZ2V0UmFuZG9tSW50KHJvb21IZWlnaHRbMF0sIHJvb21IZWlnaHRbMV0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoaiA+IDApIHtcblx0XHRcdFx0b3RoZXJSb29tID0gdGhpcy5yb29tc1tpXVtqLTFdO1xuXHRcdFx0XHR3aGlsZSAoc3kgLSAob3RoZXJSb29tW1wieVwiXSArIG90aGVyUm9vbVtcImhlaWdodFwiXSApIDwgMykge1xuXHRcdFx0XHRcdHN5Kys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdG90aGVyUm9vbSA9IHRoaXMucm9vbXNbaS0xXVtqXTtcblx0XHRcdFx0d2hpbGUoc3ggLSAob3RoZXJSb29tW1wieFwiXSArIG90aGVyUm9vbVtcIndpZHRoXCJdKSA8IDMpIHtcblx0XHRcdFx0XHRzeCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdHZhciBzeE9mZnNldCA9IE1hdGgucm91bmQodGhpcy5fZ2V0UmFuZG9tSW50KDAsIGN3cC1yb29tdykvMik7XG5cdFx0XHR2YXIgc3lPZmZzZXQgPSBNYXRoLnJvdW5kKHRoaXMuX2dldFJhbmRvbUludCgwLCBjaHAtcm9vbWgpLzIpO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoc3ggKyBzeE9mZnNldCArIHJvb213ID49IHcpIHtcblx0XHRcdFx0aWYoc3hPZmZzZXQpIHtcblx0XHRcdFx0XHRzeE9mZnNldC0tO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJvb213LS07IFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHdoaWxlIChzeSArIHN5T2Zmc2V0ICsgcm9vbWggPj0gaCkgeyBcblx0XHRcdFx0aWYoc3lPZmZzZXQpIHtcblx0XHRcdFx0XHRzeU9mZnNldC0tO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJvb21oLS07IFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHN4ID0gc3ggKyBzeE9mZnNldDtcblx0XHRcdHN5ID0gc3kgKyBzeU9mZnNldDtcblx0XHRcdFxuXHRcdFx0dGhpcy5yb29tc1tpXVtqXVtcInhcIl0gPSBzeDtcblx0XHRcdHRoaXMucm9vbXNbaV1bal1bXCJ5XCJdID0gc3k7XG5cdFx0XHR0aGlzLnJvb21zW2ldW2pdW1wid2lkdGhcIl0gPSByb29tdztcblx0XHRcdHRoaXMucm9vbXNbaV1bal1bXCJoZWlnaHRcIl0gPSByb29taDsgIFxuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpaSA9IHN4OyBpaSA8IHN4ICsgcm9vbXc7IGlpKyspIHtcblx0XHRcdFx0Zm9yICh2YXIgamogPSBzeTsgamogPCBzeSArIHJvb21oOyBqaisrKSB7XG5cdFx0XHRcdFx0dGhpcy5tYXBbaWldW2pqXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0gIFxuXHRcdH1cblx0fVxufVxuXG5ST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fZ2V0V2FsbFBvc2l0aW9uID0gZnVuY3Rpb24oYVJvb20sIGFEaXJlY3Rpb24pIHtcblx0dmFyIHJ4O1xuXHR2YXIgcnk7XG5cdHZhciBkb29yO1xuXHRcblx0aWYgKGFEaXJlY3Rpb24gPT0gMSB8fCBhRGlyZWN0aW9uID09IDMpIHtcblx0XHRyeCA9IHRoaXMuX2dldFJhbmRvbUludChhUm9vbVtcInhcIl0gKyAxLCBhUm9vbVtcInhcIl0gKyBhUm9vbVtcIndpZHRoXCJdIC0gMik7XG5cdFx0aWYgKGFEaXJlY3Rpb24gPT0gMSkge1xuXHRcdFx0cnkgPSBhUm9vbVtcInlcIl0gLSAyO1xuXHRcdFx0ZG9vciA9IHJ5ICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cnkgPSBhUm9vbVtcInlcIl0gKyBhUm9vbVtcImhlaWdodFwiXSArIDE7XG5cdFx0XHRkb29yID0gcnkgLTE7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMubWFwW3J4XVtkb29yXSA9IDA7IC8vIGknbSBub3Qgc2V0dGluZyBhIHNwZWNpZmljICdkb29yJyB0aWxlIHZhbHVlIHJpZ2h0IG5vdywganVzdCBlbXB0eSBzcGFjZS4gXG5cdFx0XG5cdH0gZWxzZSBpZiAoYURpcmVjdGlvbiA9PSAyIHx8IGFEaXJlY3Rpb24gPT0gNCkge1xuXHRcdHJ5ID0gdGhpcy5fZ2V0UmFuZG9tSW50KGFSb29tW1wieVwiXSArIDEsIGFSb29tW1wieVwiXSArIGFSb29tW1wiaGVpZ2h0XCJdIC0gMik7XG5cdFx0aWYoYURpcmVjdGlvbiA9PSAyKSB7XG5cdFx0XHRyeCA9IGFSb29tW1wieFwiXSArIGFSb29tW1wid2lkdGhcIl0gKyAxO1xuXHRcdFx0ZG9vciA9IHJ4IC0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cnggPSBhUm9vbVtcInhcIl0gLSAyO1xuXHRcdFx0ZG9vciA9IHJ4ICsgMTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5tYXBbZG9vcl1bcnldID0gMDsgLy8gaSdtIG5vdCBzZXR0aW5nIGEgc3BlY2lmaWMgJ2Rvb3InIHRpbGUgdmFsdWUgcmlnaHQgbm93LCBqdXN0IGVtcHR5IHNwYWNlLiBcblx0XHRcblx0fVxuXHRyZXR1cm4gW3J4LCByeV07XG59XG5cbi8qKipcbiogQHBhcmFtIHN0YXJ0UG9zaXRpb24gYSAyIGVsZW1lbnQgYXJyYXlcbiogQHBhcmFtIGVuZFBvc2l0aW9uIGEgMiBlbGVtZW50IGFycmF5XG4qL1xuUk9ULk1hcC5Sb2d1ZS5wcm90b3R5cGUuX2RyYXdDb3JyaWRvcmUgPSBmdW5jdGlvbiAoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcblx0dmFyIHhPZmZzZXQgPSBlbmRQb3NpdGlvblswXSAtIHN0YXJ0UG9zaXRpb25bMF07XG5cdHZhciB5T2Zmc2V0ID0gZW5kUG9zaXRpb25bMV0gLSBzdGFydFBvc2l0aW9uWzFdO1xuXHRcblx0dmFyIHhwb3MgPSBzdGFydFBvc2l0aW9uWzBdO1xuXHR2YXIgeXBvcyA9IHN0YXJ0UG9zaXRpb25bMV07XG5cdFxuXHR2YXIgdGVtcERpc3Q7XG5cdHZhciB4RGlyO1xuXHR2YXIgeURpcjtcblx0XG5cdHZhciBtb3ZlOyAvLyAyIGVsZW1lbnQgYXJyYXksIGVsZW1lbnQgMCBpcyB0aGUgZGlyZWN0aW9uLCBlbGVtZW50IDEgaXMgdGhlIHRvdGFsIHZhbHVlIHRvIG1vdmUuIFxuXHR2YXIgbW92ZXMgPSBbXTsgLy8gYSBsaXN0IG9mIDIgZWxlbWVudCBhcnJheXNcblx0XG5cdHZhciB4QWJzID0gTWF0aC5hYnMoeE9mZnNldCk7XG5cdHZhciB5QWJzID0gTWF0aC5hYnMoeU9mZnNldCk7XG5cdFxuXHR2YXIgcGVyY2VudCA9IFJPVC5STkcuZ2V0VW5pZm9ybSgpOyAvLyB1c2VkIHRvIHNwbGl0IHRoZSBtb3ZlIGF0IGRpZmZlcmVudCBwbGFjZXMgYWxvbmcgdGhlIGxvbmcgYXhpc1xuXHR2YXIgZmlyc3RIYWxmID0gcGVyY2VudDtcblx0dmFyIHNlY29uZEhhbGYgPSAxIC0gcGVyY2VudDtcblx0XG5cdHhEaXIgPSB4T2Zmc2V0ID4gMCA/IDIgOiA2O1xuXHR5RGlyID0geU9mZnNldCA+IDAgPyA0IDogMDtcblx0XG5cdGlmICh4QWJzIDwgeUFicykge1xuXHRcdC8vIG1vdmUgZmlyc3RIYWxmIG9mIHRoZSB5IG9mZnNldFxuXHRcdHRlbXBEaXN0ID0gTWF0aC5jZWlsKHlBYnMgKiBmaXJzdEhhbGYpO1xuXHRcdG1vdmVzLnB1c2goW3lEaXIsIHRlbXBEaXN0XSk7XG5cdFx0Ly8gbW92ZSBhbGwgdGhlIHggb2Zmc2V0XG5cdFx0bW92ZXMucHVzaChbeERpciwgeEFic10pO1xuXHRcdC8vIG1vdmUgc2VuZEhhbGYgb2YgdGhlICB5IG9mZnNldFxuXHRcdHRlbXBEaXN0ID0gTWF0aC5mbG9vcih5QWJzICogc2Vjb25kSGFsZik7XG5cdFx0bW92ZXMucHVzaChbeURpciwgdGVtcERpc3RdKTtcblx0fSBlbHNlIHtcblx0XHQvLyAgbW92ZSBmaXJzdEhhbGYgb2YgdGhlIHggb2Zmc2V0XG5cdFx0dGVtcERpc3QgPSBNYXRoLmNlaWwoeEFicyAqIGZpcnN0SGFsZik7XG5cdFx0bW92ZXMucHVzaChbeERpciwgdGVtcERpc3RdKTtcblx0XHQvLyBtb3ZlIGFsbCB0aGUgeSBvZmZzZXRcblx0XHRtb3Zlcy5wdXNoKFt5RGlyLCB5QWJzXSk7XG5cdFx0Ly8gbW92ZSBzZWNvbmRIYWxmIG9mIHRoZSB4IG9mZnNldC5cblx0XHR0ZW1wRGlzdCA9IE1hdGguZmxvb3IoeEFicyAqIHNlY29uZEhhbGYpO1xuXHRcdG1vdmVzLnB1c2goW3hEaXIsIHRlbXBEaXN0XSk7ICBcblx0fVxuXHRcblx0dGhpcy5tYXBbeHBvc11beXBvc10gPSAwO1xuXHRcblx0d2hpbGUgKG1vdmVzLmxlbmd0aCA+IDApIHtcblx0XHRtb3ZlID0gbW92ZXMucG9wKCk7XG5cdFx0d2hpbGUgKG1vdmVbMV0gPiAwKSB7XG5cdFx0XHR4cG9zICs9IFJPVC5ESVJTWzhdW21vdmVbMF1dWzBdO1xuXHRcdFx0eXBvcyArPSBST1QuRElSU1s4XVttb3ZlWzBdXVsxXTtcblx0XHRcdHRoaXMubWFwW3hwb3NdW3lwb3NdID0gMDtcblx0XHRcdG1vdmVbMV0gPSBtb3ZlWzFdIC0gMTtcblx0XHR9XG5cdH1cbn1cblxuUk9ULk1hcC5Sb2d1ZS5wcm90b3R5cGUuX2NyZWF0ZUNvcnJpZG9ycyA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gRHJhdyBDb3JyaWRvcnMgYmV0d2VlbiBjb25uZWN0ZWQgcm9vbXNcblx0XG5cdHZhciBjdyA9IHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoO1xuXHR2YXIgY2ggPSB0aGlzLl9vcHRpb25zLmNlbGxIZWlnaHQ7XG5cdHZhciByb29tO1xuXHR2YXIgY29ubmVjdGlvbjtcblx0dmFyIG90aGVyUm9vbTtcblx0dmFyIHdhbGw7XG5cdHZhciBvdGhlcldhbGw7XG5cdFxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGN3OyBpKyspIHtcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNoOyBqKyspIHtcblx0XHRcdHJvb20gPSB0aGlzLnJvb21zW2ldW2pdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHJvb21bXCJjb25uZWN0aW9uc1wiXS5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRjb25uZWN0aW9uID0gcm9vbVtcImNvbm5lY3Rpb25zXCJdW2tdOyBcblx0XHRcdFx0XG5cdFx0XHRcdG90aGVyUm9vbSA9IHRoaXMucm9vbXNbY29ubmVjdGlvblswXV1bY29ubmVjdGlvblsxXV07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBmaWd1cmUgb3V0IHdoYXQgd2FsbCBvdXIgY29ycmlkb3Igd2lsbCBzdGFydCBvbmUuXG5cdFx0XHRcdC8vIGZpZ3VyZSBvdXQgd2hhdCB3YWxsIG91ciBjb3JyaWRvciB3aWxsIGVuZCBvbi4gXG5cdFx0XHRcdGlmIChvdGhlclJvb21bXCJjZWxseFwiXSA+IHJvb21bXCJjZWxseFwiXSApIHtcblx0XHRcdFx0XHR3YWxsID0gMjtcblx0XHRcdFx0XHRvdGhlcldhbGwgPSA0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKG90aGVyUm9vbVtcImNlbGx4XCJdIDwgcm9vbVtcImNlbGx4XCJdICkge1xuXHRcdFx0XHRcdHdhbGwgPSA0O1xuXHRcdFx0XHRcdG90aGVyV2FsbCA9IDI7XG5cdFx0XHRcdH0gZWxzZSBpZihvdGhlclJvb21bXCJjZWxseVwiXSA+IHJvb21bXCJjZWxseVwiXSkge1xuXHRcdFx0XHRcdHdhbGwgPSAzO1xuXHRcdFx0XHRcdG90aGVyV2FsbCA9IDE7XG5cdFx0XHRcdH0gZWxzZSBpZihvdGhlclJvb21bXCJjZWxseVwiXSA8IHJvb21bXCJjZWxseVwiXSkge1xuXHRcdFx0XHRcdHdhbGwgPSAxO1xuXHRcdFx0XHRcdG90aGVyV2FsbCA9IDM7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX2RyYXdDb3JyaWRvcmUodGhpcy5fZ2V0V2FsbFBvc2l0aW9uKHJvb20sIHdhbGwpLCB0aGlzLl9nZXRXYWxsUG9zaXRpb24ob3RoZXJSb29tLCBvdGhlcldhbGwpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbi8qKlxuICogQGNsYXNzIER1bmdlb24gZmVhdHVyZTsgaGFzIG93biAuY3JlYXRlKCkgbWV0aG9kXG4gKi9cblJPVC5NYXAuRmVhdHVyZSA9IGZ1bmN0aW9uKCkge31cblJPVC5NYXAuRmVhdHVyZS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKGNhbkJlRHVnQ2FsbGJhY2spIHt9XG5ST1QuTWFwLkZlYXR1cmUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRpZ0NhbGxiYWNrKSB7fVxuUk9ULk1hcC5GZWF0dXJlLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uKCkge31cblJPVC5NYXAuRmVhdHVyZS5jcmVhdGVSYW5kb21BdCA9IGZ1bmN0aW9uKHgsIHksIGR4LCBkeSwgb3B0aW9ucykge31cblxuLyoqXG4gKiBAY2xhc3MgUm9vbVxuICogQGF1Z21lbnRzIFJPVC5NYXAuRmVhdHVyZVxuICogQHBhcmFtIHtpbnR9IHgxXG4gKiBAcGFyYW0ge2ludH0geTFcbiAqIEBwYXJhbSB7aW50fSB4MlxuICogQHBhcmFtIHtpbnR9IHkyXG4gKiBAcGFyYW0ge2ludH0gW2Rvb3JYXVxuICogQHBhcmFtIHtpbnR9IFtkb29yWV1cbiAqL1xuUk9ULk1hcC5GZWF0dXJlLlJvb20gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgZG9vclgsIGRvb3JZKSB7XG5cdHRoaXMuX3gxID0geDE7XG5cdHRoaXMuX3kxID0geTE7XG5cdHRoaXMuX3gyID0geDI7XG5cdHRoaXMuX3kyID0geTI7XG5cdHRoaXMuX2Rvb3JzID0ge307XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCkgeyB0aGlzLmFkZERvb3IoZG9vclgsIGRvb3JZKTsgfVxufVxuUk9ULk1hcC5GZWF0dXJlLlJvb20uZXh0ZW5kKFJPVC5NYXAuRmVhdHVyZSk7XG5cbi8qKlxuICogUm9vbSBvZiByYW5kb20gc2l6ZSwgd2l0aCBhIGdpdmVuIGRvb3JzIGFuZCBkaXJlY3Rpb25cbiAqL1xuUk9ULk1hcC5GZWF0dXJlLlJvb20uY3JlYXRlUmFuZG9tQXQgPSBmdW5jdGlvbih4LCB5LCBkeCwgZHksIG9wdGlvbnMpIHtcblx0dmFyIG1pbiA9IG9wdGlvbnMucm9vbVdpZHRoWzBdO1xuXHR2YXIgbWF4ID0gb3B0aW9ucy5yb29tV2lkdGhbMV07XG5cdHZhciB3aWR0aCA9IG1pbiArIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqKG1heC1taW4rMSkpO1xuXHRcblx0dmFyIG1pbiA9IG9wdGlvbnMucm9vbUhlaWdodFswXTtcblx0dmFyIG1heCA9IG9wdGlvbnMucm9vbUhlaWdodFsxXTtcblx0dmFyIGhlaWdodCA9IG1pbiArIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqKG1heC1taW4rMSkpO1xuXHRcblx0aWYgKGR4ID09IDEpIHsgLyogdG8gdGhlIHJpZ2h0ICovXG5cdFx0dmFyIHkyID0geSAtIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkgKiBoZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgdGhpcyh4KzEsIHkyLCB4K3dpZHRoLCB5MitoZWlnaHQtMSwgeCwgeSk7XG5cdH1cblx0XG5cdGlmIChkeCA9PSAtMSkgeyAvKiB0byB0aGUgbGVmdCAqL1xuXHRcdHZhciB5MiA9IHkgLSBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogaGVpZ2h0KTtcblx0XHRyZXR1cm4gbmV3IHRoaXMoeC13aWR0aCwgeTIsIHgtMSwgeTIraGVpZ2h0LTEsIHgsIHkpO1xuXHR9XG5cblx0aWYgKGR5ID09IDEpIHsgLyogdG8gdGhlIGJvdHRvbSAqL1xuXHRcdHZhciB4MiA9IHggLSBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogd2lkdGgpO1xuXHRcdHJldHVybiBuZXcgdGhpcyh4MiwgeSsxLCB4Mit3aWR0aC0xLCB5K2hlaWdodCwgeCwgeSk7XG5cdH1cblxuXHRpZiAoZHkgPT0gLTEpIHsgLyogdG8gdGhlIHRvcCAqL1xuXHRcdHZhciB4MiA9IHggLSBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogd2lkdGgpO1xuXHRcdHJldHVybiBuZXcgdGhpcyh4MiwgeS1oZWlnaHQsIHgyK3dpZHRoLTEsIHktMSwgeCwgeSk7XG5cdH1cbn1cblxuLyoqXG4gKiBSb29tIG9mIHJhbmRvbSBzaXplLCBwb3NpdGlvbmVkIGFyb3VuZCBjZW50ZXIgY29vcmRzXG4gKi9cblJPVC5NYXAuRmVhdHVyZS5Sb29tLmNyZWF0ZVJhbmRvbUNlbnRlciA9IGZ1bmN0aW9uKGN4LCBjeSwgb3B0aW9ucykge1xuXHR2YXIgbWluID0gb3B0aW9ucy5yb29tV2lkdGhbMF07XG5cdHZhciBtYXggPSBvcHRpb25zLnJvb21XaWR0aFsxXTtcblx0dmFyIHdpZHRoID0gbWluICsgTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSoobWF4LW1pbisxKSk7XG5cdFxuXHR2YXIgbWluID0gb3B0aW9ucy5yb29tSGVpZ2h0WzBdO1xuXHR2YXIgbWF4ID0gb3B0aW9ucy5yb29tSGVpZ2h0WzFdO1xuXHR2YXIgaGVpZ2h0ID0gbWluICsgTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSoobWF4LW1pbisxKSk7XG5cblx0dmFyIHgxID0gY3ggLSBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpKndpZHRoKTtcblx0dmFyIHkxID0gY3kgLSBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpKmhlaWdodCk7XG5cdHZhciB4MiA9IHgxICsgd2lkdGggLSAxO1xuXHR2YXIgeTIgPSB5MSArIGhlaWdodCAtIDE7XG5cblx0cmV0dXJuIG5ldyB0aGlzKHgxLCB5MSwgeDIsIHkyKTtcbn1cblxuLyoqXG4gKiBSb29tIG9mIHJhbmRvbSBzaXplIHdpdGhpbiBhIGdpdmVuIGRpbWVuc2lvbnNcbiAqL1xuUk9ULk1hcC5GZWF0dXJlLlJvb20uY3JlYXRlUmFuZG9tID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQsIG9wdGlvbnMpIHtcblx0dmFyIG1pbiA9IG9wdGlvbnMucm9vbVdpZHRoWzBdO1xuXHR2YXIgbWF4ID0gb3B0aW9ucy5yb29tV2lkdGhbMV07XG5cdHZhciB3aWR0aCA9IG1pbiArIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqKG1heC1taW4rMSkpO1xuXHRcblx0dmFyIG1pbiA9IG9wdGlvbnMucm9vbUhlaWdodFswXTtcblx0dmFyIG1heCA9IG9wdGlvbnMucm9vbUhlaWdodFsxXTtcblx0dmFyIGhlaWdodCA9IG1pbiArIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqKG1heC1taW4rMSkpO1xuXHRcblx0dmFyIGxlZnQgPSBhdmFpbFdpZHRoIC0gd2lkdGggLSAxO1xuXHR2YXIgdG9wID0gYXZhaWxIZWlnaHQgLSBoZWlnaHQgLSAxO1xuXG5cdHZhciB4MSA9IDEgKyBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpKmxlZnQpO1xuXHR2YXIgeTEgPSAxICsgTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSp0b3ApO1xuXHR2YXIgeDIgPSB4MSArIHdpZHRoIC0gMTtcblx0dmFyIHkyID0geTEgKyBoZWlnaHQgLSAxO1xuXG5cdHJldHVybiBuZXcgdGhpcyh4MSwgeTEsIHgyLCB5Mik7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5hZGREb29yID0gZnVuY3Rpb24oeCwgeSkge1xuXHR0aGlzLl9kb29yc1t4K1wiLFwiK3ldID0gMTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn1cbiAqL1xuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldERvb3JzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuX2Rvb3JzKSB7XG5cdFx0dmFyIHBhcnRzID0ga2V5LnNwbGl0KFwiLFwiKTtcblx0XHRjYWxsYmFjayhwYXJzZUludChwYXJ0c1swXSksIHBhcnNlSW50KHBhcnRzWzFdKSk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5jbGVhckRvb3JzID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX2Rvb3JzID0ge307XG5cdHJldHVybiB0aGlzO1xufVxuXG5ST1QuTWFwLkZlYXR1cmUuUm9vbS5wcm90b3R5cGUuYWRkRG9vcnMgPSBmdW5jdGlvbihpc1dhbGxDYWxsYmFjaykge1xuXHR2YXIgbGVmdCA9IHRoaXMuX3gxLTE7XG5cdHZhciByaWdodCA9IHRoaXMuX3gyKzE7XG5cdHZhciB0b3AgPSB0aGlzLl95MS0xO1xuXHR2YXIgYm90dG9tID0gdGhpcy5feTIrMTtcblxuXHRmb3IgKHZhciB4PWxlZnQ7IHg8PXJpZ2h0OyB4KyspIHtcblx0XHRmb3IgKHZhciB5PXRvcDsgeTw9Ym90dG9tOyB5KyspIHtcblx0XHRcdGlmICh4ICE9IGxlZnQgJiYgeCAhPSByaWdodCAmJiB5ICE9IHRvcCAmJiB5ICE9IGJvdHRvbSkgeyBjb250aW51ZTsgfVxuXHRcdFx0aWYgKGlzV2FsbENhbGxiYWNrKHgsIHkpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHRoaXMuYWRkRG9vcih4LCB5KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oKSB7XG5cdGNvbnNvbGUubG9nKFwicm9vbVwiLCB0aGlzLl94MSwgdGhpcy5feTEsIHRoaXMuX3gyLCB0aGlzLl95Mik7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oaXNXYWxsQ2FsbGJhY2ssIGNhbkJlRHVnQ2FsbGJhY2spIHsgXG5cdHZhciBsZWZ0ID0gdGhpcy5feDEtMTtcblx0dmFyIHJpZ2h0ID0gdGhpcy5feDIrMTtcblx0dmFyIHRvcCA9IHRoaXMuX3kxLTE7XG5cdHZhciBib3R0b20gPSB0aGlzLl95MisxO1xuXHRcblx0Zm9yICh2YXIgeD1sZWZ0OyB4PD1yaWdodDsgeCsrKSB7XG5cdFx0Zm9yICh2YXIgeT10b3A7IHk8PWJvdHRvbTsgeSsrKSB7XG5cdFx0XHRpZiAoeCA9PSBsZWZ0IHx8IHggPT0gcmlnaHQgfHwgeSA9PSB0b3AgfHwgeSA9PSBib3R0b20pIHtcblx0XHRcdFx0aWYgKCFpc1dhbGxDYWxsYmFjayh4LCB5KSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghY2FuQmVEdWdDYWxsYmFjayh4LCB5KSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaWdDYWxsYmFjayBEaWcgY2FsbGJhY2sgd2l0aCBhIHNpZ25hdHVyZSAoeCwgeSwgdmFsdWUpLiBWYWx1ZXM6IDAgPSBlbXB0eSwgMSA9IHdhbGwsIDIgPSBkb29yLiBNdWx0aXBsZSBkb29ycyBhcmUgYWxsb3dlZC5cbiAqL1xuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRpZ0NhbGxiYWNrKSB7IFxuXHR2YXIgbGVmdCA9IHRoaXMuX3gxLTE7XG5cdHZhciByaWdodCA9IHRoaXMuX3gyKzE7XG5cdHZhciB0b3AgPSB0aGlzLl95MS0xO1xuXHR2YXIgYm90dG9tID0gdGhpcy5feTIrMTtcblx0XG5cdHZhciB2YWx1ZSA9IDA7XG5cdGZvciAodmFyIHg9bGVmdDsgeDw9cmlnaHQ7IHgrKykge1xuXHRcdGZvciAodmFyIHk9dG9wOyB5PD1ib3R0b207IHkrKykge1xuXHRcdFx0aWYgKHgrXCIsXCIreSBpbiB0aGlzLl9kb29ycykge1xuXHRcdFx0XHR2YWx1ZSA9IDI7XG5cdFx0XHR9IGVsc2UgaWYgKHggPT0gbGVmdCB8fCB4ID09IHJpZ2h0IHx8IHkgPT0gdG9wIHx8IHkgPT0gYm90dG9tKSB7XG5cdFx0XHRcdHZhbHVlID0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gMDtcblx0XHRcdH1cblx0XHRcdGRpZ0NhbGxiYWNrKHgsIHksIHZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gW01hdGgucm91bmQoKHRoaXMuX3gxICsgdGhpcy5feDIpLzIpLCBNYXRoLnJvdW5kKCh0aGlzLl95MSArIHRoaXMuX3kyKS8yKV07XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl94MTtcbn1cblxuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl94Mjtcbn1cblxuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5feTE7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX3kyO1xufVxuXG4vKipcbiAqIEBjbGFzcyBDb3JyaWRvclxuICogQGF1Z21lbnRzIFJPVC5NYXAuRmVhdHVyZVxuICogQHBhcmFtIHtpbnR9IHN0YXJ0WFxuICogQHBhcmFtIHtpbnR9IHN0YXJ0WVxuICogQHBhcmFtIHtpbnR9IGVuZFhcbiAqIEBwYXJhbSB7aW50fSBlbmRZXG4gKi9cblJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvciA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZKSB7XG5cdHRoaXMuX3N0YXJ0WCA9IHN0YXJ0WDtcblx0dGhpcy5fc3RhcnRZID0gc3RhcnRZO1xuXHR0aGlzLl9lbmRYID0gZW5kWDsgXG5cdHRoaXMuX2VuZFkgPSBlbmRZO1xuXHR0aGlzLl9lbmRzV2l0aEFXYWxsID0gdHJ1ZTtcbn1cblJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvci5leHRlbmQoUk9ULk1hcC5GZWF0dXJlKTtcblxuUk9ULk1hcC5GZWF0dXJlLkNvcnJpZG9yLmNyZWF0ZVJhbmRvbUF0ID0gZnVuY3Rpb24oeCwgeSwgZHgsIGR5LCBvcHRpb25zKSB7XG5cdHZhciBtaW4gPSBvcHRpb25zLmNvcnJpZG9yTGVuZ3RoWzBdO1xuXHR2YXIgbWF4ID0gb3B0aW9ucy5jb3JyaWRvckxlbmd0aFsxXTtcblx0dmFyIGxlbmd0aCA9IG1pbiArIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqKG1heC1taW4rMSkpO1xuXHRcblx0cmV0dXJuIG5ldyB0aGlzKHgsIHksIHggKyBkeCpsZW5ndGgsIHkgKyBkeSpsZW5ndGgpO1xufVxuXG5ST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3IucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oKSB7XG5cdGNvbnNvbGUubG9nKFwiY29ycmlkb3JcIiwgdGhpcy5fc3RhcnRYLCB0aGlzLl9zdGFydFksIHRoaXMuX2VuZFgsIHRoaXMuX2VuZFkpO1xufVxuXG5ST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbihpc1dhbGxDYWxsYmFjaywgY2FuQmVEdWdDYWxsYmFjayl7IFxuXHR2YXIgc3ggPSB0aGlzLl9zdGFydFg7XG5cdHZhciBzeSA9IHRoaXMuX3N0YXJ0WTtcblx0dmFyIGR4ID0gdGhpcy5fZW5kWC1zeDtcblx0dmFyIGR5ID0gdGhpcy5fZW5kWS1zeTtcblx0dmFyIGxlbmd0aCA9IDEgKyBNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSk7XG5cdFxuXHRpZiAoZHgpIHsgZHggPSBkeC9NYXRoLmFicyhkeCk7IH1cblx0aWYgKGR5KSB7IGR5ID0gZHkvTWF0aC5hYnMoZHkpOyB9XG5cdHZhciBueCA9IGR5O1xuXHR2YXIgbnkgPSAtZHg7XG5cdFxuXHR2YXIgb2sgPSB0cnVlO1xuXHRmb3IgKHZhciBpPTA7IGk8bGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgeCA9IHN4ICsgaSpkeDtcblx0XHR2YXIgeSA9IHN5ICsgaSpkeTtcblxuXHRcdGlmICghY2FuQmVEdWdDYWxsYmFjayggICAgIHgsICAgICAgeSkpIHsgb2sgPSBmYWxzZTsgfVxuXHRcdGlmICghaXNXYWxsQ2FsbGJhY2sgICh4ICsgbngsIHkgKyBueSkpIHsgb2sgPSBmYWxzZTsgfVxuXHRcdGlmICghaXNXYWxsQ2FsbGJhY2sgICh4IC0gbngsIHkgLSBueSkpIHsgb2sgPSBmYWxzZTsgfVxuXHRcdFxuXHRcdGlmICghb2spIHtcblx0XHRcdGxlbmd0aCA9IGk7XG5cdFx0XHR0aGlzLl9lbmRYID0geC1keDtcblx0XHRcdHRoaXMuX2VuZFkgPSB5LWR5O1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogSWYgdGhlIGxlbmd0aCBkZWdlbmVyYXRlZCwgdGhpcyBjb3JyaWRvciBtaWdodCBiZSBpbnZhbGlkXG5cdCAqL1xuXHQgXG5cdC8qIG5vdCBzdXBwb3J0ZWQgKi9cblx0aWYgKGxlbmd0aCA9PSAwKSB7IHJldHVybiBmYWxzZTsgfSBcblx0XG5cdCAvKiBsZW5ndGggMSBhbGxvd2VkIG9ubHkgaWYgdGhlIG5leHQgc3BhY2UgaXMgZW1wdHkgKi9cblx0aWYgKGxlbmd0aCA9PSAxICYmIGlzV2FsbENhbGxiYWNrKHRoaXMuX2VuZFggKyBkeCwgdGhpcy5fZW5kWSArIGR5KSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XG5cdC8qKlxuXHQgKiBXZSBkbyBub3Qgd2FudCB0aGUgY29ycmlkb3IgdG8gY3Jhc2ggaW50byBhIGNvcm5lciBvZiBhIHJvb207XG5cdCAqIGlmIGFueSBvZiB0aGUgZW5kaW5nIGNvcm5lcnMgaXMgZW1wdHksIHRoZSBOKzF0aCBjZWxsIG9mIHRoaXMgY29ycmlkb3IgbXVzdCBiZSBlbXB0eSB0b28uXG5cdCAqIFxuXHQgKiBTaXR1YXRpb246XG5cdCAqICMjIyMjIyMxXG5cdCAqIC4uLi4uLi4/XG5cdCAqICMjIyMjIyMyXG5cdCAqIFxuXHQgKiBUaGUgY29ycmlkb3Igd2FzIGR1ZyBmcm9tIGxlZnQgdG8gcmlnaHQuXG5cdCAqIDEsIDIgLSBwcm9ibGVtYXRpYyBjb3JuZXJzLCA/ID0gTisxdGggY2VsbCAobm90IGR1Zylcblx0ICovXG5cdHZhciBmaXJzdENvcm5lckJhZCA9ICFpc1dhbGxDYWxsYmFjayh0aGlzLl9lbmRYICsgZHggKyBueCwgdGhpcy5fZW5kWSArIGR5ICsgbnkpO1xuXHR2YXIgc2Vjb25kQ29ybmVyQmFkID0gIWlzV2FsbENhbGxiYWNrKHRoaXMuX2VuZFggKyBkeCAtIG54LCB0aGlzLl9lbmRZICsgZHkgLSBueSk7XG5cdHRoaXMuX2VuZHNXaXRoQVdhbGwgPSBpc1dhbGxDYWxsYmFjayh0aGlzLl9lbmRYICsgZHgsIHRoaXMuX2VuZFkgKyBkeSk7XG5cdGlmICgoZmlyc3RDb3JuZXJCYWQgfHwgc2Vjb25kQ29ybmVyQmFkKSAmJiB0aGlzLl9lbmRzV2l0aEFXYWxsKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpZ0NhbGxiYWNrIERpZyBjYWxsYmFjayB3aXRoIGEgc2lnbmF0dXJlICh4LCB5LCB2YWx1ZSkuIFZhbHVlczogMCA9IGVtcHR5LlxuICovXG5ST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3IucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRpZ0NhbGxiYWNrKSB7IFxuXHR2YXIgc3ggPSB0aGlzLl9zdGFydFg7XG5cdHZhciBzeSA9IHRoaXMuX3N0YXJ0WTtcblx0dmFyIGR4ID0gdGhpcy5fZW5kWC1zeDtcblx0dmFyIGR5ID0gdGhpcy5fZW5kWS1zeTtcblx0dmFyIGxlbmd0aCA9IDErTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpO1xuXHRcblx0aWYgKGR4KSB7IGR4ID0gZHgvTWF0aC5hYnMoZHgpOyB9XG5cdGlmIChkeSkgeyBkeSA9IGR5L01hdGguYWJzKGR5KTsgfVxuXHR2YXIgbnggPSBkeTtcblx0dmFyIG55ID0gLWR4O1xuXHRcblx0Zm9yICh2YXIgaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHggPSBzeCArIGkqZHg7XG5cdFx0dmFyIHkgPSBzeSArIGkqZHk7XG5cdFx0ZGlnQ2FsbGJhY2soeCwgeSwgMCk7XG5cdH1cblx0XG5cdHJldHVybiB0cnVlO1xufVxuXG5ST1QuTWFwLkZlYXR1cmUuQ29ycmlkb3IucHJvdG90eXBlLmNyZWF0ZVByaW9yaXR5V2FsbHMgPSBmdW5jdGlvbihwcmlvcml0eVdhbGxDYWxsYmFjaykge1xuXHRpZiAoIXRoaXMuX2VuZHNXaXRoQVdhbGwpIHsgcmV0dXJuOyB9XG5cblx0dmFyIHN4ID0gdGhpcy5fc3RhcnRYO1xuXHR2YXIgc3kgPSB0aGlzLl9zdGFydFk7XG5cblx0dmFyIGR4ID0gdGhpcy5fZW5kWC1zeDtcblx0dmFyIGR5ID0gdGhpcy5fZW5kWS1zeTtcblx0aWYgKGR4KSB7IGR4ID0gZHgvTWF0aC5hYnMoZHgpOyB9XG5cdGlmIChkeSkgeyBkeSA9IGR5L01hdGguYWJzKGR5KTsgfVxuXHR2YXIgbnggPSBkeTtcblx0dmFyIG55ID0gLWR4O1xuXG5cdHByaW9yaXR5V2FsbENhbGxiYWNrKHRoaXMuX2VuZFggKyBkeCwgdGhpcy5fZW5kWSArIGR5KTtcblx0cHJpb3JpdHlXYWxsQ2FsbGJhY2sodGhpcy5fZW5kWCArIG54LCB0aGlzLl9lbmRZICsgbnkpO1xuXHRwcmlvcml0eVdhbGxDYWxsYmFjayh0aGlzLl9lbmRYIC0gbngsIHRoaXMuX2VuZFkgLSBueSk7XG59LyoqXG4gKiBAY2xhc3MgQmFzZSBub2lzZSBnZW5lcmF0b3JcbiAqL1xuUk9ULk5vaXNlID0gZnVuY3Rpb24oKSB7XG59O1xuXG5ST1QuTm9pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHgsIHkpIHt9XG4vKipcbiAqIEEgc2ltcGxlIDJkIGltcGxlbWVudGF0aW9uIG9mIHNpbXBsZXggbm9pc2UgYnkgT25kcmVqIFphcmFcbiAqXG4gKiBCYXNlZCBvbiBhIHNwZWVkLWltcHJvdmVkIHNpbXBsZXggbm9pc2UgYWxnb3JpdGhtIGZvciAyRCwgM0QgYW5kIDREIGluIEphdmEuXG4gKiBXaGljaCBpcyBiYXNlZCBvbiBleGFtcGxlIGNvZGUgYnkgU3RlZmFuIEd1c3RhdnNvbiAoc3RlZ3VAaXRuLmxpdS5zZSkuXG4gKiBXaXRoIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxuICogQmV0dGVyIHJhbmsgb3JkZXJpbmcgbWV0aG9kIGJ5IFN0ZWZhbiBHdXN0YXZzb24gaW4gMjAxMi5cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyRCBzaW1wbGV4IG5vaXNlIGdlbmVyYXRvclxuICogQHBhcmFtIHtpbnR9IFtncmFkaWVudHM9MjU2XSBSYW5kb20gZ3JhZGllbnRzXG4gKi9cblJPVC5Ob2lzZS5TaW1wbGV4ID0gZnVuY3Rpb24oZ3JhZGllbnRzKSB7XG5cdFJPVC5Ob2lzZS5jYWxsKHRoaXMpO1xuXG5cdHRoaXMuX0YyID0gMC41ICogKE1hdGguc3FydCgzKSAtIDEpO1xuICAgIHRoaXMuX0cyID0gKDMgLSBNYXRoLnNxcnQoMykpIC8gNjtcblxuXHR0aGlzLl9ncmFkaWVudHMgPSBbXG5cdFx0WyAwLCAtMV0sXG5cdFx0WyAxLCAtMV0sXG5cdFx0WyAxLCAgMF0sXG5cdFx0WyAxLCAgMV0sXG5cdFx0WyAwLCAgMV0sXG5cdFx0Wy0xLCAgMV0sXG5cdFx0Wy0xLCAgMF0sXG5cdFx0Wy0xLCAtMV1cblx0XTtcblxuXHR2YXIgcGVybXV0YXRpb25zID0gW107XG5cdHZhciBjb3VudCA9IGdyYWRpZW50cyB8fCAyNTY7XG5cdGZvciAodmFyIGk9MDtpPGNvdW50O2krKykgeyBwZXJtdXRhdGlvbnMucHVzaChpKTsgfVxuXHRwZXJtdXRhdGlvbnMgPSBwZXJtdXRhdGlvbnMucmFuZG9taXplKCk7XG5cblx0dGhpcy5fcGVybXMgPSBbXTtcblx0dGhpcy5faW5kZXhlcyA9IFtdO1xuXG5cdGZvciAodmFyIGk9MDtpPDIqY291bnQ7aSsrKSB7XG5cdFx0dGhpcy5fcGVybXMucHVzaChwZXJtdXRhdGlvbnNbaSAlIGNvdW50XSk7XG5cdFx0dGhpcy5faW5kZXhlcy5wdXNoKHRoaXMuX3Blcm1zW2ldICUgdGhpcy5fZ3JhZGllbnRzLmxlbmd0aCk7XG5cdH1cblxufTtcblJPVC5Ob2lzZS5TaW1wbGV4LmV4dGVuZChST1QuTm9pc2UpO1xuXG5ST1QuTm9pc2UuU2ltcGxleC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oeGluLCB5aW4pIHtcblx0dmFyIHBlcm1zID0gdGhpcy5fcGVybXM7XG5cdHZhciBpbmRleGVzID0gdGhpcy5faW5kZXhlcztcblx0dmFyIGNvdW50ID0gcGVybXMubGVuZ3RoLzI7XG5cdHZhciBHMiA9IHRoaXMuX0cyO1xuXG5cdHZhciBuMCA9MCwgbjEgPSAwLCBuMiA9IDAsIGdpOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcblxuXHQvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG5cdHZhciBzID0gKHhpbiArIHlpbikgKiB0aGlzLl9GMjsgLy8gSGFpcnkgZmFjdG9yIGZvciAyRFxuXHR2YXIgaSA9IE1hdGguZmxvb3IoeGluICsgcyk7XG5cdHZhciBqID0gTWF0aC5mbG9vcih5aW4gKyBzKTtcblx0dmFyIHQgPSAoaSArIGopICogRzI7XG5cdHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSkgc3BhY2Vcblx0dmFyIFkwID0gaiAtIHQ7XG5cdHZhciB4MCA9IHhpbiAtIFgwOyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuXHR2YXIgeTAgPSB5aW4gLSBZMDtcblxuXHQvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLlxuXHQvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG5cdHZhciBpMSwgajE7IC8vIE9mZnNldHMgZm9yIHNlY29uZCAobWlkZGxlKSBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqKSBjb29yZHNcblx0aWYgKHgwID4geTApIHtcblx0XHRpMSA9IDE7XG5cdFx0ajEgPSAwO1xuXHR9IGVsc2UgeyAvLyBsb3dlciB0cmlhbmdsZSwgWFkgb3JkZXI6ICgwLDApLT4oMSwwKS0+KDEsMSlcblx0XHRpMSA9IDA7XG5cdFx0ajEgPSAxO1xuXHR9IC8vIHVwcGVyIHRyaWFuZ2xlLCBZWCBvcmRlcjogKDAsMCktPigwLDEpLT4oMSwxKVxuXG5cdC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZFxuXHQvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuXHQvLyBjID0gKDMtc3FydCgzKSkvNlxuXHR2YXIgeDEgPSB4MCAtIGkxICsgRzI7IC8vIE9mZnNldHMgZm9yIG1pZGRsZSBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG5cdHZhciB5MSA9IHkwIC0gajEgKyBHMjtcblx0dmFyIHgyID0geDAgLSAxICsgMipHMjsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG5cdHZhciB5MiA9IHkwIC0gMSArIDIqRzI7XG5cblx0Ly8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSB0aHJlZSBzaW1wbGV4IGNvcm5lcnNcblx0dmFyIGlpID0gaS5tb2QoY291bnQpO1xuXHR2YXIgamogPSBqLm1vZChjb3VudCk7XG5cblx0Ly8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xuXHR2YXIgdDAgPSAwLjUgLSB4MCp4MCAtIHkwKnkwO1xuXHRpZiAodDAgPj0gMCkge1xuXHRcdHQwICo9IHQwO1xuXHRcdGdpID0gaW5kZXhlc1tpaStwZXJtc1tqal1dO1xuXHRcdHZhciBncmFkID0gdGhpcy5fZ3JhZGllbnRzW2dpXTtcblx0XHRuMCA9IHQwICogdDAgKiAoZ3JhZFswXSAqIHgwICsgZ3JhZFsxXSAqIHkwKTtcblx0fVxuXHRcblx0dmFyIHQxID0gMC41IC0geDEqeDEgLSB5MSp5MTtcblx0aWYgKHQxID49IDApIHtcblx0XHR0MSAqPSB0MTtcblx0XHRnaSA9IGluZGV4ZXNbaWkraTErcGVybXNbamorajFdXTtcblx0XHR2YXIgZ3JhZCA9IHRoaXMuX2dyYWRpZW50c1tnaV07XG5cdFx0bjEgPSB0MSAqIHQxICogKGdyYWRbMF0gKiB4MSArIGdyYWRbMV0gKiB5MSk7XG5cdH1cblx0XG5cdHZhciB0MiA9IDAuNSAtIHgyKngyIC0geTIqeTI7XG5cdGlmICh0MiA+PSAwKSB7XG5cdFx0dDIgKj0gdDI7XG5cdFx0Z2kgPSBpbmRleGVzW2lpKzErcGVybXNbamorMV1dO1xuXHRcdHZhciBncmFkID0gdGhpcy5fZ3JhZGllbnRzW2dpXTtcblx0XHRuMiA9IHQyICogdDIgKiAoZ3JhZFswXSAqIHgyICsgZ3JhZFsxXSAqIHkyKTtcblx0fVxuXG5cdC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cblx0Ly8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLDFdLlxuXHRyZXR1cm4gNzAgKiAobjAgKyBuMSArIG4yKTtcbn1cbi8qKlxuICogQGNsYXNzIEFic3RyYWN0IEZPViBhbGdvcml0aG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpZ2h0UGFzc2VzQ2FsbGJhY2sgRG9lcyB0aGUgbGlnaHQgcGFzcyB0aHJvdWdoIHgseT9cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy50b3BvbG9neT04XSA0LzYvOFxuICovXG5ST1QuRk9WID0gZnVuY3Rpb24obGlnaHRQYXNzZXNDYWxsYmFjaywgb3B0aW9ucykge1xuXHR0aGlzLl9saWdodFBhc3NlcyA9IGxpZ2h0UGFzc2VzQ2FsbGJhY2s7XG5cdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0dG9wb2xvZ3k6IDhcblx0fVxuXHRmb3IgKHZhciBwIGluIG9wdGlvbnMpIHsgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07IH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSB2aXNpYmlsaXR5IGZvciBhIDM2MC1kZWdyZWUgY2lyY2xlXG4gKiBAcGFyYW0ge2ludH0geFxuICogQHBhcmFtIHtpbnR9IHlcbiAqIEBwYXJhbSB7aW50fSBSIE1heGltdW0gdmlzaWJpbGl0eSByYWRpdXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblJPVC5GT1YucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbih4LCB5LCBSLCBjYWxsYmFjaykge31cblxuLyoqXG4gKiBSZXR1cm4gYWxsIG5laWdoYm9ycyBpbiBhIGNvbmNlbnRyaWMgcmluZ1xuICogQHBhcmFtIHtpbnR9IGN4IGNlbnRlci14XG4gKiBAcGFyYW0ge2ludH0gY3kgY2VudGVyLXlcbiAqIEBwYXJhbSB7aW50fSByIHJhbmdlXG4gKi9cblJPVC5GT1YucHJvdG90eXBlLl9nZXRDaXJjbGUgPSBmdW5jdGlvbihjeCwgY3ksIHIpIHtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHR2YXIgZGlycywgY291bnRGYWN0b3IsIHN0YXJ0T2Zmc2V0O1xuXG5cdHN3aXRjaCAodGhpcy5fb3B0aW9ucy50b3BvbG9neSkge1xuXHRcdGNhc2UgNDpcblx0XHRcdGNvdW50RmFjdG9yID0gMTtcblx0XHRcdHN0YXJ0T2Zmc2V0ID0gWzAsIDFdO1xuXHRcdFx0ZGlycyA9IFtcblx0XHRcdFx0Uk9ULkRJUlNbOF1bN10sXG5cdFx0XHRcdFJPVC5ESVJTWzhdWzFdLFxuXHRcdFx0XHRST1QuRElSU1s4XVszXSxcblx0XHRcdFx0Uk9ULkRJUlNbOF1bNV1cblx0XHRcdF1cblx0XHRicmVhaztcblxuXHRcdGNhc2UgNjpcblx0XHRcdGRpcnMgPSBST1QuRElSU1s2XTtcblx0XHRcdGNvdW50RmFjdG9yID0gMTtcblx0XHRcdHN0YXJ0T2Zmc2V0ID0gWy0xLCAxXTtcblx0XHRicmVhaztcblxuXHRcdGNhc2UgODpcblx0XHRcdGRpcnMgPSBST1QuRElSU1s0XTtcblx0XHRcdGNvdW50RmFjdG9yID0gMjtcblx0XHRcdHN0YXJ0T2Zmc2V0ID0gWy0xLCAxXTtcblx0XHRicmVhaztcblx0fVxuXG5cdC8qIHN0YXJ0aW5nIG5laWdoYm9yICovXG5cdHZhciB4ID0gY3ggKyBzdGFydE9mZnNldFswXSpyO1xuXHR2YXIgeSA9IGN5ICsgc3RhcnRPZmZzZXRbMV0qcjtcblxuXHQvKiBjaXJjbGUgKi9cblx0Zm9yICh2YXIgaT0wO2k8ZGlycy5sZW5ndGg7aSsrKSB7XG5cdFx0Zm9yICh2YXIgaj0wO2o8cipjb3VudEZhY3RvcjtqKyspIHtcblx0XHRcdHJlc3VsdC5wdXNoKFt4LCB5XSk7XG5cdFx0XHR4ICs9IGRpcnNbaV1bMF07XG5cdFx0XHR5ICs9IGRpcnNbaV1bMV07XG5cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAY2xhc3MgRGlzY3JldGUgc2hhZG93Y2FzdGluZyBhbGdvcml0aG0uIE9ic29sZXRlZCBieSBQcmVjaXNlIHNoYWRvd2Nhc3RpbmcuXG4gKiBAYXVnbWVudHMgUk9ULkZPVlxuICovXG5ST1QuRk9WLkRpc2NyZXRlU2hhZG93Y2FzdGluZyA9IGZ1bmN0aW9uKGxpZ2h0UGFzc2VzQ2FsbGJhY2ssIG9wdGlvbnMpIHtcblx0Uk9ULkZPVi5jYWxsKHRoaXMsIGxpZ2h0UGFzc2VzQ2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuUk9ULkZPVi5EaXNjcmV0ZVNoYWRvd2Nhc3RpbmcuZXh0ZW5kKFJPVC5GT1YpO1xuXG4vKipcbiAqIEBzZWUgUk9ULkZPViNjb21wdXRlXG4gKi9cblJPVC5GT1YuRGlzY3JldGVTaGFkb3djYXN0aW5nLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24oeCwgeSwgUiwgY2FsbGJhY2spIHtcblx0dmFyIGNlbnRlciA9IHRoaXMuX2Nvb3Jkcztcblx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHQvKiB0aGlzIHBsYWNlIGlzIGFsd2F5cyB2aXNpYmxlICovXG5cdGNhbGxiYWNrKHgsIHksIDApO1xuXG5cdC8qIHN0YW5kaW5nIGluIGEgZGFyayBwbGFjZS4gRklYTUUgaXMgdGhpcyBhIGdvb2QgaWRlYT8gICovXG5cdGlmICghdGhpcy5fbGlnaHRQYXNzZXMoeCwgeSkpIHsgcmV0dXJuOyB9XG5cdFxuXHQvKiBzdGFydCBhbmQgZW5kIGFuZ2xlcyAqL1xuXHR2YXIgREFUQSA9IFtdO1xuXHRcblx0dmFyIEEsIEIsIGN4LCBjeSwgYmxvY2tzO1xuXG5cdC8qIGFuYWx5emUgc3Vycm91bmRpbmcgY2VsbHMgaW4gY29uY2VudHJpYyByaW5ncywgc3RhcnRpbmcgZnJvbSB0aGUgY2VudGVyICovXG5cdGZvciAodmFyIHI9MTsgcjw9UjsgcisrKSB7XG5cdFx0dmFyIG5laWdoYm9ycyA9IHRoaXMuX2dldENpcmNsZSh4LCB5LCByKTtcblx0XHR2YXIgYW5nbGUgPSAzNjAgLyBuZWlnaGJvcnMubGVuZ3RoO1xuXG5cdFx0Zm9yICh2YXIgaT0wO2k8bmVpZ2hib3JzLmxlbmd0aDtpKyspIHtcblx0XHRcdGN4ID0gbmVpZ2hib3JzW2ldWzBdO1xuXHRcdFx0Y3kgPSBuZWlnaGJvcnNbaV1bMV07XG5cdFx0XHRBID0gYW5nbGUgKiAoaSAtIDAuNSk7XG5cdFx0XHRCID0gQSArIGFuZ2xlO1xuXHRcdFx0XG5cdFx0XHRibG9ja3MgPSAhdGhpcy5fbGlnaHRQYXNzZXMoY3gsIGN5KTtcblx0XHRcdGlmICh0aGlzLl92aXNpYmxlQ29vcmRzKE1hdGguZmxvb3IoQSksIE1hdGguY2VpbChCKSwgYmxvY2tzLCBEQVRBKSkgeyBjYWxsYmFjayhjeCwgY3ksIHIsIDEpOyB9XG5cdFx0XHRcblx0XHRcdGlmIChEQVRBLmxlbmd0aCA9PSAyICYmIERBVEFbMF0gPT0gMCAmJiBEQVRBWzFdID09IDM2MCkgeyByZXR1cm47IH0gLyogY3V0b2ZmPyAqL1xuXG5cdFx0fSAvKiBmb3IgYWxsIGNlbGxzIGluIHRoaXMgcmluZyAqL1xuXHR9IC8qIGZvciBhbGwgcmluZ3MgKi9cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ludH0gQSBzdGFydCBhbmdsZVxuICogQHBhcmFtIHtpbnR9IEIgZW5kIGFuZ2xlXG4gKiBAcGFyYW0ge2Jvb2x9IGJsb2NrcyBEb2VzIGN1cnJlbnQgY2VsbCBibG9jayB2aXNpYmlsaXR5P1xuICogQHBhcmFtIHtpbnRbXVtdfSBEQVRBIHNoYWRvd2VkIGFuZ2xlIHBhaXJzXG4gKi9cblJPVC5GT1YuRGlzY3JldGVTaGFkb3djYXN0aW5nLnByb3RvdHlwZS5fdmlzaWJsZUNvb3JkcyA9IGZ1bmN0aW9uKEEsIEIsIGJsb2NrcywgREFUQSkge1xuXHRpZiAoQSA8IDApIHsgXG5cdFx0dmFyIHYxID0gYXJndW1lbnRzLmNhbGxlZSgwLCBCLCBibG9ja3MsIERBVEEpO1xuXHRcdHZhciB2MiA9IGFyZ3VtZW50cy5jYWxsZWUoMzYwK0EsIDM2MCwgYmxvY2tzLCBEQVRBKTtcblx0XHRyZXR1cm4gdjEgfHwgdjI7XG5cdH1cblx0XG5cdHZhciBpbmRleCA9IDA7XG5cdHdoaWxlIChpbmRleCA8IERBVEEubGVuZ3RoICYmIERBVEFbaW5kZXhdIDwgQSkgeyBpbmRleCsrOyB9XG5cdFxuXHRpZiAoaW5kZXggPT0gREFUQS5sZW5ndGgpIHsgLyogY29tcGxldGVseSBuZXcgc2hhZG93ICovXG5cdFx0aWYgKGJsb2NrcykgeyBEQVRBLnB1c2goQSwgQik7IH0gXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdHZhciBjb3VudCA9IDA7XG5cdFxuXHRpZiAoaW5kZXggJSAyKSB7IC8qIHRoaXMgc2hhZG93IHN0YXJ0cyBpbiBhbiBleGlzdGluZyBzaGFkb3csIG9yIHdpdGhpbiBpdHMgZW5kaW5nIGJvdW5kYXJ5ICovXG5cdFx0d2hpbGUgKGluZGV4IDwgREFUQS5sZW5ndGggJiYgREFUQVtpbmRleF0gPCBCKSB7XG5cdFx0XHRpbmRleCsrO1xuXHRcdFx0Y291bnQrKztcblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNvdW50ID09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XG5cdFx0aWYgKGJsb2NrcykgeyBcblx0XHRcdGlmIChjb3VudCAlIDIpIHtcblx0XHRcdFx0REFUQS5zcGxpY2UoaW5kZXgtY291bnQsIGNvdW50LCBCKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdERBVEEuc3BsaWNlKGluZGV4LWNvdW50LCBjb3VudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0gZWxzZSB7IC8qIHRoaXMgc2hhZG93IHN0YXJ0cyBvdXRzaWRlIGFuIGV4aXN0aW5nIHNoYWRvdywgb3Igd2l0aGluIGEgc3RhcnRpbmcgYm91bmRhcnkgKi9cblx0XHR3aGlsZSAoaW5kZXggPCBEQVRBLmxlbmd0aCAmJiBEQVRBW2luZGV4XSA8IEIpIHtcblx0XHRcdGluZGV4Kys7XG5cdFx0XHRjb3VudCsrO1xuXHRcdH1cblx0XHRcblx0XHQvKiB2aXNpYmxlIHdoZW4gb3V0c2lkZSBhbiBleGlzdGluZyBzaGFkb3csIG9yIHdoZW4gb3ZlcmxhcHBpbmcgKi9cblx0XHRpZiAoQSA9PSBEQVRBW2luZGV4LWNvdW50XSAmJiBjb3VudCA9PSAxKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFxuXHRcdGlmIChibG9ja3MpIHsgXG5cdFx0XHRpZiAoY291bnQgJSAyKSB7XG5cdFx0XHRcdERBVEEuc3BsaWNlKGluZGV4LWNvdW50LCBjb3VudCwgQSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHREQVRBLnNwbGljZShpbmRleC1jb3VudCwgY291bnQsIEEsIEIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG4vKipcbiAqIEBjbGFzcyBQcmVjaXNlIHNoYWRvd2Nhc3RpbmcgYWxnb3JpdGhtXG4gKiBAYXVnbWVudHMgUk9ULkZPVlxuICovXG5ST1QuRk9WLlByZWNpc2VTaGFkb3djYXN0aW5nID0gZnVuY3Rpb24obGlnaHRQYXNzZXNDYWxsYmFjaywgb3B0aW9ucykge1xuXHRST1QuRk9WLmNhbGwodGhpcywgbGlnaHRQYXNzZXNDYWxsYmFjaywgb3B0aW9ucyk7XG59XG5ST1QuRk9WLlByZWNpc2VTaGFkb3djYXN0aW5nLmV4dGVuZChST1QuRk9WKTtcblxuLyoqXG4gKiBAc2VlIFJPVC5GT1YjY29tcHV0ZVxuICovXG5ST1QuRk9WLlByZWNpc2VTaGFkb3djYXN0aW5nLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24oeCwgeSwgUiwgY2FsbGJhY2spIHtcblx0LyogdGhpcyBwbGFjZSBpcyBhbHdheXMgdmlzaWJsZSAqL1xuXHRjYWxsYmFjayh4LCB5LCAwLCAxKTtcblxuXHQvKiBzdGFuZGluZyBpbiBhIGRhcmsgcGxhY2UuIEZJWE1FIGlzIHRoaXMgYSBnb29kIGlkZWE/ICAqL1xuXHRpZiAoIXRoaXMuX2xpZ2h0UGFzc2VzKHgsIHkpKSB7IHJldHVybjsgfVxuXHRcblx0LyogbGlzdCBvZiBhbGwgc2hhZG93cyAqL1xuXHR2YXIgU0hBRE9XUyA9IFtdO1xuXHRcblx0dmFyIGN4LCBjeSwgYmxvY2tzLCBBMSwgQTIsIHZpc2liaWxpdHk7XG5cblx0LyogYW5hbHl6ZSBzdXJyb3VuZGluZyBjZWxscyBpbiBjb25jZW50cmljIHJpbmdzLCBzdGFydGluZyBmcm9tIHRoZSBjZW50ZXIgKi9cblx0Zm9yICh2YXIgcj0xOyByPD1SOyByKyspIHtcblx0XHR2YXIgbmVpZ2hib3JzID0gdGhpcy5fZ2V0Q2lyY2xlKHgsIHksIHIpO1xuXHRcdHZhciBuZWlnaGJvckNvdW50ID0gbmVpZ2hib3JzLmxlbmd0aDtcblxuXHRcdGZvciAodmFyIGk9MDtpPG5laWdoYm9yQ291bnQ7aSsrKSB7XG5cdFx0XHRjeCA9IG5laWdoYm9yc1tpXVswXTtcblx0XHRcdGN5ID0gbmVpZ2hib3JzW2ldWzFdO1xuXHRcdFx0Lyogc2hpZnQgaGFsZi1hbi1hbmdsZSBiYWNrd2FyZHMgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3kgb2YgMC10aCBjZWxscyAqL1xuXHRcdFx0QTEgPSBbaSA/IDIqaS0xIDogMipuZWlnaGJvckNvdW50LTEsIDIqbmVpZ2hib3JDb3VudF07XG5cdFx0XHRBMiA9IFsyKmkrMSwgMipuZWlnaGJvckNvdW50XTsgXG5cdFx0XHRcblx0XHRcdGJsb2NrcyA9ICF0aGlzLl9saWdodFBhc3NlcyhjeCwgY3kpO1xuXHRcdFx0dmlzaWJpbGl0eSA9IHRoaXMuX2NoZWNrVmlzaWJpbGl0eShBMSwgQTIsIGJsb2NrcywgU0hBRE9XUyk7XG5cdFx0XHRpZiAodmlzaWJpbGl0eSkgeyBjYWxsYmFjayhjeCwgY3ksIHIsIHZpc2liaWxpdHkpOyB9XG5cblx0XHRcdGlmIChTSEFET1dTLmxlbmd0aCA9PSAyICYmIFNIQURPV1NbMF1bMF0gPT0gMCAmJiBTSEFET1dTWzFdWzBdID09IFNIQURPV1NbMV1bMV0pIHsgcmV0dXJuOyB9IC8qIGN1dG9mZj8gKi9cblxuXHRcdH0gLyogZm9yIGFsbCBjZWxscyBpbiB0aGlzIHJpbmcgKi9cblx0fSAvKiBmb3IgYWxsIHJpbmdzICovXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbnRbMl19IEExIGFyYyBzdGFydFxuICogQHBhcmFtIHtpbnRbMl19IEEyIGFyYyBlbmRcbiAqIEBwYXJhbSB7Ym9vbH0gYmxvY2tzIERvZXMgY3VycmVudCBhcmMgYmxvY2sgdmlzaWJpbGl0eT9cbiAqIEBwYXJhbSB7aW50W11bXX0gU0hBRE9XUyBsaXN0IG9mIGFjdGl2ZSBzaGFkb3dzXG4gKi9cblJPVC5GT1YuUHJlY2lzZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLl9jaGVja1Zpc2liaWxpdHkgPSBmdW5jdGlvbihBMSwgQTIsIGJsb2NrcywgU0hBRE9XUykge1xuXHRpZiAoQTFbMF0gPiBBMlswXSkgeyAvKiBzcGxpdCBpbnRvIHR3byBzdWItYXJjcyAqL1xuXHRcdHZhciB2MSA9IHRoaXMuX2NoZWNrVmlzaWJpbGl0eShBMSwgW0ExWzFdLCBBMVsxXV0sIGJsb2NrcywgU0hBRE9XUyk7XG5cdFx0dmFyIHYyID0gdGhpcy5fY2hlY2tWaXNpYmlsaXR5KFswLCAxXSwgQTIsIGJsb2NrcywgU0hBRE9XUyk7XG5cdFx0cmV0dXJuICh2MSt2MikvMjtcblx0fVxuXG5cdC8qIGluZGV4MTogZmlyc3Qgc2hhZG93ID49IEExICovXG5cdHZhciBpbmRleDEgPSAwLCBlZGdlMSA9IGZhbHNlO1xuXHR3aGlsZSAoaW5kZXgxIDwgU0hBRE9XUy5sZW5ndGgpIHtcblx0XHR2YXIgb2xkID0gU0hBRE9XU1tpbmRleDFdO1xuXHRcdHZhciBkaWZmID0gb2xkWzBdKkExWzFdIC0gQTFbMF0qb2xkWzFdO1xuXHRcdGlmIChkaWZmID49IDApIHsgLyogb2xkID49IEExICovXG5cdFx0XHRpZiAoZGlmZiA9PSAwICYmICEoaW5kZXgxICUgMikpIHsgZWRnZTEgPSB0cnVlOyB9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aW5kZXgxKys7XG5cdH1cblxuXHQvKiBpbmRleDI6IGxhc3Qgc2hhZG93IDw9IEEyICovXG5cdHZhciBpbmRleDIgPSBTSEFET1dTLmxlbmd0aCwgZWRnZTIgPSBmYWxzZTtcblx0d2hpbGUgKGluZGV4Mi0tKSB7XG5cdFx0dmFyIG9sZCA9IFNIQURPV1NbaW5kZXgyXTtcblx0XHR2YXIgZGlmZiA9IEEyWzBdKm9sZFsxXSAtIG9sZFswXSpBMlsxXTtcblx0XHRpZiAoZGlmZiA+PSAwKSB7IC8qIG9sZCA8PSBBMiAqL1xuXHRcdFx0aWYgKGRpZmYgPT0gMCAmJiAoaW5kZXgyICUgMikpIHsgZWRnZTIgPSB0cnVlOyB9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHR2YXIgdmlzaWJsZSA9IHRydWU7XG5cdGlmIChpbmRleDEgPT0gaW5kZXgyICYmIChlZGdlMSB8fCBlZGdlMikpIHsgIC8qIHN1YnNldCBvZiBleGlzdGluZyBzaGFkb3csIG9uZSBvZiB0aGUgZWRnZXMgbWF0Y2ggKi9cblx0XHR2aXNpYmxlID0gZmFsc2U7IFxuXHR9IGVsc2UgaWYgKGVkZ2UxICYmIGVkZ2UyICYmIGluZGV4MSsxPT1pbmRleDIgJiYgKGluZGV4MiAlIDIpKSB7IC8qIGNvbXBsZXRlbHkgZXF1aXZhbGVudCB3aXRoIGV4aXN0aW5nIHNoYWRvdyAqL1xuXHRcdHZpc2libGUgPSBmYWxzZTtcblx0fSBlbHNlIGlmIChpbmRleDEgPiBpbmRleDIgJiYgKGluZGV4MSAlIDIpKSB7IC8qIHN1YnNldCBvZiBleGlzdGluZyBzaGFkb3csIG5vdCB0b3VjaGluZyAqL1xuXHRcdHZpc2libGUgPSBmYWxzZTtcblx0fVxuXHRcblx0aWYgKCF2aXNpYmxlKSB7IHJldHVybiAwOyB9IC8qIGZhc3QgY2FzZTogbm90IHZpc2libGUgKi9cblx0XG5cdHZhciB2aXNpYmxlTGVuZ3RoLCBQO1xuXG5cdC8qIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB2aXNpYmxlIGFyYywgYWRqdXN0IGxpc3Qgb2Ygc2hhZG93cyAoaWYgYmxvY2tpbmcpICovXG5cdHZhciByZW1vdmUgPSBpbmRleDItaW5kZXgxKzE7XG5cdGlmIChyZW1vdmUgJSAyKSB7XG5cdFx0aWYgKGluZGV4MSAlIDIpIHsgLyogZmlyc3QgZWRnZSB3aXRoaW4gZXhpc3Rpbmcgc2hhZG93LCBzZWNvbmQgb3V0c2lkZSAqL1xuXHRcdFx0dmFyIFAgPSBTSEFET1dTW2luZGV4MV07XG5cdFx0XHR2aXNpYmxlTGVuZ3RoID0gKEEyWzBdKlBbMV0gLSBQWzBdKkEyWzFdKSAvIChQWzFdICogQTJbMV0pO1xuXHRcdFx0aWYgKGJsb2NrcykgeyBTSEFET1dTLnNwbGljZShpbmRleDEsIHJlbW92ZSwgQTIpOyB9XG5cdFx0fSBlbHNlIHsgLyogc2Vjb25kIGVkZ2Ugd2l0aGluIGV4aXN0aW5nIHNoYWRvdywgZmlyc3Qgb3V0c2lkZSAqL1xuXHRcdFx0dmFyIFAgPSBTSEFET1dTW2luZGV4Ml07XG5cdFx0XHR2aXNpYmxlTGVuZ3RoID0gKFBbMF0qQTFbMV0gLSBBMVswXSpQWzFdKSAvIChBMVsxXSAqIFBbMV0pO1xuXHRcdFx0aWYgKGJsb2NrcykgeyBTSEFET1dTLnNwbGljZShpbmRleDEsIHJlbW92ZSwgQTEpOyB9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmIChpbmRleDEgJSAyKSB7IC8qIGJvdGggZWRnZXMgd2l0aGluIGV4aXN0aW5nIHNoYWRvd3MgKi9cblx0XHRcdHZhciBQMSA9IFNIQURPV1NbaW5kZXgxXTtcblx0XHRcdHZhciBQMiA9IFNIQURPV1NbaW5kZXgyXTtcblx0XHRcdHZpc2libGVMZW5ndGggPSAoUDJbMF0qUDFbMV0gLSBQMVswXSpQMlsxXSkgLyAoUDFbMV0gKiBQMlsxXSk7XG5cdFx0XHRpZiAoYmxvY2tzKSB7IFNIQURPV1Muc3BsaWNlKGluZGV4MSwgcmVtb3ZlKTsgfVxuXHRcdH0gZWxzZSB7IC8qIGJvdGggZWRnZXMgb3V0c2lkZSBleGlzdGluZyBzaGFkb3dzICovXG5cdFx0XHRpZiAoYmxvY2tzKSB7IFNIQURPV1Muc3BsaWNlKGluZGV4MSwgcmVtb3ZlLCBBMSwgQTIpOyB9XG5cdFx0XHRyZXR1cm4gMTsgLyogd2hvbGUgYXJjIHZpc2libGUhICovXG5cdFx0fVxuXHR9XG5cblx0dmFyIGFyY0xlbmd0aCA9IChBMlswXSpBMVsxXSAtIEExWzBdKkEyWzFdKSAvIChBMVsxXSAqIEEyWzFdKTtcblxuXHRyZXR1cm4gdmlzaWJsZUxlbmd0aC9hcmNMZW5ndGg7XG59XG4vKipcbiAqIEBjbGFzcyBSZWN1cnNpdmUgc2hhZG93Y2FzdGluZyBhbGdvcml0aG1cbiAqIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIDQvOCB0b3BvbG9naWVzLCBub3QgaGV4YWdvbmFsLlxuICogQmFzZWQgb24gUGV0ZXIgSGFya2lucycgaW1wbGVtZW50YXRpb24gb2YgQmrDtnJuIEJlcmdzdHLDtm0ncyBhbGdvcml0aG0gZGVzY3JpYmVkIGhlcmU6IGh0dHA6Ly93d3cucm9ndWViYXNpbi5jb20vaW5kZXgucGhwP3RpdGxlPUZPVl91c2luZ19yZWN1cnNpdmVfc2hhZG93Y2FzdGluZ1xuICogQGF1Z21lbnRzIFJPVC5GT1ZcbiAqL1xuUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nID0gZnVuY3Rpb24obGlnaHRQYXNzZXNDYWxsYmFjaywgb3B0aW9ucykge1xuXHRST1QuRk9WLmNhbGwodGhpcywgbGlnaHRQYXNzZXNDYWxsYmFjaywgb3B0aW9ucyk7XG59XG5ST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuZXh0ZW5kKFJPVC5GT1YpO1xuXG4vKiogT2N0YW50cyB1c2VkIGZvciB0cmFuc2xhdGluZyByZWN1cnNpdmUgc2hhZG93Y2FzdGluZyBvZmZzZXRzICovXG5ST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuT0NUQU5UUyA9IFtcblx0Wy0xLCAgMCwgIDAsICAxXSxcblx0WyAwLCAtMSwgIDEsICAwXSxcblx0WyAwLCAtMSwgLTEsICAwXSxcblx0Wy0xLCAgMCwgIDAsIC0xXSxcblx0WyAxLCAgMCwgIDAsIC0xXSxcblx0WyAwLCAgMSwgLTEsICAwXSxcblx0WyAwLCAgMSwgIDEsICAwXSxcblx0WyAxLCAgMCwgIDAsICAxXVxuXTtcblxuLyoqXG4gKiBDb21wdXRlIHZpc2liaWxpdHkgZm9yIGEgMzYwLWRlZ3JlZSBjaXJjbGVcbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHBhcmFtIHtpbnR9IFIgTWF4aW11bSB2aXNpYmlsaXR5IHJhZGl1c1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24oeCwgeSwgUiwgY2FsbGJhY2spIHtcblx0Ly9Zb3UgY2FuIGFsd2F5cyBzZWUgeW91ciBvd24gdGlsZVxuXHRjYWxsYmFjayh4LCB5LCAwLCB0cnVlKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhpcy5fcmVuZGVyT2N0YW50KHgsIHksIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTW2ldLCBSLCBjYWxsYmFjayk7XG5cdH1cbn1cblxuLyoqXG4gKiBDb21wdXRlIHZpc2liaWxpdHkgZm9yIGEgMTgwLWRlZ3JlZSBhcmNcbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHBhcmFtIHtpbnR9IFIgTWF4aW11bSB2aXNpYmlsaXR5IHJhZGl1c1xuICogQHBhcmFtIHtpbnR9IGRpciBEaXJlY3Rpb24gdG8gbG9vayBpbiAoZXhwcmVzc2VkIGluIGEgUk9ULkRJUiB2YWx1ZSk7XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5ST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLmNvbXB1dGUxODAgPSBmdW5jdGlvbih4LCB5LCBSLCBkaXIsIGNhbGxiYWNrKSB7XG5cdC8vWW91IGNhbiBhbHdheXMgc2VlIHlvdXIgb3duIHRpbGVcblx0Y2FsbGJhY2soeCwgeSwgMCwgdHJ1ZSk7XG5cdHZhciBwcmV2aW91c09jdGFudCA9IChkaXIgLSAxICsgOCkgJSA4OyAvL05lZWQgdG8gcmV0cmlldmUgdGhlIHByZXZpb3VzIG9jdGFudCB0byByZW5kZXIgYSBmdWxsIDE4MCBkZWdyZWVzXG5cdHZhciBuZXh0UHJldmlvdXNPY3RhbnQgPSAoZGlyIC0gMiArIDgpICUgODsgLy9OZWVkIHRvIHJldHJpZXZlIHRoZSBwcmV2aW91cyB0d28gb2N0YW50cyB0byByZW5kZXIgYSBmdWxsIDE4MCBkZWdyZWVzXG5cdHZhciBuZXh0T2N0YW50ID0gKGRpcisgMSArIDgpICUgODsgLy9OZWVkIHRvIGdyYWIgdG8gbmV4dCBvY3RhbnQgdG8gcmVuZGVyIGEgZnVsbCAxODAgZGVncmVlc1xuXHR0aGlzLl9yZW5kZXJPY3RhbnQoeCwgeSwgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLk9DVEFOVFNbbmV4dFByZXZpb3VzT2N0YW50XSwgUiwgY2FsbGJhY2spO1xuXHR0aGlzLl9yZW5kZXJPY3RhbnQoeCwgeSwgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLk9DVEFOVFNbcHJldmlvdXNPY3RhbnRdLCBSLCBjYWxsYmFjayk7XG5cdHRoaXMuX3JlbmRlck9jdGFudCh4LCB5LCBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuT0NUQU5UU1tkaXJdLCBSLCBjYWxsYmFjayk7XG5cdHRoaXMuX3JlbmRlck9jdGFudCh4LCB5LCBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuT0NUQU5UU1tuZXh0T2N0YW50XSwgUiwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIENvbXB1dGUgdmlzaWJpbGl0eSBmb3IgYSA5MC1kZWdyZWUgYXJjXG4gKiBAcGFyYW0ge2ludH0geFxuICogQHBhcmFtIHtpbnR9IHlcbiAqIEBwYXJhbSB7aW50fSBSIE1heGltdW0gdmlzaWJpbGl0eSByYWRpdXNcbiAqIEBwYXJhbSB7aW50fSBkaXIgRGlyZWN0aW9uIHRvIGxvb2sgaW4gKGV4cHJlc3NlZCBpbiBhIFJPVC5ESVIgdmFsdWUpO1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLnByb3RvdHlwZS5jb21wdXRlOTAgPSBmdW5jdGlvbih4LCB5LCBSLCBkaXIsIGNhbGxiYWNrKSB7XG5cdC8vWW91IGNhbiBhbHdheXMgc2VlIHlvdXIgb3duIHRpbGVcblx0Y2FsbGJhY2soeCwgeSwgMCwgdHJ1ZSk7XG5cdHZhciBwcmV2aW91c09jdGFudCA9IChkaXIgLSAxICsgOCkgJSA4OyAvL05lZWQgdG8gcmV0cmlldmUgdGhlIHByZXZpb3VzIG9jdGFudCB0byByZW5kZXIgYSBmdWxsIDkwIGRlZ3JlZXNcblx0dGhpcy5fcmVuZGVyT2N0YW50KHgsIHksIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTW2Rpcl0sIFIsIGNhbGxiYWNrKTtcblx0dGhpcy5fcmVuZGVyT2N0YW50KHgsIHksIFJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTW3ByZXZpb3VzT2N0YW50XSwgUiwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJlbmRlciBvbmUgb2N0YW50ICg0NS1kZWdyZWUgYXJjKSBvZiB0aGUgdmlld3NoZWRcbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHBhcmFtIHtpbnR9IG9jdGFudCBPY3RhbnQgdG8gYmUgcmVuZGVyZWRcbiAqIEBwYXJhbSB7aW50fSBSIE1heGltdW0gdmlzaWJpbGl0eSByYWRpdXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5wcm90b3R5cGUuX3JlbmRlck9jdGFudCA9IGZ1bmN0aW9uKHgsIHksIG9jdGFudCwgUiwgY2FsbGJhY2spIHtcblx0Ly9SYWRpdXMgaW5jcmVtZW50ZWQgYnkgMSB0byBwcm92aWRlIHNhbWUgY292ZXJhZ2UgYXJlYSBhcyBvdGhlciBzaGFkb3djYXN0aW5nIHJhZGl1c2VzXG5cdHRoaXMuX2Nhc3RWaXNpYmlsaXR5KHgsIHksIDEsIDEuMCwgMC4wLCBSICsgMSwgb2N0YW50WzBdLCBvY3RhbnRbMV0sIG9jdGFudFsyXSwgb2N0YW50WzNdLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogQWN0dWFsbHkgY2FsY3VsYXRlcyB0aGUgdmlzaWJpbGl0eVxuICogQHBhcmFtIHtpbnR9IHN0YXJ0WCBUaGUgc3RhcnRpbmcgWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge2ludH0gc3RhcnRZIFRoZSBzdGFydGluZyBZIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7aW50fSByb3cgVGhlIHJvdyB0byByZW5kZXJcbiAqIEBwYXJhbSB7ZmxvYXR9IHZpc1Nsb3BlU3RhcnQgVGhlIHNsb3BlIHRvIHN0YXJ0IGF0XG4gKiBAcGFyYW0ge2Zsb2F0fSB2aXNTbG9wZUVuZCBUaGUgc2xvcGUgdG8gZW5kIGF0XG4gKiBAcGFyYW0ge2ludH0gcmFkaXVzIFRoZSByYWRpdXMgdG8gcmVhY2ggb3V0IHRvXG4gKiBAcGFyYW0ge2ludH0geHggXG4gKiBAcGFyYW0ge2ludH0geHkgXG4gKiBAcGFyYW0ge2ludH0geXggXG4gKiBAcGFyYW0ge2ludH0geXkgXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gdXNlIHdoZW4gd2UgaGl0IGEgYmxvY2sgdGhhdCBpcyB2aXNpYmxlXG4gKi9cblJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5wcm90b3R5cGUuX2Nhc3RWaXNpYmlsaXR5ID0gZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIHJvdywgdmlzU2xvcGVTdGFydCwgdmlzU2xvcGVFbmQsIHJhZGl1cywgeHgsIHh5LCB5eCwgeXksIGNhbGxiYWNrKSB7XG5cdGlmKHZpc1Nsb3BlU3RhcnQgPCB2aXNTbG9wZUVuZCkgeyByZXR1cm47IH1cblx0Zm9yKHZhciBpID0gcm93OyBpIDw9IHJhZGl1czsgaSsrKSB7XG5cdFx0dmFyIGR4ID0gLWkgLSAxO1xuXHRcdHZhciBkeSA9IC1pO1xuXHRcdHZhciBibG9ja2VkID0gZmFsc2U7XG5cdFx0dmFyIG5ld1N0YXJ0ID0gMDtcblxuXHRcdC8vJ1JvdycgY291bGQgYmUgY29sdW1uLCBuYW1lcyBoZXJlIGFzc3VtZSBvY3RhbnQgMCBhbmQgd291bGQgYmUgZmxpcHBlZCBmb3IgaGFsZiB0aGUgb2N0YW50c1xuXHRcdHdoaWxlKGR4IDw9IDApIHtcblx0XHRcdGR4ICs9IDE7XG5cblx0XHRcdC8vVHJhbnNsYXRlIGZyb20gcmVsYXRpdmUgY29vcmRpbmF0ZXMgdG8gbWFwIGNvb3JkaW5hdGVzXG5cdFx0XHR2YXIgbWFwWCA9IHN0YXJ0WCArIGR4ICogeHggKyBkeSAqIHh5O1xuXHRcdFx0dmFyIG1hcFkgPSBzdGFydFkgKyBkeCAqIHl4ICsgZHkgKiB5eTtcblxuXHRcdFx0Ly9SYW5nZSBvZiB0aGUgcm93XG5cdFx0XHR2YXIgc2xvcGVTdGFydCA9IChkeCAtIDAuNSkgLyAoZHkgKyAwLjUpO1xuXHRcdFx0dmFyIHNsb3BlRW5kID0gKGR4ICsgMC41KSAvIChkeSAtIDAuNSk7XG5cdFx0XG5cdFx0XHQvL0lnbm9yZSBpZiBub3QgeWV0IGF0IGxlZnQgZWRnZSBvZiBPY3RhbnRcblx0XHRcdGlmKHNsb3BlRW5kID4gdmlzU2xvcGVTdGFydCkgeyBjb250aW51ZTsgfVxuXHRcdFx0XG5cdFx0XHQvL0RvbmUgaWYgcGFzdCByaWdodCBlZGdlXG5cdFx0XHRpZihzbG9wZVN0YXJ0IDwgdmlzU2xvcGVFbmQpIHsgYnJlYWs7IH1cblx0XHRcdFx0XG5cdFx0XHQvL0lmIGl0J3MgaW4gcmFuZ2UsIGl0J3MgdmlzaWJsZVxuXHRcdFx0aWYoKGR4ICogZHggKyBkeSAqIGR5KSA8IChyYWRpdXMgKiByYWRpdXMpKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG1hcFgsIG1hcFksIGksIHRydWUpO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmKCFibG9ja2VkKSB7XG5cdFx0XHRcdC8vSWYgdGlsZSBpcyBhIGJsb2NraW5nIHRpbGUsIGNhc3QgYXJvdW5kIGl0XG5cdFx0XHRcdGlmKCF0aGlzLl9saWdodFBhc3NlcyhtYXBYLCBtYXBZKSAmJiBpIDwgcmFkaXVzKSB7XG5cdFx0XHRcdFx0YmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5fY2FzdFZpc2liaWxpdHkoc3RhcnRYLCBzdGFydFksIGkgKyAxLCB2aXNTbG9wZVN0YXJ0LCBzbG9wZVN0YXJ0LCByYWRpdXMsIHh4LCB4eSwgeXgsIHl5LCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0bmV3U3RhcnQgPSBzbG9wZUVuZDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly9LZWVwIG5hcnJvd2luZyBpZiBzY2FubmluZyBhY3Jvc3MgYSBibG9ja1xuXHRcdFx0XHRpZighdGhpcy5fbGlnaHRQYXNzZXMobWFwWCwgbWFwWSkpIHtcblx0XHRcdFx0XHRuZXdTdGFydCA9IHNsb3BlRW5kO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0Ly9CbG9jayBoYXMgZW5kZWRcblx0XHRcdFx0YmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHR2aXNTbG9wZVN0YXJ0ID0gbmV3U3RhcnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGJsb2NrZWQpIHsgYnJlYWs7IH1cblx0fVxufVxuLyoqXG4gKiBAbmFtZXNwYWNlIENvbG9yIG9wZXJhdGlvbnNcbiAqL1xuUk9ULkNvbG9yID0ge1xuXHRmcm9tU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcblx0XHR2YXIgY2FjaGVkLCByO1xuXHRcdGlmIChzdHIgaW4gdGhpcy5fY2FjaGUpIHtcblx0XHRcdGNhY2hlZCA9IHRoaXMuX2NhY2hlW3N0cl07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChzdHIuY2hhckF0KDApID09IFwiI1wiKSB7IC8qIGhleCByZ2IgKi9cblxuXHRcdFx0XHR2YXIgdmFsdWVzID0gc3RyLm1hdGNoKC9bMC05YS1mXS9naSkubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBhcnNlSW50KHgsIDE2KTsgfSk7XG5cdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID09IDMpIHtcblx0XHRcdFx0XHRjYWNoZWQgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHgqMTc7IH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAodmFyIGk9MDtpPDM7aSsrKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbaSsxXSArPSAxNip2YWx1ZXNbaV07XG5cdFx0XHRcdFx0XHR2YWx1ZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWNoZWQgPSB2YWx1ZXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmIChyID0gc3RyLm1hdGNoKC9yZ2JcXCgoWzAtOSwgXSspXFwpL2kpKSB7IC8qIGRlY2ltYWwgcmdiICovXG5cdFx0XHRcdGNhY2hlZCA9IHJbMV0uc3BsaXQoL1xccyosXFxzKi8pLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBwYXJzZUludCh4KTsgfSk7XG5cdFx0XHR9IGVsc2UgeyAvKiBodG1sIG5hbWUgKi9cblx0XHRcdFx0Y2FjaGVkID0gWzAsIDAsIDBdO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jYWNoZVtzdHJdID0gY2FjaGVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBjYWNoZWQuc2xpY2UoKTtcblx0fSxcblxuXHQvKipcblx0ICogQWRkIHR3byBvciBtb3JlIGNvbG9yc1xuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjFcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdGFkZDogZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcblx0XHR2YXIgcmVzdWx0ID0gY29sb3IxLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaT0wO2k8MztpKyspIHtcblx0XHRcdGZvciAodmFyIGo9MTtqPGFyZ3VtZW50cy5sZW5ndGg7aisrKSB7XG5cdFx0XHRcdHJlc3VsdFtpXSArPSBhcmd1bWVudHNbal1baV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCB0d28gb3IgbW9yZSBjb2xvcnMsIE1PRElGSUVTIEZJUlNUIEFSR1VNRU5UXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjJcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0YWRkXzogZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcblx0XHRmb3IgKHZhciBpPTA7aTwzO2krKykge1xuXHRcdFx0Zm9yICh2YXIgaj0xO2o8YXJndW1lbnRzLmxlbmd0aDtqKyspIHtcblx0XHRcdFx0Y29sb3IxW2ldICs9IGFyZ3VtZW50c1tqXVtpXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvbG9yMTtcblx0fSxcblxuXHQvKipcblx0ICogTXVsdGlwbHkgKG1peCkgdHdvIG9yIG1vcmUgY29sb3JzXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjJcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyKSB7XG5cdFx0dmFyIHJlc3VsdCA9IGNvbG9yMS5zbGljZSgpO1xuXHRcdGZvciAodmFyIGk9MDtpPDM7aSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqPTE7ajxhcmd1bWVudHMubGVuZ3RoO2orKykge1xuXHRcdFx0XHRyZXN1bHRbaV0gKj0gYXJndW1lbnRzW2pdW2ldIC8gMjU1O1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNdWx0aXBseSAobWl4KSB0d28gb3IgbW9yZSBjb2xvcnMsIE1PRElGSUVTIEZJUlNUIEFSR1VNRU5UXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjJcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0bXVsdGlwbHlfOiBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikge1xuXHRcdGZvciAodmFyIGk9MDtpPDM7aSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqPTE7ajxhcmd1bWVudHMubGVuZ3RoO2orKykge1xuXHRcdFx0XHRjb2xvcjFbaV0gKj0gYXJndW1lbnRzW2pdW2ldIC8gMjU1O1xuXHRcdFx0fVxuXHRcdFx0Y29sb3IxW2ldID0gTWF0aC5yb3VuZChjb2xvcjFbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY29sb3IxO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbnRlcnBvbGF0ZSAoYmxlbmQpIHR3byBjb2xvcnMgd2l0aCBhIGdpdmVuIGZhY3RvclxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjFcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IyXG5cdCAqIEBwYXJhbSB7ZmxvYXR9IFtmYWN0b3I9MC41XSAwLi4xXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMiwgZmFjdG9yKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7IGZhY3RvciA9IDAuNTsgfVxuXHRcdHZhciByZXN1bHQgPSBjb2xvcjEuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpPTA7aTwzO2krKykge1xuXHRcdFx0cmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0gKyBmYWN0b3IqKGNvbG9yMltpXS1jb2xvcjFbaV0pKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHQvKipcblx0ICogSW50ZXJwb2xhdGUgKGJsZW5kKSB0d28gY29sb3JzIHdpdGggYSBnaXZlbiBmYWN0b3IgaW4gSFNMIG1vZGVcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IxXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMlxuXHQgKiBAcGFyYW0ge2Zsb2F0fSBbZmFjdG9yPTAuNV0gMC4uMVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRpbnRlcnBvbGF0ZUhTTDogZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIsIGZhY3Rvcikge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgeyBmYWN0b3IgPSAwLjU7IH1cblx0XHR2YXIgaHNsMSA9IHRoaXMucmdiMmhzbChjb2xvcjEpO1xuXHRcdHZhciBoc2wyID0gdGhpcy5yZ2IyaHNsKGNvbG9yMik7XG5cdFx0Zm9yICh2YXIgaT0wO2k8MztpKyspIHtcblx0XHRcdGhzbDFbaV0gKz0gZmFjdG9yKihoc2wyW2ldLWhzbDFbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5oc2wycmdiKGhzbDEpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgcmFuZG9tIGNvbG9yIGJhc2VkIG9uIHRoaXMgb25lXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGRpZmYgU2V0IG9mIHN0YW5kYXJkIGRldmlhdGlvbnNcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0cmFuZG9taXplOiBmdW5jdGlvbihjb2xvciwgZGlmZikge1xuXHRcdGlmICghKGRpZmYgaW5zdGFuY2VvZiBBcnJheSkpIHsgZGlmZiA9IFJPVC5STkcuZ2V0Tm9ybWFsKDAsIGRpZmYpOyB9XG5cdFx0dmFyIHJlc3VsdCA9IGNvbG9yLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaT0wO2k8MztpKyspIHtcblx0XHRcdHJlc3VsdFtpXSArPSAoZGlmZiBpbnN0YW5jZW9mIEFycmF5ID8gTWF0aC5yb3VuZChST1QuUk5HLmdldE5vcm1hbCgwLCBkaWZmW2ldKSkgOiBkaWZmKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTTC4gRXhwZWN0cyAwLi4yNTUgaW5wdXRzLCBwcm9kdWNlcyAwLi4xIG91dHB1dHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHJnYjJoc2w6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dmFyIHIgPSBjb2xvclswXS8yNTU7XG5cdFx0dmFyIGcgPSBjb2xvclsxXS8yNTU7XG5cdFx0dmFyIGIgPSBjb2xvclsyXS8yNTU7XG5cblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRcdHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuXG5cdFx0aWYgKG1heCA9PSBtaW4pIHtcblx0XHRcdGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZCA9IG1heCAtIG1pbjtcblx0XHRcdHMgPSAobCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbikpO1xuXHRcdFx0c3dpdGNoKG1heCkge1xuXHRcdFx0XHRjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRoIC89IDY7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtoLCBzLCBsXTtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgYW4gSFNMIGNvbG9yIHZhbHVlIHRvIFJHQi4gRXhwZWN0cyAwLi4xIGlucHV0cywgcHJvZHVjZXMgMC4uMjU1IG91dHB1dHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdGhzbDJyZ2I6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dmFyIGwgPSBjb2xvclsyXTtcblxuXHRcdGlmIChjb2xvclsxXSA9PSAwKSB7XG5cdFx0XHRsID0gTWF0aC5yb3VuZChsKjI1NSk7XG5cdFx0XHRyZXR1cm4gW2wsIGwsIGxdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcblx0XHRcdFx0aWYgKHQgPCAwKSB0ICs9IDE7XG5cdFx0XHRcdGlmICh0ID4gMSkgdCAtPSAxO1xuXHRcdFx0XHRpZiAodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG5cdFx0XHRcdGlmICh0IDwgMS8yKSByZXR1cm4gcTtcblx0XHRcdFx0aWYgKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XG5cdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IGNvbG9yWzFdO1xuXHRcdFx0dmFyIHEgPSAobCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcyk7XG5cdFx0XHR2YXIgcCA9IDIgKiBsIC0gcTtcblx0XHRcdHZhciByID0gaHVlMnJnYihwLCBxLCBjb2xvclswXSArIDEvMyk7XG5cdFx0XHR2YXIgZyA9IGh1ZTJyZ2IocCwgcSwgY29sb3JbMF0pO1xuXHRcdFx0dmFyIGIgPSBodWUycmdiKHAsIHEsIGNvbG9yWzBdIC0gMS8zKTtcblx0XHRcdHJldHVybiBbTWF0aC5yb3VuZChyKjI1NSksIE1hdGgucm91bmQoZyoyNTUpLCBNYXRoLnJvdW5kKGIqMjU1KV07XG5cdFx0fVxuXHR9LFxuXG5cdHRvUkdCOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHJldHVybiBcInJnYihcIiArIHRoaXMuX2NsYW1wKGNvbG9yWzBdKSArIFwiLFwiICsgdGhpcy5fY2xhbXAoY29sb3JbMV0pICsgXCIsXCIgKyB0aGlzLl9jbGFtcChjb2xvclsyXSkgKyBcIilcIjtcblx0fSxcblxuXHR0b0hleDogZnVuY3Rpb24oY29sb3IpIHtcblx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRmb3IgKHZhciBpPTA7aTwzO2krKykge1xuXHRcdFx0cGFydHMucHVzaCh0aGlzLl9jbGFtcChjb2xvcltpXSkudG9TdHJpbmcoMTYpLmxwYWQoXCIwXCIsIDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIFwiI1wiICsgcGFydHMuam9pbihcIlwiKTtcblx0fSxcblxuXHRfY2xhbXA6IGZ1bmN0aW9uKG51bSkge1xuXHRcdGlmIChudW0gPCAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9IGVsc2UgaWYgKG51bSA+IDI1NSkge1xuXHRcdFx0cmV0dXJuIDI1NTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bTtcblx0XHR9XG5cdH0sXG5cblx0X2NhY2hlOiB7XG5cdFx0XCJibGFja1wiOiBbMCwwLDBdLFxuXHRcdFwibmF2eVwiOiBbMCwwLDEyOF0sXG5cdFx0XCJkYXJrYmx1ZVwiOiBbMCwwLDEzOV0sXG5cdFx0XCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1XSxcblx0XHRcImJsdWVcIjogWzAsMCwyNTVdLFxuXHRcdFwiZGFya2dyZWVuXCI6IFswLDEwMCwwXSxcblx0XHRcImdyZWVuXCI6IFswLDEyOCwwXSxcblx0XHRcInRlYWxcIjogWzAsMTI4LDEyOF0sXG5cdFx0XCJkYXJrY3lhblwiOiBbMCwxMzksMTM5XSxcblx0XHRcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTVdLFxuXHRcdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5XSxcblx0XHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLDI1MCwxNTRdLFxuXHRcdFwibGltZVwiOiBbMCwyNTUsMF0sXG5cdFx0XCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3XSxcblx0XHRcImFxdWFcIjogWzAsMjU1LDI1NV0sXG5cdFx0XCJjeWFuXCI6IFswLDI1NSwyNTVdLFxuXHRcdFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTJdLFxuXHRcdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NV0sXG5cdFx0XCJmb3Jlc3RncmVlblwiOiBbMzQsMTM5LDM0XSxcblx0XHRcInNlYWdyZWVuXCI6IFs0NiwxMzksODddLFxuXHRcdFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzldLFxuXHRcdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzldLFxuXHRcdFwibGltZWdyZWVuXCI6IFs1MCwyMDUsNTBdLFxuXHRcdFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTNdLFxuXHRcdFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4XSxcblx0XHRcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNV0sXG5cdFx0XCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODBdLFxuXHRcdFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsNjEsMTM5XSxcblx0XHRcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNF0sXG5cdFx0XCJpbmRpZ29cIjogWzc1LDAsMTMwXSxcblx0XHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDddLFxuXHRcdFwiY2FkZXRibHVlXCI6IFs5NSwxNTgsMTYwXSxcblx0XHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzN10sXG5cdFx0XCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MF0sXG5cdFx0XCJkaW1ncmF5XCI6IFsxMDUsMTA1LDEwNV0sXG5cdFx0XCJkaW1ncmV5XCI6IFsxMDUsMTA1LDEwNV0sXG5cdFx0XCJzbGF0ZWJsdWVcIjogWzEwNiw5MCwyMDVdLFxuXHRcdFwib2xpdmVkcmFiXCI6IFsxMDcsMTQyLDM1XSxcblx0XHRcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDRdLFxuXHRcdFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NF0sXG5cdFx0XCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTNdLFxuXHRcdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzXSxcblx0XHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzhdLFxuXHRcdFwibGF3bmdyZWVuXCI6IFsxMjQsMjUyLDBdLFxuXHRcdFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwXSxcblx0XHRcImFxdWFtYXJpbmVcIjogWzEyNywyNTUsMjEyXSxcblx0XHRcIm1hcm9vblwiOiBbMTI4LDAsMF0sXG5cdFx0XCJwdXJwbGVcIjogWzEyOCwwLDEyOF0sXG5cdFx0XCJvbGl2ZVwiOiBbMTI4LDEyOCwwXSxcblx0XHRcImdyYXlcIjogWzEyOCwxMjgsMTI4XSxcblx0XHRcImdyZXlcIjogWzEyOCwxMjgsMTI4XSxcblx0XHRcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1XSxcblx0XHRcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LDIwNiwyNTBdLFxuXHRcdFwiYmx1ZXZpb2xldFwiOiBbMTM4LDQzLDIyNl0sXG5cdFx0XCJkYXJrcmVkXCI6IFsxMzksMCwwXSxcblx0XHRcImRhcmttYWdlbnRhXCI6IFsxMzksMCwxMzldLFxuXHRcdFwic2FkZGxlYnJvd25cIjogWzEzOSw2OSwxOV0sXG5cdFx0XCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzXSxcblx0XHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0XSxcblx0XHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTZdLFxuXHRcdFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExXSxcblx0XHRcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTJdLFxuXHRcdFwiZGFya29yY2hpZFwiOiBbMTUzLDUwLDIwNF0sXG5cdFx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MF0sXG5cdFx0XCJzaWVubmFcIjogWzE2MCw4Miw0NV0sXG5cdFx0XCJicm93blwiOiBbMTY1LDQyLDQyXSxcblx0XHRcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OV0sXG5cdFx0XCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjldLFxuXHRcdFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMF0sXG5cdFx0XCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0N10sXG5cdFx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOF0sXG5cdFx0XCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LDE5NiwyMjJdLFxuXHRcdFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzBdLFxuXHRcdFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzRdLFxuXHRcdFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LDEzNCwxMV0sXG5cdFx0XCJtZWRpdW1vcmNoaWRcIjogWzE4Niw4NSwyMTFdLFxuXHRcdFwicm9zeWJyb3duXCI6IFsxODgsMTQzLDE0M10sXG5cdFx0XCJkYXJra2hha2lcIjogWzE4OSwxODMsMTA3XSxcblx0XHRcInNpbHZlclwiOiBbMTkyLDE5MiwxOTJdLFxuXHRcdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzXSxcblx0XHRcImluZGlhbnJlZFwiOiBbMjA1LDkyLDkyXSxcblx0XHRcInBlcnVcIjogWzIwNSwxMzMsNjNdLFxuXHRcdFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwXSxcblx0XHRcInRhblwiOiBbMjEwLDE4MCwxNDBdLFxuXHRcdFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMV0sXG5cdFx0XCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExXSxcblx0XHRcInBhbGV2aW9sZXRyZWRcIjogWzIxNiwxMTIsMTQ3XSxcblx0XHRcInRoaXN0bGVcIjogWzIxNiwxOTEsMjE2XSxcblx0XHRcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTRdLFxuXHRcdFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyXSxcblx0XHRcImNyaW1zb25cIjogWzIyMCwyMCw2MF0sXG5cdFx0XCJnYWluc2Jvcm9cIjogWzIyMCwyMjAsMjIwXSxcblx0XHRcInBsdW1cIjogWzIyMSwxNjAsMjIxXSxcblx0XHRcImJ1cmx5d29vZFwiOiBbMjIyLDE4NCwxMzVdLFxuXHRcdFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NV0sXG5cdFx0XCJsYXZlbmRlclwiOiBbMjMwLDIzMCwyNTBdLFxuXHRcdFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjJdLFxuXHRcdFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOF0sXG5cdFx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsMjMyLDE3MF0sXG5cdFx0XCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOF0sXG5cdFx0XCJraGFraVwiOiBbMjQwLDIzMCwxNDBdLFxuXHRcdFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NV0sXG5cdFx0XCJob25leWRld1wiOiBbMjQwLDI1NSwyNDBdLFxuXHRcdFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1XSxcblx0XHRcInNhbmR5YnJvd25cIjogWzI0NCwxNjQsOTZdLFxuXHRcdFwid2hlYXRcIjogWzI0NSwyMjIsMTc5XSxcblx0XHRcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMF0sXG5cdFx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NV0sXG5cdFx0XCJtaW50Y3JlYW1cIjogWzI0NSwyNTUsMjUwXSxcblx0XHRcImdob3N0d2hpdGVcIjogWzI0OCwyNDgsMjU1XSxcblx0XHRcInNhbG1vblwiOiBbMjUwLDEyOCwxMTRdLFxuXHRcdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNV0sXG5cdFx0XCJsaW5lblwiOiBbMjUwLDI0MCwyMzBdLFxuXHRcdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwyNTAsMjEwXSxcblx0XHRcIm9sZGxhY2VcIjogWzI1MywyNDUsMjMwXSxcblx0XHRcInJlZFwiOiBbMjU1LDAsMF0sXG5cdFx0XCJmdWNoc2lhXCI6IFsyNTUsMCwyNTVdLFxuXHRcdFwibWFnZW50YVwiOiBbMjU1LDAsMjU1XSxcblx0XHRcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3XSxcblx0XHRcIm9yYW5nZXJlZFwiOiBbMjU1LDY5LDBdLFxuXHRcdFwidG9tYXRvXCI6IFsyNTUsOTksNzFdLFxuXHRcdFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODBdLFxuXHRcdFwiY29yYWxcIjogWzI1NSwxMjcsODBdLFxuXHRcdFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwXSxcblx0XHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsMTYwLDEyMl0sXG5cdFx0XCJvcmFuZ2VcIjogWzI1NSwxNjUsMF0sXG5cdFx0XCJsaWdodHBpbmtcIjogWzI1NSwxODIsMTkzXSxcblx0XHRcInBpbmtcIjogWzI1NSwxOTIsMjAzXSxcblx0XHRcImdvbGRcIjogWzI1NSwyMTUsMF0sXG5cdFx0XCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1XSxcblx0XHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsMjIyLDE3M10sXG5cdFx0XCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODFdLFxuXHRcdFwiYmlzcXVlXCI6IFsyNTUsMjI4LDE5Nl0sXG5cdFx0XCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1XSxcblx0XHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNV0sXG5cdFx0XCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxM10sXG5cdFx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NV0sXG5cdFx0XCJzZWFzaGVsbFwiOiBbMjU1LDI0NSwyMzhdLFxuXHRcdFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwXSxcblx0XHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDVdLFxuXHRcdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwXSxcblx0XHRcInNub3dcIjogWzI1NSwyNTAsMjUwXSxcblx0XHRcInllbGxvd1wiOiBbMjU1LDI1NSwwXSxcblx0XHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNF0sXG5cdFx0XCJpdm9yeVwiOiBbMjU1LDI1NSwyNDBdLFxuXHRcdFwid2hpdGVcIjogWzI1NSwyNTUsMjU1XVxuXHR9XG59XG4vKipcbiAqIEBjbGFzcyBMaWdodGluZyBjb21wdXRhdGlvbiwgYmFzZWQgb24gYSB0cmFkaXRpb25hbCBGT1YgZm9yIG11bHRpcGxlIGxpZ2h0IHNvdXJjZXMgYW5kIG11bHRpcGxlIHBhc3Nlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlZmxlY3Rpdml0eUNhbGxiYWNrIENhbGxiYWNrIHRvIHJldHJpZXZlIGNlbGwgcmVmbGVjdGl2aXR5ICgwLi4xKVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnBhc3Nlcz0xXSBOdW1iZXIgb2YgcGFzc2VzLiAxIGVxdWFscyB0byBzaW1wbGUgRk9WIG9mIGFsbCBsaWdodCBzb3VyY2VzLCA+MSBtZWFucyBhICpoaWdobHkgc2ltcGxpZmllZCogcmFkaW9zaXR5LWxpa2UgYWxnb3JpdGhtLlxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmVtaXNzaW9uVGhyZXNob2xkPTEwMF0gQ2VsbHMgd2l0aCBlbWlzc2l2aXR5ID4gdGhyZXNob2xkIHdpbGwgYmUgdHJlYXRlZCBhcyBsaWdodCBzb3VyY2UgaW4gdGhlIG5leHQgcGFzcy5cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5yYW5nZT0xMF0gTWF4IGxpZ2h0IHJhbmdlXG4gKi9cblJPVC5MaWdodGluZyA9IGZ1bmN0aW9uKHJlZmxlY3Rpdml0eUNhbGxiYWNrLCBvcHRpb25zKSB7XG5cdHRoaXMuX3JlZmxlY3Rpdml0eUNhbGxiYWNrID0gcmVmbGVjdGl2aXR5Q2FsbGJhY2s7XG5cdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0cGFzc2VzOiAxLFxuXHRcdGVtaXNzaW9uVGhyZXNob2xkOiAxMDAsXG5cdFx0cmFuZ2U6IDEwXG5cdH07XG5cdHRoaXMuX2ZvdiA9IG51bGw7XG5cblx0dGhpcy5fbGlnaHRzID0ge307XG5cdHRoaXMuX3JlZmxlY3Rpdml0eUNhY2hlID0ge307XG5cdHRoaXMuX2ZvdkNhY2hlID0ge307XG5cblx0dGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEFkanVzdCBvcHRpb25zIGF0IHJ1bnRpbWVcbiAqIEBzZWUgUk9ULkxpZ2h0aW5nXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKi9cblJPVC5MaWdodGluZy5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgcCBpbiBvcHRpb25zKSB7IHRoaXMuX29wdGlvbnNbcF0gPSBvcHRpb25zW3BdOyB9XG5cdGlmIChvcHRpb25zLnJhbmdlKSB7IHRoaXMucmVzZXQoKTsgfVxuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHVzZWQgRmllbGQtT2YtVmlldyBhbGdvXG4gKiBAcGFyYW0ge1JPVC5GT1Z9IGZvdlxuICovXG5ST1QuTGlnaHRpbmcucHJvdG90eXBlLnNldEZPViA9IGZ1bmN0aW9uKGZvdikge1xuXHR0aGlzLl9mb3YgPSBmb3Y7XG5cdHRoaXMuX2ZvdkNhY2hlID0ge307XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFNldCAob3IgcmVtb3ZlKSBhIGxpZ2h0IHNvdXJjZVxuICogQHBhcmFtIHtpbnR9IHhcbiAqIEBwYXJhbSB7aW50fSB5XG4gKiBAcGFyYW0ge251bGwgfHwgc3RyaW5nIHx8IG51bWJlclszXX0gY29sb3JcbiAqL1xuUk9ULkxpZ2h0aW5nLnByb3RvdHlwZS5zZXRMaWdodCA9IGZ1bmN0aW9uKHgsIHksIGNvbG9yKSB7XG5cdHZhciBrZXkgPSB4K1wiLFwiK3k7XG5cblx0aWYgKGNvbG9yKSB7XG5cdFx0dGhpcy5fbGlnaHRzW2tleV0gPSAodHlwZW9mKGNvbG9yKSA9PSBcInN0cmluZ1wiID8gUk9ULkNvbG9yLmZyb21TdHJpbmcoY29sb3IpIDogY29sb3IpO1xuXHR9IGVsc2Uge1xuXHRcdGRlbGV0ZSB0aGlzLl9saWdodHNba2V5XTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpZ2h0IHNvdXJjZXNcbiAqL1xuUk9ULkxpZ2h0aW5nLnByb3RvdHlwZS5jbGVhckxpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpZ2h0cyA9IHt9O1xufVxuXG4vKipcbiAqIFJlc2V0IHRoZSBwcmUtY29tcHV0ZWQgdG9wb2xvZ3kgdmFsdWVzLiBDYWxsIHdoZW5ldmVyIHRoZSB1bmRlcmx5aW5nIG1hcCBjaGFuZ2VzIGl0cyBsaWdodC1wYXNzYWJpbGl0eS5cbiAqL1xuUk9ULkxpZ2h0aW5nLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9yZWZsZWN0aXZpdHlDYWNoZSA9IHt9O1xuXHR0aGlzLl9mb3ZDYWNoZSA9IHt9O1xuXG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxpZ2h0aW5nXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaWdodGluZ0NhbGxiYWNrIFdpbGwgYmUgY2FsbGVkIHdpdGggKHgsIHksIGNvbG9yKSBmb3IgZXZlcnkgbGl0IGNlbGxcbiAqL1xuUk9ULkxpZ2h0aW5nLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24obGlnaHRpbmdDYWxsYmFjaykge1xuXHR2YXIgZG9uZUNlbGxzID0ge307XG5cdHZhciBlbWl0dGluZ0NlbGxzID0ge307XG5cdHZhciBsaXRDZWxscyA9IHt9O1xuXG5cdGZvciAodmFyIGtleSBpbiB0aGlzLl9saWdodHMpIHsgLyogcHJlcGFyZSBlbWl0dGVycyBmb3IgZmlyc3QgcGFzcyAqL1xuXHRcdHZhciBsaWdodCA9IHRoaXMuX2xpZ2h0c1trZXldO1xuXHRcdGlmICghKGtleSBpbiBlbWl0dGluZ0NlbGxzKSkgeyBlbWl0dGluZ0NlbGxzW2tleV0gPSBbMCwgMCwgMF07IH1cblxuXHRcdFJPVC5Db2xvci5hZGRfKGVtaXR0aW5nQ2VsbHNba2V5XSwgbGlnaHQpO1xuXHR9XG5cblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fb3B0aW9ucy5wYXNzZXM7aSsrKSB7IC8qIG1haW4gbG9vcCAqL1xuXHRcdHRoaXMuX2VtaXRMaWdodChlbWl0dGluZ0NlbGxzLCBsaXRDZWxscywgZG9uZUNlbGxzKTtcblx0XHRpZiAoaSsxID09IHRoaXMuX29wdGlvbnMucGFzc2VzKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBmb3IgdGhlIGxhc3QgcGFzcyAqL1xuXHRcdGVtaXR0aW5nQ2VsbHMgPSB0aGlzLl9jb21wdXRlRW1pdHRlcnMobGl0Q2VsbHMsIGRvbmVDZWxscyk7XG5cdH1cblxuXHRmb3IgKHZhciBsaXRLZXkgaW4gbGl0Q2VsbHMpIHsgLyogbGV0IHRoZSB1c2VyIGtub3cgd2hhdCBhbmQgaG93IGlzIGxpdCAqL1xuXHRcdHZhciBwYXJ0cyA9IGxpdEtleS5zcGxpdChcIixcIik7XG5cdFx0dmFyIHggPSBwYXJzZUludChwYXJ0c1swXSk7XG5cdFx0dmFyIHkgPSBwYXJzZUludChwYXJ0c1sxXSk7XG5cdFx0bGlnaHRpbmdDYWxsYmFjayh4LCB5LCBsaXRDZWxsc1tsaXRLZXldKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENvbXB1dGUgb25lIGl0ZXJhdGlvbiBmcm9tIGFsbCBlbWl0dGluZyBjZWxsc1xuICogQHBhcmFtIHtvYmplY3R9IGVtaXR0aW5nQ2VsbHMgVGhlc2UgZW1pdCBsaWdodFxuICogQHBhcmFtIHtvYmplY3R9IGxpdENlbGxzIEFkZCBwcm9qZWN0ZWQgbGlnaHQgdG8gdGhlc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBkb25lQ2VsbHMgVGhlc2UgYWxyZWFkeSBlbWl0dGVkLCBmb3JiaWQgdGhlbSBmcm9tIGZ1cnRoZXIgY2FsY3VsYXRpb25zXG4gKi9cblJPVC5MaWdodGluZy5wcm90b3R5cGUuX2VtaXRMaWdodCA9IGZ1bmN0aW9uKGVtaXR0aW5nQ2VsbHMsIGxpdENlbGxzLCBkb25lQ2VsbHMpIHtcblx0Zm9yICh2YXIga2V5IGluIGVtaXR0aW5nQ2VsbHMpIHtcblx0XHR2YXIgcGFydHMgPSBrZXkuc3BsaXQoXCIsXCIpO1xuXHRcdHZhciB4ID0gcGFyc2VJbnQocGFydHNbMF0pO1xuXHRcdHZhciB5ID0gcGFyc2VJbnQocGFydHNbMV0pO1xuXHRcdHRoaXMuX2VtaXRMaWdodEZyb21DZWxsKHgsIHksIGVtaXR0aW5nQ2VsbHNba2V5XSwgbGl0Q2VsbHMpO1xuXHRcdGRvbmVDZWxsc1trZXldID0gMTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBQcmVwYXJlIGEgbGlzdCBvZiBlbWl0dGVycyBmb3IgbmV4dCBwYXNzXG4gKiBAcGFyYW0ge29iamVjdH0gbGl0Q2VsbHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBkb25lQ2VsbHNcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblJPVC5MaWdodGluZy5wcm90b3R5cGUuX2NvbXB1dGVFbWl0dGVycyA9IGZ1bmN0aW9uKGxpdENlbGxzLCBkb25lQ2VsbHMpIHtcblx0dmFyIHJlc3VsdCA9IHt9O1xuXG5cdGZvciAodmFyIGtleSBpbiBsaXRDZWxscykge1xuXHRcdGlmIChrZXkgaW4gZG9uZUNlbGxzKSB7IGNvbnRpbnVlOyB9IC8qIGFscmVhZHkgZW1pdHRlZCAqL1xuXG5cdFx0dmFyIGNvbG9yID0gbGl0Q2VsbHNba2V5XTtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcmVmbGVjdGl2aXR5Q2FjaGUpIHtcblx0XHRcdHZhciByZWZsZWN0aXZpdHkgPSB0aGlzLl9yZWZsZWN0aXZpdHlDYWNoZVtrZXldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBrZXkuc3BsaXQoXCIsXCIpO1xuXHRcdFx0dmFyIHggPSBwYXJzZUludChwYXJ0c1swXSk7XG5cdFx0XHR2YXIgeSA9IHBhcnNlSW50KHBhcnRzWzFdKTtcblx0XHRcdHZhciByZWZsZWN0aXZpdHkgPSB0aGlzLl9yZWZsZWN0aXZpdHlDYWxsYmFjayh4LCB5KTtcblx0XHRcdHRoaXMuX3JlZmxlY3Rpdml0eUNhY2hlW2tleV0gPSByZWZsZWN0aXZpdHk7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZmxlY3Rpdml0eSA9PSAwKSB7IGNvbnRpbnVlOyB9IC8qIHdpbGwgbm90IHJlZmxlY3QgYXQgYWxsICovXG5cblx0XHQvKiBjb21wdXRlIGVtaXNzaW9uIGNvbG9yICovXG5cdFx0dmFyIGVtaXNzaW9uID0gW107XG5cdFx0dmFyIGludGVuc2l0eSA9IDA7XG5cdFx0Zm9yICh2YXIgaT0wO2k8MztpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gTWF0aC5yb3VuZChjb2xvcltpXSpyZWZsZWN0aXZpdHkpO1xuXHRcdFx0ZW1pc3Npb25baV0gPSBwYXJ0O1xuXHRcdFx0aW50ZW5zaXR5ICs9IHBhcnQ7XG5cdFx0fVxuXHRcdGlmIChpbnRlbnNpdHkgPiB0aGlzLl9vcHRpb25zLmVtaXNzaW9uVGhyZXNob2xkKSB7IHJlc3VsdFtrZXldID0gZW1pc3Npb247IH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBvbmUgaXRlcmF0aW9uIGZyb20gb25lIGNlbGxcbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBsaXRDZWxscyBDZWxsIGRhdGEgdG8gYnkgdXBkYXRlZFxuICovXG5ST1QuTGlnaHRpbmcucHJvdG90eXBlLl9lbWl0TGlnaHRGcm9tQ2VsbCA9IGZ1bmN0aW9uKHgsIHksIGNvbG9yLCBsaXRDZWxscykge1xuXHR2YXIga2V5ID0geCtcIixcIit5O1xuXHRpZiAoa2V5IGluIHRoaXMuX2ZvdkNhY2hlKSB7XG5cdFx0dmFyIGZvdiA9IHRoaXMuX2ZvdkNhY2hlW2tleV07XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGZvdiA9IHRoaXMuX3VwZGF0ZUZPVih4LCB5KTtcblx0fVxuXG5cdGZvciAodmFyIGZvdktleSBpbiBmb3YpIHtcblx0XHR2YXIgZm9ybUZhY3RvciA9IGZvdltmb3ZLZXldO1xuXG5cdFx0aWYgKGZvdktleSBpbiBsaXRDZWxscykgeyAvKiBhbHJlYWR5IGxpdCAqL1xuXHRcdFx0dmFyIHJlc3VsdCA9IGxpdENlbGxzW2ZvdktleV07XG5cdFx0fSBlbHNlIHsgLyogbmV3bHkgbGl0ICovXG5cdFx0XHR2YXIgcmVzdWx0ID0gWzAsIDAsIDBdO1xuXHRcdFx0bGl0Q2VsbHNbZm92S2V5XSA9IHJlc3VsdDtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpPTA7aTwzO2krKykgeyByZXN1bHRbaV0gKz0gTWF0aC5yb3VuZChjb2xvcltpXSpmb3JtRmFjdG9yKTsgfSAvKiBhZGQgbGlnaHQgY29sb3IgKi9cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENvbXB1dGUgRk9WIChcImZvcm0gZmFjdG9yXCIpIGZvciBhIHBvdGVudGlhbCBsaWdodCBzb3VyY2UgYXQgW3gseV1cbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuUk9ULkxpZ2h0aW5nLnByb3RvdHlwZS5fdXBkYXRlRk9WID0gZnVuY3Rpb24oeCwgeSkge1xuXHR2YXIga2V5MSA9IHgrXCIsXCIreTtcblx0dmFyIGNhY2hlID0ge307XG5cdHRoaXMuX2ZvdkNhY2hlW2tleTFdID0gY2FjaGU7XG5cdHZhciByYW5nZSA9IHRoaXMuX29wdGlvbnMucmFuZ2U7XG5cdHZhciBjYiA9IGZ1bmN0aW9uKHgsIHksIHIsIHZpcykge1xuXHRcdHZhciBrZXkyID0geCtcIixcIit5O1xuXHRcdHZhciBmb3JtRmFjdG9yID0gdmlzICogKDEtci9yYW5nZSk7XG5cdFx0aWYgKGZvcm1GYWN0b3IgPT0gMCkgeyByZXR1cm47IH1cblx0XHRjYWNoZVtrZXkyXSA9IGZvcm1GYWN0b3I7XG5cdH1cblx0dGhpcy5fZm92LmNvbXB1dGUoeCwgeSwgcmFuZ2UsIGNiLmJpbmQodGhpcykpO1xuXG5cdHJldHVybiBjYWNoZTtcbn1cbi8qKlxuICogQGNsYXNzIEFic3RyYWN0IHBhdGhmaW5kZXJcbiAqIEBwYXJhbSB7aW50fSB0b1ggVGFyZ2V0IFggY29vcmRcbiAqIEBwYXJhbSB7aW50fSB0b1kgVGFyZ2V0IFkgY29vcmRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHBhc3NhYmxlQ2FsbGJhY2sgQ2FsbGJhY2sgdG8gZGV0ZXJtaW5lIG1hcCBwYXNzYWJpbGl0eVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnRvcG9sb2d5PThdXG4gKi9cblJPVC5QYXRoID0gZnVuY3Rpb24odG9YLCB0b1ksIHBhc3NhYmxlQ2FsbGJhY2ssIG9wdGlvbnMpIHtcblx0dGhpcy5fdG9YID0gdG9YO1xuXHR0aGlzLl90b1kgPSB0b1k7XG5cdHRoaXMuX2Zyb21YID0gbnVsbDtcblx0dGhpcy5fZnJvbVkgPSBudWxsO1xuXHR0aGlzLl9wYXNzYWJsZUNhbGxiYWNrID0gcGFzc2FibGVDYWxsYmFjaztcblx0dGhpcy5fb3B0aW9ucyA9IHtcblx0XHR0b3BvbG9neTogOFxuXHR9XG5cdGZvciAodmFyIHAgaW4gb3B0aW9ucykgeyB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsgfVxuXG5cdHRoaXMuX2RpcnMgPSBST1QuRElSU1t0aGlzLl9vcHRpb25zLnRvcG9sb2d5XTtcblx0aWYgKHRoaXMuX29wdGlvbnMudG9wb2xvZ3kgPT0gOCkgeyAvKiByZW9yZGVyIGRpcnMgZm9yIG1vcmUgYWVzdGhldGljIHJlc3VsdCAodmVydGljYWwvaG9yaXpvbnRhbCBmaXJzdCkgKi9cblx0XHR0aGlzLl9kaXJzID0gW1xuXHRcdFx0dGhpcy5fZGlyc1swXSxcblx0XHRcdHRoaXMuX2RpcnNbMl0sXG5cdFx0XHR0aGlzLl9kaXJzWzRdLFxuXHRcdFx0dGhpcy5fZGlyc1s2XSxcblx0XHRcdHRoaXMuX2RpcnNbMV0sXG5cdFx0XHR0aGlzLl9kaXJzWzNdLFxuXHRcdFx0dGhpcy5fZGlyc1s1XSxcblx0XHRcdHRoaXMuX2RpcnNbN11cblx0XHRdXG5cdH1cbn1cblxuLyoqXG4gKiBDb21wdXRlIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gcG9pbnRcbiAqIEBwYXJhbSB7aW50fSBmcm9tWFxuICogQHBhcmFtIHtpbnR9IGZyb21ZXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBXaWxsIGJlIGNhbGxlZCBmb3IgZXZlcnkgcGF0aCBpdGVtIHdpdGggYXJndW1lbnRzIFwieFwiIGFuZCBcInlcIlxuICovXG5ST1QuUGF0aC5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKGZyb21YLCBmcm9tWSwgY2FsbGJhY2spIHtcbn1cblxuUk9ULlBhdGgucHJvdG90eXBlLl9nZXROZWlnaGJvcnMgPSBmdW5jdGlvbihjeCwgY3kpIHtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHRmb3IgKHZhciBpPTA7aTx0aGlzLl9kaXJzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgZGlyID0gdGhpcy5fZGlyc1tpXTtcblx0XHR2YXIgeCA9IGN4ICsgZGlyWzBdO1xuXHRcdHZhciB5ID0gY3kgKyBkaXJbMV07XG5cdFx0XG5cdFx0aWYgKCF0aGlzLl9wYXNzYWJsZUNhbGxiYWNrKHgsIHkpKSB7IGNvbnRpbnVlOyB9XG5cdFx0cmVzdWx0LnB1c2goW3gsIHldKTtcblx0fVxuXHRcblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQGNsYXNzIFNpbXBsaWZpZWQgRGlqa3N0cmEncyBhbGdvcml0aG06IGFsbCBlZGdlcyBoYXZlIGEgdmFsdWUgb2YgMVxuICogQGF1Z21lbnRzIFJPVC5QYXRoXG4gKiBAc2VlIFJPVC5QYXRoXG4gKi9cblJPVC5QYXRoLkRpamtzdHJhID0gZnVuY3Rpb24odG9YLCB0b1ksIHBhc3NhYmxlQ2FsbGJhY2ssIG9wdGlvbnMpIHtcblx0Uk9ULlBhdGguY2FsbCh0aGlzLCB0b1gsIHRvWSwgcGFzc2FibGVDYWxsYmFjaywgb3B0aW9ucyk7XG5cblx0dGhpcy5fY29tcHV0ZWQgPSB7fTtcblx0dGhpcy5fdG9kbyA9IFtdO1xuXHR0aGlzLl9hZGQodG9YLCB0b1ksIG51bGwpO1xufVxuUk9ULlBhdGguRGlqa3N0cmEuZXh0ZW5kKFJPVC5QYXRoKTtcblxuLyoqXG4gKiBDb21wdXRlIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gcG9pbnRcbiAqIEBzZWUgUk9ULlBhdGgjY29tcHV0ZVxuICovXG5ST1QuUGF0aC5EaWprc3RyYS5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKGZyb21YLCBmcm9tWSwgY2FsbGJhY2spIHtcblx0dmFyIGtleSA9IGZyb21YK1wiLFwiK2Zyb21ZO1xuXHRpZiAoIShrZXkgaW4gdGhpcy5fY29tcHV0ZWQpKSB7IHRoaXMuX2NvbXB1dGUoZnJvbVgsIGZyb21ZKTsgfVxuXHRpZiAoIShrZXkgaW4gdGhpcy5fY29tcHV0ZWQpKSB7IHJldHVybjsgfVxuXHRcblx0dmFyIGl0ZW0gPSB0aGlzLl9jb21wdXRlZFtrZXldO1xuXHR3aGlsZSAoaXRlbSkge1xuXHRcdGNhbGxiYWNrKGl0ZW0ueCwgaXRlbS55KTtcblx0XHRpdGVtID0gaXRlbS5wcmV2O1xuXHR9XG59XG5cbi8qKlxuICogQ29tcHV0ZSBhIG5vbi1jYWNoZWQgdmFsdWVcbiAqL1xuUk9ULlBhdGguRGlqa3N0cmEucHJvdG90eXBlLl9jb21wdXRlID0gZnVuY3Rpb24oZnJvbVgsIGZyb21ZKSB7XG5cdHdoaWxlICh0aGlzLl90b2RvLmxlbmd0aCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fdG9kby5zaGlmdCgpO1xuXHRcdGlmIChpdGVtLnggPT0gZnJvbVggJiYgaXRlbS55ID09IGZyb21ZKSB7IHJldHVybjsgfVxuXHRcdFxuXHRcdHZhciBuZWlnaGJvcnMgPSB0aGlzLl9nZXROZWlnaGJvcnMoaXRlbS54LCBpdGVtLnkpO1xuXHRcdFxuXHRcdGZvciAodmFyIGk9MDtpPG5laWdoYm9ycy5sZW5ndGg7aSsrKSB7XG5cdFx0XHR2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG5cdFx0XHR2YXIgeCA9IG5laWdoYm9yWzBdO1xuXHRcdFx0dmFyIHkgPSBuZWlnaGJvclsxXTtcblx0XHRcdHZhciBpZCA9IHgrXCIsXCIreTtcblx0XHRcdGlmIChpZCBpbiB0aGlzLl9jb21wdXRlZCkgeyBjb250aW51ZTsgfSAvKiBhbHJlYWR5IGRvbmUgKi9cdFxuXHRcdFx0dGhpcy5fYWRkKHgsIHksIGl0ZW0pOyBcblx0XHR9XG5cdH1cbn1cblxuUk9ULlBhdGguRGlqa3N0cmEucHJvdG90eXBlLl9hZGQgPSBmdW5jdGlvbih4LCB5LCBwcmV2KSB7XG5cdHZhciBvYmogPSB7XG5cdFx0eDogeCxcblx0XHR5OiB5LFxuXHRcdHByZXY6IHByZXZcblx0fVxuXHR0aGlzLl9jb21wdXRlZFt4K1wiLFwiK3ldID0gb2JqO1xuXHR0aGlzLl90b2RvLnB1c2gob2JqKTtcbn1cbi8qKlxuICogQGNsYXNzIFNpbXBsaWZpZWQgQSogYWxnb3JpdGhtOiBhbGwgZWRnZXMgaGF2ZSBhIHZhbHVlIG9mIDFcbiAqIEBhdWdtZW50cyBST1QuUGF0aFxuICogQHNlZSBST1QuUGF0aFxuICovXG5ST1QuUGF0aC5BU3RhciA9IGZ1bmN0aW9uKHRvWCwgdG9ZLCBwYXNzYWJsZUNhbGxiYWNrLCBvcHRpb25zKSB7XG5cdFJPVC5QYXRoLmNhbGwodGhpcywgdG9YLCB0b1ksIHBhc3NhYmxlQ2FsbGJhY2ssIG9wdGlvbnMpO1xuXG5cdHRoaXMuX3RvZG8gPSBbXTtcblx0dGhpcy5fZG9uZSA9IHt9O1xuXHR0aGlzLl9mcm9tWCA9IG51bGw7XG5cdHRoaXMuX2Zyb21ZID0gbnVsbDtcbn1cblJPVC5QYXRoLkFTdGFyLmV4dGVuZChST1QuUGF0aCk7XG5cbi8qKlxuICogQ29tcHV0ZSBhIHBhdGggZnJvbSBhIGdpdmVuIHBvaW50XG4gKiBAc2VlIFJPVC5QYXRoI2NvbXB1dGVcbiAqL1xuUk9ULlBhdGguQVN0YXIucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbihmcm9tWCwgZnJvbVksIGNhbGxiYWNrKSB7XG5cdHRoaXMuX3RvZG8gPSBbXTtcblx0dGhpcy5fZG9uZSA9IHt9O1xuXHR0aGlzLl9mcm9tWCA9IGZyb21YO1xuXHR0aGlzLl9mcm9tWSA9IGZyb21ZO1xuXHR0aGlzLl9hZGQodGhpcy5fdG9YLCB0aGlzLl90b1ksIG51bGwpO1xuXG5cdHdoaWxlICh0aGlzLl90b2RvLmxlbmd0aCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fdG9kby5zaGlmdCgpO1xuXHRcdGlmIChpdGVtLnggPT0gZnJvbVggJiYgaXRlbS55ID09IGZyb21ZKSB7IGJyZWFrOyB9XG5cdFx0dmFyIG5laWdoYm9ycyA9IHRoaXMuX2dldE5laWdoYm9ycyhpdGVtLngsIGl0ZW0ueSk7XG5cblx0XHRmb3IgKHZhciBpPTA7aTxuZWlnaGJvcnMubGVuZ3RoO2krKykge1xuXHRcdFx0dmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXHRcdFx0dmFyIHggPSBuZWlnaGJvclswXTtcblx0XHRcdHZhciB5ID0gbmVpZ2hib3JbMV07XG5cdFx0XHR2YXIgaWQgPSB4K1wiLFwiK3k7XG5cdFx0XHRpZiAoaWQgaW4gdGhpcy5fZG9uZSkgeyBjb250aW51ZTsgfVxuXHRcdFx0dGhpcy5fYWRkKHgsIHksIGl0ZW0pOyBcblx0XHR9XG5cdH1cblx0XG5cdHZhciBpdGVtID0gdGhpcy5fZG9uZVtmcm9tWCtcIixcIitmcm9tWV07XG5cdGlmICghaXRlbSkgeyByZXR1cm47IH1cblx0XG5cdHdoaWxlIChpdGVtKSB7XG5cdFx0Y2FsbGJhY2soaXRlbS54LCBpdGVtLnkpO1xuXHRcdGl0ZW0gPSBpdGVtLnByZXY7XG5cdH1cbn1cblxuUk9ULlBhdGguQVN0YXIucHJvdG90eXBlLl9hZGQgPSBmdW5jdGlvbih4LCB5LCBwcmV2KSB7XG5cdHZhciBvYmogPSB7XG5cdFx0eDogeCxcblx0XHR5OiB5LFxuXHRcdHByZXY6IHByZXYsXG5cdFx0ZzogKHByZXYgPyBwcmV2LmcrMSA6IDApLFxuXHRcdGg6IHRoaXMuX2Rpc3RhbmNlKHgsIHkpXG5cdH1cblx0dGhpcy5fZG9uZVt4K1wiLFwiK3ldID0gb2JqO1xuXHRcblx0LyogaW5zZXJ0IGludG8gcHJpb3JpdHkgcXVldWUgKi9cblx0XG5cdHZhciBmID0gb2JqLmcgKyBvYmouaDtcblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fdG9kby5sZW5ndGg7aSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLl90b2RvW2ldO1xuXHRcdGlmIChmIDwgaXRlbS5nICsgaXRlbS5oKSB7XG5cdFx0XHR0aGlzLl90b2RvLnNwbGljZShpLCAwLCBvYmopO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXHRcblx0dGhpcy5fdG9kby5wdXNoKG9iaik7XG59XG5cblJPVC5QYXRoLkFTdGFyLnByb3RvdHlwZS5fZGlzdGFuY2UgPSBmdW5jdGlvbih4LCB5KSB7XG5cdHN3aXRjaCAodGhpcy5fb3B0aW9ucy50b3BvbG9neSkge1xuXHRcdGNhc2UgNDpcblx0XHRcdHJldHVybiAoTWF0aC5hYnMoeC10aGlzLl9mcm9tWCkgKyBNYXRoLmFicyh5LXRoaXMuX2Zyb21ZKSk7XG5cdFx0YnJlYWs7XG5cblx0XHRjYXNlIDY6XG5cdFx0XHR2YXIgZHggPSBNYXRoLmFicyh4IC0gdGhpcy5fZnJvbVgpO1xuXHRcdFx0dmFyIGR5ID0gTWF0aC5hYnMoeSAtIHRoaXMuX2Zyb21ZKTtcblx0XHRcdHJldHVybiBkeSArIE1hdGgubWF4KDAsIChkeC1keSkvMik7XG5cdFx0YnJlYWs7XG5cblx0XHRjYXNlIDg6IFxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKHgtdGhpcy5fZnJvbVgpLCBNYXRoLmFicyh5LXRoaXMuX2Zyb21ZKSk7XG5cdFx0YnJlYWs7XG5cdH1cbn1cbi8qKlxuICogQGNsYXNzIFRlcm1pbmFsIGJhY2tlbmRcbiAqIEBwcml2YXRlXG4gKi9cblJPVC5EaXNwbGF5LlRlcm0gPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFJPVC5EaXNwbGF5LkJhY2tlbmQuY2FsbCh0aGlzLCBjb250ZXh0KTtcblx0dGhpcy5fY3ggPSAtMTtcblx0dGhpcy5fY3kgPSAtMTtcblx0dGhpcy5fbGFzdENvbG9yID0gXCJcIjtcblx0dGhpcy5fb3B0aW9ucyA9IHt9O1xuXHR0aGlzLl9veCA9IDA7XG5cdHRoaXMuX295ID0gMDtcblx0dGhpcy5fdGVybWNvbG9yID0ge307XG59XG5ST1QuRGlzcGxheS5UZXJtLmV4dGVuZChST1QuRGlzcGxheS5CYWNrZW5kKTtcblxuUk9ULkRpc3BsYXkuVGVybS5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0dGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cdHRoaXMuX294ID0gTWF0aC5mbG9vcigocHJvY2Vzcy5zdGRvdXQuY29sdW1ucyAtIG9wdGlvbnMud2lkdGgpIC8gMik7XG5cdHRoaXMuX295ID0gTWF0aC5mbG9vcigocHJvY2Vzcy5zdGRvdXQucm93cyAtIG9wdGlvbnMuaGVpZ2h0KSAvIDIpO1xuXHR0aGlzLl90ZXJtY29sb3IgPSBuZXcgUk9ULkRpc3BsYXkuVGVybVtvcHRpb25zLnRlcm1Db2xvci5jYXBpdGFsaXplKCldKHRoaXMuX2NvbnRleHQpO1xuXHR0aGlzLl9jb250ZXh0Ll90ZXJtY29sb3IgPSB0aGlzLl90ZXJtY29sb3I7XG59XG5cblJPVC5EaXNwbGF5LlRlcm0ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihkYXRhLCBjbGVhckJlZm9yZSkge1xuXHQvLyBkZXRlcm1pbmUgd2hlcmUgdG8gZHJhdyB3aGF0IHdpdGggd2hhdCBjb2xvcnNcblx0dmFyIHggPSBkYXRhWzBdO1xuXHR2YXIgeSA9IGRhdGFbMV07XG5cdHZhciBjaCA9IGRhdGFbMl07XG5cdHZhciBmZyA9IGRhdGFbM107XG5cdHZhciBiZyA9IGRhdGFbNF07XG5cblx0Ly8gZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gbW92ZSB0aGUgdGVybWluYWwgY3Vyc29yXG5cdHZhciBkeCA9IHRoaXMuX294ICsgeDtcblx0dmFyIGR5ID0gdGhpcy5fb3kgKyB5O1xuXHRpZiAoZHggPCAwIHx8IGR4ID49IHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnMpIHsgcmV0dXJuOyB9XG5cdGlmIChkeSA8IDAgfHwgZHkgPj0gcHJvY2Vzcy5zdGRvdXQucm93cykgeyByZXR1cm47IH1cblx0aWYgKGR4ICE9PSB0aGlzLl9jeCB8fCBkeSAhPT0gdGhpcy5fY3kpIHtcblx0XHRwcm9jZXNzLnN0ZG91dC53cml0ZSh0aGlzLl90ZXJtY29sb3IucG9zaXRpb25Ub0Fuc2koZHgsZHkpKTtcblx0XHR0aGlzLl9jeCA9IGR4O1xuXHRcdHRoaXMuX2N5ID0gZHk7XG5cdH1cblxuXHQvLyB0ZXJtaW5hbHMgYXV0b21hdGljYWxseSBjbGVhciwgYnV0IGlmIHdlJ3JlIGNsZWFyaW5nIHdoZW4gd2UncmVcblx0Ly8gbm90IG90aGVyd2lzZSBwcm92aWRlZCB3aXRoIGEgY2hhcmFjdGVyLCBqdXN0IHVzZSBhIHNwYWNlIGluc3RlYWRcblx0aWYgKGNsZWFyQmVmb3JlKSB7XG5cdFx0aWYgKCFjaCkge1xuXHRcdFx0Y2ggPSBcIiBcIjtcblx0XHR9XG5cdH1cblx0XHRcblx0Ly8gaWYgd2UncmUgbm90IGNsZWFyaW5nIGFuZCBub3QgcHJvdmlkZWQgd2l0aCBhIGNoYXJhY3RlciwgZG8gbm90aGluZ1xuXHRpZiAoIWNoKSB7IHJldHVybjsgfVxuXG5cdC8vIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIGNoYW5nZSBjb2xvcnNcblx0dmFyIG5ld0NvbG9yID0gdGhpcy5fdGVybWNvbG9yLmNvbG9yVG9BbnNpKGZnLGJnKTtcblx0aWYgKG5ld0NvbG9yICE9PSB0aGlzLl9sYXN0Q29sb3IpIHtcblx0XHRwcm9jZXNzLnN0ZG91dC53cml0ZShuZXdDb2xvcik7XG5cdFx0dGhpcy5fbGFzdENvbG9yID0gbmV3Q29sb3I7XG5cdH1cblxuXHQvLyB3cml0ZSB0aGUgcHJvdmlkZWQgc3ltYm9sIHRvIHRoZSBkaXNwbGF5XG5cdHZhciBjaGFycyA9IFtdLmNvbmNhdChjaCk7XG5cdHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNoYXJzWzBdKTtcblxuXHQvLyB1cGRhdGUgb3VyIHBvc2l0aW9uLCBnaXZlbiB0aGF0IHdlIHdyb3RlIGEgY2hhcmFjdGVyXG5cdHRoaXMuX2N4Kys7XG5cdGlmICh0aGlzLl9jeCA+PSBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zKSB7XG5cdFx0dGhpcy5fY3ggPSAwO1xuXHRcdHRoaXMuX2N5Kys7XG5cdH1cbn1cblxuUk9ULkRpc3BsYXkuVGVybS5wcm90b3R5cGUuY29tcHV0ZVNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkge1xuXHRyZXR1cm4gW3Byb2Nlc3Muc3Rkb3V0LmNvbHVtbnMsIHByb2Nlc3Muc3Rkb3V0LnJvd3NdO1xufVxuXG5ST1QuRGlzcGxheS5UZXJtLnByb3RvdHlwZS5jb21wdXRlRm9udFNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkge1xuXHRyZXR1cm4gMTI7XG59XG5cblJPVC5EaXNwbGF5LlRlcm0ucHJvdG90eXBlLmV2ZW50VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0cmV0dXJuIFt4LHldXG59XG4vKipcbiAqIEBjbGFzcyBBYnN0cmFjdCB0ZXJtaW5hbCBjb2RlIG1vZHVsZVxuICogQHByaXZhdGVcbiAqL1xuUk9ULkRpc3BsYXkuVGVybS5Db2xvciA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0dGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblJPVC5EaXNwbGF5LlRlcm0uQ29sb3IucHJvdG90eXBlLmNsZWFyVG9BbnNpID0gZnVuY3Rpb24oYmcpIHtcbn1cblxuUk9ULkRpc3BsYXkuVGVybS5Db2xvci5wcm90b3R5cGUuY29sb3JUb0Fuc2kgPSBmdW5jdGlvbihmZywgYmcpIHtcbn1cblxuUk9ULkRpc3BsYXkuVGVybS5Db2xvci5wcm90b3R5cGUucG9zaXRpb25Ub0Fuc2kgPSBmdW5jdGlvbih4LCB5KSB7XG59XG4vKipcbiAqIEBjbGFzcyB4dGVybSB0ZXJtaW5hbCBjb2RlIG1vZHVsZVxuICogQHByaXZhdGVcbiAqL1xuUk9ULkRpc3BsYXkuVGVybS5YdGVybSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0Uk9ULkRpc3BsYXkuVGVybS5Db2xvci5jYWxsKHRoaXMsIGNvbnRleHQpO1xufVxuUk9ULkRpc3BsYXkuVGVybS5YdGVybS5leHRlbmQoUk9ULkRpc3BsYXkuVGVybS5Db2xvcik7XG5cblJPVC5EaXNwbGF5LlRlcm0uWHRlcm0ucHJvdG90eXBlLmNsZWFyVG9BbnNpID0gZnVuY3Rpb24oYmcpIHtcblx0cmV0dXJuIFwiXFx4MWJbMDs0ODs1O1wiXG5cdFx0KyB0aGlzLl90ZXJtY29sb3IoYmcpXG5cdFx0KyBcIm1cXHgxYlsySlwiO1xufVxuXG5ST1QuRGlzcGxheS5UZXJtLlh0ZXJtLnByb3RvdHlwZS5jb2xvclRvQW5zaSA9IGZ1bmN0aW9uKGZnLCBiZykge1xuXHRyZXR1cm4gXCJcXHgxYlswOzM4OzU7XCJcblx0XHQrIHRoaXMuX3Rlcm1jb2xvcihmZylcblx0XHQrIFwiOzQ4OzU7XCJcblx0XHQrIHRoaXMuX3Rlcm1jb2xvcihiZylcblx0XHQrIFwibVwiO1xufVxuXG5ST1QuRGlzcGxheS5UZXJtLlh0ZXJtLnByb3RvdHlwZS5wb3NpdGlvblRvQW5zaSA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0cmV0dXJuIFwiXFx4MWJbXCIgKyAoeSsxKSArIFwiO1wiICsgKHgrMSkgKyBcIkhcIjtcbn1cblxuUk9ULkRpc3BsYXkuVGVybS5YdGVybS5wcm90b3R5cGUuX3Rlcm1jb2xvciA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdHZhciBTUkNfQ09MT1JTID0gMjU2LjA7XG5cdHZhciBEU1RfQ09MT1JTID0gNi4wO1xuXHR2YXIgQ09MT1JfUkFUSU8gPSBEU1RfQ09MT1JTIC8gU1JDX0NPTE9SUztcblx0dmFyIHJnYiA9IFJPVC5Db2xvci5mcm9tU3RyaW5nKGNvbG9yKTtcblx0dmFyIHIgPSBNYXRoLmZsb29yKHJnYlswXSAqIENPTE9SX1JBVElPKTtcblx0dmFyIGcgPSBNYXRoLmZsb29yKHJnYlsxXSAqIENPTE9SX1JBVElPKTtcblx0dmFyIGIgPSBNYXRoLmZsb29yKHJnYlsyXSAqIENPTE9SX1JBVElPKTtcblx0cmV0dXJuIHIqMzYgKyBnKjYgKyBiKjEgKyAxNjtcbn1cbi8qKlxuICogRXhwb3J0IHRvIE5vZGUuanMgbW9kdWxlXG4gKi9cbmZvciAodmFyIHAgaW4gUk9UKSB7XG5cdGV4cG9ydHNbcF0gPSBST1RbcF07XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJcbmltcG9ydCBtb2R1bGUgZnJvbSAnLi4vbW9kdWxlJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vcm9ndWUvaW5pdC9nYW1lc3RhdGUnO1xuXG5tb2R1bGUuY29udHJvbGxlcignRHVuZ2VvbicsICgkc2NvcGUpID0+IHtcblxuICAkc2NvcGUuY3VycmVudEZsb29yID0gMDtcblxuICBHYW1lU3RhdGUub24oJ3N0YXJ0JywgKCkgPT4ge1xuICAgICRzY29wZS53b3JsZCA9IEdhbWVTdGF0ZS53b3JsZDtcbiAgICAkc2NvcGUudmljdG9yeSA9IEdhbWVTdGF0ZS53aW5Db25kaXRpb247XG4gICAgJHNjb3BlLmN1cnJlbnRGbG9vciA9IEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3I7XG4gIH0pO1xuXG4gIEdhbWVTdGF0ZS5vbignZGVzY2VuZCcsICgpID0+IHtcbiAgICAkc2NvcGUuY3VycmVudEZsb29yID0gR2FtZVN0YXRlLmN1cnJlbnRGbG9vcjtcbiAgfSk7XG5cbn0pO1xuIiwiXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL3JvZ3VlL2xpYi9sb2dnZXInO1xuXG5pbXBvcnQgbW9kdWxlIGZyb20gJy4uL21vZHVsZSc7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uLy4uL3JvZ3VlL2luaXQvZ2FtZXN0YXRlJztcblxuaW1wb3J0IHsgTWVzc2FnZVR5cGVzIH0gZnJvbSAnLi4vLi4vcm9ndWUvZGlzcGxheS9tZXNzYWdlLWhhbmRsZXInO1xuXG5tb2R1bGUuY29udHJvbGxlcignTG9nJywgKCRzY29wZSwgJGxvY2FsU3RvcmFnZSkgPT4ge1xuXG4gICRsb2NhbFN0b3JhZ2UuZmlsdGVycyA9ICRsb2NhbFN0b3JhZ2UuZmlsdGVycyB8fCB7XG4gICAgTWV0YTogdHJ1ZSxcbiAgICBJdGVtOiB0cnVlLFxuICAgIENvbWJhdDogdHJ1ZSxcbiAgICBEdW5nZW9uOiB0cnVlXG4gIH07XG5cbiAgJGxvY2FsU3RvcmFnZS5kZWF0aExvZyA9ICRsb2NhbFN0b3JhZ2UuZGVhdGhMb2cgfHwgW107XG5cbiAgJHNjb3BlLmZpbHRlcnMgPSAkbG9jYWxTdG9yYWdlLmZpbHRlcnM7XG4gICRzY29wZS5kZWF0aExvZyA9ICRsb2NhbFN0b3JhZ2UuZGVhdGhMb2c7XG5cbiAgJHNjb3BlLmxvZyA9IFtdO1xuXG4gIGNvbnN0IGFkZE1lc3NhZ2UgPSAobXNnT2JqKSA9PiB7XG4gICAgaWYoIW1zZ09iai50eXBlKSB7XG4gICAgICBMb2coJ0dhbWVMb2cnLCBgTWVzc2FnZSBcIiR7bXNnT2JqLm1lc3NhZ2V9XCIgaGFzIG5vIHR5cGVgKTtcbiAgICB9XG5cbiAgICAkc2NvcGUubG9nLnB1c2gobXNnT2JqKTtcblxuICAgIGlmKCRzY29wZS5sb2cubGVuZ3RoID4gMTAwKSB7XG4gICAgICAkc2NvcGUubG9nLnNoaWZ0KCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFkZE1ldGFNZXNzYWdlID0gKG1zZykgPT4ge1xuICAgIGFkZE1lc3NhZ2UoeyBtZXNzYWdlOiBtc2csIHR5cGU6IE1lc3NhZ2VUeXBlcy5NRVRBLCB0dXJuOiAkc2NvcGUubG9nWyRzY29wZS5sb2cubGVuZ3RoLTFdLnR1cm4rMSB9KTtcbiAgfTtcblxuICBHYW1lU3RhdGUub24oJ2dhbWVlbmQudmljdG9yeScsICgpID0+IHtcbiAgICBhZGRNZXRhTWVzc2FnZSgnWW91IHdpbiEnKTtcbiAgICBhZGRNZXRhTWVzc2FnZShgWW91IGVhcm5lZCAke0dhbWVTdGF0ZS5zcEVhcm5lZH0gU1AsICR7R2FtZVN0YXRlLmtwRWFybmVkfSBLUCwgYW5kICR7R2FtZVN0YXRlLnZwRWFybmVkfSBWUC5gKTtcbiAgfSk7XG5cbiAgR2FtZVN0YXRlLm9uKCdnYW1lZW5kLmdhbWVvdmVyJywgKCkgPT4ge1xuICAgIGFkZE1ldGFNZXNzYWdlKCdHYW1lIG92ZXIhIEV2ZXJ5b25lIGRpZWQuJyk7XG4gICAgYWRkTWV0YU1lc3NhZ2UoYFlvdSBlYXJuZWQgJHtHYW1lU3RhdGUuc3BFYXJuZWR9IFNQIGFuZCAke0dhbWVTdGF0ZS5rcEVhcm5lZH0gS1AuYCk7XG4gIH0pO1xuXG4gIEdhbWVTdGF0ZS5vbignbG9nJywgKGxvZ09iaikgPT4ge1xuICAgIGFkZE1lc3NhZ2UobG9nT2JqKTtcbiAgfSk7XG5cbiAgR2FtZVN0YXRlLm9uKCdkaWUnLCBwbGF5ZXIgPT4ge1xuICAgICRzY29wZS5kZWF0aExvZy51bnNoaWZ0KHtcbiAgICAgIG5hbWU6IHBsYXllci5uYW1lLFxuICAgICAgbGV2ZWw6IHBsYXllci5sZXZlbCxcbiAgICAgIGFsaWduOiBwbGF5ZXIuZ2V0QWxpZ24oKSxcbiAgICAgIGdlbmRlcjogcGxheWVyLmdlbmRlcixcbiAgICAgIHRpdGxlOiBwbGF5ZXIucHJvZmVzc2lvbkluc3QudGl0bGUsXG4gICAgICByYWNlOiBwbGF5ZXIucmFjZSxcbiAgICAgIHByb2Zlc3Npb246IHBsYXllci5wcm9mZXNzaW9uLFxuICAgICAgZmxvb3I6IEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3IsXG4gICAgICBzcEVhcm5lZDogcGxheWVyLmdldFNjb3JlKCksXG4gICAgICBkZWF0aFRpbWU6IERhdGUubm93KClcbiAgICB9KTtcblxuICAgIGlmKCRzY29wZS5kZWF0aExvZy5sZW5ndGggPiAyNSkge1xuICAgICAgJHNjb3BlLmRlYXRoTG9nLnBvcCgpO1xuICAgIH1cbiAgfSk7XG59KTsiLCJpbXBvcnQgbW9kdWxlIGZyb20gJy4uL21vZHVsZSc7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uLy4uL3JvZ3VlL2luaXQvZ2FtZXN0YXRlJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbm1vZHVsZS5jb250cm9sbGVyKCdPcHRpb25zJywgKCRzY29wZSkgPT4ge1xuXG4gICRzY29wZS5zZXBwdWt1ID0gKCkgPT4ge1xuICAgIF8uZWFjaChHYW1lU3RhdGUucGxheWVycywgcCA9PiAge1xuICAgICAgaWYgKCFwLmhwLmF0TWluKCkpIHtcbiAgICAgICAgcC5kaWUoeyBuYW1lOidTZXBwdWt1JyB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAkc2NvcGUuZ2V0Q3VycmVudFNwS3AgPSAoKSA9PiB7XG4gICAgJHNjb3BlLnNwRWFybmVkID0gR2FtZVN0YXRlLnNwRWFybmVkO1xuICAgICRzY29wZS5rcEVhcm5lZCA9IEdhbWVTdGF0ZS5rcEVhcm5lZDtcbiAgfTtcblxufSk7XG4iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCBtb2R1bGUgZnJvbSAnLi4vbW9kdWxlJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vcm9ndWUvaW5pdC9nYW1lc3RhdGUnO1xuXG5tb2R1bGUuY29udHJvbGxlcignUGFydHknLCAoJHNjb3BlLCAkdWliTW9kYWwsICR0aW1lb3V0KSA9PiB7XG5cbiAgJHNjb3BlLmludmVudG9yeU9mZnNldCA9ICgpID0+IDYwICsgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncGxheWVyLWJsb2NrJylbMF0ub2Zmc2V0SGVpZ2h0O1xuXG4gICRzY29wZS5jb3VudFNsb3RzVGFrZW4gPSAoZXF1aXBtZW50KSA9PiBfLnJlZHVjZShlcXVpcG1lbnQsIChwcmV2LCBpdGVtKSA9PiBwcmV2ICsgaXRlbS5zbG90c1Rha2VuLCAwKTtcblxuICAkc2NvcGUub3BlbkVkaXRXaW5kb3cgPSAocGxheWVyLCBpbmRleCkgPT4ge1xuICAgICR1aWJNb2RhbC5vcGVuKHtcbiAgICAgIHRlbXBsYXRlVXJsOiAncGxheWVyLWVkaXQnLFxuICAgICAgY29udHJvbGxlcjogJ1BhcnR5TWVtYmVyRWRpdCcsXG4gICAgICBrZXlib2FyZDogZmFsc2UsXG4gICAgICBiYWNrZHJvcDogJ3N0YXRpYycsXG4gICAgICByZXNvbHZlOiB7IHBsYXllciwgaW5kZXggfVxuICAgIH0pO1xuICB9O1xuXG4gICRzY29wZS5pc0JlbG93ID0gKHBsYXllciwgc3RhdCwgdGhyZXNob2xkKSA9PiAocGxheWVyW3N0YXRdLmN1ci9wbGF5ZXJbc3RhdF0ubWF4KjEwMDx0aHJlc2hvbGQpO1xuICAkc2NvcGUuaXNBYm92ZSA9IChwbGF5ZXIsIHN0YXQsIHRocmVzaG9sZCkgPT4gKHBsYXllcltzdGF0XS5jdXIvcGxheWVyW3N0YXRdLm1heCoxMDA+dGhyZXNob2xkKTtcblxuICBHYW1lU3RhdGUub24oJ3JlZHJhdycsICgpID0+IHtcblxuICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnBsYXllcnMgPSBHYW1lU3RhdGUucGxheWVycztcbiAgICB9KTtcblxuICB9KTtcbn0pO1xuXG5tb2R1bGUuY29udHJvbGxlcignUGFydHlNZW1iZXJFZGl0JywgKCRzY29wZSwgJHVpYk1vZGFsSW5zdGFuY2UsIFRlbXBsYXRlRGF0YU1hbmFnZXIsIFVwZ3JhZGVEYXRhTWFuYWdlciwgcGxheWVyLCBpbmRleCkgPT4ge1xuICAkc2NvcGUuY2xvc2UgPSAkdWliTW9kYWxJbnN0YW5jZS5jbG9zZTtcblxuICBjb25zdCB1cGdyYWRlc0J5U3BsaXQgPSAoc3BsaXQsIGRlZmF1bHRWYWwgPSAnUmFuZG9tJykgPT4ge1xuICAgIHJldHVybiBbeyBrZXk6IGRlZmF1bHRWYWwsIHZhbDogdW5kZWZpbmVkIH1dLmNvbmNhdChfKFVwZ3JhZGVEYXRhTWFuYWdlci51cGdyYWRlcylcbiAgICAgIC5maWx0ZXIodSA9PiBfLmNvbnRhaW5zKHUsIHNwbGl0KSlcbiAgICAgIC5tYXAodSA9PiB1LnNwbGl0KHNwbGl0KVsxXS50cmltKCkpXG4gICAgICAubWFwKHUgPT4gKHsga2V5OiB1LCB2YWw6IHUgfSkpXG4gICAgICAudmFsdWUoKSk7XG4gIH07XG5cbiAgJHNjb3BlLnRlbXBsYXRlRGF0YU1hbmFnZXIgPSBUZW1wbGF0ZURhdGFNYW5hZ2VyO1xuICAkc2NvcGUudXBncmFkZURhdGFNYW5hZ2VyID0gVXBncmFkZURhdGFNYW5hZ2VyO1xuICAkc2NvcGUuaW5kZXggPSBpbmRleDtcbiAgJHNjb3BlLnBsYXllciA9IHBsYXllcjtcblxuICAkc2NvcGUuZ2VuZGVycyA9IFtcbiAgICB7IGtleTogJ1JhbmRvbScsIHZhbDogdW5kZWZpbmVkIH0sXG4gICAgeyBrZXk6ICdNYWxlJywgdmFsOiAnTWFsZScgfSxcbiAgICB7IGtleTogJ0ZlbWFsZScsIHZhbDogJ0ZlbWFsZScgfVxuICBdO1xuXG4gICRzY29wZS5hbGlnbnMgPSBbXG4gICAgeyBrZXk6ICdSYW5kb20nLCB2YWw6IHVuZGVmaW5lZCB9LFxuICAgIHsga2V5OiAnRXZpbGVyJywgdmFsOiAtMjAwIH0sXG4gICAgeyBrZXk6ICdFdmlsJywgdmFsOiAtMTAwIH0sXG4gICAgeyBrZXk6ICdOZXV0cmFsJywgdmFsOiAwIH0sXG4gICAgeyBrZXk6ICdHb29kJywgdmFsOiAxMDAgfSxcbiAgICB7IGtleTogJ0dvb2RlcicsIHZhbDogMjAwIH1cbiAgXTtcblxuICAkc2NvcGUucHJvZmVzc2lvbnMgPSB1cGdyYWRlc0J5U3BsaXQoJ0NsYXNzOicpO1xuXG4gICRzY29wZS5yYWNlcyA9IHVwZ3JhZGVzQnlTcGxpdCgnUmFjZTonKTtcblxuICAkc2NvcGUuY29sb3JzID0gW1xuICAgIHsga2V5OiAnRGVmYXVsdCcsIHZhbDogdW5kZWZpbmVkIH0sXG4gICAgeyBrZXk6ICdSZWQnLCB2YWw6ICcjZjAwJyB9LFxuICAgIHsga2V5OiAnQmx1ZScsIHZhbDogJyMwMGYnIH0sXG4gICAgeyBrZXk6ICdHcmVlbicsIHZhbDogJyMwZjAnIH0sXG4gICAgeyBrZXk6ICdZZWxsb3cnLCB2YWw6ICcjZmYwJyB9LFxuICAgIHsga2V5OiAnQ3lhbicsIHZhbDogJyMwZmYnIH0sXG4gICAgeyBrZXk6ICdNYWdlbnRhJywgdmFsOiAnI2YwZicgfVxuICBdO1xuXG4gICRzY29wZS5ncmVhdGVyID0gdXBncmFkZXNCeVNwbGl0KCdUcmFpdDogRy4nLCAnTm9uZScpO1xuICAkc2NvcGUubGVzc2VyID0gdXBncmFkZXNCeVNwbGl0KCdUcmFpdDogTC4nLCAnTm9uZScpO1xuICAkc2NvcGUudXRpbGl0eSA9IHVwZ3JhZGVzQnlTcGxpdCgnVHJhaXQ6IFUuJywgJ05vbmUnKTtcbiAgJHNjb3BlLmJ1ZmYgPSB1cGdyYWRlc0J5U3BsaXQoJ0J1ZmY6JywgJ05vbmUnKTtcblxuICAkc2NvcGUuYWlzID0gW1xuICAgIHsga2V5OiAnRXhwbG9yZSBEdW5nZW9uJywgdmFsOiB1bmRlZmluZWQgfSxcbiAgICB7IGtleTogJ1dhbmRlcicsIHZhbDogJ1dhbmRlcicgfVxuICBdO1xufSk7XG4iLCJcbmltcG9ydCBtb2R1bGUgZnJvbSAnLi4vbW9kdWxlJztcblxubW9kdWxlLmNvbnRyb2xsZXIoJ1Jvb3QnLCAoJHNjb3BlLCAkaHR0cCwgJGludGVydmFsLCAkd2luZG93KSA9PiB7XG5cbiAgLy8gZ2V0IHRoZSBjdXJyZW50IHZlcnNpb25cbiAgJGh0dHAuZ2V0KCd2ZXJzaW9uLmpzb24nKS50aGVuKHJlcyA9PiB7XG4gICAgJHNjb3BlLnRhZyA9IHJlcy5kYXRhLnRhZztcbiAgfSk7XG5cbiAgLy8gdGl0bGUgaXMgZWl0aGVyIHRoZSBnYW1lIG5hbWUgb3Igd2l0aCB0aGUgdmVyc2lvbiB0YWcgaWYgYXZhaWxhYmxlXG4gICRzY29wZS50aXRsZSA9ICgpID0+IHtcbiAgICBpZigkc2NvcGUudGFnKSB7XG4gICAgICByZXR1cm4gYFJvZ3VhdGhpYSB2JHskc2NvcGUudGFnfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuICdSb2d1YXRoaWEnO1xuICB9O1xuXG4gICRzY29wZS5yZWxvYWQgPSAoKSA9PiAkd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuXG4gIC8vIGNoZWNrIGZvciBhbiB1cGRhdGUgZXZlcnkgMTAgbWludXRlc1xuICAkaW50ZXJ2YWwoKCkgPT4ge1xuICAgICRodHRwLmdldCgnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy9zZWl5cmlhL1JvZ3VhdGhpYS90YWdzJykudGhlbihyZXMgPT4ge1xuICAgICAgJHNjb3BlLmxhdGVzdFRhZyA9IHJlcy5kYXRhID8gcmVzLmRhdGFbMF0ubmFtZSA6IG51bGw7XG4gICAgICAkc2NvcGUudXBkYXRlQXZhaWxhYmxlID0gJHNjb3BlLnRhZyAhPSAkc2NvcGUubGF0ZXN0VGFnO1xuICAgIH0pO1xuICB9LCA2MDAwMDApO1xufSk7IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgbW9kdWxlIGZyb20gJy4uL21vZHVsZSc7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uLy4uL3JvZ3VlL2luaXQvZ2FtZXN0YXRlJztcbmltcG9ydCB7IFN0YXJ0R2FtZUN5Y2xlIH0gZnJvbSAnLi4vLi4vcm9ndWUvaW5pdC9pbml0JztcbmltcG9ydCB7IE5ld1N0YXRlLCBTZXRTdGF0ZSB9IGZyb20gJy4uLy4uL3JvZ3VlL2luaXQvZ2FtZXVwZ3JhZGVzJztcbmltcG9ydCBVcGdyYWRlcyBmcm9tICcuLi8uLi9yb2d1ZS9jb25zdGFudHMvdXBncmFkZXMnO1xuXG5tb2R1bGUuZmlsdGVyKCd2aXNpYmxlVXBncmFkZXMnLCAoQ3VycmVuY3lEYXRhTWFuYWdlciwgVXBncmFkZURhdGFNYW5hZ2VyKSA9PiB7XG4gIHJldHVybiAodXBncmFkZXMsIHR5cGUpID0+IHtcbiAgICByZXR1cm4gXy5maWx0ZXIodXBncmFkZXMsIHVwZ3JhZGUgPT4gdXBncmFkZS5jb3N0IC8gMiA8IEN1cnJlbmN5RGF0YU1hbmFnZXIuY3VycmVuY3lbdHlwZV1cbiAgICAgICYmIHVwZ3JhZGUuY3VycmVuY3kgPT09IHR5cGVcbiAgICAgICYmIFVwZ3JhZGVEYXRhTWFuYWdlci5jYW5TZWVVcGdyYWRlKHVwZ3JhZGUpXG4gICAgKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuY29udHJvbGxlcignVXBncmFkZXMnLCAoJHNjb3BlLCAkbG9jYWxTdG9yYWdlLCR0aW1lb3V0LCBDdXJyZW5jeURhdGFNYW5hZ2VyLCBVcGdyYWRlRGF0YU1hbmFnZXIsIFRlbXBsYXRlRGF0YU1hbmFnZXIpID0+IHtcblxuICAkc2NvcGUudXBncmFkZXMgPSBVcGdyYWRlcztcbiAgJHNjb3BlLnVwZ3JhZGVEYXRhTWFuYWdlciA9IFVwZ3JhZGVEYXRhTWFuYWdlcjtcbiAgJHNjb3BlLmN1cnJlbmN5RGF0YU1hbmFnZXIgPSBDdXJyZW5jeURhdGFNYW5hZ2VyO1xuXG4gIGxldCBjdXJTdGF0ZSA9IHt9O1xuXG4gICRzY29wZS5idXlVcGdyYWRlID0gKHVwZ3JhZGUpID0+IHtcbiAgICBpZighVXBncmFkZURhdGFNYW5hZ2VyLmJ1eVVwZ3JhZGUodXBncmFkZSkpIHJldHVybjtcbiAgICBpZih1cGdyYWRlLm9wZXJhdGUpIHVwZ3JhZGUub3BlcmF0ZShjdXJTdGF0ZSk7XG4gIH07XG5cbiAgY29uc3QgcmVidWlsZFVwZ3JhZGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY3VyU3RhdGUgPSBOZXdTdGF0ZSgpO1xuXG4gICAgXy5lYWNoKG5ld1N0YXRlLnVubG9ja2VkLnJhY2UuY29uY2F0KG5ld1N0YXRlLnVubG9ja2VkLnByb2Zlc3Npb24pLCByYW5kb20gPT4ge1xuICAgICAgaWYoXy5jb250YWlucyhVcGdyYWRlRGF0YU1hbmFnZXIudXBncmFkZXMsIGBSYW5kb206ICR7cmFuZG9tfWApKSByZXR1cm47XG4gICAgICBVcGdyYWRlRGF0YU1hbmFnZXIudXBncmFkZXMucHVzaChgUmFuZG9tOiAke3JhbmRvbX1gKTtcbiAgICB9KTtcblxuICAgIF8uZWFjaChVcGdyYWRlRGF0YU1hbmFnZXIudXBncmFkZXMsIG5hbWUgPT4ge1xuICAgICAgY29uc3QgdXBncmFkZSA9IF8uZmluZFdoZXJlKFVwZ3JhZGVzLCB7IG5hbWUgfSk7XG4gICAgICBpZih1cGdyYWRlICYmIHVwZ3JhZGUub3BlcmF0ZSkgdXBncmFkZS5vcGVyYXRlKG5ld1N0YXRlKTtcbiAgICB9KTtcblxuICAgIG5ld1N0YXRlLnRlbXBsYXRlcyA9IFRlbXBsYXRlRGF0YU1hbmFnZXIudGVtcGxhdGVzO1xuXG4gICAgU2V0U3RhdGUobmV3U3RhdGUpO1xuICB9O1xuXG4gIGNvbnN0IGdldEN1cnJlbmN5RnJvbSA9IChzdG9yZSkgPT4ge1xuICAgIF8uZWFjaChbJ3NwJywgJ2twJywgJ3ZwJ10sIGtleSA9PiB7XG4gICAgICBjb25zdCBhZGQgPSBzdG9yZVtgJHtrZXl9RWFybmVkYF0gfHwgMDtcbiAgICAgIEN1cnJlbmN5RGF0YU1hbmFnZXIuYWRkQ3VycmVuY3koa2V5LCBhZGQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGlmKCRsb2NhbFN0b3JhZ2Uuc2F2ZVN0YXRlQ2FjaGUpIHtcbiAgICBnZXRDdXJyZW5jeUZyb20oJGxvY2FsU3RvcmFnZS5zYXZlU3RhdGVDYWNoZSk7XG4gICAgJGxvY2FsU3RvcmFnZS5zYXZlU3RhdGVDYWNoZSA9IG51bGw7XG4gIH1cblxuICByZWJ1aWxkVXBncmFkZXMoKTtcbiAgU3RhcnRHYW1lQ3ljbGUoKTtcblxuICBHYW1lU3RhdGUub24oJ3JlZHJhdycsICgpID0+IHtcbiAgICAkbG9jYWxTdG9yYWdlLnNhdmVTdGF0ZUNhY2hlID0ge1xuICAgICAgc3BFYXJuZWQ6IEdhbWVTdGF0ZS5zcEVhcm5lZCxcbiAgICAgIGtwRWFybmVkOiBHYW1lU3RhdGUua3BFYXJuZWRcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBhd2FyZEN1cnJlbmN5ID0gKCkgPT4ge1xuICAgIFxuICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZ2V0Q3VycmVuY3lGcm9tKEdhbWVTdGF0ZSk7XG5cbiAgICAgICRsb2NhbFN0b3JhZ2Uuc2F2ZVN0YXRlQ2FjaGUgPSBudWxsO1xuXG4gICAgICByZWJ1aWxkVXBncmFkZXMoKTtcbiAgICB9KTtcblxuICB9O1xuXG4gIEdhbWVTdGF0ZS5vbignZ2FtZWVuZC5nYW1lb3ZlcicsIGF3YXJkQ3VycmVuY3kpO1xuICBHYW1lU3RhdGUub24oJ2dhbWVlbmQudmljdG9yeScsIGF3YXJkQ3VycmVuY3kpO1xuXG59KTtcbiIsIlxuaW1wb3J0IG1vZHVsZSBmcm9tICcuLi9tb2R1bGUnO1xuXG5tb2R1bGUuZGlyZWN0aXZlKCdmaWxsSGVpZ2h0JywgKCR3aW5kb3csICRwYXJzZSkgPT4ge1xuICByZXR1cm4ge1xuICAgIHNjb3BlOiB7XG4gICAgICBzY3JvbGxCb3R0b206ICc9J1xuICAgIH0sXG4gICAgbGluazogKHNjb3BlLCBlbGVtZW50LCBhdHRycykgPT4ge1xuICAgICAgY29uc3Qgc2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgICAgZWxlbWVudFswXS5zdHlsZS5oZWlnaHQgPSBgJHskd2luZG93LmlubmVySGVpZ2h0IC0gKCRwYXJzZShhdHRycy5vZmZzZXQpKHNjb3BlKSB8fCAwKX1weGA7XG4gICAgICB9O1xuXG4gICAgICBzZXRTaXplKCk7XG5cbiAgICAgIGFuZ3VsYXIuZWxlbWVudCgkd2luZG93KS5iaW5kKCdyZXNpemUnLCBzZXRTaXplKTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCgpID0+IGF0dHJzLm9mZnNldCwgc2V0U2l6ZSk7XG5cbiAgICAgIGlmKHNjb3BlLnNjcm9sbEJvdHRvbSkge1xuICAgICAgICBzY29wZS4kd2F0Y2hDb2xsZWN0aW9uKCdzY3JvbGxCb3R0b20nLCAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICBpZighbmV3VmFsdWUpIHJldHVybjtcbiAgICAgICAgICBlbGVtZW50WzBdLnNjcm9sbFRvcCA9IGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KTsiLCJcbmltcG9ydCBtb2R1bGUgZnJvbSAnLi4vLi4vbW9kdWxlJztcblxubW9kdWxlLmRpcmVjdGl2ZSgnbG9nJywgKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xsZXI6ICdMb2cnLFxuICAgIHJlc3RyaWN0OiAnRScsXG4gICAgdGVtcGxhdGVVcmw6ICdsb2ctdGFiJ1xuICB9O1xufSk7IiwiXG5pbXBvcnQgJy4vY29udHJvbGxlcnMvUm9vdCc7XG5pbXBvcnQgJy4vY29udHJvbGxlcnMvUGFydHknO1xuaW1wb3J0ICcuL2NvbnRyb2xsZXJzL0xvZyc7XG5pbXBvcnQgJy4vY29udHJvbGxlcnMvRHVuZ2Vvbic7XG5pbXBvcnQgJy4vY29udHJvbGxlcnMvT3B0aW9ucyc7XG5pbXBvcnQgJy4vY29udHJvbGxlcnMvVXBncmFkZXMnO1xuXG5cbmltcG9ydCAnLi9zZXJ2aWNlcy9VcGdyYWRlRGF0YU1hbmFnZXInO1xuaW1wb3J0ICcuL3NlcnZpY2VzL0N1cnJlbmN5RGF0YU1hbmFnZXInO1xuaW1wb3J0ICcuL3NlcnZpY2VzL1RlbXBsYXRlRGF0YU1hbmFnZXInO1xuXG5pbXBvcnQgJy4vZGlyZWN0aXZlcy90YWJzL2xvZy10YWInO1xuXG5pbXBvcnQgJy4vZGlyZWN0aXZlcy9maWxsLWhlaWdodCc7XG4iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IG1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdSb2d1YXRoaWEnLCBbJ3VpLmJvb3RzdHJhcCcsICduZ1N0b3JhZ2UnXSk7XG5cbm1vZHVsZS5ydW4oKCRyb290U2NvcGUpID0+ICRyb290U2NvcGUuXyA9IF8pO1xuXG5leHBvcnQgZGVmYXVsdCBtb2R1bGU7IiwiXG5pbXBvcnQgbW9kdWxlIGZyb20gJy4uL21vZHVsZSc7XG5cbm1vZHVsZS5zZXJ2aWNlKCdDdXJyZW5jeURhdGFNYW5hZ2VyJywgKCRsb2NhbFN0b3JhZ2UpID0+IHtcblxuICBpZighJGxvY2FsU3RvcmFnZS5jdXJyZW5jeSkge1xuICAgICRsb2NhbFN0b3JhZ2UuY3VycmVuY3kgPSB7IHNwOiAwLCBrcDogMCwgdnA6IDAgfTtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbmN5ID0gJGxvY2FsU3RvcmFnZS5jdXJyZW5jeTtcblxuICBjb25zdCBhZGRDdXJyZW5jeSA9IChrZXksIHZhbCkgPT4ge1xuICAgIGN1cnJlbmN5W2tleV0gKz0gdmFsO1xuICAgICRsb2NhbFN0b3JhZ2UuY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgfTtcblxuICBjb25zdCBoYXNDdXJyZW5jeSA9IChrZXksIHZhbCkgPT4gY3VycmVuY3lba2V5XSA+PSB2YWw7XG5cbiAgY29uc3QgdXNlQ3VycmVuY3kgPSAoa2V5LCB2YWwpID0+IHtcbiAgICBpZighaGFzQ3VycmVuY3koa2V5LCB2YWwpKSByZXR1cm47XG4gICAgYWRkQ3VycmVuY3koa2V5LCAtdmFsKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFkZEN1cnJlbmN5LFxuICAgIGhhc0N1cnJlbmN5LFxuICAgIHVzZUN1cnJlbmN5LFxuICAgIGN1cnJlbmN5XG4gIH07XG5cbn0pOyIsIlxuaW1wb3J0IG1vZHVsZSBmcm9tICcuLi9tb2R1bGUnO1xuXG5tb2R1bGUuc2VydmljZSgnVGVtcGxhdGVEYXRhTWFuYWdlcicsICgkbG9jYWxTdG9yYWdlKSA9PiB7XG5cbiAgaWYoISRsb2NhbFN0b3JhZ2UudGVtcGxhdGVzKSB7XG4gICAgJGxvY2FsU3RvcmFnZS50ZW1wbGF0ZXMgPSBbXTtcbiAgfVxuXG4gIGNvbnN0IHRlbXBsYXRlcyA9ICRsb2NhbFN0b3JhZ2UudGVtcGxhdGVzO1xuXG4gIHJldHVybiB7XG4gICAgdGVtcGxhdGVzXG4gIH07XG5cbn0pOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBtb2R1bGUgZnJvbSAnLi4vbW9kdWxlJztcblxubW9kdWxlLnNlcnZpY2UoJ1VwZ3JhZGVEYXRhTWFuYWdlcicsIChDdXJyZW5jeURhdGFNYW5hZ2VyLCAkbG9jYWxTdG9yYWdlKSA9PiB7XG5cbiAgaWYoISRsb2NhbFN0b3JhZ2UudXBncmFkZXMpIHtcbiAgICAkbG9jYWxTdG9yYWdlLnVwZ3JhZGVzID0gW107XG4gIH1cblxuICBjb25zdCB1cGdyYWRlcyA9ICRsb2NhbFN0b3JhZ2UudXBncmFkZXM7XG5cbiAgY29uc3QgX2hhc1VwZ3JhZGUgPSAodXBncmFkZU5hbWUpID0+IF8uY29udGFpbnModXBncmFkZXMsIHVwZ3JhZGVOYW1lKTtcbiAgY29uc3QgaGFzVXBncmFkZSA9ICh1cGdyYWRlKSA9PiBfaGFzVXBncmFkZSh1cGdyYWRlLm5hbWUpO1xuXG4gIGNvbnN0IGhhc1VwZ3JhZGVSZXEgPSAodXBncmFkZSkgPT4gdXBncmFkZS5yZXEgPyBfaGFzVXBncmFkZSh1cGdyYWRlLnJlcSkgOiB0cnVlO1xuXG4gIGNvbnN0IGJ1eVVwZ3JhZGUgPSAodXBncmFkZSkgPT4ge1xuICAgIGlmKCFDdXJyZW5jeURhdGFNYW5hZ2VyLmhhc0N1cnJlbmN5KHVwZ3JhZGUuY3VycmVuY3ksIHVwZ3JhZGUuY29zdCkpIHJldHVybjtcbiAgICBpZighaGFzVXBncmFkZVJlcSh1cGdyYWRlKSkgcmV0dXJuO1xuICAgIEN1cnJlbmN5RGF0YU1hbmFnZXIudXNlQ3VycmVuY3kodXBncmFkZS5jdXJyZW5jeSwgdXBncmFkZS5jb3N0KTtcbiAgICB1cGdyYWRlcy5wdXNoKHVwZ3JhZGUubmFtZSk7XG4gICAgJGxvY2FsU3RvcmFnZS51cGdyYWRlcyA9IHVwZ3JhZGVzO1xuICB9O1xuXG4gIGNvbnN0IGNhblNlZVVwZ3JhZGUgPSAodXBncmFkZSkgPT4gIWhhc1VwZ3JhZGUodXBncmFkZSkgJiYgaGFzVXBncmFkZVJlcSh1cGdyYWRlKTtcblxuICByZXR1cm4ge1xuICAgIGJ1eVVwZ3JhZGUsXG4gICAgaGFzVXBncmFkZSxcbiAgICBfaGFzVXBncmFkZSxcbiAgICBjYW5TZWVVcGdyYWRlLFxuICAgIHVwZ3JhZGVzXG4gIH07XG5cbn0pOyIsIlxuaW1wb3J0ICcuL2FuZ3VsYXIvaW5pdCc7IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuXG5jb25zdCBjb25kdWN0cyA9IFtcbiAgLy8gYnJlYWthYmxlIGNvbmR1Y3RzXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+ICFwbGF5ZXIuYnJva2VuQ29uZHVjdC5zdHViYm9ybiwgYWZmaXJtTWVzc2FnZTogJ1lvdSBuZXZlciBjaGFuZ2VkIGVxdWlwbWVudC4nIH0sXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+ICFwbGF5ZXIuYnJva2VuQ29uZHVjdC53aWVsZGVkV2VhcG9uLCBhZmZpcm1NZXNzYWdlOiAnWW91IG5ldmVyIGhpdCB3aXRoIGEgd2llbGRlZCB3ZWFwb24uJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiAhcGxheWVyLmJyb2tlbkNvbmR1Y3QucGFjaWZpc3QsIGFmZmlybU1lc3NhZ2U6ICdZb3UgJXdlcmUgYSBwYWNpZmlzdC4nIH0sXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+ICFwbGF5ZXIuYnJva2VuQ29uZHVjdC5udWRpc3QsIGFmZmlybU1lc3NhZ2U6ICdZb3UgbmV2ZXIgZXF1aXBwZWQgYXJtb3IuJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiAhcGxheWVyLmJyb2tlbkNvbmR1Y3QuY2VsaWJhdGUsIGFmZmlybU1lc3NhZ2U6ICdZb3UgJXdlcmUgY2VsaWJhdGUuJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiBwbGF5ZXIuYnJva2VuQ29uZHVjdC5saWZlU2F2ZSwgYWZmaXJtTWVzc2FnZTogJ1lvdXIgbGlmZSAld2FzIHNhdmVkLicgfSxcblxuICAvLyB0cmFpdHNcbiAgeyBjaGVjazogKHBsYXllcikgPT4gcGxheWVyLmhhc1RyYWl0KCdJbmZyYXZpc2lvbicpLCBhZmZpcm1NZXNzYWdlOiAnWW91ICVoYWQgaW5mcmF2aXNpb24uJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiBwbGF5ZXIuaGFzVHJhaXQoJ1Byb3RlY3Rpb24nKSwgYWZmaXJtTWVzc2FnZTogJ1lvdSAlaGFkIHByb3RlY3Rpb24uJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiBwbGF5ZXIuaGFzVHJhaXQoJ0NsYWlydm95YW5jZScpLCBhZmZpcm1NZXNzYWdlOiAnWW91ICVoYWQgY2xhaXJ2b3lhbmNlLicgfSxcbiAgeyBjaGVjazogKHBsYXllcikgPT4gcGxheWVyLmhhc1RyYWl0KCdXYXJuaW5nJyksIGFmZmlybU1lc3NhZ2U6ICdZb3UgJXdlcmUgd2FybmVkLicgfSxcbiAgeyBjaGVjazogKHBsYXllcikgPT4gcGxheWVyLmhhc1RyYWl0KCdUZWxlcGF0aHknKSwgYWZmaXJtTWVzc2FnZTogJ1lvdSAld2VyZSB0ZWxlcGF0aGljLicgfSxcbiAgeyBjaGVjazogKHBsYXllcikgPT4gcGxheWVyLmhhc1RyYWl0KCdTdGVhbHRoJyksIGFmZmlybU1lc3NhZ2U6ICdZb3UgJXdlcmUgc3RlYWx0aHkuJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiBwbGF5ZXIuaGFzVHJhaXQoJ0ludmlzaWJsZScpLCBhZmZpcm1NZXNzYWdlOiAnWW91ICV3ZXJlIGludmlzaWJsZS4nIH0sXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+IHBsYXllci5oYXNUcmFpdCgnU2VlSW52aXNpYmxlJyksIGFmZmlybU1lc3NhZ2U6ICdZb3UgJWNvdWxkIHNlZSBpbnZpc2libGUuJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiBwbGF5ZXIuZ2V0U3BlZWQoKSA+IFNldHRpbmdzLmdhbWUuYmFzZVNwZWVkLCBhZmZpcm1NZXNzYWdlOiAnWW91ICV3ZXJlIGZhc3QuJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiBwbGF5ZXIuZ2V0U3BlZWQoKSA8IFNldHRpbmdzLmdhbWUuYmFzZVNwZWVkLCBhZmZpcm1NZXNzYWdlOiAnWW91ICV3ZXJlIHNsb3cuJyB9LFxuXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+IHBsYXllci5oYXNUcmFpdCgnUG9pc29uUmVzaXN0YW5jZScpLCBhZmZpcm1NZXNzYWdlOiAnWW91ICV3ZXJlIHBvaXNvbiByZXNpc3RhbnQuJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiBwbGF5ZXIuaGFzVHJhaXQoJ1Nob2NrUmVzaXN0YW5jZScpLCBhZmZpcm1NZXNzYWdlOiAnWW91ICV3ZXJlIHNob2NrIHJlc2lzdGFudC4nIH0sXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+IHBsYXllci5oYXNUcmFpdCgnRmlyZVJlc2lzdGFuY2UnKSwgYWZmaXJtTWVzc2FnZTogJ1lvdSAld2VyZSBmaXJlIHJlc2lzdGFudC4nIH0sXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+IHBsYXllci5oYXNUcmFpdCgnQWNpZFJlc2lzdGFuY2UnKSwgYWZmaXJtTWVzc2FnZTogJ1lvdSAld2VyZSBhY2lkIHJlc2lzdGFudC4nIH0sXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+IHBsYXllci5oYXNUcmFpdCgnSWNlUmVzaXN0YW5jZScpLCBhZmZpcm1NZXNzYWdlOiAnWW91ICV3ZXJlIGljZSByZXNpc3RhbnQuJyB9LFxuXG4gIC8vIHN0YXR1c2VzXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+IHBsYXllci5oYXNCZWhhdmlvcignU3R1bm5lZCcpLCBhZmZpcm1NZXNzYWdlOiAnWW91ICV3ZXJlIHN0dW5uZWQuJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiBwbGF5ZXIuaGFzQmVoYXZpb3IoJ1BvaXNvbmVkJyksIGFmZmlybU1lc3NhZ2U6ICdZb3UgJXdlcmUgcG9pc29uZWQuJyB9LFxuICB7IGNoZWNrOiAocGxheWVyKSA9PiBwbGF5ZXIuaGFzQmVoYXZpb3IoJ1NlZHVjZWQnKSwgYWZmaXJtTWVzc2FnZTogJ1lvdSAld2VyZSBzZWR1Y2VkLicgfSxcblxuICAvLyBhbGlnbm1lbnRcbiAgeyBjaGVjazogKHBsYXllcikgPT4gcGxheWVyLmdldEFsaWduKCkgPT09IDAsIGFmZmlybU1lc3NhZ2U6ICdZb3UgJXdlcmUgbmV1dHJhbC4nIH0sXG4gIHsgY2hlY2s6IChwbGF5ZXIpID0+IHBsYXllci5nZXRBbGlnbigpIDwgMCwgYWZmaXJtTWVzc2FnZTogJ1lvdSAld2VyZSBldmlsLicgfSxcbiAgeyBjaGVjazogKHBsYXllcikgPT4gcGxheWVyLmdldEFsaWduKCkgPiAwLCBhZmZpcm1NZXNzYWdlOiAnWW91ICV3ZXJlIGdvb2QuJyB9LFxuXG4gIC8vIHlvdSBwcm9iYWJseSBhbHdheXMgc2VlIHRoaXNcbiAgeyBjaGVjazogKHBsYXllcikgPT4gcGxheWVyLmhwLmF0TWluKCksIGFmZmlybU1lc3NhZ2U6ICdZb3UgZGllZC4nIH1cbl07XG5cbmV4cG9ydCBkZWZhdWx0IChwbGF5ZXIpID0+IHtcbiAgY29uc3QgZmluYWxDb25kdWN0ID0gW107XG5cbiAgY29uc3QgdGVuc2VzID0gW1xuICAgIHsgc3BsaXQ6ICclY291bGQnLCBwYXN0OiAnY291bGQnLCBub3c6ICdjYW4nIH0sXG4gICAgeyBzcGxpdDogJyV3ZXJlJywgIHBhc3Q6ICd3ZXJlJywgIG5vdzogJ2FyZScgfSxcbiAgICB7IHNwbGl0OiAnJXdhcycsICAgcGFzdDogJ3dhcycsICAgbm93OiAnd2lsbCBiZScgfSxcbiAgICB7IHNwbGl0OiAnJWhhZCcsICAgcGFzdDogJ2hhZCcsICAgbm93OiAnaGF2ZScgfVxuICBdO1xuXG4gIGNvbnN0IGFkanVzdE1lc3NhZ2UgPSAobXNnKSA9PiBfLnJlZHVjZSh0ZW5zZXMsICgocHJldiwgb2JqKSA9PiBwcmV2LnNwbGl0KG9iai5zcGxpdCkuam9pbihwbGF5ZXIuaHAuYXRNaW4oKSA/IG9iai5wYXN0IDogb2JqLm5vdykpLCBtc2cpO1xuICBjb25zdCBhZGRNZXNzYWdlID0gKG1zZykgPT4gZmluYWxDb25kdWN0LnB1c2goYWRqdXN0TWVzc2FnZShtc2cpKTtcblxuICBfLmVhY2goY29uZHVjdHMsIChjb25kdWN0KSA9PiB7XG4gICAgaWYoY29uZHVjdC5jaGVjayhwbGF5ZXIpKSB7XG4gICAgICBhZGRNZXNzYWdlKGNvbmR1Y3QuYWZmaXJtTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmKGNvbmR1Y3QucmVqZWN0TWVzc2FnZSkge1xuICAgICAgYWRkTWVzc2FnZShjb25kdWN0LnJlamVjdE1lc3NhZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIF8uc29ydEJ5KGZpbmFsQ29uZHVjdCk7XG59OyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGNvbnN0IHJhcml0eSA9IChyYXJpdHkpID0+ICh0YXJnZXQpID0+IHsgcmV0dXJuIHRhcmdldC5fX2RlZmluZUdldHRlcl9fKCdyYXJpdHknLCAoKSA9PiByYXJpdHkpLCB0YXJnZXQ7IH07XG5leHBvcnQgY29uc3QgbWF0ZXJpYWwgPSAobWF0ZXJpYWwpID0+ICh0YXJnZXQpID0+IHsgcmV0dXJuIHRhcmdldC5wcm90b3R5cGUubWF0ZXJpYWwgPSBtYXRlcmlhbCwgdGFyZ2V0OyB9O1xuZXhwb3J0IGNvbnN0IHR3b0hhbmRlZCA9ICh0YXJnZXQpID0+IHsgcmV0dXJuIHRhcmdldC5wcm90b3R5cGUuc2xvdHNUYWtlbiA9IDIsIHRhcmdldDsgfTtcbmV4cG9ydCBjb25zdCByYW5nZWQgPSAocmFuZ2UpID0+ICh0YXJnZXQpID0+IHtcbiAgcmV0dXJuIHRhcmdldC5wcm90b3R5cGUucmFuZ2UgPSBfLmV4dGVuZCh7IG51bVNob3RzOiAxLCBkYW1hZ2VCb29zdDogJzBkMCcsIGFtbW86IFtdIH0sIHJhbmdlKSwgdGFyZ2V0O1xufTtcbiIsIlxuZXhwb3J0IGRlZmF1bHQge1xuICBNT05TVEVSOiAnTW9uc3RlcicsXG4gIFBMQVlFUjogJ1BsYXllcicsXG4gIFxuICBNQUdJQzogJ01hZ2ljJyxcblxuICBBTEw6ICdhbGwnXG59OyIsIlxuZXhwb3J0IGNvbnN0IFJpbmcgPSBbJ3BlYXJsJywgJ2lyb24nLCAndHdpc3RlZCcsICdzdGVlbCcsICd3aXJlJywgJ2VuZ2FnZW1lbnQnLCAnc2hpbnknLCAnYnJvbnplJywgJ2JyYXNzJywgJ2NvcHBlcicsICdzaWx2ZXInLCAnZ29sZCcsICd3b29kZW4nLCAnZ3Jhbml0ZScsICdvcGFsJywgJ2NsYXknLCAnY29yYWwnLCAnYmxhY2sgb255eCcsICdtb29uc3RvbmUnLCAndGlnZXIgZXllJywgJ2phZGUnLCAnYWdhdGUnLCAndG9wYXonLCAnc2FwcGhpcmUnLCAncnVieScsICdkaWFtb25kJywgJ2l2b3J5JywgJ2VtZXJhbGQnXTtcblxuZXhwb3J0IGNvbnN0IFBvdGlvbiA9IFsncnVieScsICdkYXJrIGdyZWVuJywgJ3B1cnBsZS1yZWQnLCAnc21va3knLCAnYnJvd24nLCAncGluaycsICdjeWFuJywgJ3B1Y2UnLCAnY2xvdWR5JywgJ2Zpenp5JywgJ29yYW5nZScsICdza3kgYmx1ZScsICdtaWxreScsICdlZmZlcnZlc2NlbnQnLCAnZGFyaycsICd5ZWxsb3cnLCAnYnJpbGxpYW50IGJsdWUnLCAnc3dpcmx5JywgJ2JsYWNrJywgJ3doaXRlJywgJ2VtZXJhbGQnLCAnbWFnZW50YScsICdidWJibHknLCAnZ29sZGVuJywgJ211cmt5J107XG4iLCJcbmV4cG9ydCBjb25zdCBFbnRpdGllcyA9IHtcbiAgRWxlbWVudHM6IHtcbiAgICBXYXRlcjogJ2JsdWUnLFxuICAgIEZpcmU6ICdyZWQnLFxuICAgIFNob2NrOiAnZ3JlZW4nLFxuICAgIEljZTogJ2xpZ2h0Ymx1ZSdcbiAgfSxcbiAgVGllcnM6IHtcbiAgICBCYXNpYzogJ2dyYXknLFxuICAgIFdlYWs6ICdicm93bicsXG4gICAgSW5hZGVxdWF0ZTogJ29yYW5nZScsXG4gICAgTW9kZXJhdGU6ICd5ZWxsb3cnLFxuICAgIEFkZXF1YXRlOiAncmVkJyxcbiAgICBTdHJvbmc6ICcnLFxuICAgIFBvd2VyZnVsOiAnJyxcbiAgICBEaWZmaWN1bHQ6ICcnLFxuICAgIE5pZ2h0bWFyaXNoOiAnJ1xuICB9LFxuICBDb2xvcnM6IHtcbiAgICBCbGFjazogJ2dyYXknLCAvLyBpdCB3b3VsZCBiZSBpbXBvc3NpYmxlIHRvIHNlZSBpZiBpdCB3ZXJlIHJlYWxseSBibGFja1xuICAgIFllbGxvdzogJ3llbGxvdycsXG4gICAgR3JlZW46ICdncmVlbicsXG4gICAgQnJvd246ICdicm93bicsXG4gICAgUmVkOiAncmVkJyxcbiAgICBCbHVlOiAnYmx1ZSdcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IEl0ZW1zID0ge1xuICBHb2xkOiAnZ29sZCdcbn07XG5cbmV4cG9ydCBjb25zdCBUaWxlcyA9IHtcbiAgRG9vcjogJ2dvbGQnLFxuICBGb3VudGFpbjogJyMwMGYnLFxuICBTaW5rOiAnI2QzZDNmZicsXG4gIFRocm9uZTogJ3llbGxvdydcbn07XG5cbmV4cG9ydCBjb25zdCBTcGVjaWFsID0ge1xuICBTZWx5azogJyNmMGYnXG59OyIsIlxuZXhwb3J0IGNvbnN0IEVudGl0aWVzID0ge1xuICBQbGF5ZXI6ICdAJyxcblxuICBBbnQ6ICdhJyxcbiAgQ2FuaW5lOiAnZCcsXG4gIERlbW9uOiAnJicsXG4gIEVsZW1lbnRhbDogJ0UnLFxuICBHbm9tZTogJ0cnLFxuICBIdW1hbm9pZDogJ2gnLFxuICBKZWxseTogJ2onLFxuICBLb2JvbGQ6ICdrJyxcbiAgTGl6YXJkOiAnOicsXG4gIE15c3RpY2FsOiAneCcsXG4gIE55bXBoOiAnbicsXG4gIE9yYzogJ28nLFxuICBQdWRkaW5nOiAnUCcsXG4gIFJhdDogJ3InLFxuICBTbmFrZTogJ1MnLFxuICBTcG9yZTogJ2UnXG59O1xuXG5leHBvcnQgY29uc3QgSXRlbXMgPSB7XG4gIEJvZHk6ICdbJyxcbiAgQ2xvYWs6ICdbJyxcbiAgQ29tZXN0aWJsZTogJyUnLFxuICBGZWV0OiAnWycsXG4gIEdlbTogJyonLFxuICBHb2xkOiAnJCcsXG4gIEhhbmRzOiAnKScsXG4gIEhlYWQ6ICdbJyxcbiAgTmVjazogJ1wiJyxcbiAgUG90aW9uOiAnIScsXG4gIFJpbmc6ICc9JyxcbiAgU2Nyb2xsOiAnPycsXG4gIFNwZWxsYm9vazogJysnLFxuICBUb29sOiAnKCcsXG4gIFdhbmQ6ICcvJyxcbiAgV3Jpc3Q6ICdbJ1xufTtcblxuZXhwb3J0IGNvbnN0IFRpbGVzID0ge1xuICBBbHRhcjogJ18nLFxuICBDb3JyaWRvcjogJyMnLFxuICBEb29yQ2xvc2VkOiAnKycsXG4gIERvb3JPcGVuSG9yaXpvbnRhbDogJy0nLFxuICBEb29yT3BlblZlcnRpY2FsOiAnfCcsXG4gIEZsb29yOiAnLicsXG4gIEZvdW50YWluOiAneycsXG4gIFNpbms6ICcjJyxcbiAgU3RhaXJzRG93bjogJz4nLFxuICBTdGFpcnNVcDogJzwnLFxuICBUaHJvbmU6ICdcXFxcJyxcbiAgV2FsbEhvcml6b250YWw6ICctJyxcbiAgV2FsbFZlcnRpY2FsOiAnfCdcbn07IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCBtYXRlcmlhbHMgPSB7XG4gIFVua25vd246IDAsXG4gIENsb3RoOiAxLCAgICAgLy8gY2FuIGJ1cm4sIHJvdFxuICBMZWF0aGVyOiAyLCAgIC8vIGNhbiBidXJuLCByb3RcbiAgSXJvbjogMywgICAgICAvLyBjYW4gcnVzdCwgY29ycm9kZVxuICBNaXRocmlsOiA0LFxuICBDb3BwZXI6IDUsICAgIC8vIGNhbiBjb3Jyb2RlXG4gIEdsYXNzOiA2LCAgICAgLy8gY2FuIGJ1cm4gKG1lbHQpLCBleHBsb2RlIChpZiBwb3Rpb24pLCBzaGF0dGVyXG4gIERyYWdvbjogNyxcbiAgV29vZDogOCwgICAgICAvLyBjYW4gYnVybiwgcm90LFxuICBGb29kOiA5LFxuICBTaWx2ZXI6IDEwLFxuICBHb2xkOiAxMSxcbiAgTWluZXJhbDogMTIsXG4gIFBsYXN0aWM6IDEzLCAgIC8vIGNhbiBidXJuXG4gIFN0b25lOiAxNCAgICAgIC8vIGNhbiBjb3Jyb2RlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXRlcmlhbHM7XG5cbmV4cG9ydCBjb25zdCBBZmZlY3RlZEJ5RmlyZSAgID0gKGl0ZW0pID0+IF8uY29udGFpbnMoW21hdGVyaWFscy5DbG90aCwgbWF0ZXJpYWxzLkxlYXRoZXIsIG1hdGVyaWFscy5HbGFzcywgbWF0ZXJpYWxzLldvb2QsIG1hdGVyaWFscy5QbGFzdGljXSwgaXRlbS5tYXRlcmlhbCk7XG5leHBvcnQgY29uc3QgQWZmZWN0ZWRCeUFjaWQgICA9IChpdGVtKSA9PiBfLmNvbnRhaW5zKFttYXRlcmlhbHMuSXJvbiwgbWF0ZXJpYWxzLkNvcHBlciwgbWF0ZXJpYWxzLlN0b25lXSwgaXRlbS5tYXRlcmlhbCk7XG5leHBvcnQgY29uc3QgQWZmZWN0ZWRCeVBvaXNvbiA9IChpdGVtKSA9PiBfLmNvbnRhaW5zKFttYXRlcmlhbHMuV29vZCwgbWF0ZXJpYWxzLkNsb3RoLCBtYXRlcmlhbHMuTGVhdGhlcl0sIGl0ZW0ubWF0ZXJpYWwpO1xuZXhwb3J0IGNvbnN0IEFmZmVjdGVkQnlJY2UgICAgPSAoaXRlbSkgPT4gXy5jb250YWlucyhbbWF0ZXJpYWxzLkdsYXNzXSwgaXRlbS5tYXRlcmlhbCk7XG4iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBGb29kcyBmcm9tICcuLi9jb250ZW50L2l0ZW1zL2Zvb2RzJztcbmltcG9ydCAqIGFzIEZlZXRzIGZyb20gJy4uL2NvbnRlbnQvaXRlbXMvZmVldHMnO1xuaW1wb3J0ICogYXMgSGVhZHMgZnJvbSAnLi4vY29udGVudC9pdGVtcy9oZWFkcyc7XG5pbXBvcnQgKiBhcyBCb2R5cyBmcm9tICcuLi9jb250ZW50L2l0ZW1zL2JvZHlzJztcbmltcG9ydCAqIGFzIFJpbmdzIGZyb20gJy4uL2NvbnRlbnQvaXRlbXMvcmluZ3MnO1xuaW1wb3J0ICogYXMgTmVja3MgZnJvbSAnLi4vY29udGVudC9pdGVtcy9uZWNrcyc7XG5pbXBvcnQgKiBhcyBXYW5kcyBmcm9tICcuLi9jb250ZW50L2l0ZW1zL3dhbmRzJztcbmltcG9ydCAqIGFzIFdyaXN0cyBmcm9tICcuLi9jb250ZW50L2l0ZW1zL3dyaXN0cyc7XG5pbXBvcnQgKiBhcyBDbG9ha3MgZnJvbSAnLi4vY29udGVudC9pdGVtcy9jbG9ha3MnO1xuaW1wb3J0ICogYXMgV2VhcG9ucyBmcm9tICcuLi9jb250ZW50L2l0ZW1zL193ZWFwb25zJztcbmltcG9ydCAqIGFzIFBvdGlvbnMgZnJvbSAnLi4vY29udGVudC9pdGVtcy9wb3Rpb25zJztcbmltcG9ydCAqIGFzIFNwZWxsYm9va3MgZnJvbSAnLi4vY29udGVudC9pdGVtcy9zcGVsbGJvb2tzJztcbmltcG9ydCAqIGFzIFByb2plY3RpbGVzIGZyb20gJy4uL2NvbnRlbnQvaXRlbXMvcHJvamVjdGlsZXMnO1xuaW1wb3J0ICogYXMgUHJvZmVzc2lvbnMgZnJvbSAnLi4vY29udGVudC9wcm9mZXNzaW9ucy9fYWxsJztcbmltcG9ydCAqIGFzIFJhY2VzIGZyb20gJy4uL2NvbnRlbnQvcmFjZXMvX2FsbCc7XG5cbmNvbnN0IGdldFJhbmRvbSA9IChmcm9tLCBleGNsdWRlID0gW10pID0+IF8oZnJvbSkudmFsdWVzKCkuZmlsdGVyKCh0eXBlKSA9PiAhXy5jb250YWlucyhleGNsdWRlLCB0eXBlLm5hbWUpKS5zYW1wbGUoKTtcblxuZXhwb3J0IGNvbnN0IEZvb2QgPSAob3B0cywgZXhjbHVkZSkgPT4gbmV3IChnZXRSYW5kb20oRm9vZHMsIGV4Y2x1ZGUpKShvcHRzKTtcbmV4cG9ydCBjb25zdCBGZWV0ID0gKG9wdHMsIGV4Y2x1ZGUpID0+IG5ldyAoZ2V0UmFuZG9tKEZlZXRzLCBleGNsdWRlKSkob3B0cyk7XG5leHBvcnQgY29uc3QgSGVhZCA9IChvcHRzLCBleGNsdWRlKSA9PiBuZXcgKGdldFJhbmRvbShIZWFkcywgZXhjbHVkZSkpKG9wdHMpO1xuZXhwb3J0IGNvbnN0IEJvZHkgPSAob3B0cywgZXhjbHVkZSkgPT4gbmV3IChnZXRSYW5kb20oQm9keXMsIGV4Y2x1ZGUpKShvcHRzKTtcbmV4cG9ydCBjb25zdCBSaW5nID0gKG9wdHMsIGV4Y2x1ZGUpID0+IG5ldyAoZ2V0UmFuZG9tKFJpbmdzLCBleGNsdWRlKSkob3B0cyk7XG5leHBvcnQgY29uc3QgTmVjayA9IChvcHRzLCBleGNsdWRlKSA9PiBuZXcgKGdldFJhbmRvbShOZWNrcywgZXhjbHVkZSkpKG9wdHMpO1xuZXhwb3J0IGNvbnN0IFdhbmQgPSAob3B0cywgZXhjbHVkZSkgPT4gbmV3IChnZXRSYW5kb20oV2FuZHMsIGV4Y2x1ZGUpKShvcHRzKTtcbmV4cG9ydCBjb25zdCBXcmlzdCA9IChvcHRzLCBleGNsdWRlKSA9PiBuZXcgKGdldFJhbmRvbShXcmlzdHMsIGV4Y2x1ZGUpKShvcHRzKTtcbmV4cG9ydCBjb25zdCBDbG9hayA9IChvcHRzLCBleGNsdWRlKSA9PiBuZXcgKGdldFJhbmRvbShDbG9ha3MsIGV4Y2x1ZGUpKShvcHRzKTtcbmV4cG9ydCBjb25zdCBXZWFwb24gPSAob3B0cywgZXhjbHVkZSkgPT4gbmV3IChnZXRSYW5kb20oV2VhcG9ucywgZXhjbHVkZSkpKG9wdHMpO1xuZXhwb3J0IGNvbnN0IFBvdGlvbiA9IChvcHRzLCBleGNsdWRlKSA9PiBuZXcgKGdldFJhbmRvbShQb3Rpb25zLCBleGNsdWRlKSkob3B0cyk7XG5leHBvcnQgY29uc3QgU3BlbGxib29rID0gKG9wdHMsIGV4Y2x1ZGUpID0+IG5ldyAoZ2V0UmFuZG9tKFNwZWxsYm9va3MsIGV4Y2x1ZGUpKShvcHRzKTtcbmV4cG9ydCBjb25zdCBQcm9qZWN0aWxlID0gKG9wdHMsIGV4Y2x1ZGUpID0+IG5ldyAoZ2V0UmFuZG9tKFByb2plY3RpbGVzLCBleGNsdWRlKSkob3B0cyk7XG5leHBvcnQgY29uc3QgUHJvZmVzc2lvbiA9IChvcHRzLCBleGNsdWRlID0gWydNb25zdGVyJywgJ0RldmVsb3BlciddKSA9PiBuZXcgKGdldFJhbmRvbShQcm9mZXNzaW9ucywgZXhjbHVkZSkpKG9wdHMpO1xuZXhwb3J0IGNvbnN0IFJhY2UgPSAob3B0cywgZXhjbHVkZSA9IFtdKSA9PiBuZXcgKGdldFJhbmRvbShSYWNlcywgZXhjbHVkZSkpKG9wdHMpOyIsIlxuZXhwb3J0IGRlZmF1bHQge1xuICBzY3JlZW46IHtcbiAgICB3aWR0aDogODAsXG4gICAgaGVpZ2h0OiAyNFxuICB9LFxuICBnYW1lOiB7XG4gICAgdHVybkRlbGF5OiAxMDAsXG4gICAga2lsbFhwRGl2aXNvcjogNSxcbiAgICBtaW5TdGF0VmFsdWU6IDMsXG4gICAgYWxpZ25UaHJlc2hvbGQ6IDEwMCxcbiAgICBiYXNlQUM6IDEwLFxuICAgIHNwYXduU3RlcHM6IDIwLFxuICAgIG5hbWVMZW5ndGg6IDEyLFxuXG4gICAgZGlzcGxheToge1xuICAgICAgdHVybnM6IDQsXG4gICAgICBsb2c6IDUwXG4gICAgfSxcblxuICAgIGRlZmF1bHRTdGF0czoge1xuICAgICAgbW9uc3Rlcjoge1xuICAgICAgICBzdHI6IDgsXG4gICAgICAgIGNvbjogOCxcbiAgICAgICAgZGV4OiA4LFxuICAgICAgICBpbnQ6IDgsXG4gICAgICAgIHdpczogOCxcbiAgICAgICAgY2hhOiA4XG4gICAgICB9LFxuXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGFjOiAgMCxcbiAgICAgICAgc3RyOiA4LFxuICAgICAgICBjb246IDgsXG4gICAgICAgIGRleDogOCxcbiAgICAgICAgaW50OiA4LFxuICAgICAgICB3aXM6IDgsXG4gICAgICAgIGNoYTogOCxcbiAgICAgICAgbHVrOiAwLFxuICAgICAgICBnb2xkOiAwLFxuICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgYWxpZ246IDAsXG4gICAgICAgIHNwZWVkOiAxMDAsXG4gICAgICAgIHNpZ2h0OiA0LFxuICAgICAgICBzb3VuZDogNTAsXG4gICAgICAgIGtpbGxYcDogJzBkMCcsXG4gICAgICAgIHNwYXduSHA6ICcxNWQxJyxcbiAgICAgICAgc3Bhd25NcDogJzBkMCcsXG4gICAgICAgIHJlZ2VuSHA6IDIwLFxuICAgICAgICByZWdlbk1wOiAxMFxuICAgICAgfSxcblxuICAgICAgc3RhdHM6IHtcbiAgICAgICAgZ2VuZGVyOiAnTWFsZScsXG4gICAgICAgIG5hbWU6ICdEdWRsZXknLFxuICAgICAgICByYWNlOiAnSHVtYW4nLFxuICAgICAgICBhdHRhY2tzOiBbXSxcbiAgICAgICAgYmVoYXZpb3JzOiBbXSxcbiAgICAgICAgcHJvZmVzc2lvbjogJ0RldmVsb3BlcidcbiAgICAgIH0sXG5cbiAgICAgIHByb2Zlc3Npb246IHtcbiAgICAgICAgaHAgIDogJzBkMCcsXG4gICAgICAgIG1wICA6ICcwZDAnLFxuICAgICAgICBhYyAgOiAwLFxuICAgICAgICBzdHIgOiAwLFxuICAgICAgICBjb24gOiAwLFxuICAgICAgICBpbnQgOiAwLFxuICAgICAgICBkZXggOiAwLFxuICAgICAgICB3aXMgOiAwLFxuICAgICAgICBjaGEgOiAwLFxuICAgICAgICBsdWsgOiAwLFxuICAgICAgICBzcGVlZDogMCxcbiAgICAgICAgc2lnaHQ6IDAsXG4gICAgICAgIHNwYXduU3RlcHM6IDAsXG4gICAgICAgIGFkZEZhY3Rpb25zOiBbXSxcbiAgICAgICAgYWRkQmVoYXZpb3JzOiBbXSxcbiAgICAgICAgdGl0bGVzOiBbXSxcbiAgICAgICAgYXR0YWNrczogW10sXG4gICAgICAgIHRyYWl0czogW10sXG4gICAgICAgIHNraWxsQ2Fwczoge31cbiAgICAgIH0sXG5cbiAgICAgIGVxdWlwbWVudFNsb3RzOiB7XG4gICAgICAgIGhhbmRzOiAgMixcbiAgICAgICAgaGVhZDogICAxLFxuICAgICAgICBib2R5OiAgIDEsXG4gICAgICAgIGZlZXQ6ICAgMixcbiAgICAgICAgd3Jpc3Q6ICAyLFxuICAgICAgICBjbG9hazogIDEsXG4gICAgICAgIG5lY2s6ICAgMSxcbiAgICAgICAgcmluZzogICAyXG4gICAgICB9LFxuXG4gICAgICByYWNlOiB7XG4gICAgICAgIGFjICA6IDAsXG4gICAgICAgIGhwICA6IDAsXG4gICAgICAgIG1wICA6IDAsXG4gICAgICAgIHN0ciA6IDAsXG4gICAgICAgIGNvbiA6IDAsXG4gICAgICAgIGludCA6IDAsXG4gICAgICAgIGRleCA6IDAsXG4gICAgICAgIHdpcyA6IDAsXG4gICAgICAgIGNoYSA6IDAsXG4gICAgICAgIGx1ayA6IDAsXG4gICAgICAgIHNwZWVkOiAwLFxuICAgICAgICBzaWdodDogMCxcbiAgICAgICAgc3Bhd25TdGVwczogMCxcbiAgICAgICAgYWRkRmFjdGlvbnM6IFtdLFxuICAgICAgICBhZGRCZWhhdmlvcnM6IFtdLFxuICAgICAgICBhdHRhY2tzOiBbXSxcbiAgICAgICAgdHJhaXRzOiBbXSxcbiAgICAgICAgc2tpbGxCb251czoge31cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHVwZ3JhZGVQYXJhbWV0ZXJzOiB7XG4gICAgTUFYX0ZFQVRVUkVfU1BBV05fQ0hBTkNFOiAxMDAwMFxuICB9LFxuICB1cGdyYWRlczoge1xuICAgIGl0ZW1zSW5EdW5nZW9uOiAwLFxuICAgIGl0ZW1Ecm9wQ2hhbmNlOiAwLFxuICAgIGFsdGFyU3Bhd25DaGFuY2U6IDAsXG4gICAgdGVtcGxlU3Bhd25DaGFuY2U6IDAsXG4gICAgdGhyb25lU3Bhd25DaGFuY2U6IDAsXG4gICAgdGhyb25lUm9vbVNwYXduQ2hhbmNlOiAwLFxuICAgIGdyYXZlU3Bhd25DaGFuY2U6IDAsXG4gICAgZ3JhdmV5YXJkU3Bhd25DaGFuY2U6IDAsXG4gICAgZm91bnRhaW5TcGF3bkNoYW5jZTogMCxcbiAgICBvcmFjbGVSb29tQ2hhbmNlOiAwLFxuICAgIHNpbmtTcGF3bkNoYW5jZTogMCxcbiAgICBiYXRocm9vbVNwYXduQ2hhbmNlOiAwLFxuICAgIG1vbnN0ZXJMaW1pdDogMTAsXG4gICAgbWF4RGlmZmljdWx0eTogNSxcbiAgICBkZXB0aDogMCxcbiAgICByZXNwYXduVGltZTogMFxuICB9LFxuICB1cGdyYWRlc01heDoge1xuICAgIGl0ZW1zSW5EdW5nZW9uOiAyMCxcbiAgICBpdGVtRHJvcENoYW5jZTogNzUsXG4gICAgYWx0YXJTcGF3bkNoYW5jZTogMTAwMCxcbiAgICB0ZW1wbGVTcGF3bkNoYW5jZTogMTAwLFxuICAgIHRocm9uZVNwYXduQ2hhbmNlOiAxMDAwLFxuICAgIHRocm9uZVJvb21TcGF3bkNoYW5jZTogMTAwLFxuICAgIGdyYXZlU3Bhd25DaGFuY2U6IDEwMDAsXG4gICAgZ3JhdmV5YXJkU3Bhd25DaGFuY2U6IDEwMCxcbiAgICBmb3VudGFpblNwYXduQ2hhbmNlOiAxMDAwLFxuICAgIG9yYWNsZVJvb21DaGFuY2U6IDEwMCxcbiAgICBzaW5rU3Bhd25DaGFuY2U6IDEwMDAsXG4gICAgYmF0aHJvb21TcGF3bkNoYW5jZTogMTAwLFxuICAgIG1vbnN0ZXJMaW1pdDogNTAsXG4gICAgbWF4RGlmZmljdWx0eTogNTUsXG4gICAgZGVwdGg6IDEwMCxcbiAgICByZXNwYXduVGltZTogMTBcbiAgfVxufTsiLCJcbmV4cG9ydCBjb25zdCBVbnNraWxsZWQgPSAwO1xuZXhwb3J0IGNvbnN0IEJhc2ljID0gMTtcbmV4cG9ydCBjb25zdCBDb21wZXRlbnQgPSAyO1xuZXhwb3J0IGNvbnN0IFNraWxsZWQgPSAzO1xuZXhwb3J0IGNvbnN0IEV4cGVydCA9IDQ7XG5leHBvcnQgY29uc3QgTWFzdGVyID0gNTtcbmV4cG9ydCBjb25zdCBHcmFuZG1hc3RlciA9IDY7XG5leHBvcnQgY29uc3QgTGVnZW5kYXJ5ID0gNztcblxuZXhwb3J0IGRlZmF1bHQgW1xuICB7IG5hbWU6ICdVbnNraWxsZWQnLCBtYXg6IDAgfSxcbiAgeyBuYW1lOiAnQmFzaWMnLCBtYXg6IDIwIH0sXG4gIHsgbmFtZTogJ0NvbXBldGVudCcsIG1heDogODAgfSxcbiAgeyBuYW1lOiAnU2tpbGxlZCcsIG1heDogMTgwIH0sXG4gIHsgbmFtZTogJ0V4cGVydCcsIG1heDogMzIwIH0sXG4gIHsgbmFtZTogJ01hc3RlcicsIG1heDogNTAwIH0sXG4gIHsgbmFtZTogJ0dyYW5kbWFzdGVyJywgbWF4OiA3NTAgfSxcbiAgeyBuYW1lOiAnTGVnZW5kYXJ5JywgbWF4OiAxMDAwIH1cbl07IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFByb2Zlc3Npb25zIGZyb20gJy4uL2NvbnRlbnQvcHJvZmVzc2lvbnMvX2FsbCc7XG5pbXBvcnQgUmFjZXMgZnJvbSAnLi4vY29udGVudC9yYWNlcy9fYWxsJztcbmltcG9ydCAqIGFzIFRyYWl0cyBmcm9tICcuLi9jb250ZW50L3RyYWl0cy9fYWxsJztcblxuY29uc3QgdXBncmFkZXMgPSBbXG4gIHsgbmFtZTogJ1JlbmFtZSBUYWcnLFxuICAgIGhlbHA6ICdBbGxvdyBmb3IgcmVuYW1pbmcgb2YgcGxheWVyIGNoYXJhY3RlcnMuJyxcbiAgICBjb3N0OiAxMDAwMDAsXG4gICAgY3VycmVuY3k6ICdzcCcgfSxcbiAgeyBuYW1lOiAnQ29sb3IgVGFnJyxcbiAgICBoZWxwOiAnQWxsb3cgZm9yIGNoYW5naW5nIG9mIHBsYXllciBjaGFyYWN0ZXJzIGNvbG9yLicsXG4gICAgY29zdDogMTAwMDAwLFxuICAgIGN1cnJlbmN5OiAnc3AnIH1cbl07XG5cbi8vIFNQXG5fLmVhY2goXy5rZXlzKFByb2Zlc3Npb25zKSwgcHJvZmVzc2lvbiA9PiB7XG4gIHVwZ3JhZGVzLnB1c2goXG4gICAgeyBuYW1lOiBgUmFuZG9tOiAke3Byb2Zlc3Npb259YCxcbiAgICAgIGhlbHA6IGBUaGlzIGNsYXNzICgke3Byb2Zlc3Npb259KSB3aWxsIHNob3cgdXAgcmFuZG9tbHkuYCxcbiAgICAgIGNvc3Q6IDEwMDAwLFxuICAgICAgY3VycmVuY3k6ICdzcCcsXG4gICAgICBvcGVyYXRlOiAodXBncmFkZURhdGEpID0+IHVwZ3JhZGVEYXRhLnVubG9ja2VkLnByb2Zlc3Npb24ucHVzaChwcm9mZXNzaW9uKVxuICAgIH0pO1xuXG4gIHVwZ3JhZGVzLnB1c2goXG4gICAgeyBuYW1lOiBgQ2xhc3M6ICR7cHJvZmVzc2lvbn1gLFxuICAgICAgaGVscDogYFRoaXMgY2xhc3MgKCR7cHJvZmVzc2lvbn0pIGNhbiBiZSBzZWxlY3RlZCBmb3IgYWxsIHBhcnR5IG1lbWJlcnMuYCxcbiAgICAgIHJlcTogYFJhbmRvbTogJHtwcm9mZXNzaW9ufWAsXG4gICAgICB1bmxvY2tlZFByb2Zlc3Npb246IHByb2Zlc3Npb24sXG4gICAgICBjb3N0OiA1MDAwMCxcbiAgICAgIGN1cnJlbmN5OiAnc3AnLFxuICAgICAgb3BlcmF0ZTogKHVwZ3JhZGVEYXRhKSA9PiB1cGdyYWRlRGF0YS5zZWxlY3RhYmxlLnByb2Zlc3Npb24ucHVzaChwcm9mZXNzaW9uKVxuICAgIH0pO1xufSk7XG5cbl8uZWFjaChfLmtleXMoUmFjZXMpLCByYWNlID0+IHtcbiAgdXBncmFkZXMucHVzaChcbiAgICB7IG5hbWU6IGBSYW5kb206ICR7cmFjZX1gLFxuICAgICAgaGVscDogYFRoaXMgcmFjZSAoJHtyYWNlfSkgd2lsbCBzaG93IHVwIHJhbmRvbWx5LmAsXG4gICAgICBjb3N0OiAyMDAwMCxcbiAgICAgIGN1cnJlbmN5OiAnc3AnLFxuICAgICAgb3BlcmF0ZTogKHVwZ3JhZGVEYXRhKSA9PiB1cGdyYWRlRGF0YS51bmxvY2tlZC5yYWNlLnB1c2gocmFjZSlcbiAgICB9KTtcblxuICB1cGdyYWRlcy5wdXNoKFxuICAgIHsgbmFtZTogYFJhY2U6ICR7cmFjZX1gLFxuICAgICAgaGVscDogYFRoaXMgcmFjZSAoJHtyYWNlfSkgY2FuIGJlIHNlbGVjdGVkIGZvciBhbGwgcGFydHkgbWVtYmVycy5gLFxuICAgICAgcmVxOiBgUmFuZG9tOiAke3JhY2V9YCxcbiAgICAgIHVubG9ja2VkUmFjZTogcmFjZSxcbiAgICAgIGNvc3Q6IDgwMDAwLFxuICAgICAgY3VycmVuY3k6ICdzcCcsXG4gICAgICBvcGVyYXRlOiAodXBncmFkZURhdGEpID0+IHVwZ3JhZGVEYXRhLnNlbGVjdGFibGUucmFjZS5wdXNoKHJhY2UpXG4gICAgfSk7XG59KTtcblxuXy5lYWNoKFsnU1RSJywgJ0RFWCcsICdDT04nLCAnSU5UJywgJ1dJUycsICdDSEEnLCAnTFVLJ10sIHN0YXQgPT4ge1xuICB1cGdyYWRlcy5wdXNoKHtcbiAgICBuYW1lOiBgVHJhaXQ6IEwuICR7c3RhdH1gLFxuICAgIGhlbHA6IGBMZXNzZXIgJHtzdGF0fSBncmFudHMgKzEgJHtzdGF0fSB3aGVuIGFzc2lnbmVkIHRvIGEgY2hhcmFjdGVyLmAsXG4gICAgY29zdDogNTAwMCxcbiAgICBjdXJyZW5jeTogJ3NwJ1xuICB9KTtcblxuICB1cGdyYWRlcy5wdXNoKHtcbiAgICBuYW1lOiBgVHJhaXQ6IEcuICR7c3RhdH1gLFxuICAgIGhlbHA6IGBHcmVhdGVyICR7c3RhdH0gZ3JhbnRzICszICR7c3RhdH0gd2hlbiBhc3NpZ25lZCB0byBhIGNoYXJhY3Rlci5gLFxuICAgIGNvc3Q6IDUwMDAwLFxuICAgIGN1cnJlbmN5OiAnc3AnXG4gIH0pO1xufSk7XG5cbl8uZWFjaChfLmtleXMoVHJhaXRzKSwgdHJhaXQgPT4ge1xuICB1cGdyYWRlcy5wdXNoKHtcbiAgICBuYW1lOiBgVHJhaXQ6IFUuICR7dHJhaXR9YCxcbiAgICBoZWxwOiBgR3JhbnRzIHV0aWxpdHkgZm9yIGEgYmFzaWMgbGV2ZWwgb2YgJHt0cmFpdH0gd2hlbiBhc3NpZ25lZCB0byBhIGNoYXJhY3RlcmAsXG4gICAgY29zdDogMTAwMDAwLFxuICAgIGN1cnJlbmN5OiAnc3AnXG4gIH0pO1xufSk7XG5cbnVwZ3JhZGVzLnB1c2goe1xuICBuYW1lOiAnQnVmZjogUHJvZmljaWVudCcsXG4gIGhlbHA6ICdUaGUgYXNzaWduZWQgY2hhcmFjdGVyIGlzIG1vcmUgcHJvZmljaWVudCB3aXRoIGV2ZXJ5IHdlYXBvbi4nLFxuICBjb3N0OiAxMDAwMDAsXG4gIGN1cnJlbmN5OiAnc3AnXG59KTtcblxudXBncmFkZXMucHVzaCh7XG4gIG5hbWU6ICdCdWZmOiBIaWdoZXIgTGV2ZWwnLFxuICBoZWxwOiAnVGhlIGFzc2lnbmVkIGNoYXJhY3RlciBzdGFydHMgYXQgYSBoaWdoZXIgbGV2ZWwuJyxcbiAgY29zdDogMTUwMDAwLFxuICBjdXJyZW5jeTogJ3NwJ1xufSk7XG5cbnVwZ3JhZGVzLnB1c2goe1xuICBuYW1lOiAnQnVmZjogRW5jaGFudGVkIEdlYXInLFxuICBoZWxwOiAnVGhlIGFzc2lnbmVkIGNoYXJhY3RlciBnZXRzIGFuIGVuY2hhbnRtZW50IG9uIGFsbCBvZiB0aGVpciBnZWFyLicsXG4gIGNvc3Q6IDIwMDAwMCxcbiAgY3VycmVuY3k6ICdzcCdcbn0pO1xuXG51cGdyYWRlcy5wdXNoKHtcbiAgbmFtZTogJ0J1ZmY6IENoYXJnZWQgR2VhcicsXG4gIGhlbHA6ICdUaGUgYXNzaWduZWQgY2hhcmFjdGVyIGdldHMgbW9yZSBjaGFyZ2VzIG9uIGFsbCBvZiB0aGVpciBnZWFyLicsXG4gIGNvc3Q6IDI1MDAwMCxcbiAgY3VycmVuY3k6ICdzcCdcbn0pO1xuXG5mb3IobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gIHVwZ3JhZGVzLnB1c2goe1xuICAgIG5hbWU6IGBCaWdnZXIgUGFydHkgJHtpKzF9YCxcbiAgICBoZWxwOiBgQWRkIG9uZSBtZW1iZXIgdG8geW91ciBhZHZlbnR1cmluZyBwYXJ0eS5gLFxuICAgIHJlcTogaSA+IDAgPyBgQmlnZ2VyIFBhcnR5ICR7aX1gIDogbnVsbCxcbiAgICBjdXJyZW5jeTogJ3NwJyxcbiAgICBjb3N0OiAoaSsyKSAqIDE1MDAwMCxcbiAgICBvcGVyYXRlOiAodXBncmFkZURhdGEpID0+IHVwZ3JhZGVEYXRhLmV4dHJhLnBsYXllcnMrK1xuICB9KTtcbn1cbi8vIG5vIG1vcmUgU1BcblxuLy8gS1BcbmZvcihsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgdXBncmFkZXMucHVzaCh7XG4gICAgbmFtZTogYE1vcmUgTW9uc3RlcnMgJHtpKzF9YCxcbiAgICBoZWxwOiBgTW9yZSBtb25zdGVycyB3aWxsIGJlIGFibGUgdG8gc3Bhd24gaW4gdGhlIGR1bmdlb24uYCxcbiAgICByZXE6IGkgPiAwID8gYE1vcmUgTW9uc3RlcnMgJHtpfWAgOiBudWxsLFxuICAgIGN1cnJlbmN5OiAna3AnLFxuICAgIGNvc3Q6IChpKzEpICogMjAwMDAsXG4gICAgb3BlcmF0ZTogKHVwZ3JhZGVEYXRhKSA9PiB1cGdyYWRlRGF0YS5kdW5nZW9uLm1vbnN0ZXJMaW1pdCArPSA1XG4gIH0pO1xufVxuXG5mb3IobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICB1cGdyYWRlcy5wdXNoKHtcbiAgICBuYW1lOiBgRGFya2VyIE1vbnN0ZXJzICR7aSsxfWAsXG4gICAgaGVscDogYE1vcmUgZGlmZmljdWx0IG1vbnN0ZXJzIHdpbGwgYmUgYWJsZSB0byBzcGF3biBpbiB0aGUgZHVuZ2Vvbi5gLFxuICAgIHJlcTogaSA+IDAgPyBgRGFya2VyIE1vbnN0ZXJzICR7aX1gIDogbnVsbCxcbiAgICBjdXJyZW5jeTogJ2twJyxcbiAgICBjb3N0OiAoaSsxKSAqIDEwMDAwLFxuICAgIG9wZXJhdGU6ICh1cGdyYWRlRGF0YSkgPT4gdXBncmFkZURhdGEuZHVuZ2Vvbi5tYXhEaWZmaWN1bHR5ICs9IDVcbiAgfSk7XG59XG4vLyBubyBtb3JlIEtQXG5cbi8vIFZQXG5fLmVhY2goWyd0aHJvbmUnLCAnZm91bnRhaW4nLCAnc2luayddLCBmZWF0ID0+IHtcbiAgZm9yKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgIHVwZ3JhZGVzLnB1c2goe1xuICAgICAgbmFtZTogYEZlYXR1cmU6ICR7Xy5jYXBpdGFsaXplKGZlYXQpfSAke2krMX1gLFxuICAgICAgaGVscDogYFRoZSBkdW5nZW9uIHdpbGwgc3Bhd24gJHtmZWF0fXMgbW9yZSBmcmVxdWVudGx5LmAsXG4gICAgICByZXE6IGkgPiAwID8gYEZlYXR1cmU6ICR7Xy5jYXBpdGFsaXplKGZlYXQpfSAke2l9YCA6IG51bGwsXG4gICAgICBjdXJyZW5jeTogJ3ZwJyxcbiAgICAgIGNvc3Q6IChpKzEpICogMTAsXG4gICAgICBvcGVyYXRlOiAodXBncmFkZURhdGEpID0+IHVwZ3JhZGVEYXRhLmR1bmdlb25bYCR7ZmVhdH1zcGF3bkNoYW5jZWBdICs9IDIwMCAvLyArMiVcbiAgICB9KTtcbiAgfVxufSk7XG5cbmZvcihsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgdXBncmFkZXMucHVzaCh7XG4gICAgbmFtZTogYERlZXBlciBEdW5nZW9uICR7aSsxfWAsXG4gICAgaGVscDogYFRoZSBkdW5nZW9uIHdpbGwgZ2V0IDEwIGZsb29ycyBkZWVwZXIuYCxcbiAgICByZXE6IGkgPiAwID8gYERlZXBlciBEdW5nZW9uICR7aX1gIDogbnVsbCxcbiAgICBjdXJyZW5jeTogJ3ZwJyxcbiAgICBjb3N0OiAoaSsxKSAqIDIwLFxuICAgIG9wZXJhdGU6ICh1cGdyYWRlRGF0YSkgPT4gdXBncmFkZURhdGEuZHVuZ2Vvbi5kZXB0aCArPSAxMFxuICB9KTtcbn1cblxuZm9yKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICB1cGdyYWRlcy5wdXNoKHtcbiAgICBuYW1lOiBgU3F1YXJlciBEdW5nZW9uICR7aSsxfWAsXG4gICAgaGVscDogYFRoZSBkdW5nZW9uIHdpbGwgZ2V0IHdpZGVyIGFuZCB0YWxsZXIuYCxcbiAgICByZXE6IGkgPiAwID8gYFNxdWFyZXIgRHVuZ2VvbiAke2l9YCA6IG51bGwsXG4gICAgY3VycmVuY3k6ICd2cCcsXG4gICAgY29zdDogKGkrMSkgKiA1LFxuICAgIG9wZXJhdGU6ICh1cGdyYWRlRGF0YSkgPT4gdXBncmFkZURhdGEuZHVuZ2Vvbi5zcXVhcml0eSArPSAxMFxuICB9KTtcbn1cblxuZm9yKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICB1cGdyYWRlcy5wdXNoKHtcbiAgICBuYW1lOiBgTG9zdCBhbmQgRm91bmQgJHtpKzF9YCxcbiAgICBoZWxwOiBgTW9yZSBpdGVtcyBnb3QgbG9zdCBieSBwcmV2aW91cyBhZHZlbnR1cmVycywgc28geW91IGNhbiBmaW5kIHRoZW0hYCxcbiAgICByZXE6IGkgPiAwID8gYExvc3QgYW5kIEZvdW5kICR7aX1gIDogbnVsbCxcbiAgICBjdXJyZW5jeTogJ3ZwJyxcbiAgICBjb3N0OiAoaSsxKSAqIDE1LFxuICAgIG9wZXJhdGU6ICh1cGdyYWRlRGF0YSkgPT4gdXBncmFkZURhdGEuZHVuZ2Vvbi5pdGVtc0luRHVuZ2VvbiArPSA0XG4gIH0pO1xufVxuXG5mb3IobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gIHVwZ3JhZGVzLnB1c2goe1xuICAgIG5hbWU6IGBQZXJjZXB0aW9uIEJvb3N0ICR7aSsxfWAsXG4gICAgaGVscDogYExvc3QgaXRlbXMgYXJlIG1vcmUgbGlrZWx5IHRvIGJlIG91dCBpbiB0aGUgb3Blbi5gLFxuICAgIHJlcTogaSA+IDAgPyBgUGVyY2VwdGlvbiBCb29zdCAke2l9YCA6IG51bGwsXG4gICAgY3VycmVuY3k6ICd2cCcsXG4gICAgY29zdDogKGkrMSkgKiAyNSxcbiAgICBvcGVyYXRlOiAodXBncmFkZURhdGEpID0+IHVwZ3JhZGVEYXRhLmR1bmdlb24uaXRlbURyb3BDaGFuY2UgKz0gMTVcbiAgfSk7XG59XG5cbmZvcihsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gIHVwZ3JhZGVzLnB1c2goe1xuICAgIG5hbWU6IGBGYXN0ZXIgUmVzcGF3biAke2krMX1gLFxuICAgIGhlbHA6IGBSZXNwYXduIGZhc3RlciBzbyB0aGUgZHVuZ2VvbiBjYW4gZWF0IHlvdSBhZ2FpbiBmYXN0ZXIuYCxcbiAgICByZXE6IGkgPiAwID8gYEZhc3RlciBSZXNwYXduICR7aX1gIDogbnVsbCxcbiAgICBjdXJyZW5jeTogJ3ZwJyxcbiAgICBjb3N0OiAoaSsxKSAqIDI1LFxuICAgIG9wZXJhdGU6ICh1cGdyYWRlRGF0YSkgPT4gdXBncmFkZURhdGEuZXh0cmEucmVzcGF3blRpbWUgKz0gMVxuICB9KTtcbn1cbi8vIG5vIG1vcmUgVlBcblxuZXhwb3J0IGRlZmF1bHQgdXBncmFkZXM7XG4iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uL2luaXQvZ2FtZXN0YXRlJztcbmltcG9ydCAqIGFzIFRpbGVzIGZyb20gJy4uL3dvcmxkZ2VuL3RpbGVzL19hbGwnO1xuaW1wb3J0IHsgU3RvbmVPZlNlbHlrLCBTZWx5a0NlbGxhcktleSB9IGZyb20gJy4uL2NvbnRlbnQvaXRlbXMvX3NwZWNpYWwnO1xuaW1wb3J0IHsgU2VseWsgfSBmcm9tICcuLi9jb250ZW50L21vbnN0ZXJzL19zcGVjaWFsJztcbmltcG9ydCBBbHRhciBmcm9tICcuLi93b3JsZGdlbi9tYXB0eXBlcy9hbHRhcic7XG5pbXBvcnQgTW9uc3RlciBmcm9tICcuLi9kZWZpbml0aW9ucy9tb25zdGVyJztcblxuY2xhc3MgVmljdG9yeSB7XG4gIHN0YXRpYyB2cCgpIHsgcmV0dXJuIDU7IH1cbiAgc3RhdGljIGNoZWNrKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICBzdGF0aWMgZ2V0IG1lc3NhZ2UoKSB7IHJldHVybiAnWW91IHN1cnZpdmVkISc7IH1cbiAgc3RhdGljIGdldCBkZXNjcmlwdGlvbigpIHsgcmV0dXJuICdTdXJ2aXZlISc7IH1cbiAgc3RhdGljIHNob3VsZFRyaWdnZXIoKSB7IHJldHVybiBmYWxzZTsgfVxuICBzdGF0aWMgdHJpZ2dlcigpIHt9XG4gIHN0YXRpYyBtYXBBZGRpdGlvbnMoKSB7fVxuICBzdGF0aWMgbWFwU3RhaXJzKGkpIHsgcmV0dXJuIFtUaWxlcy5TdGFpcnNVcCwgaSAhPT0gR2FtZVN0YXRlLndvcmxkLmRlcHRoLTEgPyBUaWxlcy5TdGFpcnNEb3duIDogbnVsbF07IH1cbn1cblxuZXhwb3J0IGNsYXNzIFN1cnZpdmFsIGV4dGVuZHMgVmljdG9yeSB7XG4gIHN0YXRpYyB2cCgpIHsgcmV0dXJuIEdhbWVTdGF0ZS53b3JsZC5kZXB0aDsgfVxuICBzdGF0aWMgcmVxdWlyZWRUdXJucygpIHsgcmV0dXJuIEdhbWVTdGF0ZS53b3JsZC5kZXB0aCoxMDAwOyB9XG4gIHN0YXRpYyBjaGVjaygpIHsgcmV0dXJuIF8ubWF4KEdhbWVTdGF0ZS5wbGF5ZXJzLCAnY3VycmVudFR1cm4nKS5jdXJyZW50VHVybiA+PSB0aGlzLnJlcXVpcmVkVHVybnMoKTsgfVxuICBzdGF0aWMgZ2V0IG1lc3NhZ2UoKSB7IHJldHVybiBgWW91IHN1cnZpdmVkICR7dGhpcy5yZXF1aXJlZFR1cm5zKCl9IHR1cm5zLmA7IH1cbiAgc3RhdGljIGdldCBkZXNjcmlwdGlvbigpIHsgcmV0dXJuIGBTdXJ2aXZlIGZvciAke3RoaXMucmVxdWlyZWRUdXJucygpfSB0dXJucy5gOyB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdG9uZU9mU2VseWtGaW5kIGV4dGVuZHMgVmljdG9yeSB7XG4gIHN0YXRpYyB2cCgpIHsgcmV0dXJuIDMgKiBHYW1lU3RhdGUud29ybGQuZGVwdGg7IH1cbiAgc3RhdGljIGNoZWNrKCkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIF8uZWFjaChHYW1lU3RhdGUucGxheWVycywgKHBsYXllcikgPT4ge1xuICAgICAgaWYocGxheWVyLmhhc0luSW52ZW50b3J5KFN0b25lT2ZTZWx5aykpIGZvdW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgc3RhdGljIHNob3VsZFRyaWdnZXIoKSB7IHJldHVybiBHYW1lU3RhdGUud29ybGQuZGVwdGggPT09IEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3IrMTsgfVxuICBzdGF0aWMgdHJpZ2dlcigpIHtcbiAgICBHYW1lU3RhdGUud29ybGQucGxhY2VJdGVtQXRSYW5kb21Mb2NhdGlvbihuZXcgU3RvbmVPZlNlbHlrKCksIEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3IpO1xuICB9XG4gIHN0YXRpYyBnZXQgbWVzc2FnZSgpIHsgcmV0dXJuIGBZb3UgZm91bmQgdGhlIFN0b25lIG9mIFNlbHlrLmA7IH1cbiAgc3RhdGljIGdldCBkZXNjcmlwdGlvbigpIHsgcmV0dXJuIGBGaW5kIHRoZSBTdG9uZSBvZiBTZWx5ay5gOyB9XG59XG5cbmV4cG9ydCBjbGFzcyBTZWx5a0FsdGFyIGV4dGVuZHMgVmljdG9yeSB7XG4gIHN0YXRpYyB2cCgpIHsgcmV0dXJuIDEwICogR2FtZVN0YXRlLndvcmxkLmRlcHRoOyB9XG4gIHN0YXRpYyBjaGVjaygpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBfLmVhY2goR2FtZVN0YXRlLnBsYXllcnMsIChwbGF5ZXIpID0+IHtcbiAgICAgIGlmKHBsYXllci5fYXNjZW5kZWQpIGZvdW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgc3RhdGljIG1hcEFkZGl0aW9ucygpIHtcbiAgICBjb25zdCBmbG9vciA9IEdhbWVTdGF0ZS53b3JsZC5kZXB0aDtcbiAgICBHYW1lU3RhdGUud29ybGQuc2V0TWFwQXQoQWx0YXIuZ2VuZXJhdGUoeyB6OiBmbG9vciB9KSwgZmxvb3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBzaG91bGRUcmlnZ2VyKCkgeyByZXR1cm4gR2FtZVN0YXRlLndvcmxkLmRlcHRoLTEgPT09IEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3IrMTsgfVxuICBzdGF0aWMgdHJpZ2dlcigpIHtcbiAgICBHYW1lU3RhdGUud29ybGQucGxhY2VJdGVtQXRSYW5kb21Mb2NhdGlvbihuZXcgU2VseWtDZWxsYXJLZXkoKSwgR2FtZVN0YXRlLmN1cnJlbnRGbG9vcik7XG4gIH1cbiAgc3RhdGljIGdldCBtZXNzYWdlKCkgeyByZXR1cm4gYFlvdSBzYWNyaWZpY2VkIHlvdXJzZWxmIGF0IHRoZSBhbHRhciBvZiBTZWx5ay5gOyB9XG4gIHN0YXRpYyBnZXQgZGVzY3JpcHRpb24oKSB7IHJldHVybiBgUmVhY2ggdGhlIGFsdGFyIG9mIFNlbHlrLmA7IH1cbiAgc3RhdGljIG1hcFN0YWlycyhpKSB7IHJldHVybiBbVGlsZXMuU3RhaXJzVXAsIGkgIT09IEdhbWVTdGF0ZS53b3JsZC5kZXB0aC0xID8gVGlsZXMuU3RhaXJzRG93biA6IFRpbGVzLlNlbHlrU3RhaXJzRG93bl07IH1cbn1cblxuZXhwb3J0IGNsYXNzIEtpbGxTZWx5ayBleHRlbmRzIFZpY3Rvcnkge1xuICBzdGF0aWMgdnAoKSB7IHJldHVybiAyMCAqIEdhbWVTdGF0ZS53b3JsZC5kZXB0aDsgfVxuICBzdGF0aWMgY2hlY2soKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgXy5lYWNoKEdhbWVTdGF0ZS5wbGF5ZXJzLCAocGxheWVyKSA9PiB7XG4gICAgICBpZihwbGF5ZXIuY29ucXVlc3QuU2VseWspIGZvdW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgc3RhdGljIHNob3VsZFRyaWdnZXIoKSB7IHJldHVybiBHYW1lU3RhdGUud29ybGQuZGVwdGggPT09IEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3IrMTsgfVxuICBzdGF0aWMgdHJpZ2dlcigpIHtcbiAgICBHYW1lU3RhdGUud29ybGQucGxhY2VFbnRpdHlBdFJhbmRvbUxvY2F0aW9uKG5ldyBNb25zdGVyKDAsIDAsIDAsIFNlbHlrLmluaXQoKSksIEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3IpO1xuICB9XG4gIHN0YXRpYyBnZXQgbWVzc2FnZSgpIHsgcmV0dXJuIGBZb3Uga2lsbGVkIFNlbHlrLmA7IH1cbiAgc3RhdGljIGdldCBkZXNjcmlwdGlvbigpIHsgcmV0dXJuIGBLaWxsIFNlbHlrLmA7IH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBNb25zdGVyQXR0YWNrcyBmcm9tICcuL21vbnN0ZXItYXR0YWNrcyc7XG5pbXBvcnQgKiBhcyBQaHlzaWNhbEF0dGFja3MgZnJvbSAnLi9waHlzaWNhbC1hdHRhY2tzJztcbmltcG9ydCAqIGFzIE1hZ2ljQXR0YWNrcyBmcm9tICcuL21hZ2ljLWF0dGFja3MnO1xuXG5jb25zdCBhdHRhY2tzID0ge307XG5jb25zdCB0aGVzZUF0dGFja3MgPSBfLnZhbHVlcyhNb25zdGVyQXR0YWNrcylcbiAgLmNvbmNhdChfLnZhbHVlcyhQaHlzaWNhbEF0dGFja3MpKVxuICAuY29uY2F0KF8udmFsdWVzKE1hZ2ljQXR0YWNrcykpO1xuXG5fLmVhY2godGhlc2VBdHRhY2tzLCAoYXR0YWNrKSA9PiB7XG4gIGNvbnN0IGF0dGFja0Z1bmMgPSAociwgaCwgZCkgPT4gbmV3IGF0dGFjayhyLCBoLCBkKTtcbiAgYXR0YWNrRnVuYy5yZWFsID0gYXR0YWNrO1xuICBhdHRhY2tzW2F0dGFjay5uYW1lXSA9IGF0dGFja0Z1bmM7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXR0YWNrczsiLCJcbmltcG9ydCB7IE1hZ2ljIH0gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvYXR0YWNrJztcblxuZXhwb3J0IGNsYXNzIEZvcmNlIGV4dGVuZHMgTWFnaWMge31cbiIsIlxuaW1wb3J0ICogYXMgQmVoYXZpb3JzIGZyb20gJy4uL2JlaGF2aW9ycy9fYWxsJztcbmltcG9ydCB7IEF0dGFjayB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2F0dGFjayc7XG5cbmV4cG9ydCBjbGFzcyBCaXRlIGV4dGVuZHMgQXR0YWNrIHt9XG5leHBvcnQgY2xhc3MgQ2xhdyBleHRlbmRzIEF0dGFjayB7fVxuZXhwb3J0IGNsYXNzIFRvdWNoIGV4dGVuZHMgQXR0YWNrIHt9XG5leHBvcnQgY2xhc3MgQmVhcmh1ZyBleHRlbmRzIEF0dGFjayB7fVxuXG5leHBvcnQgY2xhc3MgUG9pc29uIGV4dGVuZHMgQXR0YWNrIHtcbiAgaGl0U3RyaW5nKG93bmVyLCB0YXJnZXQsIGRhbWFnZSwgZXh0cmEpIHtcbiAgICBsZXQgcHNuID0gYGA7XG4gICAgaWYoZXh0cmEgJiYgIXRhcmdldC5oYXNUcmFpdCgnUG9pc29uUmVzaXN0YW5jZScpKSB7XG4gICAgICBwc24gPSBgICR7dGFyZ2V0Lm5hbWV9IGdvdCBwb2lzb25lZCFgO1xuICAgICAgdGFyZ2V0LmFkZFVuaXF1ZUJlaGF2aW9yKEJlaGF2aW9ycy5Qb2lzb25lZCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke293bmVyLm5hbWV9IGhpdCAke3RhcmdldC5uYW1lfSBmb3IgJHtkYW1hZ2V9IGRhbWFnZSEke3Bzbn1gO1xuICB9XG4gIGhpdENhbGxiYWNrKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFbGVjdHJpY1RvdWNoIGV4dGVuZHMgQXR0YWNrIHtcbiAgaGl0U3RyaW5nKG93bmVyLCB0YXJnZXQsIGRhbWFnZSwgZXh0cmEpIHtcbiAgICBsZXQgemFwID0gYGA7XG4gICAgaWYoZXh0cmEpIHtcbiAgICAgIHphcCA9IGAgJHt0YXJnZXQubmFtZX0gZ290IHphcHBlZCFgO1xuICAgICAgdGFyZ2V0LmFkZFVuaXF1ZUJlaGF2aW9yKEJlaGF2aW9ycy5TdHVubmVkKCkpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7b3duZXIubmFtZX0gaGl0ICR7dGFyZ2V0Lm5hbWV9IGZvciAke2RhbWFnZX0gZGFtYWdlISR7emFwfWA7XG4gIH1cbiAgaGl0Q2FsbGJhY2soKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEV4cGxvZGUgZXh0ZW5kcyBBdHRhY2sge1xuICBoaXRTdHJpbmcob3duZXIsIHRhcmdldCwgZGFtYWdlKSB7XG4gICAgcmV0dXJuIGAke293bmVyLm5hbWV9IGV4cGxvZGVzISAke3RhcmdldC5uYW1lfSB0b29rICR7ZGFtYWdlfSBkYW1hZ2UuYDtcbiAgfVxuXG4gIGNhbkhpdCgpIHsgcmV0dXJuIHRydWU7IH1cblxuICBhZnRlckhpdENhbGxiYWNrKG93bmVyKSB7XG4gICAgb3duZXIuZGllKG93bmVyKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2VkdWN0aXZlVG91Y2ggZXh0ZW5kcyBBdHRhY2sge1xuICBoaXRTdHJpbmcob3duZXIsIHRhcmdldCwgZGFtYWdlLCBleHRyYSkge1xuICAgIGxldCBzZWQgPSBgYDtcbiAgICBpZihleHRyYSkge1xuICAgICAgc2VkID0gYCAke3RhcmdldC5uYW1lfSBpcyBzZWR1Y2VkIWA7XG4gICAgICB0YXJnZXQuYWRkVW5pcXVlQmVoYXZpb3IoQmVoYXZpb3JzLlNlZHVjZWQoKSk7XG4gICAgfVxuICAgIHJldHVybiBgJHtvd25lci5uYW1lfSBoaXQgJHt0YXJnZXQubmFtZX0gZm9yICR7ZGFtYWdlfSBkYW1hZ2UhJHtzZWR9YDtcbiAgfVxuICBoaXRDYWxsYmFjaygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGVsZXBhdGhpY0JsYXN0IGV4dGVuZHMgQXR0YWNrIHtcbiAgaGl0U3RyaW5nKG93bmVyLCB0YXJnZXQsIGRhbWFnZSkge1xuICAgIHJldHVybiBgJHtvd25lci5uYW1lfSBnb3QgYmxhc3RlZCBieSAke3RhcmdldC5uYW1lfSdzIHBzeWNoaWMgYmxhc3QgZm9yICR7ZGFtYWdlfSBkYW1hZ2UhYDtcbiAgfVxuICBoaXRDYWxsYmFjayhvd25lcikge1xuICAgIHJldHVybiBvd25lci5oYXNUcmFpdCgnVGVsZXBhdGh5Jyk7XG4gIH1cbn0iLCJcbmltcG9ydCB7IFJlYWdlbnQsIFNraWxsZWRBdHRhY2sgfSBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9hdHRhY2snO1xuaW1wb3J0IEdseXBoIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2dseXBoJztcblxuZXhwb3J0IGNsYXNzIEJhc2ggZXh0ZW5kcyBTa2lsbGVkQXR0YWNrIHt9XG5cbmV4cG9ydCBjbGFzcyBSYW5nZWQgZXh0ZW5kcyBSZWFnZW50IHt9XG5cbmV4cG9ydCBjbGFzcyBTaG90IGV4dGVuZHMgU2tpbGxlZEF0dGFjayB7XG4gIGluaXQoKSB7XG4gICAgdGhpcy5nbHlwaCA9IG5ldyBHbHlwaCgnKScsICcjMDBmJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNsYXNoIGV4dGVuZHMgU2tpbGxlZEF0dGFjayB7fVxuXG5leHBvcnQgY2xhc3MgU21hc2ggZXh0ZW5kcyBTa2lsbGVkQXR0YWNrIHt9XG5cbmV4cG9ydCBjbGFzcyBTdGFiIGV4dGVuZHMgU2tpbGxlZEF0dGFjayB7fVxuXG5leHBvcnQgY2xhc3MgVGhydXN0IGV4dGVuZHMgU2tpbGxlZEF0dGFjayB7fVxuXG5leHBvcnQgY2xhc3MgVW5hcm1lZCBleHRlbmRzIFNraWxsZWRBdHRhY2sge30iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBBbWJpZW50IGZyb20gJy4vYW1iaWVudCc7XG5pbXBvcnQgKiBhcyBDb21iYXQgZnJvbSAnLi9jb21iYXQnO1xuaW1wb3J0ICogYXMgQ29uZGl0aW9ucyBmcm9tICcuL2NvbmRpdGlvbnMnO1xuaW1wb3J0ICogYXMgRGVhdGggZnJvbSAnLi9kZWF0aCc7XG5pbXBvcnQgKiBhcyBJbnRlcmFjdGlvbnMgZnJvbSAnLi9pbnRlcmFjdGlvbnMnO1xuaW1wb3J0ICogYXMgUmVnZW5lcmF0aW9uIGZyb20gJy4vcmVnZW5lcmF0aW9uJztcbmltcG9ydCAqIGFzIFRhcmdldHRpbmcgZnJvbSAnLi90YXJnZXR0aW5nJztcblxuZXhwb3J0IGRlZmF1bHQgXy5leHRlbmQoe30sIEFtYmllbnQsIENvbWJhdCwgQ29uZGl0aW9ucywgRGVhdGgsIEludGVyYWN0aW9ucywgUmVnZW5lcmF0aW9uLCBUYXJnZXR0aW5nKTsiLCJcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcbmltcG9ydCBCZWhhdmlvciwgeyBQcmlvcml0eSB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2JlaGF2aW9yJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vaW5pdC9nYW1lc3RhdGUnO1xuXG4vKiBiZWluZyBzdHVubmVkIHN1Y2tzICovXG5jbGFzcyBFbWl0c0xpZ2h0QmVoYXZpb3IgZXh0ZW5kcyBCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yID0gJyNmZmYnKSB7XG4gICAgc3VwZXIoUHJpb3JpdHkuQUxXQVlTKTtcbiAgICB0aGlzLmNvbG9yID0gUk9ULkNvbG9yLmZyb21TdHJpbmcoY29sb3IpO1xuICB9XG5cbiAgc3Bhd24obWUpIHtcbiAgICBtZS5fbGlnaHRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgR2FtZVN0YXRlLndvcmxkLmFkZExpZ2h0aW5nKG1lKTtcbiAgfVxuXG4gIGRpZShtZSkge1xuICAgIEdhbWVTdGF0ZS53b3JsZC5yZW1vdmVMaWdodGluZyhtZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEVtaXRzTGlnaHQgPSAoY29sb3IpID0+IG5ldyBFbWl0c0xpZ2h0QmVoYXZpb3IoY29sb3IpOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcbmltcG9ydCBCZWhhdmlvciwgeyBQcmlvcml0eSB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2JlaGF2aW9yJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vaW5pdC9nYW1lc3RhdGUnO1xuaW1wb3J0IE1lc3NhZ2VRdWV1ZSwgeyBNZXNzYWdlVHlwZXMgfSBmcm9tICcuLi8uLi9kaXNwbGF5L21lc3NhZ2UtaGFuZGxlcic7XG5pbXBvcnQgTW9uc3RlclNwYXduZXIgZnJvbSAnLi4vLi4vd29ybGRnZW4vbW9uc3Rlci1zcGF3bmVyJztcbmltcG9ydCB7IFN0dW5uZWQgfSBmcm9tICcuL2NvbmRpdGlvbnMnO1xuaW1wb3J0IFJvbGwgZnJvbSAnLi4vLi4vbGliL2RpY2Utcm9sbGVyJztcblxuLyogbW9uc3RlcnMgY2FuIGF0dGFjayB3aXRoIHRoaXMgKi9cbmNsYXNzIEF0dGFja3NCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFByaW9yaXR5LkRFRkVOU0UpOyB9XG4gIGFjdChtZSkge1xuICAgIHJldHVybiAhbWUudHJ5QXR0YWNrKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEF0dGFja3MgPSAoKSA9PiBuZXcgQXR0YWNrc0JlaGF2aW9yKCk7XG5cbmNsYXNzIFRlbGVwb3J0c1doZW5IaXRCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IocGVyY2VudCA9IDEwMCkge1xuICAgIHN1cGVyKFByaW9yaXR5LkRFRkVSKTtcbiAgICB0aGlzLnBlcmNlbnQgPSBwZXJjZW50O1xuICB9XG4gIHRha2VEYW1hZ2UobWUpIHtcbiAgICBpZihST1QuUk5HLmdldFBlcmNlbnRhZ2UoKSA+IHRoaXMucGVyY2VudCkgcmV0dXJuO1xuICAgIEdhbWVTdGF0ZS53b3JsZC5wbGFjZUVudGl0eUF0UmFuZG9tTG9jYXRpb24obWUpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBUZWxlcG9ydHNXaGVuSGl0ID0gKHBlcmNlbnQpID0+IG5ldyBUZWxlcG9ydHNXaGVuSGl0QmVoYXZpb3IocGVyY2VudCk7XG5cbi8qIGhpdHRpbmcgaW4gbWVsZWUgcmFuZ2Ugd2lsbCBzdHVuIHlvdSAqL1xuY2xhc3MgUGFyYWx5emVzV2hlbkhpdEJlaGF2aW9yIGV4dGVuZHMgQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3RvcihwZXJjZW50ID0gMTAwLCByYW5nZSA9IDIpIHtcbiAgICBzdXBlcihQcmlvcml0eS5ERUZFUik7XG4gICAgdGhpcy5wZXJjZW50ID0gcGVyY2VudDtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gIH1cbiAgdGFrZURhbWFnZShtZSwgYXR0YWNrZXIpIHtcbiAgICBpZihST1QuUk5HLmdldFBlcmNlbnRhZ2UoKSA+IHRoaXMucGVyY2VudCB8fCBtZS5kaXN0QmV0d2VlbihhdHRhY2tlcikgPiB0aGlzLnJhbmdlKSByZXR1cm47XG4gICAgY29uc3QgdHVybnMgPSBSb2xsKCcxZDUwICsgNTAnKTtcbiAgICBhdHRhY2tlci5hZGRVbmlxdWVCZWhhdmlvcihTdHVubmVkKHR1cm5zKSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFBhcmFseXplc1doZW5IaXQgPSAocGVyY2VudCwgcmFuZ2UpID0+IG5ldyBQYXJhbHl6ZXNXaGVuSGl0QmVoYXZpb3IocGVyY2VudCwgcmFuZ2UpO1xuXG5jbGFzcyBTdGVhbHNCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IocGVyY2VudCA9IDEwMCkge1xuICAgIHN1cGVyKFByaW9yaXR5LkFMV0FZUyk7XG4gICAgdGhpcy5wZXJjZW50ID0gcGVyY2VudDtcbiAgfVxuICBhY3QobWUpIHtcbiAgICBpZihST1QuUk5HLmdldFBlcmNlbnRhZ2UoKSA+IHRoaXMucGVyY2VudCkgcmV0dXJuO1xuICAgIGxldCBkaWRTdGVhbCA9IGZhbHNlO1xuICAgIGxldCBpdGVtID0gbnVsbDtcbiAgICBjb25zdCBlbnRpdGllcyA9IEdhbWVTdGF0ZS53b3JsZC5nZXRWYWxpZEVudGl0aWVzSW5SYW5nZShtZS54LCBtZS55LCBtZS56LCAxLCBlbnQgPT4gbWUuY2FuQXR0YWNrKGVudCkpO1xuICAgIF8uZWFjaChlbnRpdGllcywgZW50ID0+IHtcbiAgICAgIGl0ZW0gPSBfLnNhbXBsZShlbnQuaW52ZW50b3J5KTtcbiAgICAgIGlmKCFpdGVtKSByZXR1cm47XG4gICAgICBkaWRTdGVhbCA9IGVudDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIGlmKGRpZFN0ZWFsKSB7XG4gICAgICBNZXNzYWdlUXVldWUuYWRkKHsgbWVzc2FnZTogYCR7bWUubmFtZX0gc3RvbGUgJHtpdGVtLm5hbWV9IGZyb20gJHtkaWRTdGVhbC5uYW1lfSFgLCB0eXBlOiBNZXNzYWdlVHlwZXMuQ09NQkFUIH0pO1xuICAgICAgZGlkU3RlYWwucmVtb3ZlRnJvbUludmVudG9yeShpdGVtKTtcbiAgICAgIG1lLmFkZFRvSW52ZW50b3J5KGl0ZW0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgU3RlYWxzID0gKCkgPT4gbmV3IFN0ZWFsc0JlaGF2aW9yKCk7XG5cbmNsYXNzIFNwbGl0c1doZW5IaXRCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IocGVyY2VudCA9IDEwMCkge1xuICAgIHN1cGVyKFByaW9yaXR5LkFMV0FZUyk7XG4gICAgdGhpcy5wZXJjZW50ID0gcGVyY2VudDtcbiAgfVxuICB0YWtlRGFtYWdlKG1lKSB7XG4gICAgaWYoUk9ULlJORy5nZXRQZXJjZW50YWdlKCkgPiB0aGlzLnBlcmNlbnQgfHwgbWUuaHAuYXRNaW4oKSkgcmV0dXJuO1xuICAgIGNvbnN0IHZhbGlkVGlsZXMgPSBHYW1lU3RhdGUud29ybGQuZ2V0VmFsaWRUaWxlc0luUmFuZ2UobWUueCwgbWUueSwgbWUueiwgMSwgKHRpbGUpID0+IEdhbWVTdGF0ZS53b3JsZC5pc1RpbGVFbXB0eSh0aWxlLngsIHRpbGUueSwgdGlsZS56KSk7XG4gICAgY29uc3QgY2hvc2VuVGlsZSA9IF8uc2FtcGxlKHZhbGlkVGlsZXMpO1xuXG4gICAgaWYoIWNob3NlblRpbGUpIHJldHVybjtcblxuICAgIGNvbnN0IG5ld1NwYXduID0gTW9uc3RlclNwYXduZXIuc3Bhd25TaW5nbGUobWUuX25hbWUsIGNob3NlblRpbGUpO1xuICAgIGlmKCFuZXdTcGF3bikgcmV0dXJuO1xuICAgIGNvbnN0IG5ld0hwID0gTWF0aC5mbG9vcihtZS5ocC5jdXIgLyAyKTtcbiAgICBtZS5ocC5fc2V0KG5ld0hwKTtcbiAgICBuZXdTcGF3bi5ocC5fc2V0KG5ld0hwKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgU3BsaXRzV2hlbkhpdCA9IChwZXJjZW50KSA9PiBuZXcgU3BsaXRzV2hlbkhpdEJlaGF2aW9yKHBlcmNlbnQpOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSb2xsIGZyb20gJy4uLy4uL2xpYi9kaWNlLXJvbGxlcic7XG5pbXBvcnQgQmVoYXZpb3IsIHsgUHJpb3JpdHkgfSBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9iZWhhdmlvcic7XG5pbXBvcnQgTWVzc2FnZVF1ZXVlLCB7IE1lc3NhZ2VUeXBlcyB9IGZyb20gJy4uLy4uL2Rpc3BsYXkvbWVzc2FnZS1oYW5kbGVyJztcblxuLyogYmVpbmcgc3R1bm5lZCBzdWNrcyAqL1xuY2xhc3MgU3R1bm5lZEJlaGF2aW9yIGV4dGVuZHMgQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3RvcihudW1UdXJucyA9IDEpIHtcbiAgICBzdXBlcihQcmlvcml0eS5TVFVOKTtcbiAgICB0aGlzLnN0dW5UdXJucyA9IG51bVR1cm5zO1xuICB9XG4gIGFjdChtZSkge1xuICAgIGlmKHRoaXMuc3R1blR1cm5zIDw9IDApIHtcbiAgICAgIG1lLnJlbW92ZUJlaGF2aW9yKHRoaXMpO1xuICAgICAgTWVzc2FnZVF1ZXVlLmFkZCh7IG1lc3NhZ2U6IGAke21lLm5hbWV9IGlzIG5vIGxvbmdlciBzdHVubmVkLmAsIHR5cGU6IE1lc3NhZ2VUeXBlcy5DT01CQVQgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBNZXNzYWdlUXVldWUuYWRkKHsgbWVzc2FnZTogYCR7bWUubmFtZX0gaXMgc3R1bm5lZCFgLCB0eXBlOiBNZXNzYWdlVHlwZXMuQ09NQkFUIH0pO1xuICAgIHRoaXMuc3R1blR1cm5zLS07XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBTdHVubmVkID0gKG51bVR1cm5zKSA9PiBuZXcgU3R1bm5lZEJlaGF2aW9yKG51bVR1cm5zKTtcblxuLyogYmVpbmcgcG9pc29uZWQgYWxzbyBzdWNrcyAqL1xuY2xhc3MgUG9pc29uZWRCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IobnVtVHVybnMgPSAzKSB7XG4gICAgc3VwZXIoUHJpb3JpdHkuQUxXQVlTKTtcbiAgICB0aGlzLnBvaXNvblR1cm5zID0gbnVtVHVybnM7XG4gIH1cbiAgYWN0KG1lKSB7XG4gICAgaWYodGhpcy5wb2lzb25UdXJucyA8PSAwKSB7XG4gICAgICBtZS5yZW1vdmVCZWhhdmlvcih0aGlzKTtcbiAgICAgIE1lc3NhZ2VRdWV1ZS5hZGQoeyBtZXNzYWdlOiBgJHttZS5uYW1lfSBpcyBubyBsb25nZXIgcG9pc29uZWQuYCwgdHlwZTogTWVzc2FnZVR5cGVzLkNPTUJBVCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkYW1hZ2UgPSBSb2xsKCcxZDQnKTtcbiAgICBNZXNzYWdlUXVldWUuYWRkKHsgbWVzc2FnZTogYCR7bWUubmFtZX0gdGFrZXMgJHtkYW1hZ2V9IHBvaXNvbiBkYW1hZ2UhYCwgdHlwZTogTWVzc2FnZVR5cGVzLkNPTUJBVCB9KTtcbiAgICB0aGlzLnBvaXNvblR1cm5zLS07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFBvaXNvbmVkID0gKG51bVR1cm5zKSA9PiBuZXcgUG9pc29uZWRCZWhhdmlvcihudW1UdXJucyk7XG5cbi8qIGJlaW5nIHNlZHVjZWQgcmVhbGx5IHN1Y2tzICovXG5jbGFzcyBTZWR1Y2VkQmVoYXZpb3IgZXh0ZW5kcyBCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKG51bVR1cm5zID0gMikge1xuICAgIHN1cGVyKFByaW9yaXR5LlNUVU4pO1xuICAgIHRoaXMuc3R1blR1cm5zID0gbnVtVHVybnM7XG4gIH1cbiAgYWN0KG1lKSB7XG4gICAgbWUuYnJlYWtDb25kdWN0KCdjZWxpYmF0ZScpO1xuICAgIGlmKHRoaXMuc3R1blR1cm5zIDw9IDApIHtcbiAgICAgIG1lLnJlbW92ZUJlaGF2aW9yKHRoaXMpO1xuICAgICAgTWVzc2FnZVF1ZXVlLmFkZCh7IG1lc3NhZ2U6IGAke21lLm5hbWV9IGlzIG5vIGxvbmdlciBzZWR1Y2VkLmAsIHR5cGU6IE1lc3NhZ2VUeXBlcy5DT01CQVQgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnN0dW5UdXJucy0tO1xuICAgIE1lc3NhZ2VRdWV1ZS5hZGQoeyBtZXNzYWdlOiBgJHttZS5uYW1lfSBpcyBzZWR1Y2VkIWAsIHR5cGU6IE1lc3NhZ2VUeXBlcy5DT01CQVQgfSk7XG5cbiAgICBjb25zdCBpdGVtID0gXyhtZS5lcXVpcG1lbnQpLnZhbHVlcygpLmZsYXR0ZW4oKS5zYW1wbGUoKTtcbiAgICBpZighaXRlbSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgbWUudW5lcXVpcChpdGVtKTtcbiAgICBtZS5kcm9wSXRlbShpdGVtKTtcblxuICAgIE1lc3NhZ2VRdWV1ZS5hZGQoeyBtZXNzYWdlOiBgJHttZS5uYW1lfSBkcm9wcGVkICR7aXRlbS5uYW1lfSFgLCB0eXBlOiBNZXNzYWdlVHlwZXMuQ09NQkFUIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgU2VkdWNlZCA9IChudW1UdXJucykgPT4gbmV3IFNlZHVjZWRCZWhhdmlvcihudW1UdXJucyk7IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJPVCBmcm9tICdyb3QtanMnO1xuaW1wb3J0IFJvbGwgZnJvbSAnLi4vLi4vbGliL2RpY2Utcm9sbGVyJztcbmltcG9ydCBCZWhhdmlvciwgeyBQcmlvcml0eSB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2JlaGF2aW9yJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vaW5pdC9nYW1lc3RhdGUnO1xuaW1wb3J0IE1lc3NhZ2VRdWV1ZSwgeyBNZXNzYWdlVHlwZXMgfSBmcm9tICcuLi8uLi9kaXNwbGF5L21lc3NhZ2UtaGFuZGxlcic7XG5pbXBvcnQgeyBHb2xkLCBDb3Jwc2UgfSBmcm9tICcuLi9pdGVtcy9fc3BlY2lhbCc7XG5cbi8qIGRpZSBhZnRlciBhIHBlcmlvZCBvZiB0aW1lICovXG5jbGFzcyBLaWxsc1NlbGZBZnRlclBlcmlvZE9mVGltZUJlaGF2aW9yIGV4dGVuZHMgQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3Rvcih0dXJucyA9IDUwKSB7XG4gICAgc3VwZXIoUHJpb3JpdHkuREVGRVIpO1xuICAgIHRoaXMudHVybnMgPSB0dXJucztcbiAgfVxuICBhY3QobWUpIHtcbiAgICBpZih0aGlzLnR1cm5zLS0gPiAwKSByZXR1cm47XG4gICAgbWUuZGllKHsgbmFtZTogJ3RpbWUnIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBLaWxsc1NlbGZBZnRlclBlcmlvZE9mVGltZSA9ICh0dXJucykgPT4gbmV3IEtpbGxzU2VsZkFmdGVyUGVyaW9kT2ZUaW1lQmVoYXZpb3IodHVybnMpO1xuXG4vKiBkcm9wIGNvbnRlbnRzIG9uIGRlYXRoICovXG5jbGFzcyBEcm9wc0l0ZW1zQmVoYXZpb3IgZXh0ZW5kcyBCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihQcmlvcml0eS5ERUZFUik7IH1cbiAgZGllKG1lKSB7XG4gICAgY29uc3QgZXF1aXBwZWQgPSBfKG1lLmVxdWlwbWVudCkudmFsdWVzKCkuZmxhdHRlbigpLnZhbHVlKCk7XG4gICAgXy5lYWNoKGVxdWlwcGVkLCBpdGVtID0+IG1lLnVuZXF1aXAoaXRlbSkpO1xuICAgIF8uZWFjaChtZS5pbnZlbnRvcnksIChpdGVtKSA9PiB7XG4gICAgICBtZS5kcm9wSXRlbShpdGVtKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRHJvcHNJdGVtcyA9ICgpID0+IG5ldyBEcm9wc0l0ZW1zQmVoYXZpb3IoKTtcblxuLyogbW9uc3RlcnMgbGVhdmUgYSBjb3Jwc2UgKi9cbmNsYXNzIExlYXZlc0NvcnBzZUJlaGF2aW9yIGV4dGVuZHMgQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3Rvcihkcm9wUGVyY2VudCA9IDEwMCkge1xuICAgIHN1cGVyKFByaW9yaXR5LkRFRkVSKTtcbiAgICB0aGlzLmRyb3BQZXJjZW50ID0gZHJvcFBlcmNlbnQ7XG4gIH1cbiAgZGllKG1lKSB7XG4gICAgaWYoUk9ULlJORy5nZXRQZXJjZW50YWdlKCkgPiB0aGlzLmRyb3BQZXJjZW50KSByZXR1cm47XG4gICAgY29uc3QgY29ycHNlID0gbmV3IENvcnBzZSh7IG1vbnN0ZXJOYW1lOiBtZS5uYW1lLCBnbHlwaDogeyBmZzogbWUuZ2x5cGguZmcgfSB9KTtcbiAgICBHYW1lU3RhdGUud29ybGQubW92ZUl0ZW0oY29ycHNlLCBtZS54LCBtZS55LCBtZS56KTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTGVhdmVzQ29ycHNlID0gKHBlcmNlbnQpID0+IG5ldyBMZWF2ZXNDb3Jwc2VCZWhhdmlvcihwZXJjZW50KTtcblxuLyogc29tZSB0aGluZ3MgZHJvcCBnb2xkICovXG5jbGFzcyBEcm9wc0dvbGRCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IoZ29sZCkge1xuICAgIHN1cGVyKFByaW9yaXR5LkRFRkVSKTtcbiAgICB0aGlzLmdvbGREcm9wID0gZ29sZDtcbiAgfVxuICBkaWUobWUpIHtcbiAgICBjb25zdCBkcm9wcGVkR29sZCA9IFJvbGwodGhpcy5nb2xkRHJvcCk7XG4gICAgY29uc3QgZ29sZEl0ZW0gPSBuZXcgR29sZChkcm9wcGVkR29sZCArIG1lLmdvbGQpO1xuICAgIGlmKGdvbGRJdGVtLmdvbGRWYWx1ZSA9PT0gMCkgcmV0dXJuO1xuICAgIEdhbWVTdGF0ZS53b3JsZC5tb3ZlSXRlbShnb2xkSXRlbSwgbWUueCwgbWUueSwgbWUueik7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IERyb3BzR29sZCA9IChnb2xkKSA9PiBuZXcgRHJvcHNHb2xkQmVoYXZpb3IoZ29sZCk7XG5cbi8qIGV4cGxvZGVzIHVwb24gZGVhdGguIGNhbiBiZSBwcmV0dHkgZGFuZ2Vyb3VzICovXG5jbGFzcyBFeHBsb2Rlc0JlaGF2aW9yIGV4dGVuZHMgQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3Rvcihyb2xsID0gJzFkNCcsIHJhbmdlID0gMSwgcGVyY2VudCA9IDEwMCkge1xuICAgIHN1cGVyKFByaW9yaXR5LkRFRkVSKTtcbiAgICB0aGlzLnJvbGwgPSByb2xsO1xuICAgIHRoaXMucGVyY2VudCA9IHBlcmNlbnQ7XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICB9XG5cbiAgZGllKG1lKSB7XG4gICAgaWYoUk9ULlJORy5nZXRQZXJjZW50YWdlKCkgPiB0aGlzLnBlcmNlbnQpIHtcbiAgICAgIE1lc3NhZ2VRdWV1ZS5hZGQoeyBtZXNzYWdlOiBgJHttZS5uYW1lfSBleHBsb2RlcyBhIGxpdHRsZSBiaXQuYCwgdHlwZTogTWVzc2FnZVR5cGVzLkNPTUJBVCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgTWVzc2FnZVF1ZXVlLmFkZCh7IG1lc3NhZ2U6IGAke21lLm5hbWV9IHZpb2xlbnRseSBleHBsb2RlcyFgLCB0eXBlOiBNZXNzYWdlVHlwZXMuQ09NQkFUIH0pO1xuICAgIF8uZWFjaChHYW1lU3RhdGUud29ybGQuZ2V0VmFsaWRFbnRpdGllc0luUmFuZ2UobWUueCwgbWUueSwgbWUueiwgdGhpcy5yYW5nZSksIChlbnRpdHkpID0+IHtcbiAgICAgIGlmKG1lID09PSBlbnRpdHkgfHwgZW50aXR5LmhwLmF0TWluKCkpIHJldHVybjsgLy8gaW5maW5pdGUgbG9vcCBwcmV2ZW50aW9uXG4gICAgICBlbnRpdHkudGFrZURhbWFnZShSb2xsKHRoaXMucm9sbCksIG1lKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRXhwbG9kZXMgPSAocm9sbCwgcmFuZ2UsIHBlcmNlbnQpID0+IG5ldyBFeHBsb2Rlc0JlaGF2aW9yKHJvbGwsIHJhbmdlLCBwZXJjZW50KTtcblxuLyogZHJvcCBjb250ZW50cyBvbiBkZWF0aCAqL1xuY2xhc3MgTGlmZVNhdmVCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IobnVtVXNlcykgeyBzdXBlcihQcmlvcml0eS5BTFdBWVMpOyB0aGlzLm51bVVzZXMgPSBudW1Vc2VzOyB9XG4gIHRha2VEYW1hZ2UobWUpIHtcbiAgICBpZihtZS5ocC5hdE1pbigpKSB7XG4gICAgICBtZS5ocC50b01heCgpO1xuICAgICAgTWVzc2FnZVF1ZXVlLmFkZCh7IG1lc3NhZ2U6IGAke21lLm5hbWV9J3MgbGlmZSB3YXMgc2F2ZWQhYCwgdHlwZTogTWVzc2FnZVR5cGVzLkNPTUJBVCB9KTtcbiAgICAgIG1lLmJyZWFrQ29uZHVjdCgnbGlmZVNhdmUnKTtcblxuICAgICAgaWYodGhpcy5udW1Vc2VzLS0gPD0gMCkgbWUucmVtb3ZlQmVoYXZpb3IodGhpcyk7XG5cbiAgICAgIGlmKHRoaXMuX2l0ZW1SZWYpIHtcbiAgICAgICAgdGhpcy5faXRlbVJlZi5kaXNpbnRlZ3JhdGUobWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTGlmZVNhdmUgPSAobnVtVXNlcyA9IDEpID0+IG5ldyBMaWZlU2F2ZUJlaGF2aW9yKG51bVVzZXMpOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCZWhhdmlvciwgeyBQcmlvcml0eSB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2JlaGF2aW9yJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vaW5pdC9nYW1lc3RhdGUnO1xuaW1wb3J0IE1lc3NhZ2VRdWV1ZSwgeyBNZXNzYWdlVHlwZXMgfSBmcm9tICcuLi8uLi9kaXNwbGF5L21lc3NhZ2UtaGFuZGxlcic7XG5cbi8qIHJldHJpZXZlIGl0ZW1zIGZyb20gdGhlIGdyb3VuZCAqL1xuY2xhc3MgUGlja1VwSXRlbXNCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IoYmxhY2tsaXN0ID0gW10sIHdoaXRlbGlzdCA9IFtdKSB7XG4gICAgc3VwZXIoUHJpb3JpdHkuSU5URVJBQ1QpO1xuICAgIHRoaXMuYmxhY2tsaXN0ID0gYmxhY2tsaXN0O1xuICAgIHRoaXMud2hpdGVsaXN0ID0gd2hpdGVsaXN0O1xuICB9XG4gIGFjdChtZSkge1xuICAgIGNvbnN0IGl0ZW1zID0gR2FtZVN0YXRlLndvcmxkLmdldEl0ZW1zQXQobWUueCwgbWUueSwgbWUueik7XG4gICAgXyhpdGVtcykuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0uX2NhblBpY2tVcFR1cm4gfHwgaXRlbS5fY2FuUGlja1VwVHVybiA8PSBtZS5jdXJyZW50VHVybikuZWFjaChpdGVtID0+IHtcbiAgICAgIGlmKHRoaXMud2hpdGVsaXN0Lmxlbmd0aCAmJiAhXy5jb250YWlucyh0aGlzLndoaXRlbGlzdCwgaXRlbS5nZXRUeXBlKCkpKSByZXR1cm47XG4gICAgICBpZih0aGlzLmJsYWNrbGlzdC5sZW5ndGggJiYgXy5jb250YWlucyh0aGlzLmJsYWNrbGlzdCwgaXRlbS5nZXRUeXBlKCkpKSByZXR1cm47XG4gICAgICBHYW1lU3RhdGUud29ybGQucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgIG1lLmFkZFRvSW52ZW50b3J5KGl0ZW0pO1xuICAgICAgTWVzc2FnZVF1ZXVlLmFkZCh7IG1lc3NhZ2U6IGAke21lLm5hbWV9IHBpY2tlZCB1cCAke2l0ZW0ubmFtZX0uYCwgdHlwZTogTWVzc2FnZVR5cGVzLklURU0gfSk7XG4gICAgfSkudmFsdWUoKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUGlja1VwSXRlbXMgPSAoYmwsIHdsKSA9PiBuZXcgUGlja1VwSXRlbXNCZWhhdmlvcihibCwgd2wpO1xuXG4vKiBpbnRlcmFjdHMgd2l0aCBldmVyeXRoaW5nICovXG5jbGFzcyBJbnRlcmFjdHNCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFByaW9yaXR5LklOVEVSQUNUKTsgfVxuICBhY3QobWUpIHtcbiAgICBjb25zdCB0aWxlcyA9IEdhbWVTdGF0ZS53b3JsZC5nZXRBbGxUaWxlc0luUmFuZ2UobWUueCwgbWUueSwgbWUueiwgMSk7XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRpbGUgPSB0aWxlc1tpXTtcblxuICAgICAgaWYodGlsZS5jYW5JbnRlcmFjdCAmJiB0aWxlLmludGVyYWN0ICYmIHRpbGUuY2FuSW50ZXJhY3QobWUpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHRpbGUuaW50ZXJhY3QobWUpO1xuICAgICAgICBpZihtc2cpIE1lc3NhZ2VRdWV1ZS5hZGQoeyBtZXNzYWdlOiBtc2csIHR5cGU6IE1lc3NhZ2VUeXBlcy5EVU5HRU9OIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBJbnRlcmFjdHMgPSAoKSA9PiBuZXcgSW50ZXJhY3RzQmVoYXZpb3IoKTtcblxuLyogYnJlYWtzIGRvd24gZG9vcnMgdGhhdCBpdCBmaW5kcyAqL1xuY2xhc3MgQnJlYWtzRG9vcnNCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFByaW9yaXR5LklOVEVSQUNUKTsgfVxuICBhY3QoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5leHBvcnQgY29uc3QgQnJlYWtzRG9vcnMgPSAoKSA9PiBuZXcgQnJlYWtzRG9vcnNCZWhhdmlvcigpO1xuXG4vKiBvcGVucyBkb29ycyB0aGF0IGl0IGZpbmRzICovXG5jbGFzcyBPcGVuc0Rvb3JzQmVoYXZpb3IgZXh0ZW5kcyBCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihQcmlvcml0eS5JTlRFUkFDVCk7IH1cbiAgYWN0KG1lKSB7XG4gICAgY29uc3QgZG9vcnMgPSBHYW1lU3RhdGUud29ybGQuZ2V0VmFsaWRUaWxlc0luUmFuZ2UobWUueCwgbWUueSwgbWUueiwgMSwgKHRpbGUpID0+IHRpbGUuY29uc3RydWN0b3IubmFtZSA9PT0gJ0Rvb3InICYmIHRpbGUuZGVuc2l0eSk7XG4gICAgaWYoZG9vcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZG9vciA9IGRvb3JzWzBdO1xuICAgICAgZG9vci5pbnRlcmFjdChtZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBPcGVuc0Rvb3JzID0gKCkgPT4gbmV3IE9wZW5zRG9vcnNCZWhhdmlvcigpOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCZWhhdmlvciwgeyBQcmlvcml0eSB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2JlaGF2aW9yJztcblxuY2xhc3MgUmVnZW5lcmF0ZXNIcEJlaGF2aW9yIGV4dGVuZHMgQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3RvcihhbW91bnQgPSAxKSB7XG4gICAgc3VwZXIoUHJpb3JpdHkuQUxXQVlTKTtcbiAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgfVxuXG4gIGFjdChtZSkge1xuICAgIGlmKG1lLmN1cnJlbnRUdXJuICUgbWUuZ2V0UmVnZW5IcCgpID09PSAwKSBtZS5ocC5hZGQodGhpcy5hbW91bnQpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBSZWdlbmVyYXRlc0hwID0gKCkgPT4gbmV3IFJlZ2VuZXJhdGVzSHBCZWhhdmlvcigpO1xuXG5jbGFzcyBSZWdlbmVyYXRlc01wQmVoYXZpb3IgZXh0ZW5kcyBCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKGFtb3VudCA9IDEpIHtcbiAgICBzdXBlcihQcmlvcml0eS5BTFdBWVMpO1xuICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xuICB9XG5cbiAgYWN0KG1lKSB7XG4gICAgaWYobWUuY3VycmVudFR1cm4gJSBtZS5nZXRSZWdlbk1wKCkgPT09IDApIG1lLm1wLmFkZCh0aGlzLmFtb3VudCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFJlZ2VuZXJhdGVzTXAgPSAoKSA9PiBuZXcgUmVnZW5lcmF0ZXNNcEJlaGF2aW9yKCk7XG5cbmNsYXNzIEhlYWxzQmVsb3dQZXJjZW50QmVoYXZpb3IgZXh0ZW5kcyBCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKHBlcmNlbnQgPSA1MCkge1xuICAgIHN1cGVyKFByaW9yaXR5LkhFQUwpO1xuICAgIHRoaXMuaGVhbFBlcmNlbnQgPSBwZXJjZW50O1xuICB9XG4gIGFjdChtZSkge1xuICAgIGlmKG1lLmhwLmd0UGVyY2VudCh0aGlzLmhlYWxQZXJjZW50KSkgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgaGVhbEl0ZW1zID0gXy5maWx0ZXIobWUuaW52ZW50b3J5LCAoaXRlbSkgPT4gaXRlbS5oZWFsUm9sbCAmJiAgaXRlbS5jYW5Vc2UobWUpKTtcbiAgICBpZihoZWFsSXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBoZWFsSXRlbSA9IF8uc2FtcGxlKGhlYWxJdGVtcyk7XG4gICAgaGVhbEl0ZW0udXNlKG1lKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEhlYWxzQmVsb3dQZXJjZW50ID0gKHBlcmNlbnQpID0+IG5ldyBIZWFsc0JlbG93UGVyY2VudEJlaGF2aW9yKHBlcmNlbnQpOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCZWhhdmlvciwgeyBQcmlvcml0eSB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2JlaGF2aW9yJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vaW5pdC9nYW1lc3RhdGUnO1xuXG5jb25zdCBpc1RhcmdldEJhZCA9IChtZSkgPT4ge1xuICByZXR1cm4gIW1lLnRhcmdldCB8fCAobWUudGFyZ2V0ICYmIG1lLnRhcmdldC5ocC5hdE1pbigpKSB8fCAobWUudGFyZ2V0ICYmIG1lLnRhcmdldC56ICE9PSBtZS56KTtcbn07XG5cbi8vIHJldGFyZ2V0IGFuZCBmaW5kIGEgbmV3IHBsYXllciB0byBhdHRhY2tcbmNvbnN0IHRhcmdldE5ld1BsYXllciA9IChtZSkgPT4ge1xuICBpZihpc1RhcmdldEJhZChtZSkpIHtcbiAgICBtZS5zZXRUYXJnZXQoXyhHYW1lU3RhdGUucGxheWVycykucmVqZWN0KHBsYXllciA9PiBwbGF5ZXIuaHAuYXRNaW4oKSkuc2FtcGxlKCkpO1xuICB9XG5cbiAgaWYoIW1lLnRhcmdldCkgcmV0dXJuIGZhbHNlOyAvLyB0aGV5IGNhbiB3YWl0LCB5b3UgbWF5IGNvbWUgYmFja1xuXG4gIHJldHVybiB0cnVlOyAvLyBzdWNjZXNzZnVsIHJldGFyZ2V0XG59O1xuXG4vKiBhbHdheXMgc2Vla3MgYSB0YXJnZXQgKi9cbmNsYXNzIEJsb29kdGhpcnN0eUJlaGF2aW9yIGV4dGVuZHMgQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoUHJpb3JpdHkuVEFSR0VUKTsgfVxuICBhY3QobWUpIHtcbiAgICBpZighdGFyZ2V0TmV3UGxheWVyKG1lKSkgcmV0dXJuO1xuICAgIG1lLnN0ZXBUb3dhcmRzKG1lLnRhcmdldCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5leHBvcnQgY29uc3QgQmxvb2R0aGlyc3R5ID0gKCkgPT4gbmV3IEJsb29kdGhpcnN0eUJlaGF2aW9yKCk7XG5cbi8qIHNlZWtzIGEgdGFyZ2V0IGlmIHRoZXkncmUgd2l0aGluIHZpc2lvbiByYW5nZSAqL1xuY2xhc3MgU2Vla3NUYXJnZXRJblNpZ2h0QmVoYXZpb3IgZXh0ZW5kcyBCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihQcmlvcml0eS5NT1ZFKTsgfVxuICBhY3QobWUpIHtcbiAgICBjb25zdCBwb3NzaWJsZVRhcmdldHMgPSBbXTtcblxuICAgIEdhbWVTdGF0ZS53b3JsZC5mb3ZbbWUuel0uY29tcHV0ZShcbiAgICAgIG1lLngsIG1lLnksIG1lLmdldFNpZ2h0KCksXG4gICAgICAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBlbnRpdHkgPSBHYW1lU3RhdGUud29ybGQuZ2V0RW50aXR5KHgsIHksIG1lLnopO1xuICAgICAgICBpZighZW50aXR5IHx8ICFtZS5jYW5BdHRhY2soZW50aXR5KSB8fCAhbWUuY2FuU2VlKGVudGl0eSkpIHJldHVybjtcbiAgICAgICAgcG9zc2libGVUYXJnZXRzLnB1c2goZW50aXR5KTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYobWUudGFyZ2V0ICYmIF8uY29udGFpbnMocG9zc2libGVUYXJnZXRzLCBtZS50YXJnZXQpKSB7XG4gICAgICBtZS5zdGVwVG93YXJkcyhtZS50YXJnZXQpO1xuXG4gICAgfSBlbHNlIGlmKHBvc3NpYmxlVGFyZ2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICBtZS5zZXRUYXJnZXQoXy5zYW1wbGUocG9zc2libGVUYXJnZXRzKSk7XG4gICAgICBtZS5zdGVwVG93YXJkcyhtZS50YXJnZXQpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1lLnN0ZXBSYW5kb21seSgpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IFNlZWtzVGFyZ2V0SW5TaWdodCA9ICgpID0+IG5ldyBTZWVrc1RhcmdldEluU2lnaHRCZWhhdmlvcigpO1xuXG5jbGFzcyBTZWVrc1RhcmdldFZpYUhlYXJpbmdCZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IocmFuZ2UgPSA1MCkge1xuICAgIHN1cGVyKFByaW9yaXR5Lk1PVkUpO1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgfVxuICBhY3QobWUpIHtcbiAgICBpZighbWUudGFyZ2V0IHx8IGlzVGFyZ2V0QmFkKG1lKSkgcmV0dXJuIHRydWU7XG4gICAgbWUuc3RlcFRvd2FyZHMobWUudGFyZ2V0KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGVhcihtZSwgcG90ZW50aWFsVGFyZ2V0KSB7XG4gICAgY29uc3QgZGlzdEJldHdlZW5UYXJnZXQgPSBtZS5kaXN0QmV0d2Vlbihwb3RlbnRpYWxUYXJnZXQpO1xuICAgIGlmKGRpc3RCZXR3ZWVuVGFyZ2V0ID4gdGhpcy5yYW5nZSkgcmV0dXJuO1xuICAgIGlmKCFtZS50YXJnZXQpIHtcbiAgICAgIG1lLnNldFRhcmdldChwb3RlbnRpYWxUYXJnZXQpO1xuICAgIH0gZWxzZSBpZihkaXN0QmV0d2VlblRhcmdldCA8IG1lLmRpc3RCZXR3ZWVuKG1lLnRhcmdldCkpIHtcbiAgICAgIG1lLnNldFRhcmdldChwb3RlbnRpYWxUYXJnZXQpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGNvbnN0IFNlZWtzVGFyZ2V0VmlhSGVhcmluZyA9IChyYW5nZSkgPT4gbmV3IFNlZWtzVGFyZ2V0VmlhSGVhcmluZ0JlaGF2aW9yKHJhbmdlKTtcblxuLyogd2FuZGVycyBhcm91bmQgYWltbGVzc2x5ICovXG5jbGFzcyBXYW5kZXJzQmVoYXZpb3IgZXh0ZW5kcyBCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihQcmlvcml0eS5NT1ZFKTsgfVxuICBhY3QobWUpIHtcbiAgICBtZS5zdGVwUmFuZG9tbHkoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBXYW5kZXJzID0gKCkgPT4gbmV3IFdhbmRlcnNCZWhhdmlvcigpO1xuXG5jbGFzcyBFeHBsb3Jlc0R1bmdlb25CZWhhdmlvciBleHRlbmRzIEJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoUHJpb3JpdHkuTU9WRSk7XG4gICAgdGhpcy50YXJnZXRzID0gW107XG4gIH1cblxuICBnZXRDZW50cmFsQ29vcmRzKHJvb20pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcm9vbS5feDEgKyB+figocm9vbS5feDIgLSByb29tLl94MSkvMiksXG4gICAgICB5OiByb29tLl95MSArIH5+KChyb29tLl95MiAtIHJvb20uX3kxKS8yKVxuICAgIH07XG4gIH1cblxuICBjaGVja0ZvclJvb21BY3Rpdml0eShtZSwgaWdub3JlQ3VycmVudCA9IHRydWUpIHtcbiAgICAvLyBtYXJrIHRoZSBjdXJyZW50IHJvb20sIGlmIGFueSwgYXMgZXhwbG9yZWRcbiAgICBjb25zdCBjdXJyZW50Um9vbSA9IF8uZmluZChHYW1lU3RhdGUud29ybGQudGlsZXNbbWUuel0ucm9vbXMsIHJvb20gPT4ge1xuICAgICAgcmV0dXJuIHJvb20uX3gxIDwgbWUueCAmJiByb29tLl94MiA+IG1lLnggJiZcbiAgICAgICAgcm9vbS5feTEgPCBtZS55ICYmIHJvb20uX3kyID4gbWUueTtcbiAgICB9KTtcblxuICAgIGlmKCFjdXJyZW50Um9vbSB8fCAoaWdub3JlQ3VycmVudCAmJiBfLmlzRXF1YWwodGhpcy50YXJnZXQsIHRoaXMuZ2V0Q2VudHJhbENvb3JkcyhjdXJyZW50Um9vbSkpKSkgcmV0dXJuO1xuICAgIGN1cnJlbnRSb29tLmlzRXhwbG9yZWQgPSB0cnVlO1xuICB9XG5cbiAgcmVidWlsZFBhdGhUb1RhcmdldChtZSkge1xuICAgIHRoaXMucGF0aFRvVGFyZ2V0ID0gbWUuc2ltcGxlUGF0aGluZ01hcCh0aGlzLnRhcmdldC54LCB0aGlzLnRhcmdldC55KTtcbiAgfVxuXG4gIGJ1aWxkTGlzdE9mVGFyZ2V0cyhtZSkge1xuICAgIHRoaXMudGFyZ2V0cyA9IF8ubWFwKEdhbWVTdGF0ZS53b3JsZC50aWxlc1ttZS56XS5yb29tcywgcm9vbSA9PiB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuZ2V0Q2VudHJhbENvb3Jkcyhyb29tKTtcbiAgICAgIHJvb20ueCA9IHg7XG4gICAgICByb29tLnkgPSB5O1xuICAgICAgcm9vbS5pc1Jvb20gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJvb207XG4gICAgfSk7XG4gIH1cblxuICBmaW5kTWF0Y2hpbmdUYXJnZXQoKSB7XG4gICAgcmV0dXJuIF8uZmluZFdoZXJlKHRoaXMudGFyZ2V0cywgdGhpcy50YXJnZXQpO1xuICB9XG5cbiAgYWRkVGFyZ2V0KHRhcmdldHMpIHtcbiAgICB0aGlzLnRhcmdldHMudW5zaGlmdCguLi50YXJnZXRzKTtcbiAgICB0aGlzLnRhcmdldHMgPSBfLnVuaXEodGhpcy50YXJnZXRzKTtcbiAgfVxuXG4gIHJlbW92ZVRhcmdldCh0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldHMgPSBfLndpdGhvdXQodGhpcy50YXJnZXRzLCB0YXJnZXQpO1xuICB9XG5cbiAgYWN0KG1lKSB7XG5cbiAgICBpZighbWUuX3BhdGgpIHJldHVybjtcblxuICAgIGlmKCF0aGlzLnRhcmdldHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJ1aWxkTGlzdE9mVGFyZ2V0cyhtZSk7XG4gICAgfVxuXG4gICAgLy8gdGFrZSBhIHJhbmRvbSBzdGVwIGlmIHlvdSd2ZSBleHBsb3JlZCBldmVyeXRoaW5nXG4gICAgaWYoXy5hbGwodGhpcy50YXJnZXRzLCByb29tID0+IHJvb20uaXNFeHBsb3JlZCkpIHtcbiAgICAgIG1lLnN0ZXBSYW5kb21seSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lU2lnaHQgPSBtZS5nZXRTaWdodCgpO1xuXG4gICAgLy8gY2hlY2sgZm9yIHN0YWlycyBkb3duIGJ1dCBvbmx5IGlmIHlvdSdyZSBub3Qgb24gdGhlIGxhc3QgZmxvb3IgKGJlY2F1c2UgdGhvc2Ugc3RhaXJzIGRvd24gZG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhleSdyZSB0aGVyZSlcbiAgICB0aGlzLnN0YWlyc0luUmFuZ2UgPSBHYW1lU3RhdGUud29ybGQuZ2V0VmFsaWRUaWxlc0luUmFuZ2UobWUueCwgbWUueSwgbWUueiwgbWVTaWdodCwgdGlsZSA9PiB0aWxlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTdGFpcnNEb3duJylbMF07XG4gICAgaWYodGhpcy5zdGFpcnNJblJhbmdlICYmIEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3IgIT09IEdhbWVTdGF0ZS53b3JsZC5kZXB0aC0xKSB0aGlzLmFkZFRhcmdldChbdGhpcy5zdGFpcnNJblJhbmdlXSk7XG5cbiAgICBjb25zdCB0aWxlc1dpdGhJdGVtcyA9IEdhbWVTdGF0ZS53b3JsZC5nZXRWYWxpZFRpbGVzSW5SYW5nZShtZS54LCBtZS55LCBtZS56LCBtZVNpZ2h0LCB0aWxlID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gR2FtZVN0YXRlLndvcmxkLmdldEl0ZW1zQXQodGlsZS54LCB0aWxlLnksIG1lLnopO1xuICAgICAgcmV0dXJuIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDA7XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZFRhcmdldCh0aWxlc1dpdGhJdGVtcyk7XG5cbiAgICBjb25zdCBuZXh0VGFyZ2V0ID0gXy5maW5kKHRoaXMudGFyZ2V0cywgdCA9PiAhdC5pc0V4cGxvcmVkKTtcbiAgICB0aGlzLnRhcmdldCA9IHsgeDogbmV4dFRhcmdldC54LCB5OiBuZXh0VGFyZ2V0LnkgfTtcblxuICAgIGlmKCF0aGlzLmxhc3RUYXJnZXQgfHwgdGhpcy5sYXN0VGFyZ2V0ICYmICFfLmlzRXF1YWwodGhpcy50YXJnZXQsIHRoaXMubGFzdFRhcmdldCkpIHtcbiAgICAgIHRoaXMucmVidWlsZFBhdGhUb1RhcmdldChtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0VGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBubyB2YWxpZCBwYXRoIHRvIHRhcmdldC4uIHRyeSB3YW5kZXJpbmcgYXJvdW5kP1xuICAgIGlmKCFtZS5zdGVwVG93YXJkcyh0aGlzLnRhcmdldCwgdGhpcy5wYXRoVG9UYXJnZXQpKSB7XG4gICAgICBtZS5zdGVwUmFuZG9tbHkoKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoaXQgdGhlIHNwb3Qgd2UncmUgc3VwcG9zZWQgdG8gaGl0LCBjbGVhciBzb21lIHN0dWZmIHVwLlxuICAgIGlmKHRoaXMudGFyZ2V0LnggPT09IG1lLnggJiYgdGhpcy50YXJnZXQueSA9PT0gbWUueSkge1xuICAgICAgdGhpcy5jaGVja0ZvclJvb21BY3Rpdml0eShtZSk7XG4gICAgICBjb25zdCB0YXJnZXRJdGVtID0gdGhpcy5maW5kTWF0Y2hpbmdUYXJnZXQoKTtcbiAgICAgIGlmKCF0YXJnZXRJdGVtLmlzUm9vbSkgdGhpcy5yZW1vdmVUYXJnZXQodGFyZ2V0SXRlbSk7XG4gICAgfVxuICB9XG5cbiAgc3RlcChtZSkge1xuICAgIHRoaXMuY2hlY2tGb3JSb29tQWN0aXZpdHkobWUsIGZhbHNlKTtcbiAgfVxuXG4gIGRlc2NlbmQobWUpIHtcbiAgICB0aGlzLmJ1aWxkTGlzdE9mVGFyZ2V0cyhtZSk7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBFeHBsb3Jlc0R1bmdlb24gPSAoKSA9PiBuZXcgRXhwbG9yZXNEdW5nZW9uQmVoYXZpb3IoKTtcblxuLyogaGFzIHZlcnkgbG91ZCBmb290c3RlcHMuIHByZXR0eSBtdWNoLCBvbmx5IHBsYXllcnMgaGF2ZSBvciBuZWVkIHRoaXMgKi9cbmNsYXNzIEFsZXJ0c09uU3RlcEJlaGF2aW9yIGV4dGVuZHMgQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoUHJpb3JpdHkuQUxXQVlTKTsgfVxuICBzdGVwKG1lKSB7XG4gICAgbWUuYWxlcnRBbGxJblJhbmdlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFsZXJ0c09uU3RlcCA9ICgpID0+IG5ldyBBbGVydHNPblN0ZXBCZWhhdmlvcigpOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcbmltcG9ydCBSb2xsIGZyb20gJy4uLy4uL2xpYi9kaWNlLXJvbGxlcic7XG5pbXBvcnQgeyBHb2xkIH0gZnJvbSAnLi4vaXRlbXMvX3NwZWNpYWwnO1xuaW1wb3J0ICogYXMgVHJhaXRzIGZyb20gJy4uL3RyYWl0cy9fYWxsJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vaW5pdC9nYW1lc3RhdGUnO1xuaW1wb3J0IEVmZmVjdCBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9lZmZlY3QnO1xuaW1wb3J0IE1vbnN0ZXJTcGF3bmVyIGZyb20gJy4uLy4uL3dvcmxkZ2VuL21vbnN0ZXItc3Bhd25lcic7XG5cbmNsYXNzIEZvdW50YWluRWZmZWN0IGV4dGVuZHMgRWZmZWN0IHt9XG5cbmV4cG9ydCBjbGFzcyBOb0VmZmVjdCBleHRlbmRzIEZvdW50YWluRWZmZWN0IHtcbiAgc3RhdGljIGdldCBwcm9iYWJpbGl0eSgpIHsgcmV0dXJuIDE5OyB9XG4gIHN0YXRpYyB1c2UoZW50aXR5KSB7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gZHJpbmtzIGZyb20gdGhlIGZvdW50YWluLCBidXQgdGhlIHRlcGlkIHdhdGVyIGlzIHRhc3RlbGVzcy5gKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRHJvcEdvbGQgZXh0ZW5kcyBGb3VudGFpbkVmZmVjdCB7XG4gIHN0YXRpYyBnZXQgcHJvYmFiaWxpdHkoKSB7IHJldHVybiA4OyB9XG4gIHN0YXRpYyB1c2UoZW50aXR5KSB7XG4gICAgY29uc3QgZ29sZCA9IG5ldyBHb2xkKFJvbGwoJzFkMTAwMCcpKTtcbiAgICBHYW1lU3RhdGUud29ybGQubW92ZUl0ZW0oZ29sZCwgZW50aXR5LngsIGVudGl0eS55LCBlbnRpdHkueik7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gaGVhcnMgdGhlIHNvdW5kIG9mIGdvbGQgZHJvcHBpbmcgdG8gdGhlIGdyb3VuZC5gKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29udGFtaW5hdGVkIGV4dGVuZHMgRm91bnRhaW5FZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuICAgIGNvbnN0IGhhc1BzblJzdCA9IGVudGl0eS5oYXNUcmFpdCgnUG9pc29uUmVzaXN0YW5jZScpO1xuICAgIGNvbnN0IGRhbWFnZVJvbGwgPSBoYXNQc25Sc3QgPyAnMWQ0JyA6ICcxZDEwJztcbiAgICBjb25zdCBhYnVzZXNTdGF0cyA9ICFoYXNQc25Sc3Q7XG4gICAgY29uc3QgbXNnID0gaGFzUHNuUnN0ID8gYCR7ZW50aXR5Lm5hbWV9IGRyYW5rIHdhdGVyIGZyb20gYSBuZWFyYnkgYXBwbGUgZmFybSBydW5vZmYgc3RyZWFtLmAgOiBgWXVjayEgJHtlbnRpdHkubmFtZX0gZHJhbmsgY29udGFtaW5hdGVkIHdhdGVyLmA7XG4gICAgaWYoYWJ1c2VzU3RhdHMpIHtcbiAgICAgIGVudGl0eS5hYnVzZSgnc3RyJywgJzFkMisxJyk7XG4gICAgICBlbnRpdHkuYWJ1c2UoJ2NvbicsICcxZDInKTtcbiAgICB9XG5cbiAgICBlbnRpdHkudGFrZURhbWFnZShSb2xsKGRhbWFnZVJvbGwpLCB7IG5hbWU6ICdmb3VudGFpbicgfSk7XG4gICAgdGhpcy5tc2coZW50aXR5LCBtc2cpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbHVycmVkVmlzaW9uIGV4dGVuZHMgRm91bnRhaW5FZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMjsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuICAgIGVudGl0eS5hZGRUcmFpdChUcmFpdHMuU2VlSW52aXNpYmxlKHsgbGV2ZWw6IDUgfSkpO1xuICAgIGVudGl0eS5leGVyY2lzZSgnd2lzJyk7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gdmlzaW9uIGJsdXJzLCB0aGVuIHJldHVybnMgc2hhcnBlciB0aGFuIGJlZm9yZS5gKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3Bhd25TbmFrZXMgZXh0ZW5kcyBGb3VudGFpbkVmZmVjdCB7XG4gIHN0YXRpYyBnZXQgcHJvYmFiaWxpdHkoKSB7IHJldHVybiAxOyB9XG4gIHN0YXRpYyB1c2UoZW50aXR5KSB7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gZHJpbmtzIGZyb20gdGhlIGZvdW50YWluLmApO1xuICAgIHRoaXMubXNnKGVudGl0eSwgYEFuIGVuZGxlc3Mgc3RyZWFtIG9mIHNuYWtlcyBwb3VycyBvdXQhYCk7XG4gICAgY29uc3Qgc3Bhd25lZCA9IFJvbGwoJzFkNSArIDEnKTtcblxuICAgIGNvbnN0IHZhbGlkVGlsZXMgPSBfLnNhbXBsZSh0aGlzLmdldEVtcHR5VGlsZXNJblJhbmdlKGVudGl0eSksIHNwYXduZWQpO1xuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNwYXduZWQ7IGkrKykge1xuICAgICAgaWYoIXZhbGlkVGlsZXNbaV0pIGNvbnRpbnVlO1xuICAgICAgTW9uc3RlclNwYXduZXIuc3Bhd25TaW5nbGUoJ3dhdGVyTW9jY2FzaW4nLCB2YWxpZFRpbGVzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0cmFuZ2VGZWVsaW5nIGV4dGVuZHMgRm91bnRhaW5FZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMzsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuICAgIHRoaXMubXNnKGVudGl0eSwgYCR7ZW50aXR5Lm5hbWV9IG1vbWVudGFyaWx5IGZlZWxzIHN0cmFuZ2UsIHRoZW4gaXQgcGFzc2VzLmApO1xuICAgIGVudGl0eS5leGVyY2lzZSgnd2lzJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEN1cnNlSXRlbXMgZXh0ZW5kcyBGb3VudGFpbkVmZmVjdCB7XG4gIHN0YXRpYyBnZXQgcHJvYmFiaWxpdHkoKSB7IHJldHVybiAyOyB9XG4gIHN0YXRpYyB1c2UoZW50aXR5KSB7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gZHJhbmsgc29tZSBiYWQgd2F0ZXIhYCk7XG4gICAgXy5lYWNoKGVudGl0eS5pbnZlbnRvcnksIGl0ZW0gPT4ge1xuICAgICAgaWYoUk9ULlJORy5nZXRQZXJjZW50YWdlKCkgPiAyMCkgcmV0dXJuO1xuICAgICAgaXRlbS5jdXJzZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTcGF3bkRlbW9uIGV4dGVuZHMgRm91bnRhaW5FZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuXG4gICAgY29uc3QgdmFsaWRUaWxlID0gXy5zYW1wbGUodGhpcy5nZXRFbXB0eVRpbGVzSW5SYW5nZShlbnRpdHkpKTtcblxuICAgIGlmKCF2YWxpZFRpbGUpIHJldHVybjtcbiAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSBzdW1tb25zIGEgZGVtb24gZnJvbSB0aGUgd2F0ZXIgcGxhbmUhYCk7XG4gICAgTW9uc3RlclNwYXduZXIuc3Bhd25TaW5nbGUoJ3dhdGVyRGVtb24nLCB2YWxpZFRpbGUpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTcGF3bk55bXBoIGV4dGVuZHMgRm91bnRhaW5FZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuXG4gICAgY29uc3QgdmFsaWRUaWxlID0gXy5zYW1wbGUodGhpcy5nZXRFbXB0eVRpbGVzSW5SYW5nZShlbnRpdHkpKTtcbiAgICBpZighdmFsaWRUaWxlKSByZXR1cm47XG5cbiAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSBhdHRyYWN0cyBhIHdhdGVyIG55bXBoIWApO1xuICAgIE1vbnN0ZXJTcGF3bmVyLnNwYXduU2luZ2xlKCd3YXRlck55bXBoJywgdmFsaWRUaWxlKTtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSb2xsIGZyb20gJy4uLy4uL2xpYi9kaWNlLXJvbGxlcic7XG5pbXBvcnQgRWZmZWN0IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VmZmVjdCc7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uLy4uL2luaXQvZ2FtZXN0YXRlJztcbmltcG9ydCBNb25zdGVyU3Bhd25lciBmcm9tICcuLi8uLi93b3JsZGdlbi9tb25zdGVyLXNwYXduZXInO1xuaW1wb3J0IHsgUmluZyBhcyBSYW5kb21SaW5nLCBQb3Rpb24gYXMgUmFuZG9tUG90aW9uIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL3JhbmRvbSc7XG5cbmNsYXNzIFNpbmtEcmlua0VmZmVjdCBleHRlbmRzIEVmZmVjdCB7fVxuXG5leHBvcnQgY2xhc3MgTm9FZmZlY3QgZXh0ZW5kcyBTaW5rRHJpbmtFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMjU7IH1cbiAgc3RhdGljIHVzZShlbnRpdHkpIHtcbiAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSB0YWtlcyBhIHNpcCBvZiB3YXRlciBmcm9tIHRoZSBzaW5rLmApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIYXJkV2F0ZXIgZXh0ZW5kcyBTaW5rRHJpbmtFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMjA7IH1cbiAgc3RhdGljIHVzZShlbnRpdHkpIHtcbiAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSB0YXN0ZXMgaGFyZCwgYXdmdWwgd2F0ZXIuYCk7XG4gICAgZW50aXR5LmdhaW5YcCgxKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSG90V2F0ZXIgZXh0ZW5kcyBTaW5rRHJpbmtFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gNTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuICAgIGNvbnN0IGhhc0ZpcmVSc3QgPSBlbnRpdHkuaGFzVHJhaXQoJ0ZpcmVSZXNpc3RhbmNlJyk7XG4gICAgbGV0IG1zZyA9IGAke2VudGl0eS5uYW1lfSB0b29rIGEgc2lwIG9mIHNjYWxkaW5nIGhvdCB3YXRlci5gO1xuICAgIGlmKGhhc0ZpcmVSc3QpIHtcbiAgICAgIG1zZyArPSAnIEl0IHdhcyBxdWl0ZSB0YXN0eS4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkYW1hZ2UgPSBSb2xsKCcxZDYnKTtcbiAgICAgIGVudGl0eS50YWtlRGFtYWdlKGRhbWFnZSwgeyBuYW1lOiAnc2luaycgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5tc2coZW50aXR5LCBtc2cpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTcGF3blJhdCBleHRlbmRzIFNpbmtEcmlua0VmZmVjdCB7XG4gIHN0YXRpYyBnZXQgcHJvYmFiaWxpdHkoKSB7IHJldHVybiAxOyB9XG4gIHN0YXRpYyB1c2UoZW50aXR5LCBzaW5rKSB7XG5cbiAgICBjb25zdCB2YWxpZFRpbGUgPSBfLnNhbXBsZSh0aGlzLmdldEVtcHR5VGlsZXNJblJhbmdlKHNpbmspKTtcblxuICAgIGlmKCF2YWxpZFRpbGUpIHJldHVybjtcbiAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSBmb3VuZCBhIHJhdCBpbiB0aGUgc2luay4gRXd3dyFgKTtcbiAgICBNb25zdGVyU3Bhd25lci5zcGF3blNpbmdsZSgnc2V3ZXJSYXQnLCB2YWxpZFRpbGUpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTcGF3bkVsZW1lbnRhbCBleHRlbmRzIFNpbmtEcmlua0VmZmVjdCB7XG4gIHN0YXRpYyBnZXQgcHJvYmFiaWxpdHkoKSB7IHJldHVybiAxOyB9XG4gIHN0YXRpYyB1c2UoZW50aXR5LCBzaW5rKSB7XG5cbiAgICBjb25zdCB2YWxpZFRpbGUgPSBfLnNhbXBsZSh0aGlzLmdldEVtcHR5VGlsZXNJblJhbmdlKHNpbmspKTtcblxuICAgIGlmKCF2YWxpZFRpbGUpIHJldHVybjtcbiAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSBjYXVzZWQgdGhlIHdhdGVyIHRvIHRoaW5rIGZvciBpdHNlbGYhYCk7XG4gICAgTW9uc3RlclNwYXduZXIuc3Bhd25TaW5nbGUoJ3dhdGVyRWxlbWVudGFsJywgdmFsaWRUaWxlKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmluZ0dlbiBleHRlbmRzIFNpbmtEcmlua0VmZmVjdCB7XG4gIHN0YXRpYyBnZXQgcHJvYmFiaWxpdHkoKSB7IHJldHVybiAxOyB9XG4gIHN0YXRpYyB1c2UoZW50aXR5LCBzaW5rKSB7XG4gICAgaWYoc2luay5fZ290UmluZykge1xuICAgICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gc2VlcyBtdXJreSB3YXRlciBpbiB0aGUgc2luay5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2luay5fZ290UmluZyA9IHRydWU7XG4gICAgZW50aXR5LmV4ZXJjaXNlKCd3aXMnKTtcbiAgICBjb25zdCByaW5nID0gUmFuZG9tUmluZyh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSk7XG4gICAgR2FtZVN0YXRlLndvcmxkLm1vdmVJdGVtKHJpbmcsIGVudGl0eS54LCBlbnRpdHkueSwgZW50aXR5LnopO1xuICAgIHRoaXMubXNnKGVudGl0eSwgYCR7ZW50aXR5Lm5hbWV9IGZvdW5kIGEgcmluZyBpbiB0aGUgc2luayFgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUG90aW9uRHJpbmsgZXh0ZW5kcyBTaW5rRHJpbmtFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuICAgIGNvbnN0IHBvdGlvbiA9IFJhbmRvbVBvdGlvbih7IGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSk7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gc2VlcyAke3BvdGlvbi5jb2xvcn0gd2F0ZXIgZmxvd2luZyBpbiB0aGUgc2luayFgKTtcbiAgICBwb3Rpb24udXNlKGVudGl0eSk7XG4gIH1cbn1cbiIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSb2xsIGZyb20gJy4uLy4uL2xpYi9kaWNlLXJvbGxlcic7XG5pbXBvcnQgRWZmZWN0IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VmZmVjdCc7XG5pbXBvcnQgeyBSaW5nIGFzIFJhbmRvbVJpbmcgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvcmFuZG9tJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vaW5pdC9nYW1lc3RhdGUnO1xuaW1wb3J0IE1vbnN0ZXJTcGF3bmVyIGZyb20gJy4uLy4uL3dvcmxkZ2VuL21vbnN0ZXItc3Bhd25lcic7XG5cbmNsYXNzIFNpbmtLaWNrRWZmZWN0IGV4dGVuZHMgRWZmZWN0IHt9XG5cbmV4cG9ydCBjbGFzcyBCYXNpY0VmZmVjdCBleHRlbmRzIFNpbmtLaWNrRWZmZWN0IHtcbiAgc3RhdGljIGdldCBwcm9iYWJpbGl0eSgpIHsgcmV0dXJuIDc7IH1cbiAgc3RhdGljIHVzZShlbnRpdHkpIHtcbiAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSBraWNrcyB0aGUgc2luayBhbmQgaXQgdmlicmF0ZXMgbm9zaWx5LmApO1xuICAgIGVudGl0eS5hbGVydEFsbEluUmFuZ2UoNTApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSaW5nR2VuIGV4dGVuZHMgU2lua0tpY2tFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMzsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSwgc2luaykge1xuICAgIGlmKHNpbmsuX2dvdFJpbmcpIHtcbiAgICAgIHRoaXMubXNnKGVudGl0eSwgYCR7ZW50aXR5Lm5hbWV9IGtpY2tlZCBtdXJreSB3YXRlciBvdXQgb2YgdGhlIHNpbmsuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNpbmsuX2dvdFJpbmcgPSB0cnVlO1xuICAgIGVudGl0eS5leGVyY2lzZSgnd2lzJyk7XG4gICAgZW50aXR5LmV4ZXJjaXNlKCdkZXgnKTtcbiAgICBjb25zdCByaW5nID0gUmFuZG9tUmluZyh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSk7XG4gICAgR2FtZVN0YXRlLndvcmxkLm1vdmVJdGVtKHJpbmcsIGVudGl0eS54LCBlbnRpdHkueSwgZW50aXR5LnopO1xuICAgIHRoaXMubXNnKGVudGl0eSwgYCR7ZW50aXR5Lm5hbWV9IGZvdW5kIGEgcmluZyBzaGluaW5nIGluIHRoZSBtdXJreSBnb29wIWApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYWRLaWNrIGV4dGVuZHMgU2lua0tpY2tFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuICAgIHRoaXMubXNnKGVudGl0eSwgYCR7ZW50aXR5Lm5hbWV9IGZ1bWJsZWQgd2hpbGUga2lja2luZyB0aGUgc2luay5gKTtcbiAgICBlbnRpdHkuYWxlcnRBbGxJblJhbmdlKDUwKTtcbiAgICBlbnRpdHkuYWJ1c2UoJ2RleCcpO1xuICAgIGVudGl0eS5hYnVzZSgnd2lzJyk7XG4gICAgY29uc3QgZGFtYWdlID0gUm9sbCgnMWQ1Jyk7XG4gICAgZW50aXR5LnRha2VEYW1hZ2UoZGFtYWdlLCB7IG5hbWU6ICdzaW5rJyB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3Bhd25zUHVkZGluZyBleHRlbmRzIFNpbmtLaWNrRWZmZWN0IHtcbiAgc3RhdGljIGdldCBwcm9iYWJpbGl0eSgpIHsgcmV0dXJuIDE7IH1cbiAgc3RhdGljIHVzZShlbnRpdHksIHNpbmspIHtcbiAgICBjb25zdCB2YWxpZFRpbGUgPSBfLnNhbXBsZSh0aGlzLmdldEVtcHR5VGlsZXNJblJhbmdlKHNpbmspKTtcblxuICAgIGlmKCF2YWxpZFRpbGUpIHJldHVybjtcbiAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSBjYXVzZWQgYmxhY2sgb296ZSB0byByaXNlIG91dCBvZiB0aGUgc2luayFgKTtcbiAgICBNb25zdGVyU3Bhd25lci5zcGF3blNpbmdsZSgnYmxhY2tQdWRkaW5nJywgdmFsaWRUaWxlKTtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcbmltcG9ydCBSb2xsIGZyb20gJy4uLy4uL2xpYi9kaWNlLXJvbGxlcic7XG5pbXBvcnQgKiBhcyBUcmFpdHMgZnJvbSAnLi4vdHJhaXRzL19hbGwnO1xuaW1wb3J0IEdhbWVTdGF0ZSBmcm9tICcuLi8uLi9pbml0L2dhbWVzdGF0ZSc7XG5pbXBvcnQgRWZmZWN0IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VmZmVjdCc7XG5pbXBvcnQgTW9uc3RlclNwYXduZXIgZnJvbSAnLi4vLi4vd29ybGRnZW4vbW9uc3Rlci1zcGF3bmVyJztcblxuY2xhc3MgVGhyb25lRWZmZWN0IGV4dGVuZHMgRWZmZWN0IHt9XG5cbmV4cG9ydCBjbGFzcyBJZGVudGlmeSBleHRlbmRzIFRocm9uZUVmZmVjdCB7XG4gIHN0YXRpYyBnZXQgcHJvYmFiaWxpdHkoKSB7IHJldHVybiAxOyB9XG4gIHN0YXRpYyB1c2UoZW50aXR5KSB7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gd2FzIGdyYW50ZWQgaW5zaWdodCFgKTtcbiAgICBfLmVhY2goZW50aXR5LmludmVudG9yeSwgaXRlbSA9PiB7XG4gICAgICBpZihST1QuUk5HLmdldFBlcmNlbnRhZ2UoKSA8PSAyMCkgcmV0dXJuO1xuICAgICAgaXRlbS5pZGVudGlmeSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIZWFsdGhHYWluQm9udXMgZXh0ZW5kcyBUaHJvbmVFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuICAgIGNvbnN0IGhwR2FpbmVkID0gUm9sbCgnMWQxMCcpO1xuICAgIHRoaXMubXNnKGVudGl0eSwgYCR7ZW50aXR5Lm5hbWV9IGZlZWxzIG11Y2gsIG11Y2ggYmV0dGVyIWApO1xuICAgIGVudGl0eS5ocC5tYXggKz0gaHBHYWluZWQ7XG4gICAgZW50aXR5LmhwLnRvTWF4KCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE91Y2ggZXh0ZW5kcyBUaHJvbmVFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuICAgIGNvbnN0IGhwTG9zdCA9IFJvbGwoJzFkMTAnKTtcbiAgICBjb25zdCBzdGF0TG9zdCA9IFJvbGwoJzFkNCArIDInKTtcbiAgICBjb25zdCBzdGF0ID0gXy5zYW1wbGUoWydjb24nLCAnZGV4JywgJ2ludCcsICd3aXMnLCAnc3RyJywgJ2NoYScsICdsdWsnXSk7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gZmVlbHMgYSBwYWluZnVsIHN1cmdlIWApO1xuICAgIGVudGl0eS50YWtlRGFtYWdlKGhwTG9zdCwgeyBuYW1lOiAndGhyb25lJyB9KTtcbiAgICBlbnRpdHlbc3RhdF0gLT0gc3RhdExvc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNob2NraW5nIGV4dGVuZHMgVGhyb25lRWZmZWN0IHtcbiAgc3RhdGljIGdldCBwcm9iYWJpbGl0eSgpIHsgcmV0dXJuIDE7IH1cbiAgc3RhdGljIHVzZShlbnRpdHkpIHtcbiAgICBjb25zdCBoYXNTaGtSc3QgPSBlbnRpdHkuaGFzVHJhaXQoJ1Nob2NrUmVzaXN0YW5jZScpO1xuICAgIGNvbnN0IGRhbWFnZVJvbGwgPSBoYXNTaGtSc3QgPyAnMWQ2JyA6ICcxZDMwJztcblxuICAgIGVudGl0eS5hYnVzZSgnY29uJywgJzFkMScpO1xuICAgIGVudGl0eS50YWtlRGFtYWdlKFJvbGwoZGFtYWdlUm9sbCksIHsgbmFtZTogJ3Rocm9uZScgfSk7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gd2FzIHZpY2lvdXNseSBzaG9ja2VkIWApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDbGFyaXR5IGV4dGVuZHMgVGhyb25lRWZmZWN0IHtcbiAgc3RhdGljIGdldCBwcm9iYWJpbGl0eSgpIHsgcmV0dXJuIDE7IH1cbiAgc3RhdGljIHVzZShlbnRpdHkpIHtcbiAgICBpZihlbnRpdHkuaGFzVHJhaXQoJ1NlZUludmlzaWJsZScpKSB7XG4gICAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSBoYXMgYSBzdHJhbmdlIHNlbnNhdGlvbiwgdGhlbiBpdCBwYXNzZXMuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVudGl0eS5hZGRUcmFpdChUcmFpdHMuU2VlSW52aXNpYmxlKHsgbGV2ZWw6IDUgfSkpO1xuICAgIHRoaXMubXNnKGVudGl0eSwgYCR7ZW50aXR5Lm5hbWV9IGhhcyBhIG1vbWVudCBvZiBjbGFyaXR5LmApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMb3NlVGhhdEdvbGQgZXh0ZW5kcyBUaHJvbmVFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuICAgIGlmKGVudGl0eS5nb2xkID09PSAwKSB7XG4gICAgICB0aGlzLm1zZyhlbnRpdHksIGAke2VudGl0eS5uYW1lfSBoYXMgYSBzdHJhbmdlIHNlbnNhdGlvbiwgdGhlbiBpdCBwYXNzZXMuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZW50aXR5LmdvbGQgPSAwO1xuICAgIHRoaXMubXNnKGVudGl0eSwgYCR7ZW50aXR5Lm5hbWV9IGxvc3QgYSBsb3R0YSBnb2xkIWApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSYW5kb21UZWxlcG9ydCBleHRlbmRzIFRocm9uZUVmZmVjdCB7XG4gIHN0YXRpYyBnZXQgcHJvYmFiaWxpdHkoKSB7IHJldHVybiAxOyB9XG4gIHN0YXRpYyB1c2UoZW50aXR5KSB7XG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gZmVlbHMgYSB3cmVuY2hpbmcgc2Vuc2F0aW9uIWApO1xuICAgIEdhbWVTdGF0ZS53b3JsZC5wbGFjZUVudGl0eUF0UmFuZG9tTG9jYXRpb24oZW50aXR5KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3Bhd25DcmVhdHVyZXMgZXh0ZW5kcyBUaHJvbmVFZmZlY3Qge1xuICBzdGF0aWMgZ2V0IHByb2JhYmlsaXR5KCkgeyByZXR1cm4gMTsgfVxuICBzdGF0aWMgdXNlKGVudGl0eSkge1xuXG4gICAgY29uc3QgbW9uc3RlcnMgPSBbJ2tvYm9sZCcsICdnbm9tZScsICdnb2JsaW4nLCAnaG9iZ29ibGluJywgJ29yYyddO1xuXG4gICAgdGhpcy5tc2coZW50aXR5LCBgJHtlbnRpdHkubmFtZX0gc3VtbW9uZWQgYSB0aHJvbmUgcm9vbSBhdWRpZW5jZSFgKTtcbiAgICBjb25zdCBzcGF3bmVkID0gUm9sbCgnMWQxMCcpO1xuXG4gICAgY29uc3QgdmFsaWRUaWxlcyA9IF8uc2FtcGxlKHRoaXMuZ2V0RW1wdHlUaWxlc0luUmFuZ2UoZW50aXR5LCA1KSwgc3Bhd25lZCk7XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3Bhd25lZDsgaSsrKSB7XG4gICAgICBpZighdmFsaWRUaWxlc1tpXSkgY29udGludWU7XG4gICAgICBNb25zdGVyU3Bhd25lci5zcGF3blNpbmdsZShfLnNhbXBsZShtb25zdGVycyksIHZhbGlkVGlsZXNbaV0pO1xuICAgIH1cbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgJ0Vkcml4JyxcbiAgJ09yZmFuZScsXG4gICdPZGlzYXRpamUnLFxuICAnU2VmYWt5YmVoJyxcbiAgJ0VyZHlpbmphJyxcbiAgJ0VuaW51bmFnaScsXG4gICdFZmVzdScsXG4gICdXZXRlZicsXG4gICdBcmV5ZWt1d2UnLFxuICAnVXZlY3Vzb2YnLFxuICAnVmVzZWNpJyxcbiAgJ0x1bGFsb25hJyxcbiAgJ0l2ZWxldCcsXG4gICdVY2FsJyxcbiAgJ1dhcnRiZXJnJyxcbiAgJ0RldmV3JyxcbiAgJ1Nvc2UnLFxuICAnT3BoaXgnLFxuICAnVGFsb24nLFxuICAnTnVuaXQnLFxuICAnTWVwZXInLFxuICAnVGVnYXZhZCcsXG4gICdTb25qYScsXG4gICdFc2FsaScsXG4gICdUYXhpcmUnLFxuICAnWGFuZWxlbCcsXG4gICdFbmhhaWxvcicsXG4gICdTdWplYicsXG4gICdFbGFoaW9hJyxcbiAgJ0FubmFsaWUnLFxuICAnT2l2b2knLFxuICAnVGlkaXlpd2knLFxuICAnRWxhaGljYScsXG4gICdFcmlvYWxpbicsXG4gICdGaWRpdicsXG4gICdGZXJvcGl0JyxcbiAgJ05vbGlkJyxcbiAgJ0lsbGl3YW51JyxcbiAgJ0l0aXhhcycsXG4gICdEZXZlcmlsaWFuJyxcbiAgJ0NhbnViJyxcbiAgJ1dlbGJ5JyxcbiAgJ0JvbG1peGZvbicsXG4gICdEZXh0cmEnLFxuICAnVml4Z2VuJyxcbiAgJ0R1dHV5YXhlJyxcbiAgJ0xlbmF6b2RvZycsXG4gICdXb2RlbicsXG4gICdEYXJ3aW4nLFxuICAnRG9udGRpZScsXG4gICdMdXRoJyxcbiAgJ0FkYWInLFxuICAnWXVwZWQnLFxuICAnTmVkaXJ1JyxcbiAgJ0dvcnlwZWdhcycsXG4gICdBbnV0JyxcbiAgJ0V2ZW50aW5lJyxcbiAgJ015dGhlJyxcbiAgJ0F2b2ppbmRpJyxcbiAgJ09kdWZpbicsXG4gICdLaWxleScsXG4gICdJcmViZXEnLFxuICAnVGVnb25vJyxcbiAgJ0F6ZGFuJyxcbiAgJ09vbXBoYScsXG4gICdSb2tvc2VyJyxcbiAgJ0lob3hlcWF0aScsXG4gICdPaGl3dWRlaCcsXG4gICdMZXhvbnljb3InLFxuICAnRWNvcicsXG4gICdFYmFyYWQnLFxuICAnUml0b3ZhJyxcbiAgJ05lbmF0eScsXG4gICdEaXB0dXNvcm95JyxcbiAgJ0R1ZGxleScsXG4gICdNYXJ2aW4nLFxuICAnQmVuJyxcbiAgJ1RlbmF5YScsXG4gICdSb2JlcnQnLFxuICAnSXpjaGFrJyxcbiAgJ1JhYicsXG4gICdCbGl6ZXInLFxuICAnUmF5bW9uZCcsXG4gICdLeWxlJyxcbiAgJ0VyaWNoJyxcbiAgJ0F1c3RpbicsXG4gICdTa3JhbGcnLFxuICAnUm9kbmV5J1xuXTsiLCJcbmltcG9ydCB7IFNwZWNpYWwsIENvbWVzdGlibGUsIEdlbSwgVG9vbCB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgeyBJdGVtcyBhcyBHbHlwaHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhzJztcbmltcG9ydCB7IEl0ZW1zIGFzIEdseXBoQ29sb3JzLCBTcGVjaWFsIGFzIFNwZWNpYWxHbHlwaENvbG9ycyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaENvbG9ycyc7XG5pbXBvcnQgeyBtYXRlcmlhbCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcbmltcG9ydCBNYXRlcmlhbHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzL21hdGVyaWFscyc7XG5cbkBtYXRlcmlhbChNYXRlcmlhbHMuR29sZClcbmV4cG9ydCBjbGFzcyBHb2xkIGV4dGVuZHMgU3BlY2lhbCB7XG4gIGNvbnN0cnVjdG9yKG51bSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBnbHlwaDogeyBrZXk6IEdseXBocy5Hb2xkLCBmZzogR2x5cGhDb2xvcnMuR29sZCB9XG4gICAgfTtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLmdvbGRWYWx1ZSA9IG51bTtcbiAgICB0aGlzLnJlYWxOYW1lID0gYCR7dGhpcy5nb2xkVmFsdWV9IGdvbGRgO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb3Jwc2UgZXh0ZW5kcyBDb21lc3RpYmxlIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHsgbW9uc3Rlck5hbWU6ICd1bmtub3duJyB9KSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy5yZWFsTmFtZSA9IGBjb3Jwc2Ugb2YgJHtvcHRzLm1vbnN0ZXJOYW1lfWA7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0b25lT2ZTZWx5ayBleHRlbmRzIEdlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgZ2x5cGg6IHsgZmc6IFNwZWNpYWxHbHlwaENvbG9ycy5TZWx5ayB9IH0pO1xuICAgIHRoaXMucmVhbE5hbWUgPSBgU3RvbmUgb2YgU2VseWtgO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTZWx5a0NlbGxhcktleSBleHRlbmRzIFRvb2wge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7IGdseXBoOiB7IGZnOiBTcGVjaWFsR2x5cGhDb2xvcnMuU2VseWsgfSB9KTtcbiAgICB0aGlzLnJlYWxOYW1lID0gYFNlbHlrJ3MgQ2VsbGFyIEtleWA7XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBBeGVzIGZyb20gJy4vd2VhcG9ucy9heGVzJztcbmltcG9ydCAqIGFzIEJvd3MgZnJvbSAnLi93ZWFwb25zL2Jvd3MnO1xuaW1wb3J0ICogYXMgRGFnZ2VycyBmcm9tICcuL3dlYXBvbnMvZGFnZ2Vycyc7XG5pbXBvcnQgKiBhcyBNYWNlcyBmcm9tICcuL3dlYXBvbnMvbWFjZXMnO1xuaW1wb3J0ICogYXMgU2hvcnRTd29yZHMgZnJvbSAnLi93ZWFwb25zL3Nob3J0c3dvcmRzJztcbmltcG9ydCAqIGFzIFNwZWFycyBmcm9tICcuL3dlYXBvbnMvc3BlYXJzJztcbmltcG9ydCAqIGFzIFN0YXZlcyBmcm9tICcuL3dlYXBvbnMvc3RhdmVzJztcbmltcG9ydCAqIGFzIFN3b3JkcyBmcm9tICcuL3dlYXBvbnMvbG9uZ3N3b3Jkcyc7XG5cbmV4cG9ydCBkZWZhdWx0IF8uZXh0ZW5kKHt9LCBBeGVzLCBCb3dzLCBEYWdnZXJzLCBNYWNlcywgU2hvcnRTd29yZHMsIFNwZWFycywgU3RhdmVzLCBTd29yZHMpOyIsIlxuaW1wb3J0IHsgQm9keSB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgeyBBQyB9IGZyb20gJy4uLy4uL2xpYi9kZWZhdWx0LWNhbGN1bGF0aW9ucyc7XG5pbXBvcnQgTWF0ZXJpYWxzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9tYXRlcmlhbHMnO1xuaW1wb3J0IHsgbWF0ZXJpYWwsIHJhcml0eSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcblxuQHJhcml0eSgxMDApXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkNsb3RoKVxuZXhwb3J0IGNsYXNzIFRTaGlydCBleHRlbmRzIEJvZHkge31cblxuQHJhcml0eSg1MClcbkBtYXRlcmlhbChNYXRlcmlhbHMuQ2xvdGgpXG5leHBvcnQgY2xhc3MgUm9iZSBleHRlbmRzIEJvZHkge31cblxuQHJhcml0eSg3NSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuTGVhdGhlcilcbmV4cG9ydCBjbGFzcyBMZWF0aGVySmFja2V0IGV4dGVuZHMgQm9keSB7XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDY1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIE9yY2lzaFJpbmdNYWlsIGV4dGVuZHMgQm9keSB7XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzLCAyKTtcbiAgfVxufVxuXG5AcmFyaXR5KDU1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5MZWF0aGVyKVxuZXhwb3J0IGNsYXNzIFN0dWRkZWRMZWF0aGVyQXJtb3IgZXh0ZW5kcyBCb2R5IHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMsIDMpO1xuICB9XG59XG5cbkByYXJpdHkoNTUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgUmluZ01haWwgZXh0ZW5kcyBCb2R5IHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMsIDMpO1xuICB9XG59XG5cbkByYXJpdHkoMSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuRHJhZ29uKVxuZXhwb3J0IGNsYXNzIERyYWdvblNjYWxlcyBleHRlbmRzIEJvZHkge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcywgMyk7XG4gIH1cbn1cblxuQHJhcml0eSg0NSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBPcmNpc2hDaGFpbk1haWwgZXh0ZW5kcyBCb2R5IHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMsIDQpO1xuICB9XG59XG5cbkByYXJpdHkoNDUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgU2NhbGVNYWlsIGV4dGVuZHMgQm9keSB7XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzLCA0KTtcbiAgfVxufVxuXG5AcmFyaXR5KDI1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIENoYWluTWFpbCBleHRlbmRzIEJvZHkge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcywgNSk7XG4gIH1cbn1cblxuQHJhcml0eSgyNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuTWl0aHJpbClcbmV4cG9ydCBjbGFzcyBFbHZlbk1pdGhyaWxDb2F0IGV4dGVuZHMgQm9keSB7XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzLCA1KTtcbiAgfVxufVxuXG5AcmFyaXR5KDE1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIFNwbGludE1haWwgZXh0ZW5kcyBCb2R5IHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMsIDYpO1xuICB9XG59XG5cbkByYXJpdHkoMTUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgQmFuZGVkTWFpbCBleHRlbmRzIEJvZHkge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcywgNik7XG4gIH1cbn1cblxuQHJhcml0eSgxNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuTWl0aHJpbClcbmV4cG9ydCBjbGFzcyBEd2FydmVuTWl0aHJpbENvYXQgZXh0ZW5kcyBCb2R5IHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMsIDYpO1xuICB9XG59XG5cbkByYXJpdHkoMTUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkNvcHBlcilcbmV4cG9ydCBjbGFzcyBCcm9uemVQbGF0ZU1haWwgZXh0ZW5kcyBCb2R5IHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMsIDYpO1xuICB9XG59XG5cbkByYXJpdHkoNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBQbGF0ZU1haWwgZXh0ZW5kcyBCb2R5IHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMsIDcpO1xuICB9XG59XG5cbkByYXJpdHkoNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuR2xhc3MpXG5leHBvcnQgY2xhc3MgQ3J5c3RhbFBsYXRlTWFpbCBleHRlbmRzIEJvZHkge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcywgNyk7XG4gIH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5EcmFnb24pXG5leHBvcnQgY2xhc3MgRHJhZ29uU2NhbGVNYWlsIGV4dGVuZHMgQm9keSB7XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzLCA5KTtcbiAgfVxufSIsIlxuaW1wb3J0IHsgQ2xvYWsgfSBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9lcXVpcG1lbnQnO1xuaW1wb3J0IHsgQUMgfSBmcm9tICcuLi8uLi9saWIvZGVmYXVsdC1jYWxjdWxhdGlvbnMnO1xuaW1wb3J0IE1hdGVyaWFscyBmcm9tICcuLi8uLi9jb25zdGFudHMvbWF0ZXJpYWxzJztcbmltcG9ydCB7IG1hdGVyaWFsLCByYXJpdHkgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZGVjb3JhdG9ycyc7XG5cbkByYXJpdHkoNTApXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkNsb3RoKVxuZXhwb3J0IGNsYXNzIE9yZGluYXJ5Q2xvYWsgZXh0ZW5kcyBDbG9hayB7fVxuXG5AcmFyaXR5KDEwKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBNdW1teVdyYXBwaW5nIGV4dGVuZHMgQ2xvYWsge1xuICBJbnZpc2libGUoKSB7IHJldHVybiAtMTsgfVxufVxuXG5AcmFyaXR5KDIwKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBPcmNpc2hDbG9hayBleHRlbmRzIENsb2FrIHt9XG5cbkByYXJpdHkoMjApXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkNsb3RoKVxuZXhwb3J0IGNsYXNzIER3YXJ2ZW5DbG9hayBleHRlbmRzIENsb2FrIHt9XG5cbkByYXJpdHkoMilcbkBtYXRlcmlhbChNYXRlcmlhbHMuQ2xvdGgpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkxlYXRoZXIpXG5leHBvcnQgY2xhc3MgTGVhdGhlckNsb2FrIGV4dGVuZHMgQ2xvYWsge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcywgMSk7XG4gIH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBBbGNoZW15U21vY2sgZXh0ZW5kcyBDbG9hayB7XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzLCAxKTtcbiAgfVxuICBQb2lzb25SZXNpc3RhbmNlKCkgeyByZXR1cm4gMTsgfVxuICBBY2lkUmVzaXN0YW5jZSgpIHsgcmV0dXJuIDE7IH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBJbnZpc2liaWxpdHlDbG9hayBleHRlbmRzIENsb2FrIHtcbiAgSW52aXNpYmxlKCkgeyByZXR1cm4gMTsgfVxufVxuXG5AcmFyaXR5KDEpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkNsb3RoKVxuZXhwb3J0IGNsYXNzIEVsdmVuQ2xvYWsgZXh0ZW5kcyBDbG9hayB7XG4gIFN0ZWFsdGgoKSB7IHJldHVybiB0aGlzLmJ1YyAqIDI7IH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBSb2JlIGV4dGVuZHMgQ2xvYWsge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcywgMik7XG4gIH1cbn1cblxuQHJhcml0eSg1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBDbG9ha09mUHJvdGVjdGlvbiBleHRlbmRzIENsb2FrIHtcbiAgUHJvdGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5idWMgKiAtMjtcbiAgfVxufSIsIlxuaW1wb3J0IHsgRmVldCB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgeyBBQyB9IGZyb20gJy4uLy4uL2xpYi9kZWZhdWx0LWNhbGN1bGF0aW9ucyc7XG5pbXBvcnQgTWF0ZXJpYWxzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9tYXRlcmlhbHMnO1xuaW1wb3J0IHsgbWF0ZXJpYWwsIHJhcml0eSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcblxuQHJhcml0eSg1MClcbkBtYXRlcmlhbChNYXRlcmlhbHMuTGVhdGhlcilcbmV4cG9ydCBjbGFzcyBTaW1wbGVCb290cyBleHRlbmRzIEZlZXQge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcyk7XG4gIH1cbn1cblxuQHJhcml0eSgyKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5MZWF0aGVyKVxuZXhwb3J0IGNsYXNzIEVsdmVuQm9vdHMgZXh0ZW5kcyBGZWV0IHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMpO1xuICB9XG4gIFN0ZWFsdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVjICogMztcbiAgfVxufVxuXG5AcmFyaXR5KDMpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkxlYXRoZXIpXG5leHBvcnQgY2xhc3MgSGVybWVzU2FuZGFscyBleHRlbmRzIEZlZXQge1xuICBIYXN0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5idWMgKiAyO1xuICB9XG59XG5cbkByYXJpdHkoMTApXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkxlYXRoZXIpXG5leHBvcnQgY2xhc3MgSGlnaEJvb3RzIGV4dGVuZHMgRmVldCB7XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzLCAyKTtcbiAgfVxufVxuXG5AcmFyaXR5KDUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgSXJvbkJvb3RzIGV4dGVuZHMgRmVldCB7XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzLCAyKTtcbiAgfVxufVxuXG5AcmFyaXR5KDUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgQm9vdHNPZlByb3RlY3Rpb24gZXh0ZW5kcyBGZWV0IHtcbiAgUHJvdGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5idWMgKiAtMjtcbiAgfVxufSIsIlxuaW1wb3J0IHsgQ29tZXN0aWJsZSB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgeyByYXJpdHkgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZGVjb3JhdG9ycyc7XG5cbkByYXJpdHkoNTApXG5leHBvcnQgY2xhc3MgUmF0aW9uIGV4dGVuZHMgQ29tZXN0aWJsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLnJlYWxOYW1lID0gJ3JhdGlvbic7XG4gIH1cbn1cblxuQHJhcml0eSg3NSlcbmV4cG9ydCBjbGFzcyBBcHBsZSBleHRlbmRzIENvbWVzdGlibGUge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy5yZWFsTmFtZSA9ICdhcHBsZSc7XG4gIH1cbn1cblxuQHJhcml0eSg3NSlcbmV4cG9ydCBjbGFzcyBDYXJyb3QgZXh0ZW5kcyBDb21lc3RpYmxlIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMucmVhbE5hbWUgPSAnY2Fycm90JztcbiAgfVxufSIsIlxuaW1wb3J0IHsgSGVhZCB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgeyBBQyB9IGZyb20gJy4uLy4uL2xpYi9kZWZhdWx0LWNhbGN1bGF0aW9ucyc7XG5pbXBvcnQgTWF0ZXJpYWxzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9tYXRlcmlhbHMnO1xuaW1wb3J0IHsgbWF0ZXJpYWwsIHJhcml0eSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcblxuQHJhcml0eSg1MClcbkBtYXRlcmlhbChNYXRlcmlhbHMuQ2xvdGgpXG5leHBvcnQgY2xhc3MgT3JkaW5hcnlIYXQgZXh0ZW5kcyBIZWFkIHt9XG5cbkByYXJpdHkoMSkgLy8gc28gaGlwc3RlclxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBGZWRvcmEgZXh0ZW5kcyBIZWFkIHt9XG5cbkByYXJpdHkoMilcbkBtYXRlcmlhbChNYXRlcmlhbHMuTGVhdGhlcilcbmV4cG9ydCBjbGFzcyBOaWdodEdvZ2dsZXMgZXh0ZW5kcyBIZWFkIHtcbiAgSW5mcmF2aXNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVjO1xuICB9XG59XG5cbkByYXJpdHkoMilcbkBtYXRlcmlhbChNYXRlcmlhbHMuQ2xvdGgpXG5leHBvcnQgY2xhc3MgRHVuY2VDYXAgZXh0ZW5kcyBIZWFkIHtcbiAgaW50KCkgeyByZXR1cm4gLTU7IH1cbiAgd2lzKCkgeyByZXR1cm4gLTU7IH1cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgb3B0cy5idWNOYW1lID0gJ2N1cnNlZCc7IC8vIGFsd2F5cyBzdGFydHMgY3Vyc2VkXG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSgyKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBDb3JudXRoYXVtIGV4dGVuZHMgSGVhZCB7XG4gIENsYWlydm95YW5jZSgpIHtcbiAgICByZXR1cm4gMjtcbiAgfVxufVxuXG5AcmFyaXR5KDE1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIE9yY2lzaEhlbG0gZXh0ZW5kcyBIZWFkIHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMpO1xuICB9XG59XG5cbkByYXJpdHkoMTUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgSGVsbSBleHRlbmRzIEhlYWQge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcywgMik7XG4gIH1cbn1cblxuQHJhcml0eSgzNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBEZW50ZWRQb3QgZXh0ZW5kcyBIZWFkIHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMpO1xuICB9XG59XG5cbkByYXJpdHkoMTUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkxlYXRoZXIpXG5leHBvcnQgY2xhc3MgRWx2ZW5MZWF0aGVySGVsbSBleHRlbmRzIEhlYWQge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcyk7XG4gIH1cbn1cblxuQHJhcml0eSgzKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIEhlbG1PZkJyaWxsaWFuY2UgZXh0ZW5kcyBIZWFkIHtcbiAgaW50KCkgeyByZXR1cm4gMzsgfVxuICB3aXMoKSB7IHJldHVybiAzOyB9XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDIpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgSGVsbU9mVGVsZXBhdGh5IGV4dGVuZHMgSGVhZCB7XG4gIFRlbGVwYXRoeSgpIHtcbiAgICByZXR1cm4gNDtcbiAgfVxufVxuXG5AcmFyaXR5KDEwKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIER3YXJ2ZW5Jcm9uSGVsbSBleHRlbmRzIEhlYWQge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcywgMik7XG4gIH1cbn1cblxuQHJhcml0eSg1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIEhlbG1PZlByb3RlY3Rpb24gZXh0ZW5kcyBIZWFkIHtcbiAgUHJvdGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5idWMgKiAtMjtcbiAgfVxufSIsIlxuaW1wb3J0IHsgTmVjayB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgTWF0ZXJpYWxzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9tYXRlcmlhbHMnO1xuaW1wb3J0ICogYXMgQmVoYXZpb3JzIGZyb20gJy4uL2JlaGF2aW9ycy9fYWxsJztcbmltcG9ydCB7IG1hdGVyaWFsLCByYXJpdHkgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZGVjb3JhdG9ycyc7XG5cbkByYXJpdHkoNTApXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgTmVja2xhY2UgZXh0ZW5kcyBOZWNrIHt9XG5cbkByYXJpdHkoNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBBbXVsZXRPZlByb3RlY3Rpb24gZXh0ZW5kcyBOZWNrIHtcbiAgUHJvdGVjdGlvbigpIHsgcmV0dXJuIHRoaXMuYnVjICogLTI7IH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIEFtdWxldE9mVGVsZXBhdGh5IGV4dGVuZHMgTmVjayB7XG4gIFRlbGVwYXRoeSgpIHsgcmV0dXJuIDQ7IH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIEFtdWxldE9mU3RyYW5ndWxhdGlvbiBleHRlbmRzIE5lY2sge1xuICBlcXVpcChwbGF5ZXIpIHtcbiAgICBwbGF5ZXIuZGllKHsgbmFtZTogJ2FtdWxldCBvZiBzdHJhbmd1bGF0aW9uJyB9KTtcbiAgfVxufVxuXG5AcmFyaXR5KDEpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgQW11bGV0T2ZMaWZlU2F2aW5nIGV4dGVuZHMgTmVjayB7XG4gIGVxdWlwKHBsYXllcikge1xuICAgIHRoaXMuX2JlaGF2aW9yID0gQmVoYXZpb3JzLkxpZmVTYXZlKCk7XG4gICAgdGhpcy5fYmVoYXZpb3IuX2l0ZW1SZWYgPSB0aGlzO1xuICAgIHBsYXllci5hZGRVbmlxdWVCZWhhdmlvcih0aGlzLl9iZWhhdmlvcik7XG4gIH1cbiAgdW5lcXVpcChwbGF5ZXIpIHtcbiAgICBwbGF5ZXIucmVtb3ZlQmVoYXZpb3IodGhpcy5fYmVoYXZpb3IpO1xuICB9XG59XG4iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUm9sbCBmcm9tICcuLi8uLi9saWIvZGljZS1yb2xsZXInO1xuaW1wb3J0IHsgUG90aW9uIH0gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvZXF1aXBtZW50JztcbmltcG9ydCB7IHJhcml0eSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcblxuQHJhcml0eSg1MClcbmV4cG9ydCBjbGFzcyBIZWFsaW5nIGV4dGVuZHMgUG90aW9uIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywgeyBjaGFyZ2VzOiAnMWQxJywgaGVhbFJvbGw6ICc0ZDQnLCBhdXRvUmVtb3ZlOiB0cnVlIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG4gIHVzZShlbnRpdHkpIHtcbiAgICBjb25zdCBoZWFsVmFsID0gUm9sbCh0aGlzLmhlYWxSb2xsKTtcbiAgICBzdXBlci51c2UoZW50aXR5LCB7IGhlYWxWYWwsIG1lc3NhZ2VGaW5pc2g6IGByZWdhaW5lZCAke2hlYWxWYWx9IGhlYWx0aGAgfSk7XG4gIH1cbn1cblxuQHJhcml0eSg1KVxuZXhwb3J0IGNsYXNzIEV4dHJhSGVhbGluZyBleHRlbmRzIFBvdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHsgY2hhcmdlczogJzFkMScsIGhlYWxSb2xsOiAnOGQ0JywgYXV0b1JlbW92ZTogdHJ1ZSB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxuICB1c2UoZW50aXR5KSB7XG4gICAgY29uc3QgaGVhbFZhbCA9IFJvbGwodGhpcy5oZWFsUm9sbCk7XG4gICAgc3VwZXIudXNlKGVudGl0eSwgeyBoZWFsVmFsLCBtZXNzYWdlRmluaXNoOiBgcmVnYWluZWQgJHtoZWFsVmFsfSBoZWFsdGhgIH0pO1xuICB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgV2VhcG9uIH0gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvZXF1aXBtZW50JztcbmltcG9ydCBBdHRhY2tzIGZyb20gJy4uL2F0dGFja3MvX2FsbCc7XG5pbXBvcnQgTWF0ZXJpYWxzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9tYXRlcmlhbHMnO1xuaW1wb3J0IHsgbWF0ZXJpYWwsIHJhcml0eSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcblxuQHJhcml0eSg1MClcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBEYXJ0IGV4dGVuZHMgV2VhcG9uIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgYXV0b1JlbW92ZTogdHJ1ZSxcbiAgICAgIGNoYXJnZXM6ICcyZDQnLFxuICAgICAgZ2x5cGg6IHsga2V5OiAnKScsIGZnOiAnIzAwZicgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNob3QoeyByb2xsOiAnMWQzJywgdG9IaXQ6ICcwZDAnLCByYW5nZTogMyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDUwKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5TdG9uZSlcbmV4cG9ydCBjbGFzcyBSb2NrIGV4dGVuZHMgV2VhcG9uIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgYXV0b1JlbW92ZTogdHJ1ZSxcbiAgICAgIGNoYXJnZXM6ICcyZDQnLFxuICAgICAgZ2x5cGg6IHsga2V5OiAnKScsIGZnOiAnIzAwZicgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNob3QoeyByb2xsOiAnMWQzJywgdG9IaXQ6ICcwZDAnLCByYW5nZTogOSB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDI1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5TdG9uZSlcbmV4cG9ydCBjbGFzcyBGbGludFN0b25lIGV4dGVuZHMgV2VhcG9uIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgYXV0b1JlbW92ZTogdHJ1ZSxcbiAgICAgIGNoYXJnZXM6ICcyZDQnLFxuICAgICAgZ2x5cGg6IHsga2V5OiAnKScsIGZnOiAnIzAwZicgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNob3QoeyByb2xsOiAnMWQ2JywgdG9IaXQ6ICcwZDAnLCByYW5nZTogNCB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDEwKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIEphdmVsaW4gZXh0ZW5kcyBXZWFwb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBhdXRvUmVtb3ZlOiB0cnVlLFxuICAgICAgY2hhcmdlczogJzFkNCcsXG4gICAgICBnbHlwaDogeyBrZXk6ICcpJywgZmc6ICcjMDBmJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU2hvdCh7IHJvbGw6ICcxZDYnLCByYW5nZTogOSB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgU2h1cmlrZW4gZXh0ZW5kcyBXZWFwb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBhdXRvUmVtb3ZlOiB0cnVlLFxuICAgICAgY2hhcmdlczogJzVkNCcsXG4gICAgICBnbHlwaDogeyBrZXk6ICcpJywgZmc6ICcjMDBmJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU2hvdCh7IHJvbGw6ICcxZDgnLCByYW5nZTogMTUgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSg1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIFN0aWxldHRvIGV4dGVuZHMgV2VhcG9uIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgYXV0b1JlbW92ZTogdHJ1ZSxcbiAgICAgIGNoYXJnZXM6ICc0ZDQnLFxuICAgICAgZ2x5cGg6IHsga2V5OiAnKScsIGZnOiAnIzAwZicgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNob3QoeyByb2xsOiAnMWQ0JywgdG9IaXQ6ICcwZDAnLCByYW5nZTogNCB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDI1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Xb29kKVxuZXhwb3J0IGNsYXNzIE9yY2lzaEFycm93IGV4dGVuZHMgV2VhcG9uIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgYXV0b1JlbW92ZTogdHJ1ZSxcbiAgICAgIGNoYXJnZXM6ICcxZDQnLFxuICAgICAgZ2x5cGg6IHsga2V5OiAnKScsIGZnOiAnI2YwZicgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNob3QoeyByb2xsOiAnMWQ1JywgdG9IaXQ6ICcwZDAnLCByYW5nZTogNSB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDIwKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Xb29kKVxuZXhwb3J0IGNsYXNzIEFycm93IGV4dGVuZHMgV2VhcG9uIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgYXV0b1JlbW92ZTogdHJ1ZSxcbiAgICAgIGNoYXJnZXM6ICcxZDQnLFxuICAgICAgZ2x5cGg6IHsga2V5OiAnKScsIGZnOiAnI2YwZicgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNob3QoeyByb2xsOiAnMWQ2JywgdG9IaXQ6ICcwZDAnLCByYW5nZTogNiB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDE1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIEVsdmVuQXJyb3cgZXh0ZW5kcyBXZWFwb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBhdXRvUmVtb3ZlOiB0cnVlLFxuICAgICAgY2hhcmdlczogJzJkNCcsXG4gICAgICBnbHlwaDogeyBrZXk6ICcpJywgZmc6ICcjZjBmJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU2hvdCh7IHJvbGw6ICcxZDgnLCB0b0hpdDogJzFkMScsIHJhbmdlOiA3IH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoMjUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5leHBvcnQgY2xhc3MgQm9sdCBleHRlbmRzIFdlYXBvbiB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGF1dG9SZW1vdmU6IHRydWUsXG4gICAgICBjaGFyZ2VzOiAnMWQ0JyxcbiAgICAgIGdseXBoOiB7IGtleTogJyknLCBmZzogJyNmMGYnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TaG90KHsgcm9sbDogJzFkOCcsIHRvSGl0OiAnMGQwJywgcmFuZ2U6IDQgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCB7IFJpbmcgfSBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9lcXVpcG1lbnQnO1xuaW1wb3J0IE1hdGVyaWFscyBmcm9tICcuLi8uLi9jb25zdGFudHMvbWF0ZXJpYWxzJztcbmltcG9ydCB7IG1hdGVyaWFsLCByYXJpdHkgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZGVjb3JhdG9ycyc7XG5cbi8vIHJlZ2lvbiBBdHRyaWJ1dGUgUmluZ3NcbkByYXJpdHkoMTUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgUmluZ09mU3RyZW5ndGggZXh0ZW5kcyBSaW5nIHtcbiAgc3RyKCkgeyByZXR1cm4gdGhpcy5idWM7IH1cbn1cblxuQHJhcml0eSg1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Db3BwZXIpXG5leHBvcnQgY2xhc3MgUmluZ09mQ29uc3RpdHV0aW9uIGV4dGVuZHMgUmluZyB7XG4gIGNvbigpIHsgcmV0dXJuIHRoaXMuYnVjOyB9XG59XG5cbkByYXJpdHkoMTUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkNvcHBlcilcbmV4cG9ydCBjbGFzcyBSaW5nT2ZEZXh0ZXJpdHkgZXh0ZW5kcyBSaW5nIHtcbiAgZGV4KCkgeyByZXR1cm4gdGhpcy5idWM7IH1cbn1cblxuQHJhcml0eSgyMClcbkBtYXRlcmlhbChNYXRlcmlhbHMuQ29wcGVyKVxuZXhwb3J0IGNsYXNzIFJpbmdPZkludGVsbGlnZW5jZSBleHRlbmRzIFJpbmcge1xuICBpbnQoKSB7IHJldHVybiB0aGlzLmJ1YzsgfVxufVxuXG5AcmFyaXR5KDI1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Db3BwZXIpXG5leHBvcnQgY2xhc3MgUmluZ09mV2lzZG9tIGV4dGVuZHMgUmluZyB7XG4gIHdpcygpIHsgcmV0dXJuIHRoaXMuYnVjOyB9XG59XG5cbkByYXJpdHkoMilcbkBtYXRlcmlhbChNYXRlcmlhbHMuR29sZClcbmV4cG9ydCBjbGFzcyBSaW5nT2ZBZG9ybm1lbnQgZXh0ZW5kcyBSaW5nIHtcbiAgY2hhKCkgeyByZXR1cm4gdGhpcy5idWM7IH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Db3BwZXIpXG5leHBvcnQgY2xhc3MgUmluZ09mTHVjayBleHRlbmRzIFJpbmcge1xuICBsdWsoKSB7IHJldHVybiB0aGlzLmJ1YzsgfVxufVxuXG4vLyBlbmRyZWdpb25cblxuLy8gcmVnaW9uIFRyYWl0IFJpbmdzXG5AcmFyaXR5KDUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkNvcHBlcilcbmV4cG9ydCBjbGFzcyBSaW5nT2ZQcm90ZWN0aW9uIGV4dGVuZHMgUmluZyB7XG4gIFByb3RlY3Rpb24oKSB7IHJldHVybiB0aGlzLmJ1YzsgfVxufVxuXG5AcmFyaXR5KDQpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkNvcHBlcilcbmV4cG9ydCBjbGFzcyBSaW5nT2ZIYXN0ZSBleHRlbmRzIFJpbmcge1xuICBIYXN0ZSgpIHsgcmV0dXJuIHRoaXMuYnVjICogMjU7IH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Db3BwZXIpXG5leHBvcnQgY2xhc3MgUmluZ09mU2lnaHQgZXh0ZW5kcyBSaW5nIHtcbiAgSW5mcmF2aXNpb24oKSB7IHJldHVybiB0aGlzLmJ1YzsgfVxufVxuXG5AcmFyaXR5KDI1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Db3BwZXIpXG5leHBvcnQgY2xhc3MgUmluZ09mQWNjdXJhY3kgZXh0ZW5kcyBSaW5nIHtcbiAgdG9IaXQoKSB7IHJldHVybiBgMGQwICske3RoaXMuYnVjfWA7IH1cbn1cblxuQHJhcml0eSgxNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuQ29wcGVyKVxuZXhwb3J0IGNsYXNzIFJpbmdPZkJvbnVzRGFtYWdlIGV4dGVuZHMgUmluZyB7XG4gIGJvbnVzRGFtYWdlKCkgeyByZXR1cm4gYDBkMCArJHt0aGlzLmJ1Y31gOyB9XG59XG5cbkByYXJpdHkoMSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuQ2xvdGgpXG5leHBvcnQgY2xhc3MgUmluZ09mU3RlYWx0aCBleHRlbmRzIFJpbmcge1xuICBTdGVhbHRoKCkgeyByZXR1cm4gdGhpcy5idWMgKiAyOyB9XG59XG5cbkByYXJpdHkoMSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuQ2xvdGgpXG5leHBvcnQgY2xhc3MgUmluZ09mSW52aXNpYmlsaXR5IGV4dGVuZHMgUmluZyB7XG4gIEludmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMuYnVjOyB9XG59XG5cbkByYXJpdHkoMSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuQ2xvdGgpXG5leHBvcnQgY2xhc3MgUmluZ09mU2VlSW52aXNpYmxlIGV4dGVuZHMgUmluZyB7XG4gIFNlZUludmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMuYnVjOyB9XG59XG5cbkByYXJpdHkoMSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuTGVhdGhlcilcbmV4cG9ydCBjbGFzcyBSaW5nT2ZXYXJuaW5nIGV4dGVuZHMgUmluZyB7XG4gIFdhcm5pbmcoKSB7IHJldHVybiB0aGlzLmJ1YyAqIDI7IH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Db3BwZXIpXG5leHBvcnQgY2xhc3MgUmluZ09mUmVnZW5lcmF0aW9uIGV4dGVuZHMgUmluZyB7XG4gIGhwUmVnZW4oKSB7IHJldHVybiAtMyAqIHRoaXMuYnVjOyB9XG4gIG1wUmVnZW4oKSB7IHJldHVybiAtMyAqIHRoaXMuYnVjOyB9XG59XG5cbi8vIGVuZHJlZ2lvblxuXG4vLyByZWdpb24gUmVzaXN0YW5jZSBSaW5nc1xuQHJhcml0eSg1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Xb29kKVxuZXhwb3J0IGNsYXNzIFJpbmdPZlBvaXNvblJlc2lzdGFuY2UgZXh0ZW5kcyBSaW5nIHtcbiAgUG9pc29uUmVzaXN0YW5jZSgpIHsgcmV0dXJuIHRoaXMuYnVjOyB9XG59XG5cbkByYXJpdHkoNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBSaW5nT2ZTaG9ja1Jlc2lzdGFuY2UgZXh0ZW5kcyBSaW5nIHtcbiAgU2hvY2tSZXNpc3RhbmNlKCkgeyByZXR1cm4gdGhpcy5idWM7IH1cbn1cblxuQHJhcml0eSg1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5MZWF0aGVyKVxuZXhwb3J0IGNsYXNzIFJpbmdPZkFjaWRSZXNpc3RhbmNlIGV4dGVuZHMgUmluZyB7XG4gIEFjaWRSZXNpc3RhbmNlKCkgeyByZXR1cm4gdGhpcy5idWM7IH1cbn1cblxuQHJhcml0eSg1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5MZWF0aGVyKVxuZXhwb3J0IGNsYXNzIFJpbmdPZkZpcmVSZXNpc3RhbmNlIGV4dGVuZHMgUmluZyB7XG4gIEZpcmVSZXNpc3RhbmNlKCkgeyByZXR1cm4gdGhpcy5idWM7IH1cbn1cblxuQHJhcml0eSg1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5HbGFzcylcbmV4cG9ydCBjbGFzcyBSaW5nT2ZJY2VSZXNpc3RhbmNlIGV4dGVuZHMgUmluZyB7XG4gIEljZVJlc2lzdGFuY2UoKSB7IHJldHVybiB0aGlzLmJ1YzsgfVxufVxuLy8gZW5kcmVnaW9uIiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgU3BlbGxib29rIH0gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvZXF1aXBtZW50JztcbmltcG9ydCBBdHRhY2tzIGZyb20gJy4uL2F0dGFja3MvX2FsbCc7XG5pbXBvcnQgeyByYXJpdHkgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZGVjb3JhdG9ycyc7XG5cbkByYXJpdHkoMjUpXG5leHBvcnQgY2xhc3MgRm9yY2VCb2x0IGV4dGVuZHMgU3BlbGxib29rIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgbWFuYUNvc3Q6IDIsXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5Gb3JjZSh7IHJvbGw6ICcyZDYnLCByYW5nZTogNCB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDApXG5leHBvcnQgY2xhc3MgQ3VyZVNlbGYgZXh0ZW5kcyBTcGVsbGJvb2sge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBtYW5hQ29zdDogMTAsXG4gICAgICBoZWFsUm9sbDogJzNkNidcbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDApXG5leHBvcnQgY2xhc3MgRXh0cmFDdXJlU2VsZiBleHRlbmRzIFNwZWxsYm9vayB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIG1hbmFDb3N0OiAyNSxcbiAgICAgIGhlYWxSb2xsOiAnNmQ2J1xuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgV2FuZCB9IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgQXR0YWNrcyBmcm9tICcuLi9hdHRhY2tzL19hbGwnO1xuaW1wb3J0IHsgcmFyaXR5IH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2RlY29yYXRvcnMnO1xuXG5AcmFyaXR5KDI1KVxuZXhwb3J0IGNsYXNzIFdhbmRPZlN0cmlraW5nIGV4dGVuZHMgV2FuZCB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGNoYXJnZXM6ICcyZDUnLFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuRm9yY2UoeyByb2xsOiAnMmQ2JywgcmFuZ2U6IDQgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cbiIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEhhbmRzIH0gZnJvbSAnLi4vLi4vLi4vZGVmaW5pdGlvbnMvZXF1aXBtZW50JztcbmltcG9ydCBBdHRhY2tzIGZyb20gJy4uLy4uL2F0dGFja3MvX2FsbCc7XG5pbXBvcnQgTWF0ZXJpYWxzIGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy9tYXRlcmlhbHMnO1xuaW1wb3J0IHsgbWF0ZXJpYWwsIHJhcml0eSwgdHdvSGFuZGVkIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzL2RlY29yYXRvcnMnO1xuXG5AcmFyaXR5KDEwKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Xb29kKVxuZXhwb3J0IGNsYXNzIEF4ZSBleHRlbmRzIEhhbmRzIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgZ2x5cGg6IHsgZmc6ICcjY2NjJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU3RhYih7IHJvbGw6ICcxZDYnIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoMylcbkBtYXRlcmlhbChNYXRlcmlhbHMuV29vZClcbkB0d29IYW5kZWRcbmV4cG9ydCBjbGFzcyBCYXR0bGVBeGUgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAnI2NjYycgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlN0YWIoeyByb2xsOiAnMWQ4ICsgMWQ0JyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDEpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5leHBvcnQgY2xhc3MgRHdhcnZpc2hNYXR0b2NrIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJyNjY2MnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TdGFiKHsgcm9sbDogJzFkMTIgKyAxZDQnIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgSGFuZHMgfSBmcm9tICcuLi8uLi8uLi9kZWZpbml0aW9ucy9lcXVpcG1lbnQnO1xuaW1wb3J0IEF0dGFja3MgZnJvbSAnLi4vLi4vYXR0YWNrcy9fYWxsJztcbmltcG9ydCBNYXRlcmlhbHMgZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzL21hdGVyaWFscyc7XG5pbXBvcnQgeyBtYXRlcmlhbCwgcmFyaXR5LCB0d29IYW5kZWQsIHJhbmdlZCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcblxuY29uc3QgYWxsQXJyb3dzID0gWydvcmNpc2hhcnJvdycsICdhcnJvdycsICdlbHZlbmFycm93J107XG5cbkByYXJpdHkoMzUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5AdHdvSGFuZGVkXG5AcmFuZ2VkKHsgYW1tbzogYWxsQXJyb3dzLCBkYW1hZ2VCb29zdDogJzFkMScgfSlcbmV4cG9ydCBjbGFzcyBPcmNpc2hCb3cgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAnI2YwMCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlJhbmdlZCh7IHJvbGw6ICcxZDEnIH0pXSAvLyBpZiBpdCBjYW4ndCBzaG9vdCBhcnJvd3MsIGl0J2xsIGJhc2ggZm9yIDFkMVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoMjUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5AdHdvSGFuZGVkXG5AcmFuZ2VkKHsgYW1tbzogWydyb2NrJywgJ2ZsaW50IHN0b25lJ10sIGRhbWFnZUJvb3N0OiAnMWQyJyB9KVxuZXhwb3J0IGNsYXNzIFNsaW5nIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJyNmMDAnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5SYW5nZWQoeyByb2xsOiAnMWQxJyB9KV0gLy8gaWYgaXQgY2FuJ3Qgc2hvb3QgYXJyb3dzLCBpdCdsbCBiYXNoIGZvciAxZDJcbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDI1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Xb29kKVxuQHR3b0hhbmRlZFxuQHJhbmdlZCh7IGFtbW86IGFsbEFycm93cywgZGFtYWdlQm9vc3Q6ICcxZDInIH0pXG5leHBvcnQgY2xhc3MgQm93IGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJyNmMDAnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5SYW5nZWQoeyByb2xsOiAnMWQyJyB9KV0gLy8gaWYgaXQgY2FuJ3Qgc2hvb3QgYXJyb3dzLCBpdCdsbCBiYXNoIGZvciAxZDJcbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDE1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Xb29kKVxuQHR3b0hhbmRlZFxuQHJhbmdlZCh7IGFtbW86IGFsbEFycm93cywgZGFtYWdlQm9vc3Q6ICcxZDMnIH0pXG5leHBvcnQgY2xhc3MgRWx2ZW5Cb3cgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAnI2YwMCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlJhbmdlZCh7IHJvbGw6ICcxZDMnIH0pXSAvLyBpZiBpdCBjYW4ndCBzaG9vdCBhcnJvd3MsIGl0J2xsIGJhc2ggZm9yIDFkM1xuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoMjUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5AdHdvSGFuZGVkXG5AcmFuZ2VkKHsgYW1tbzogWydib2x0J10sIGRhbWFnZUJvb3N0OiAnMWQzJyB9KVxuZXhwb3J0IGNsYXNzIENyb3NzYm93IGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJyNmMDAnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5SYW5nZWQoeyByb2xsOiAnMWQyJyB9KV0gLy8gaWYgaXQgY2FuJ3Qgc2hvb3QgYXJyb3dzLCBpdCdsbCBiYXNoIGZvciAxZDJcbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuIiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgSGFuZHMgfSBmcm9tICcuLi8uLi8uLi9kZWZpbml0aW9ucy9lcXVpcG1lbnQnO1xuaW1wb3J0IEF0dGFja3MgZnJvbSAnLi4vLi4vYXR0YWNrcy9fYWxsJztcbmltcG9ydCBNYXRlcmlhbHMgZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzL21hdGVyaWFscyc7XG5pbXBvcnQgeyBtYXRlcmlhbCwgcmFyaXR5IH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzL2RlY29yYXRvcnMnO1xuXG5AcmFyaXR5KDM1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Db3BwZXIpXG5leHBvcnQgY2xhc3MgT3JjaXNoRGFnZ2VyIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJyNjY2MnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TdGFiKHsgcm9sbDogJzFkMycgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSgyNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBEYWdnZXIgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlN0YWIoeyByb2xsOiAnMWQ0JyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDI1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIFNjYWxwZWwgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlN0YWIoeyByb2xsOiAnMWQzJyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDE1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5TaWx2ZXIpXG5leHBvcnQgY2xhc3MgU2lsdmVyRGFnZ2VyIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TdGFiKHsgcm9sbDogJzFkNScgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSgxNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuV29vZClcbmV4cG9ydCBjbGFzcyBFbHZlbkRhZ2dlciBleHRlbmRzIEhhbmRzIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgZ2x5cGg6IHsgZmc6ICd0ZWFsJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU3RhYih7IHJvbGw6ICcxZDcnIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuTWluZXJhbClcbmV4cG9ydCBjbGFzcyBDcnlza25pZmUgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlN0YWIoeyByb2xsOiAnMWQxMCcgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBIYW5kcyB9IGZyb20gJy4uLy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgQXR0YWNrcyBmcm9tICcuLi8uLi9hdHRhY2tzL19hbGwnO1xuaW1wb3J0IE1hdGVyaWFscyBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMvbWF0ZXJpYWxzJztcbmltcG9ydCB7IG1hdGVyaWFsLCByYXJpdHksIHR3b0hhbmRlZCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcblxuQHJhcml0eSgyNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBMb25nc3dvcmQgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNsYXNoKHsgcm9sbDogJzFkOCcgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSgxNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBLYXRhbmEgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNsYXNoKHsgcm9sbDogJzFkMTAnIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoMjApXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgQnJvYWRzd29yZCBleHRlbmRzIEhhbmRzIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgZ2x5cGg6IHsgZmc6ICd0ZWFsJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU2xhc2goeyByb2xsOiAnMmQ0JyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5leHBvcnQgY2xhc3MgRWx2ZW5Ccm9hZHN3b3JkIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TbGFzaCh7IHJvbGw6ICcxZDYgKyAxZDQnIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoMSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuU2lsdmVyKVxuZXhwb3J0IGNsYXNzIFNpbHZlclNhYmVyIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TbGFzaCh7IHJvbGw6ICcxZDgnLCB0b0hpdDogJzFkNCcgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSg1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIFNjaW1pdGFyIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TbGFzaCh7IHJvbGw6ICcxZDgnLCB0b0hpdDogJzFkNCcgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSgxNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbkB0d29IYW5kZWRcbmV4cG9ydCBjbGFzcyBHcmVhdHN3b3JkIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TbGFzaCh7IHJvbGw6ICcxZDEyJyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDEpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5AdHdvSGFuZGVkXG5leHBvcnQgY2xhc3MgVHN1cnVnaSBleHRlbmRzIEhhbmRzIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgZ2x5cGg6IHsgZmc6ICd0ZWFsJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU2xhc2goeyByb2xsOiAnMWQxNicgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBIYW5kcyB9IGZyb20gJy4uLy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgQXR0YWNrcyBmcm9tICcuLi8uLi9hdHRhY2tzL19hbGwnO1xuaW1wb3J0IE1hdGVyaWFscyBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMvbWF0ZXJpYWxzJztcbmltcG9ydCB7IG1hdGVyaWFsLCByYXJpdHksIHR3b0hhbmRlZCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcblxuQHJhcml0eSgyNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuTGVhdGhlcilcbmV4cG9ydCBjbGFzcyBCdWxsd2hpcCBleHRlbmRzIEhhbmRzIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgZ2x5cGg6IHsgZmc6ICd0ZWFsJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU21hc2goeyByb2xsOiAnMWQzJyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDE1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5QbGFzdGljKVxuZXhwb3J0IGNsYXNzIEdhcmRlbkhvc2UgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNtYXNoKHsgcm9sbDogJzFkMicgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSgyNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuV29vZClcbmV4cG9ydCBjbGFzcyBDbHViIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TbWFzaCh7IHJvbGw6ICcxZDYnIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoMjUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgQWtseXMgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNtYXNoKHsgcm9sbDogJzFkNicgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSgyMClcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbmV4cG9ydCBjbGFzcyBNYWNlIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TbWFzaCh7IHJvbGw6ICcxZDYgKyAxJyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgRmxhaWwgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNtYXNoKHsgcm9sbDogJzFkNiArIDInLCB0b0hpdDogJzFkMicgfSksIEF0dGFja3MuU3RhYih7IHJvbGw6ICcxZDInIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoMTUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgTW9ybmluZ3N0YXIgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlNtYXNoKHsgcm9sbDogJzJkNCcgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuQHR3b0hhbmRlZFxuZXhwb3J0IGNsYXNzIFdhcmhhbW1lciBleHRlbmRzIEhhbmRzIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgZ2x5cGg6IHsgZmc6ICd0ZWFsJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU21hc2goeyByb2xsOiAnMmQxNCcgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBIYW5kcyB9IGZyb20gJy4uLy4uLy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5pbXBvcnQgQXR0YWNrcyBmcm9tICcuLi8uLi9hdHRhY2tzL19hbGwnO1xuaW1wb3J0IE1hdGVyaWFscyBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMvbWF0ZXJpYWxzJztcbmltcG9ydCB7IG1hdGVyaWFsLCByYXJpdHkgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMvZGVjb3JhdG9ycyc7XG5cbkByYXJpdHkoMjUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkNvcHBlcilcbmV4cG9ydCBjbGFzcyBPcmNpc2hTaG9ydFN3b3JkIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJyNjY2MnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TbGFzaCh7IHJvbGw6ICcxZDUnIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoMjUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgU2hvcnRzd29yZCBleHRlbmRzIEhhbmRzIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgZ2x5cGg6IHsgZmc6ICd0ZWFsJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU2xhc2goeyByb2xsOiAnMWQ2JyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDE1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Jcm9uKVxuZXhwb3J0IGNsYXNzIER3YXJ2ZW5TaG9ydHN3b3JkIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TbGFzaCh7IHJvbGw6ICcxZDcnIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG5cbkByYXJpdHkoNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuV29vZClcbmV4cG9ydCBjbGFzcyBFbHZpc2hTaG9ydHN3b3JkIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TbGFzaCh7IHJvbGw6ICcxZDgnIH0pXVxuICAgIH0pO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgSGFuZHMgfSBmcm9tICcuLi8uLi8uLi9kZWZpbml0aW9ucy9lcXVpcG1lbnQnO1xuaW1wb3J0IEF0dGFja3MgZnJvbSAnLi4vLi4vYXR0YWNrcy9fYWxsJztcbmltcG9ydCBNYXRlcmlhbHMgZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzL21hdGVyaWFscyc7XG5pbXBvcnQgeyBtYXRlcmlhbCwgcmFyaXR5LCB0d29IYW5kZWQgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMvZGVjb3JhdG9ycyc7XG5cbkByYXJpdHkoMzUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5AdHdvSGFuZGVkXG5leHBvcnQgY2xhc3MgT3JjaXNoU3BlYXIgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAnI2NjYycgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlN0YWIoeyByb2xsOiAnMWQ1JyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDI1KVxuQG1hdGVyaWFsKE1hdGVyaWFscy5Xb29kKVxuQHR3b0hhbmRlZFxuZXhwb3J0IGNsYXNzIFNwZWFyIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJ3RlYWwnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5TdGFiKHsgcm9sbDogJzFkNicgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cblxuQHJhcml0eSgxNSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuSXJvbilcbkB0d29IYW5kZWRcbmV4cG9ydCBjbGFzcyBEd2FydmVuU3BlYXIgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlN0YWIoeyByb2xsOiAnMWQ3JyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5AdHdvSGFuZGVkXG5leHBvcnQgY2xhc3MgRWx2aXNoU3BlYXIgZXh0ZW5kcyBIYW5kcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIF8uZXh0ZW5kKG9wdHMsIHtcbiAgICAgIGdseXBoOiB7IGZnOiAndGVhbCcgfSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLlN0YWIoeyByb2xsOiAnMWQ4JyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDEpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5AdHdvSGFuZGVkXG5leHBvcnQgY2xhc3MgVHJpZGVudCBleHRlbmRzIEhhbmRzIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgXy5leHRlbmQob3B0cywge1xuICAgICAgZ2x5cGg6IHsgZmc6ICd0ZWFsJyB9LFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuU3RhYih7IHJvbGw6ICcyZDYgKyAxJyB9KV1cbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxuXG4gIExpemFyZEJhbmUoKSB7IHJldHVybiAyOyB9XG4gIExpemFyZEZ1cnkoKSB7IHJldHVybiAxOyB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgSGFuZHMgfSBmcm9tICcuLi8uLi8uLi9kZWZpbml0aW9ucy9lcXVpcG1lbnQnO1xuaW1wb3J0IEF0dGFja3MgZnJvbSAnLi4vLi4vYXR0YWNrcy9fYWxsJztcbmltcG9ydCBNYXRlcmlhbHMgZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzL21hdGVyaWFscyc7XG5pbXBvcnQgeyBtYXRlcmlhbCwgcmFyaXR5LCB0d29IYW5kZWQgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMvZGVjb3JhdG9ycyc7XG5cbkByYXJpdHkoMjUpXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLldvb2QpXG5AdHdvSGFuZGVkXG5leHBvcnQgY2xhc3MgUXVhcnRlcnN0YWZmIGV4dGVuZHMgSGFuZHMge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBfLmV4dGVuZChvcHRzLCB7XG4gICAgICBnbHlwaDogeyBmZzogJyM0OTMxMWMnIH0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5CYXNoKHsgcm9sbDogJzFkNicgfSldXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cbiIsIlxuaW1wb3J0IHsgV3Jpc3QgfSBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9lcXVpcG1lbnQnO1xuaW1wb3J0IHsgQUMgfSBmcm9tICcuLi8uLi9saWIvZGVmYXVsdC1jYWxjdWxhdGlvbnMnO1xuaW1wb3J0IE1hdGVyaWFscyBmcm9tICcuLi8uLi9jb25zdGFudHMvbWF0ZXJpYWxzJztcbmltcG9ydCB7IG1hdGVyaWFsLCByYXJpdHksIHR3b0hhbmRlZCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9kZWNvcmF0b3JzJztcblxuQHJhcml0eSg0NSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuTGVhdGhlcilcbkB0d29IYW5kZWRcbmV4cG9ydCBjbGFzcyBMZWF0aGVyR2xvdmVzIGV4dGVuZHMgV3Jpc3Qge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcyk7XG4gIH1cbn1cblxuQHJhcml0eSg0NSlcbkBtYXRlcmlhbChNYXRlcmlhbHMuTGVhdGhlcilcbmV4cG9ydCBjbGFzcyBCcmFjZXIgZXh0ZW5kcyBXcmlzdCB7XG4gIGFjKCkge1xuICAgIHJldHVybiBBQyh0aGlzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDEwKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5MZWF0aGVyKVxuQHR3b0hhbmRlZFxuZXhwb3J0IGNsYXNzIEdhdW50bGV0c09mRGV4dGVyaXR5IGV4dGVuZHMgV3Jpc3Qge1xuICBhYygpIHtcbiAgICByZXR1cm4gQUModGhpcyk7XG4gIH1cbiAgZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmJ1YyAqIC0yO1xuICB9XG59XG5cbkByYXJpdHkoMTApXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLkxlYXRoZXIpXG5AdHdvSGFuZGVkXG5leHBvcnQgY2xhc3MgR2F1bnRsZXRzT2ZTdHJlbmd0aCBleHRlbmRzIFdyaXN0IHtcbiAgYWMoKSB7XG4gICAgcmV0dXJuIEFDKHRoaXMpO1xuICB9XG4gIHN0cigpIHtcbiAgICByZXR1cm4gdGhpcy5idWMgKiAtMjtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIENhbmluZXMgZnJvbSAnLi9jYW5pbmVzJztcbmltcG9ydCAqIGFzIEVsZW1lbnRhbHMgZnJvbSAnLi9lbGVtZW50YWxzJztcbmltcG9ydCAqIGFzIEdub21lcyBmcm9tICcuL2dub21lcyc7XG5pbXBvcnQgKiBhcyBJbnNlY3RzIGZyb20gJy4vaW5zZWN0cyc7XG5pbXBvcnQgKiBhcyBKZWxsaWVzIGZyb20gJy4vamVsbGllcyc7XG5pbXBvcnQgKiBhcyBLb2JvbGRzIGZyb20gJy4va29ib2xkcyc7XG5pbXBvcnQgKiBhcyBOeW1waHMgZnJvbSAnLi9ueW1waHMnO1xuaW1wb3J0ICogYXMgT3JjcyBmcm9tICcuL29yY3MnO1xuaW1wb3J0ICogYXMgUHVkZGluZ3MgZnJvbSAnLi9wdWRkaW5ncyc7XG5pbXBvcnQgKiBhcyBSYXRzIGZyb20gJy4vcmF0cyc7XG5pbXBvcnQgKiBhcyBMaXphcmRzIGZyb20gJy4vbGl6YXJkcyc7XG5pbXBvcnQgKiBhcyBTcG9yZXMgZnJvbSAnLi9zcG9yZXMnO1xuaW1wb3J0ICogYXMgU3VtbW9uZWQgZnJvbSAnLi9fc3VtbW9uZWQnO1xuXG5leHBvcnQgZGVmYXVsdCBfLmV4dGVuZCh7fSwgQ2FuaW5lcywgRWxlbWVudGFscywgR25vbWVzLFxuICBJbnNlY3RzLCBKZWxsaWVzLCBLb2JvbGRzLCBMaXphcmRzLCBOeW1waHMsIE9yY3MsIFB1ZGRpbmdzLCBSYXRzLFxuICBTcG9yZXMsIFN1bW1vbmVkKTsiLCJcbmltcG9ydCB7IFdhbmQgYXMgUmFuZG9tV2FuZCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9yYW5kb20nO1xuaW1wb3J0ICogYXMgQmVoYXZpb3JzIGZyb20gJy4uL2JlaGF2aW9ycy9fYWxsJztcbmltcG9ydCBBdHRhY2tzIGZyb20gJy4uL2F0dGFja3MvX2FsbCc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhzJztcbmltcG9ydCB7IFNwZWNpYWwgYXMgU3BlY2lhbEdseXBoQ29sb3JzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBoQ29sb3JzJztcblxuZXhwb3J0IGNvbnN0IFNlbHlrID0geyBkaWZmaWN1bHR5OiAxMCwgc3Bhd25QYXR0ZXJuOiAnMWQxJywgZnJlcXVlbmN5OiAwLCBpbml0OiAoKSA9PlxuICAoeyBpbXBvcnRhbnQ6IHRydWUsIGdseXBoOiB7IGtleTogR2x5cGhzLkh1bWFub2lkLCBmZzogU3BlY2lhbEdseXBoQ29sb3JzLlNlbHlrIH0sXG4gIGF0dHJpYnV0ZXM6IHsgYWM6IC0xMCwgc3BlZWQ6IDIwMCwgbGV2ZWw6IDIwLCBzdHI6ICcyZDEwJywgY29uOiAnMmQxMCcsIGludDogJzNkMTAnLCBtcDogJzVkMTAnLCBraWxsWHA6ICc1MGQxMCcsIHNwYXduSHA6ICc1ZDEwICsgMjUnIH0sXG4gIHN0YXRzOiB7IG5hbWU6ICdTZWx5aycsIHJhY2U6ICdIdW1hbicsIHByb2Zlc3Npb246ICdXaXphcmQnLFxuICAgIHN0YXJ0aW5nRXF1aXBtZW50OiBbXG4gICAgICB7IGluaXQ6ICgpID0+IFJhbmRvbVdhbmQoeyBidWNOYW1lOiAnYmxlc3NlZCcsIGNoYXJnZXM6ICc1ZDUnIH0pIH1cbiAgICBdLFxuICAgIGJlaGF2aW9yczogW0JlaGF2aW9ycy5CbG9vZHRoaXJzdHkoKSwgQmVoYXZpb3JzLkF0dGFja3MoKSwgQmVoYXZpb3JzLlRlbGVwb3J0c1doZW5IaXQoKSwgQmVoYXZpb3JzLk9wZW5zRG9vcnMoKV0sXG4gICAgYXR0YWNrczogW0F0dGFja3MuRWxlY3RyaWNUb3VjaCh7IHJvbGw6ICcxZDEnLCB0b0hpdDogJzFkNScgfSldXG4gIH0gfSkgfTsiLCJcbmltcG9ydCAqIGFzIEJlaGF2aW9ycyBmcm9tICcuLi9iZWhhdmlvcnMvX2FsbCc7XG5pbXBvcnQgKiBhcyBBdHRhY2tzIGZyb20gJy4uL2F0dGFja3MvX2FsbCc7XG5pbXBvcnQgRmFjdGlvbnMgZnJvbSAnLi4vLi4vY29uc3RhbnRzL2ZhY3Rpb25zJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBocyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaHMnO1xuaW1wb3J0IHsgRW50aXRpZXMgYXMgR2x5cGhDb2xvcnMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhDb2xvcnMnO1xuXG5leHBvcnQgY29uc3Qgd2F0ZXJNb2NjYXNpbiA9IHsgZGlmZmljdWx0eTogNywgc3Bhd25QYXR0ZXJuOiAnMWQxJywgZnJlcXVlbmN5OiAwLCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5TbmFrZSwgZmc6IEdseXBoQ29sb3JzLkVsZW1lbnRzLldhdGVyIH0sXG4gICAgYWRkQW50aUZhY3Rpb25zOiBbRmFjdGlvbnMuQUxMXSxcbiAgICBhdHRyaWJ1dGVzOiB7IGFjOiAtNywgc3BlZWQ6IDIwMCwgbGV2ZWw6IDQsIGtpbGxYcDogJzZkMTAnLCBzcGF3bkhwOiAnMmQ0JyB9LFxuICAgIHN0YXRzOiB7IG5hbWU6ICd3YXRlciBtb2NjYXNpbicsIHJhY2U6ICdTbmFrZScsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDEwKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldLFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuUG9pc29uKHsgcm9sbDogJzFkNicgfSldXG4gICAgfSB9KSB9O1xuXG5leHBvcnQgY29uc3Qgd2F0ZXJEZW1vbiA9IHsgZGlmZmljdWx0eTogMTEsIHNwYXduUGF0dGVybjogJzFkMScsIGZyZXF1ZW5jeTogMCwgaW5pdDogKCkgPT5cbiAgKHsgZ2x5cGg6IHsga2V5OiBHbHlwaHMuRGVtb24sIGZnOiBHbHlwaENvbG9ycy5FbGVtZW50cy5XYXRlciB9LFxuICAgIGF0dHJpYnV0ZXM6IHsgYWM6IC0xNCwgc3BlZWQ6IDE3NSwgbGV2ZWw6IDgsIGtpbGxYcDogJzE4ZDEwJywgc3Bhd25IcDogJzVkMTAnIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ3dhdGVyIGRlbW9uJywgcmFjZTogJ0RlbW9uJyxcbiAgICAgIGJlaGF2aW9yczogW0JlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKSwgQmVoYXZpb3JzLkRyb3BzSXRlbXMoKV1cbiAgICB9IH0pIH07IiwiXG5pbXBvcnQgKiBhcyBCZWhhdmlvcnMgZnJvbSAnLi4vYmVoYXZpb3JzL19hbGwnO1xuaW1wb3J0IEF0dGFja3MgZnJvbSAnLi4vYXR0YWNrcy9fYWxsJztcbmltcG9ydCAqIGFzIEZvb2RzIGZyb20gJy4uL2l0ZW1zL2Zvb2RzJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBocyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaHMnO1xuaW1wb3J0IHsgRW50aXRpZXMgYXMgR2x5cGhDb2xvcnMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhDb2xvcnMnO1xuXG5leHBvcnQgY29uc3QgamFja2FsID0geyBkaWZmaWN1bHR5OiAyLCBzcGF3blBhdHRlcm46ICcxZDMgKyAxJywgZnJlcXVlbmN5OiAyNSwgaW5pdDogKCkgPT5cbiAgKHsgZ2x5cGg6IHsga2V5OiBHbHlwaHMuQ2FuaW5lLCBmZzogR2x5cGhDb2xvcnMuVGllcnMuQmFzaWMgfSxcbiAgc3RhcnRpbmdFcXVpcG1lbnQ6IFtcbiAgICB7IHByb2JhYmlsaXR5OiAyMCwgaW5pdDogKCkgPT4gbmV3IEZvb2RzLlJhdGlvbih7IGNoYXJnZXM6ICcxZDInIH0pIH1cbiAgXSxcbiAgYXR0cmlidXRlczogeyBhYzogLTMsIHNwZWVkOiAxMjUsIGxldmVsOiAxLCBzdHI6ICcxZDQgKyAyJywgZGV4OiAnMmQzICsgNCcsIGNvbjogNCwga2lsbFhwOiAnMmQzICsgMycsIHNwYXduSHA6ICczZDMgKyA1JyB9LFxuICBzdGF0czogeyBuYW1lOiAnamFja2FsJywgcmFjZTogJ0NhbmluZScsXG4gICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSg1KSwgQmVoYXZpb3JzLkRyb3BzR29sZCgnMWQxMCcpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRWaWFIZWFyaW5nKCksIEJlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKSwgQmVoYXZpb3JzLkRyb3BzSXRlbXMoKV0sXG4gICAgYXR0YWNrczogW0F0dGFja3MuQml0ZSh7IHJvbGw6ICcxZDIgKyAxJywgdG9IaXQ6ICcxZDInIH0pXVxuICB9IH0pIH07XG5cbmV4cG9ydCBjb25zdCBmb3ggPSB7IGRpZmZpY3VsdHk6IDEsIHNwYXduUGF0dGVybjogJzFkMyArIDEnLCBmcmVxdWVuY3k6IDMwLCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5DYW5pbmUsIGZnOiBHbHlwaENvbG9ycy5UaWVycy5XZWFrIH0sXG4gIGF0dHJpYnV0ZXM6IHsgYWM6IC0xLCBzcGVlZDogMTUwLCBsZXZlbDogMSwgc3RyOiAnMWQzJywgZGV4OiAnMWQzICsgNCcsIGNvbjogNCwga2lsbFhwOiAnMmQzICsgMycsIHNwYXduSHA6ICcxZDMgKyA1JyB9LFxuICBzdGF0czogeyBuYW1lOiAnZm94JywgcmFjZTogJ0NhbmluZScsXG4gICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSg0MCksIEJlaGF2aW9ycy5Ecm9wc0dvbGQoJzFkMTAnKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCksIEJlaGF2aW9ycy5Ecm9wc0l0ZW1zKCldLFxuICAgIGF0dGFja3M6IFtBdHRhY2tzLkJpdGUoeyByb2xsOiAnMWQyICsgMScgfSldXG4gIH0gfSkgfTsiLCJcbmltcG9ydCAqIGFzIEJlaGF2aW9ycyBmcm9tICcuLi9iZWhhdmlvcnMvX2FsbCc7XG5pbXBvcnQgQXR0YWNrcyBmcm9tICcuLi9hdHRhY2tzL19hbGwnO1xuaW1wb3J0IHsgRW50aXRpZXMgYXMgR2x5cGhzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBocyc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaENvbG9ycyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaENvbG9ycyc7XG5cbmV4cG9ydCBjb25zdCB3YXRlckVsZW1lbnRhbCA9IHsgZGlmZmljdWx0eTogMTAsIHNwYXduUGF0dGVybjogJzFkMiArIDEnLCBmcmVxdWVuY3k6IDEsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLkVsZW1lbnRhbCwgZmc6IEdseXBoQ29sb3JzLkVsZW1lbnRzLldhdGVyIH0sXG4gIGF0dHJpYnV0ZXM6IHsgYWM6IC04LCBzcGVlZDogNTAsIGxldmVsOiA4LCBraWxsWHA6ICcxM2QxMCcsIHNwYXduSHA6ICc3ZDcnIH0sXG4gIHN0YXRzOiB7IG5hbWU6ICd3YXRlciBlbGVtZW50YWwnLCByYWNlOiAnRWxlbWVudGFsJyxcbiAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuU2Vla3NUYXJnZXRWaWFIZWFyaW5nKCksIEJlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKV0sXG4gICAgYXR0YWNrczogW0F0dGFja3MuQ2xhdyh7IHJvbGw6ICc1ZDYnIH0pXVxuICB9IH0pIH07IiwiXG5pbXBvcnQgKiBhcyBCZWhhdmlvcnMgZnJvbSAnLi4vYmVoYXZpb3JzL19hbGwnO1xuaW1wb3J0ICogYXMgV2VhcG9ucyBmcm9tICcuLi9pdGVtcy9fd2VhcG9ucyc7XG5pbXBvcnQgKiBhcyBQcm9qZWN0aWxlcyBmcm9tICcuLi9pdGVtcy9wcm9qZWN0aWxlcyc7XG5pbXBvcnQgKiBhcyBGZWV0cyBmcm9tICcuLi9pdGVtcy9mZWV0cyc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhzJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBoQ29sb3JzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBoQ29sb3JzJztcblxuZXhwb3J0IGNvbnN0IGdub21lID0geyBkaWZmaWN1bHR5OiAzLCBzcGF3blBhdHRlcm46ICcxZDInLCBmcmVxdWVuY3k6IDMsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLkdub21lLCBmZzogR2x5cGhDb2xvcnMuVGllcnMuV2VhayB9LFxuICAgIHN0YXJ0aW5nRXF1aXBtZW50OiBbXG4gICAgICB7IGNob2ljZXM6IHsgYm93OiAxLCBjcm9zc2JvdzogMSwgZGFydHM6IDEgfSxcbiAgICAgICAgY2hvaWNlc0luaXQ6IHtcbiAgICAgICAgICBib3c6ICgpID0+IFtuZXcgV2VhcG9ucy5Cb3coKSwgbmV3IFByb2plY3RpbGVzLkFycm93KHsgY2hhcmdlczogJzFkMTQgKyAzJyB9KV0sXG4gICAgICAgICAgY3Jvc3Nib3c6ICgpID0+IFtuZXcgV2VhcG9ucy5Dcm9zc2JvdygpLCBuZXcgUHJvamVjdGlsZXMuQm9sdCh7IGNoYXJnZXM6ICcxZDE0ICsgMycgfSldLFxuICAgICAgICAgIGRhcnRzOiAoKSA9PiBuZXcgUHJvamVjdGlsZXMuRGFydCh7IGNoYXJnZXM6ICcxZDE0ICsgMycgfSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgcHJvYmFiaWxpdHk6IDI1LCBpbml0OiAoKSA9PiBuZXcgRmVldHMuU2ltcGxlQm9vdHMoKSB9XG4gICAgXSxcbiAgICBhdHRyaWJ1dGVzOiB7IHNwZWVkOiA1MCwgbGV2ZWw6IDEsIGtpbGxYcDogJzJkMTAnLCBzcGF3bkhwOiAnNmQyJyB9LFxuICAgIHN0YXRzOiB7IG5hbWU6ICdnbm9tZScsIHJhY2U6ICdHbm9tZScsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDc1KSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldXG4gICAgfSB9KSB9OyIsIlxuaW1wb3J0ICogYXMgQmVoYXZpb3JzIGZyb20gJy4uL2JlaGF2aW9ycy9fYWxsJztcbmltcG9ydCBBdHRhY2tzIGZyb20gJy4uL2F0dGFja3MvX2FsbCc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhzJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBoQ29sb3JzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBoQ29sb3JzJztcblxuZXhwb3J0IGNvbnN0IGdyaWRCdWcgPSB7IGRpZmZpY3VsdHk6IDEsIHNwYXduUGF0dGVybjogJzFkMicsIGZyZXF1ZW5jeTogNDAsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLk15c3RpY2FsLCBmZzogR2x5cGhDb2xvcnMuVGllcnMuQmFzaWMgfSxcbiAgYXR0cmlidXRlczogeyBhYzogLTEsIHNwZWVkOiAxNTAsIGxldmVsOiAxLCBzdHI6IDUsIGRleDogMywgY29uOiAwLCBraWxsWHA6ICc0ZDEnLCBzcGF3bkhwOiAnMWQ0ICsgMicgfSxcbiAgc3RhdHM6IHsgbmFtZTogJ2dyaWQgYnVnJywgcmFjZTogJ0luc2VjdCcsXG4gICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLlNlZWtzVGFyZ2V0SW5TaWdodCgpLCBCZWhhdmlvcnMuQXR0YWNrcygpXSxcbiAgICBhdHRhY2tzOiBbQXR0YWNrcy5FbGVjdHJpY1RvdWNoKHsgcm9sbDogJzFkMyArIDEnIH0pXVxuICB9IH0pIH07XG5cbmV4cG9ydCBjb25zdCBnaWFudEFudCA9IHsgZGlmZmljdWx0eTogNCwgc3Bhd25QYXR0ZXJuOiAnMWQ0ICsgMicsIGZyZXF1ZW5jeTogNywgaW5pdDogKCkgPT5cbiAgKHsgZ2x5cGg6IHsga2V5OiBHbHlwaHMuQW50LCBmZzogR2x5cGhDb2xvcnMuVGllcnMuV2VhayB9LFxuICBhdHRyaWJ1dGVzOiB7IGFjOiAtMiwgc3BlZWQ6IDE1MCwgbGV2ZWw6IDMsIHN0cjogJzFkMyArIDMnLCBkZXg6ICcxZDMgKyAyJywgY29uOiA0LCBraWxsWHA6ICcyZDQgKyA1Jywgc3Bhd25IcDogJzFkOCArIDUnIH0sXG4gIHN0YXRzOiB7IG5hbWU6ICdnaWFudCBhbnQnLCByYWNlOiAnSW5zZWN0JyxcbiAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDEwKSwgQmVoYXZpb3JzLkRyb3BzR29sZCgnMmQ0JyksIEJlaGF2aW9ycy5TZWVrc1RhcmdldFZpYUhlYXJpbmcoKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0SW5TaWdodCgpLCBCZWhhdmlvcnMuQXR0YWNrcygpXSxcbiAgICBhdHRhY2tzOiBbQXR0YWNrcy5CaXRlKHsgcm9sbDogJzFkNCArIDEnIH0pXVxuICB9IH0pIH07XG5cbmV4cG9ydCBjb25zdCBraWxsZXJCZWUgPSB7IGRpZmZpY3VsdHk6IDEyLCBzcGF3blBhdHRlcm46ICczZDQnLCBmcmVxdWVuY3k6IDIsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLkFudCwgZmc6IEdseXBoQ29sb3JzLlRpZXJzLkluYWRlcXVhdGUgfSxcbiAgICBhdHRyaWJ1dGVzOiB7IGFjOiAtMTEsIHNwZWVkOiAxNTAsIGxldmVsOiA3LCBraWxsWHA6ICc3ZDQgKyA1Jywgc3Bhd25IcDogJzNkNCcgfSxcbiAgICBzdGF0czogeyBuYW1lOiAna2lsbGVyIGJlZScsIHJhY2U6ICdJbnNlY3QnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSgxKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldLFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuUG9pc29uKHsgcm9sbDogJzFkMycsIHBlcmNlbnQ6IDMzIH0pXVxuICAgIH0gfSkgfTtcblxuZXhwb3J0IGNvbnN0IHNvbGRpZXJBbnQgPSB7IGRpZmZpY3VsdHk6IDEzLCBzcGF3blBhdHRlcm46ICcyZDQgKyAzJywgZnJlcXVlbmN5OiAyLCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5BbnQsIGZnOiBHbHlwaENvbG9ycy5UaWVycy5JbmFkZXF1YXRlIH0sXG4gICAgYXR0cmlidXRlczogeyBhYzogLTcsIHNwZWVkOiAxNTAsIGxldmVsOiA2LCBraWxsWHA6ICcxMGQ0Jywgc3Bhd25IcDogJzRkNCcgfSxcbiAgICBzdGF0czogeyBuYW1lOiAnc29sZGllciBhbnQnLCByYWNlOiAnSW5zZWN0JyxcbiAgICAgIGJlaGF2aW9yczogW0JlaGF2aW9ycy5MZWF2ZXNDb3Jwc2UoNSksIEJlaGF2aW9ycy5TZWVrc1RhcmdldFZpYUhlYXJpbmcoKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0SW5TaWdodCgpLCBCZWhhdmlvcnMuQXR0YWNrcygpXSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLkJpdGUoeyByb2xsOiAnMmQ0JyB9KSwgQXR0YWNrcy5Qb2lzb24oeyByb2xsOiAnM2Q0JywgcGVyY2VudDogMzMgfSldXG4gICAgfSB9KSB9O1xuXG5leHBvcnQgY29uc3QgZmlyZUFudCA9IHsgZGlmZmljdWx0eTogMTEsIHNwYXduUGF0dGVybjogJzJkNCArIDMnLCBmcmVxdWVuY3k6IDIsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLkFudCwgZmc6IEdseXBoQ29sb3JzLkVsZW1lbnRzLkZpcmUgfSxcbiAgICBhdHRyaWJ1dGVzOiB7IGFjOiAtNywgc3BlZWQ6IDE1MCwgbGV2ZWw6IDUsIGtpbGxYcDogJzEwZDQnLCBzcGF3bkhwOiAnM2Q2JyB9LFxuICAgIHN0YXRzOiB7IG5hbWU6ICdmaXJlIGFudCcsIHJhY2U6ICdJbnNlY3QnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSgxKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldLFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuQml0ZSh7IHJvbGw6ICcyZDQnIH0pLCBBdHRhY2tzLkJpdGUoeyByb2xsOiAnMmQ0JywgZWxlbWVudDogJ0ZpcmUnIH0pXVxuICAgIH0gfSkgfTtcblxuZXhwb3J0IGNvbnN0IGdpYW50QmVldGxlID0geyBkaWZmaWN1bHR5OiA3LCBzcGF3blBhdHRlcm46ICcxZDMnLCBmcmVxdWVuY3k6IDUsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLkFudCwgZmc6IEdseXBoQ29sb3JzLkVsZW1lbnRzLkZpcmUgfSxcbiAgICBhdHRyaWJ1dGVzOiB7IGFjOiAtNiwgc3BlZWQ6IDUwLCBsZXZlbDogNSwga2lsbFhwOiAnMTBkNCcsIHNwYXduSHA6ICczZDYnIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ2dpYW50IGJlZXRsZScsIHJhY2U6ICdJbnNlY3QnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSg1KSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldLFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuQml0ZSh7IHJvbGw6ICczZDYnIH0pXVxuICAgIH0gfSkgfTsiLCJcbmltcG9ydCAqIGFzIEJlaGF2aW9ycyBmcm9tICcuLi9iZWhhdmlvcnMvX2FsbCc7XG5pbXBvcnQgQXR0YWNrcyBmcm9tICcuLi9hdHRhY2tzL19hbGwnO1xuaW1wb3J0IHsgRW50aXRpZXMgYXMgR2x5cGhzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBocyc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaENvbG9ycyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaENvbG9ycyc7XG5cbmV4cG9ydCBjb25zdCBibHVlSmVsbHkgPSB7IGRpZmZpY3VsdHk6IDksIHNwYXduUGF0dGVybjogJzFkMScsIGZyZXF1ZW5jeTogMiwgaW5pdDogKCkgPT5cbiAgKHsgZ2x5cGg6IHsga2V5OiBHbHlwaHMuSmVsbHksIGZnOiBHbHlwaENvbG9ycy5Db2xvcnMuQmx1ZSB9LFxuICAgIGF0dHJpYnV0ZXM6IHsgYWM6IC02LCBzcGVlZDogNTAsIGxldmVsOiA0LCBraWxsWHA6ICcxMGQ1Jywgc3Bhd25IcDogJzVkNScgfSxcbiAgICBzdGF0czogeyBuYW1lOiAnYmx1ZSBqZWxseScsIHJhY2U6ICdKZWxseScsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuQXR0YWNrcygpLCBCZWhhdmlvcnMuS2lsbHNTZWxmQWZ0ZXJQZXJpb2RPZlRpbWUoKV0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5CaXRlKHsgcm9sbDogJzRkNicsIGVsZW1lbnQ6ICdJY2UnIH0pXVxuICAgIH0gfSkgfTsiLCJcbmltcG9ydCAqIGFzIEJlaGF2aW9ycyBmcm9tICcuLi9iZWhhdmlvcnMvX2FsbCc7XG5pbXBvcnQgKiBhcyBBdHRhY2tzIGZyb20gJy4uL2F0dGFja3MvX2FsbCc7XG5pbXBvcnQgKiBhcyBXZWFwb25zIGZyb20gJy4uL2l0ZW1zL193ZWFwb25zJztcbmltcG9ydCAqIGFzIEZlZXRzIGZyb20gJy4uL2l0ZW1zL2ZlZXRzJztcbmltcG9ydCAqIGFzIFNwZWxsYm9va3MgZnJvbSAnLi4vaXRlbXMvc3BlbGxib29rcyc7XG5pbXBvcnQgKiBhcyBQcm9qZWN0aWxlcyBmcm9tICcuLi9pdGVtcy9wcm9qZWN0aWxlcyc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhzJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBoQ29sb3JzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBoQ29sb3JzJztcblxuY29uc3Qga29ib2xkU3RhcnRpbmdFcXVpcG1lbnQgPSBbXG4gIHsgY2hvaWNlczogeyBkYWdnZXI6IDIsIHNwZWFyOiAxLCBzaG9ydHN3b3JkOiAxIH0sXG4gICAgY2hvaWNlc0luaXQ6IHtcbiAgICAgIGRhZ2dlcjogKCkgPT4gbmV3IFdlYXBvbnMuT3JjaXNoRGFnZ2VyKCksXG4gICAgICBzcGVhcjogKCkgPT4gbmV3IFdlYXBvbnMuT3JjaXNoU3BlYXIoKSxcbiAgICAgIHNob3J0c3dvcmQ6ICgpID0+IG5ldyBXZWFwb25zLk9yY2lzaFNob3J0U3dvcmQoKVxuICAgIH1cbiAgfSxcbiAgeyBwcm9iYWJpbGl0eTogMjUsIGluaXQ6ICgpID0+IG5ldyBQcm9qZWN0aWxlcy5EYXJ0KHsgY2hhcmdlczogJzFkMTQgKyAzJyB9KSB9LFxuICB7IHByb2JhYmlsaXR5OiAyNSwgaW5pdDogKCkgPT4gbmV3IEZlZXRzLlNpbXBsZUJvb3RzKCkgfVxuXTtcblxuZXhwb3J0IGNvbnN0IGtvYm9sZCA9IHsgZGlmZmljdWx0eTogMSwgc3Bhd25QYXR0ZXJuOiAnMWQxJywgZnJlcXVlbmN5OiAzLCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5Lb2JvbGQsIGZnOiBHbHlwaENvbG9ycy5UaWVycy5XZWFrIH0sXG4gICAgc3RhcnRpbmdFcXVpcG1lbnQ6IGtvYm9sZFN0YXJ0aW5nRXF1aXBtZW50LFxuICAgIGF0dHJpYnV0ZXM6IHsgc3BlZWQ6IDUwLCBsZXZlbDogMSwga2lsbFhwOiAnMWQxMCcsIHNwYXduSHA6ICczZDInIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ2tvYm9sZCcsIHJhY2U6ICdLb2JvbGQnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSg1NSksIEJlaGF2aW9ycy5TZWVrc1RhcmdldFZpYUhlYXJpbmcoKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0SW5TaWdodCgpLCBCZWhhdmlvcnMuQXR0YWNrcygpXVxuICAgIH0gfSkgfTtcblxuZXhwb3J0IGNvbnN0IGxhcmdlS29ib2xkID0geyBkaWZmaWN1bHR5OiAyLCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDMsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLktvYm9sZCwgZmc6IEdseXBoQ29sb3JzLlRpZXJzLkluYWRlcXVhdGUgfSxcbiAgICBzdGFydGluZ0VxdWlwbWVudDoga29ib2xkU3RhcnRpbmdFcXVpcG1lbnQsXG4gICAgYXR0cmlidXRlczogeyBzcGVlZDogNTAsIGxldmVsOiAyLCBraWxsWHA6ICcyZDEwJywgc3Bhd25IcDogJzZkMicgfSxcbiAgICBzdGF0czogeyBuYW1lOiAnbGFyZ2Uga29ib2xkJywgcmFjZTogJ0tvYm9sZCcsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDU1KSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldXG4gICAgfSB9KSB9O1xuXG5leHBvcnQgY29uc3Qga29ib2xkTG9yZCA9IHsgZGlmZmljdWx0eTogMywgc3Bhd25QYXR0ZXJuOiAnMWQxJywgZnJlcXVlbmN5OiAzLCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5Lb2JvbGQsIGZnOiBHbHlwaENvbG9ycy5UaWVycy5Nb2RlcmF0ZSB9LFxuICAgIHN0YXJ0aW5nRXF1aXBtZW50OiBrb2JvbGRTdGFydGluZ0VxdWlwbWVudCxcbiAgICBhdHRyaWJ1dGVzOiB7IHNwZWVkOiA1MCwgbGV2ZWw6IDMsIGtpbGxYcDogJzNkMTAnLCBzcGF3bkhwOiAnMTJkMicgfSxcbiAgICBzdGF0czogeyBuYW1lOiAna29ib2xkIGxvcmQnLCByYWNlOiAnS29ib2xkJyxcbiAgICAgIGJlaGF2aW9yczogW0JlaGF2aW9ycy5MZWF2ZXNDb3Jwc2UoNDUpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRWaWFIZWFyaW5nKCksIEJlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKV0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5CaXRlKHsgcm9sbDogJzFkNCcgfSldXG4gICAgfSB9KSB9O1xuXG5leHBvcnQgY29uc3Qga29ib2xkU2hhbWFuID0geyBkaWZmaWN1bHR5OiAyLCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDMsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLktvYm9sZCwgZmc6IEdseXBoQ29sb3JzLkNvbG9ycy5CbHVlIH0sXG4gICAgc3RhcnRpbmdFcXVpcG1lbnQ6IFtcbiAgICAgIHsgaW5pdDogKCkgPT4gbmV3IFNwZWxsYm9va3MuQ3VyZVNlbGYoKSB9LFxuICAgICAgeyBpbml0OiAoKSA9PiBuZXcgU3BlbGxib29rcy5Gb3JjZUJvbHQoKSB9XG4gICAgXSxcbiAgICBhdHRyaWJ1dGVzOiB7IHNwZWVkOiA1MCwgbGV2ZWw6IDIsIGFjOiAtNCwgaW50OiA1LCBtcDogJzNkNCcsIGtpbGxYcDogJzNkMTAnLCBzcGF3bkhwOiAnMTJkMycgfSxcbiAgICBzdGF0czogeyBuYW1lOiAna29ib2xkIHNoYW1hbicsIHJhY2U6ICdLb2JvbGQnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSgzNSksIEJlaGF2aW9ycy5TZWVrc1RhcmdldFZpYUhlYXJpbmcoKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0SW5TaWdodCgpLCBCZWhhdmlvcnMuQXR0YWNrcygpXVxuICAgIH0gfSkgfTsiLCJcbmltcG9ydCAqIGFzIEJlaGF2aW9ycyBmcm9tICcuLi9iZWhhdmlvcnMvX2FsbCc7XG5pbXBvcnQgKiBhcyBUcmFpdHMgZnJvbSAnLi4vdHJhaXRzL19hbGwnO1xuaW1wb3J0IEF0dGFja3MgZnJvbSAnLi4vYXR0YWNrcy9fYWxsJztcbmltcG9ydCAqIGFzIEZlZXRzIGZyb20gJy4uL2l0ZW1zL2ZlZXRzJztcbmltcG9ydCAqIGFzIFdlYXBvbnMgZnJvbSAnLi4vaXRlbXMvX3dlYXBvbnMnO1xuaW1wb3J0ICogYXMgUHJvamVjdGlsZXMgZnJvbSAnLi4vaXRlbXMvcHJvamVjdGlsZXMnO1xuaW1wb3J0IHsgRW50aXRpZXMgYXMgR2x5cGhzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBocyc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaENvbG9ycyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaENvbG9ycyc7XG5cbmV4cG9ydCBjb25zdCBuZXd0ID0geyBkaWZmaWN1bHR5OiAxLCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDUwLCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5MaXphcmQsIGZnOiBHbHlwaENvbG9ycy5Db2xvcnMuWWVsbG93IH0sXG4gIGF0dHJpYnV0ZXM6IHsgYWM6IC0yLCBzcGVlZDogNTAsIGxldmVsOiAxLCBraWxsWHA6ICcxZDEnLCBzcGF3bkhwOiAnMWQ0JyB9LFxuICBzdGF0czogeyBuYW1lOiAnbmV3dCcsIHJhY2U6ICdMaXphcmQnLFxuICAgIGJlaGF2aW9yczogW0JlaGF2aW9ycy5MZWF2ZXNDb3Jwc2UoMjUpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldLFxuICAgIGF0dGFja3M6IFtBdHRhY2tzLkJpdGUoeyByb2xsOiAnMWQyJyB9KV1cbiAgfSB9KSB9O1xuXG5leHBvcnQgY29uc3QgZ2Vja28gPSB7IGRpZmZpY3VsdHk6IDIsIHNwYXduUGF0dGVybjogJzFkMScsIGZyZXF1ZW5jeTogMzUsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLkxpemFyZCwgZmc6IEdseXBoQ29sb3JzLkNvbG9ycy5HcmVlbiB9LFxuICAgIGF0dHJpYnV0ZXM6IHsgYWM6IC0yLCBzcGVlZDogNTAsIGxldmVsOiAyLCBraWxsWHA6ICcxZDgnLCBzcGF3bkhwOiAnMmQ0JyB9LFxuICAgIHN0YXRzOiB7IG5hbWU6ICdnZWNrbycsIHJhY2U6ICdMaXphcmQnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSgyNSksIEJlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKV0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5CaXRlKHsgcm9sbDogJzFkMycgfSldXG4gICAgfSB9KSB9O1xuXG5leHBvcnQgY29uc3QgaWd1YW5hID0geyBkaWZmaWN1bHR5OiAzLCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDI1LCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5MaXphcmQsIGZnOiBHbHlwaENvbG9ycy5Db2xvcnMuQnJvd24gfSxcbiAgICBhdHRyaWJ1dGVzOiB7IGFjOiAtMywgc3BlZWQ6IDUwLCBsZXZlbDogMywga2lsbFhwOiAnM2Q4Jywgc3Bhd25IcDogJzRkNCcgfSxcbiAgICBzdGF0czogeyBuYW1lOiAnaWd1YW5hJywgcmFjZTogJ0xpemFyZCcsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDI1KSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0SW5TaWdodCgpLCBCZWhhdmlvcnMuQXR0YWNrcygpXSxcbiAgICAgIGF0dGFja3M6IFtBdHRhY2tzLkJpdGUoeyByb2xsOiAnMWQ0JyB9KV1cbiAgICB9IH0pIH07XG5cbmV4cG9ydCBjb25zdCBiYWJ5Q3JvY29kaWxlID0geyBkaWZmaWN1bHR5OiAzLCBzcGF3blBhdHRlcm46ICcxZDInLCBmcmVxdWVuY3k6IDEsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLkxpemFyZCwgZmc6IEdseXBoQ29sb3JzLkNvbG9ycy5Ccm93biB9LFxuICAgIGF0dHJpYnV0ZXM6IHsgYWM6IC0zLCBzcGVlZDogMjUsIGxldmVsOiAzLCBraWxsWHA6ICczZDgnLCBzcGF3bkhwOiAnM2Q3JyB9LFxuICAgIHN0YXRzOiB7IG5hbWU6ICdiYWJ5IGNyb2NvZGlsZScsIHJhY2U6ICdMaXphcmQnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSgyNSksIEJlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKV0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5CaXRlKHsgcm9sbDogJzFkNCcgfSldXG4gICAgfSB9KSB9O1xuXG5leHBvcnQgY29uc3QgY3JvY29kaWxlID0geyBkaWZmaWN1bHR5OiA3LCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDEsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLkxpemFyZCwgZmc6IEdseXBoQ29sb3JzLkNvbG9ycy5Ccm93biB9LFxuICAgIGF0dHJpYnV0ZXM6IHsgYWM6IC01LCBzcGVlZDogNTAsIGxldmVsOiA2LCBraWxsWHA6ICc3ZDEyJywgc3Bhd25IcDogJzRkMTAnIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ2Nyb2NvZGlsZScsIHJhY2U6ICdMaXphcmQnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSgyNSksIEJlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKV0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5CaXRlKHsgcm9sbDogJzRkMicgfSksIEF0dGFja3MuQ2xhdyh7IHJvbGw6ICcxZDEyJyB9KV1cbiAgICB9IH0pIH07XG5cbmV4cG9ydCBjb25zdCBjaGFtZWxlb24gPSB7IGRpZmZpY3VsdHk6IDcsIHNwYXduUGF0dGVybjogJzFkMScsIGZyZXF1ZW5jeTogNSwgaW5pdDogKCkgPT5cbiAgKHsgZ2x5cGg6IHsga2V5OiBHbHlwaHMuTGl6YXJkLCBmZzogR2x5cGhDb2xvcnMuQ29sb3JzLkJyb3duIH0sXG4gICAgYXR0cmlidXRlczogeyBhYzogLTUsIHNwZWVkOiA3NSwgbGV2ZWw6IDYsIGtpbGxYcDogJzdkMTInLCBzcGF3bkhwOiAnM2QxMCcgfSxcbiAgICBzdGF0czogeyBuYW1lOiAnY2hhbWVsZW9uJywgcmFjZTogJ0xpemFyZCcsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDUpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldLFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuQml0ZSh7IHJvbGw6ICc0ZDInIH0pXVxuICAgIH0gfSkgfTtcblxuZXhwb3J0IGNvbnN0IHNhbGFtYW5kZXIgPSB7IGRpZmZpY3VsdHk6IDE3LCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDEsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLkxpemFyZCwgZmc6IEdseXBoQ29sb3JzLkNvbG9ycy5SZWQgfSxcbiAgICBhZGRGYWN0aW9uczogWydMaXphcmQnXSxcbiAgICBzdGFydGluZ0VxdWlwbWVudDogW1xuICAgICAgeyBjaG9pY2VzOiB7IHNwZWFyOiAxOCwgdHJpZGVudDogMiwgc3RpbGV0dG86IDEgfSxcbiAgICAgICAgY2hvaWNlc0luaXQ6IHtcbiAgICAgICAgICBzcGVhcjogKCkgPT4gbmV3IFdlYXBvbnMuU3BlYXIoKSxcbiAgICAgICAgICB0cmlkZW50OiAoKSA9PiBuZXcgV2VhcG9ucy5UcmlkZW50KCksXG4gICAgICAgICAgc3RpbGV0dG86ICgpID0+IG5ldyBQcm9qZWN0aWxlcy5TdGlsZXR0bygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHByb2JhYmlsaXR5OiAyNSwgaW5pdDogKCkgPT4gbmV3IEZlZXRzLlNpbXBsZUJvb3RzKCkgfVxuICAgIF0sXG4gICAgYXR0cmlidXRlczogeyBhYzogLTExLCBzcGVlZDogMTAwLCBsZXZlbDogMTAsIGtpbGxYcDogJzIwZDEwJywgc3Bhd25IcDogJzRkMjAnIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ3NhbGFtYW5kZXInLCByYWNlOiAnTGl6YXJkbWFuJyxcbiAgICAgIGJlaGF2aW9yczogW0JlaGF2aW9ycy5MZWF2ZXNDb3Jwc2UoNSksIEJlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKV0sXG4gICAgICB0cmFpdHM6IFtUcmFpdHMuRmlyZVJlc2lzdGFuY2UoKV0sXG4gICAgICBhdHRhY2tzOiBbXG4gICAgICAgIEF0dGFja3MuQmVhcmh1Zyh7IHJvbGw6ICcyZDYnIH0pLFxuICAgICAgICBBdHRhY2tzLkJlYXJodWcoeyByb2xsOiAnM2Q2JywgZWxlbWVudDogJ0ZpcmUnIH0pLFxuICAgICAgICBBdHRhY2tzLlRvdWNoKHsgcm9sbDogJzFkNicsIGVsZW1lbnQ6ICdGaXJlJyB9KV1cbiAgICB9IH0pIH07IiwiXG5pbXBvcnQgKiBhcyBCZWhhdmlvcnMgZnJvbSAnLi4vYmVoYXZpb3JzL19hbGwnO1xuaW1wb3J0IEF0dGFja3MgZnJvbSAnLi4vYXR0YWNrcy9fYWxsJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBocyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaHMnO1xuaW1wb3J0IHsgRW50aXRpZXMgYXMgR2x5cGhDb2xvcnMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhDb2xvcnMnO1xuXG5leHBvcnQgY29uc3Qgd2F0ZXJOeW1waCA9IHsgZGlmZmljdWx0eTogNSwgc3Bhd25QYXR0ZXJuOiAnMWQzICsgMScsIGZyZXF1ZW5jeTogMCwgaW5pdDogKCkgPT5cbiAgKHsgZ2x5cGg6IHsga2V5OiBHbHlwaHMuTnltcGgsIGZnOiBHbHlwaENvbG9ycy5FbGVtZW50cy5XYXRlciB9LFxuICBhdHRyaWJ1dGVzOiB7IGFjOiAtMSwgc3BlZWQ6IDEwMCwgbGV2ZWw6IDMsIGtpbGxYcDogJzdkNycsIHNwYXduSHA6ICc1ZDUgKyA1JyB9LFxuICBzdGF0czogeyBuYW1lOiAnd2F0ZXIgbnltcGgnLCByYWNlOiAnRWxmJyxcbiAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDE1KSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5TdGVhbHMoKSwgQmVoYXZpb3JzLkF0dGFja3MoKSwgQmVoYXZpb3JzLkRyb3BzSXRlbXMoKV0sXG4gICAgYXR0YWNrczogW0F0dGFja3MuQ2xhdyh7IHJvbGw6ICcxZDIgKyAxJyB9KSwgQXR0YWNrcy5TZWR1Y3RpdmVUb3VjaCh7IHJvbGw6ICcxZDInLCBjaGFuY2U6IDIwIH0pXVxuICB9IH0pIH07XG5cbmV4cG9ydCBjb25zdCBmb3Jlc3ROeW1waCA9IHsgZGlmZmljdWx0eTogNSwgc3Bhd25QYXR0ZXJuOiAnMWQxJywgZnJlcXVlbmN5OiAxLCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5OeW1waCwgZmc6IEdseXBoQ29sb3JzLkNvbG9ycy5HcmVlbiB9LFxuICAgIGF0dHJpYnV0ZXM6IHsgYWM6IC0xLCBzcGVlZDogMTAwLCBsZXZlbDogMywga2lsbFhwOiAnN2Q3Jywgc3Bhd25IcDogJzVkNSArIDUnIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ2ZvcmVzdCBueW1waCcsIHJhY2U6ICdFbGYnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSgxNSksIEJlaGF2aW9ycy5TZWVrc1RhcmdldFZpYUhlYXJpbmcoKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0SW5TaWdodCgpLCBCZWhhdmlvcnMuU3RlYWxzKCksIEJlaGF2aW9ycy5BdHRhY2tzKCksIEJlaGF2aW9ycy5Ecm9wc0l0ZW1zKCldLFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuQ2xhdyh7IHJvbGw6ICcxZDMgKyAxJyB9KSwgQXR0YWNrcy5TZWR1Y3RpdmVUb3VjaCh7IHJvbGw6ICcxZDMnLCBjaGFuY2U6IDMwIH0pXVxuICAgIH0gfSkgfTtcblxuZXhwb3J0IGNvbnN0IG1vdW50YWluTnltcGggPSB7IGRpZmZpY3VsdHk6IDI1LCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDEsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLk55bXBoLCBmZzogR2x5cGhDb2xvcnMuQ29sb3JzLkJyb3duIH0sXG4gICAgYXR0cmlidXRlczogeyBhYzogLTgsIHNwZWVkOiAxNTAsIGxldmVsOiAzLCBraWxsWHA6ICcyMGQ3Jywgc3Bhd25IcDogJzIwZDUnIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ21vdW50YWluIG55bXBoJywgcmFjZTogJ0VsZicsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDE1KSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5TdGVhbHMoKSwgQmVoYXZpb3JzLkF0dGFja3MoKSwgQmVoYXZpb3JzLkRyb3BzSXRlbXMoKV0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5DbGF3KHsgcm9sbDogJzJkNCcgfSksIEF0dGFja3MuU2VkdWN0aXZlVG91Y2goeyByb2xsOiAnMmQzJywgY2hhbmNlOiA0MCB9KV1cbiAgICB9IH0pIH07IiwiXG5pbXBvcnQgKiBhcyBCZWhhdmlvcnMgZnJvbSAnLi4vYmVoYXZpb3JzL19hbGwnO1xuaW1wb3J0ICogYXMgV2VhcG9ucyBmcm9tICcuLi9pdGVtcy9fd2VhcG9ucyc7XG5pbXBvcnQgKiBhcyBIZWFkcyBmcm9tICcuLi9pdGVtcy9oZWFkcyc7XG5pbXBvcnQgKiBhcyBCb2R5cyBmcm9tICcuLi9pdGVtcy9ib2R5cyc7XG5pbXBvcnQgKiBhcyBGZWV0cyBmcm9tICcuLi9pdGVtcy9mZWV0cyc7XG5pbXBvcnQgKiBhcyBQcm9qZWN0aWxlcyBmcm9tICcuLi9pdGVtcy9wcm9qZWN0aWxlcyc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhzJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBoQ29sb3JzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBoQ29sb3JzJztcblxuZXhwb3J0IGNvbnN0IGdvYmxpbiA9IHsgZGlmZmljdWx0eTogMSwgc3Bhd25QYXR0ZXJuOiAnMWQxJywgZnJlcXVlbmN5OiA2LCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5PcmMsIGZnOiBHbHlwaENvbG9ycy5UaWVycy5CYXNpYyB9LFxuICAgIHN0YXJ0aW5nRXF1aXBtZW50OiBbXG4gICAgICB7IHByb2JhYmlsaXR5OiA1MCwgaW5pdDogKCkgPT4gbmV3IFdlYXBvbnMuT3JjaXNoRGFnZ2VyKCkgfSxcbiAgICAgIHsgcHJvYmFiaWxpdHk6IDUwLCBpbml0OiAoKSA9PiBuZXcgSGVhZHMuT3JjaXNoSGVsbSgpIH0sXG4gICAgICB7IHByb2JhYmlsaXR5OiAyNSwgaW5pdDogKCkgPT4gbmV3IEZlZXRzLlNpbXBsZUJvb3RzKCkgfVxuICAgIF0sXG4gICAgYXR0cmlidXRlczogeyBzcGVlZDogNzUsIGxldmVsOiAxLCBraWxsWHA6ICcxZDE1Jywgc3Bhd25IcDogJzZkMicgfSxcbiAgICBzdGF0czogeyBuYW1lOiAnZ29ibGluJywgcmFjZTogJ09yYycsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDc1KSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldXG4gICAgfSB9KSB9O1xuXG5leHBvcnQgY29uc3QgaG9iZ29ibGluID0geyBkaWZmaWN1bHR5OiAzLCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDYsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLk9yYywgZmc6IEdseXBoQ29sb3JzLlRpZXJzLldlYWsgfSxcbiAgICBzdGFydGluZ0VxdWlwbWVudDogW1xuICAgICAgeyBjaG9pY2VzOiB7IGRhZ2dlcjogMSwgc2hvcnRzd29yZDogMSB9LFxuICAgICAgICBjaG9pY2VzSW5pdDoge1xuICAgICAgICAgIGRhZ2dlcjogKCkgPT4gbmV3IFdlYXBvbnMuT3JjaXNoRGFnZ2VyKCksXG4gICAgICAgICAgc2hvcnRzd29yZDogKCkgPT4gbmV3IFdlYXBvbnMuT3JjaXNoU2hvcnRTd29yZCgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHByb2JhYmlsaXR5OiA1MCwgaW5pdDogKCkgPT4gbmV3IEhlYWRzLk9yY2lzaEhlbG0oKSB9LFxuICAgICAgeyBwcm9iYWJpbGl0eTogMjUsIGluaXQ6ICgpID0+IG5ldyBGZWV0cy5TaW1wbGVCb290cygpIH1cbiAgICBdLFxuICAgIGF0dHJpYnV0ZXM6IHsgc3BlZWQ6IDc1LCBsZXZlbDogMSwga2lsbFhwOiAnMWQxNScsIHNwYXduSHA6ICc2ZDInIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ2hvYmdvYmxpbicsIHJhY2U6ICdPcmMnLFxuICAgICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSg3NSksIEJlaGF2aW9ycy5TZWVrc1RhcmdldFZpYUhlYXJpbmcoKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0SW5TaWdodCgpLCBCZWhhdmlvcnMuQXR0YWNrcygpXVxuICAgIH0gfSkgfTtcblxuZXhwb3J0IGNvbnN0IG9yYyA9IHsgZGlmZmljdWx0eTogMywgc3Bhd25QYXR0ZXJuOiAnMWQxJywgZnJlcXVlbmN5OiAwLCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5PcmMsIGZnOiBHbHlwaENvbG9ycy5UaWVycy5JbmFkZXF1YXRlIH0sXG4gICAgc3RhcnRpbmdFcXVpcG1lbnQ6IFtcbiAgICAgIHsgY2hvaWNlczogeyBzd29yZDogMSwgYm93OiAxIH0sXG4gICAgICAgIGNob2ljZXNJbml0OiB7XG4gICAgICAgICAgc3dvcmQ6ICgpID0+IG5ldyBXZWFwb25zLlNjaW1pdGFyKCksXG4gICAgICAgICAgYm93OiAoKSA9PiBbbmV3IFdlYXBvbnMuT3JjaXNoQm93KCksIG5ldyBQcm9qZWN0aWxlcy5PcmNpc2hBcnJvdyh7IGNoYXJnZXM6ICcxZDE0ICsgMycgfSldXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHByb2JhYmlsaXR5OiA1MCwgaW5pdDogKCkgPT4gbmV3IEhlYWRzLk9yY2lzaEhlbG0oKSB9LFxuICAgICAgeyBwcm9iYWJpbGl0eTogNTAsIGluaXQ6ICgpID0+IG5ldyBCb2R5cy5PcmNpc2hSaW5nTWFpbCgpIH0sXG4gICAgICB7IHByb2JhYmlsaXR5OiAyNSwgaW5pdDogKCkgPT4gbmV3IEZlZXRzLlNpbXBsZUJvb3RzKCkgfVxuICAgIF0sXG4gICAgYXR0cmlidXRlczogeyBzcGVlZDogNzUsIGxldmVsOiAxLCBraWxsWHA6ICcxZDE1Jywgc3Bhd25IcDogJzZkMicgfSxcbiAgICBzdGF0czogeyBuYW1lOiAnb3JjJywgcmFjZTogJ09yYycsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDc1KSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldXG4gICAgfSB9KSB9OyIsIlxuaW1wb3J0ICogYXMgQmVoYXZpb3JzIGZyb20gJy4uL2JlaGF2aW9ycy9fYWxsJztcbmltcG9ydCBBdHRhY2tzIGZyb20gJy4uL2F0dGFja3MvX2FsbCc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhzJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBoQ29sb3JzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBoQ29sb3JzJztcblxuZXhwb3J0IGNvbnN0IGJsYWNrUHVkZGluZyA9IHsgZGlmZmljdWx0eTogMTIsIHNwYXduUGF0dGVybjogJzFkMScsIGZyZXF1ZW5jeTogMSwgaW5pdDogKCkgPT5cbiAgKHsgZ2x5cGg6IHsga2V5OiBHbHlwaHMuUHVkZGluZywgZmc6IEdseXBoQ29sb3JzLkNvbG9ycy5CbGFjayB9LFxuICBhdHRyaWJ1dGVzOiB7IGFjOiAtNCwgc3BlZWQ6IDMwLCBsZXZlbDogMTAsIGtpbGxYcDogJzIwZDEwJywgc3Bhd25IcDogJzVkNScgfSxcbiAgc3RhdHM6IHsgbmFtZTogJ2JsYWNrIHB1ZGRpbmcnLCByYWNlOiAnUHVkZGluZycsXG4gICAgYmVoYXZpb3JzOiBbQmVoYXZpb3JzLkxlYXZlc0NvcnBzZSg1KSwgQmVoYXZpb3JzLlNwbGl0c1doZW5IaXQoKSwgQmVoYXZpb3JzLlNlZWtzVGFyZ2V0VmlhSGVhcmluZygpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCldLFxuICAgIGF0dGFja3M6IFtBdHRhY2tzLkNsYXcoeyByb2xsOiAnM2Q4JyB9KV1cbiAgfSB9KSB9OyIsIlxuaW1wb3J0ICogYXMgQmVoYXZpb3JzIGZyb20gJy4uL2JlaGF2aW9ycy9fYWxsJztcbmltcG9ydCBBdHRhY2tzIGZyb20gJy4uL2F0dGFja3MvX2FsbCc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhzJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBoQ29sb3JzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBoQ29sb3JzJztcblxuZXhwb3J0IGNvbnN0IHNld2VyUmF0ID0geyBkaWZmaWN1bHR5OiAxLCBzcGF3blBhdHRlcm46ICcxZDIgKyAxJywgZnJlcXVlbmN5OiA0NSwgaW5pdDogKCkgPT5cbiAgKHsgZ2x5cGg6IHsga2V5OiBHbHlwaHMuUmF0LCBmZzogR2x5cGhDb2xvcnMuVGllcnMuV2VhayB9LFxuICBhdHRyaWJ1dGVzOiB7IGFjOiAtMywgc3BlZWQ6IDEwMCwgbGV2ZWw6IDEsIGtpbGxYcDogJzFkNCcsIHNwYXduSHA6ICcxZDInIH0sXG4gIHN0YXRzOiB7IG5hbWU6ICdzZXdlciByYXQnLCByYWNlOiAnUmF0JyxcbiAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuTGVhdmVzQ29ycHNlKDUpLCBCZWhhdmlvcnMuU2Vla3NUYXJnZXRWaWFIZWFyaW5nKCksIEJlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKV0sXG4gICAgYXR0YWNrczogW0F0dGFja3MuQml0ZSh7IHJvbGw6ICcxZDMnIH0pXVxuICB9IH0pIH07IiwiXG5pbXBvcnQgKiBhcyBCZWhhdmlvcnMgZnJvbSAnLi4vYmVoYXZpb3JzL19hbGwnO1xuaW1wb3J0ICogYXMgQXR0YWNrcyBmcm9tICcuLi9hdHRhY2tzL19hbGwnO1xuaW1wb3J0ICogYXMgVHJhaXRzIGZyb20gJy4uL3RyYWl0cy9fYWxsJztcbmltcG9ydCB7IEVudGl0aWVzIGFzIEdseXBocyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaHMnO1xuaW1wb3J0IHsgRW50aXRpZXMgYXMgR2x5cGhDb2xvcnMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhDb2xvcnMnO1xuXG5leHBvcnQgY29uc3QgZ2FzU3BvcmUgPSB7IGRpZmZpY3VsdHk6IDIsIHNwYXduUGF0dGVybjogJzFkMScsIGZyZXF1ZW5jeTogMTUsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLlNwb3JlLCBmZzogR2x5cGhDb2xvcnMuVGllcnMuQmFzaWMgfSxcbiAgYXR0cmlidXRlczogeyBhYzogMCwgc3BlZWQ6IDI1LCBsZXZlbDogMiwga2lsbFhwOiAnMTJkMScsIHNwYXduSHA6ICcyZDQnIH0sXG4gIHN0YXRzOiB7IG5hbWU6ICdnYXMgc3BvcmUnLCByYWNlOiAnU3BvcmUnLFxuICAgIGJlaGF2aW9yczogW0JlaGF2aW9ycy5FeHBsb2RlcygnNGQ4JywgMyksIEJlaGF2aW9ycy5XYW5kZXJzKCldXG4gIH0gfSkgfTtcblxuZXhwb3J0IGNvbnN0IGZsb2F0aW5nRXllID0geyBkaWZmaWN1bHR5OiAzLCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDMsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLlNwb3JlLCBmZzogR2x5cGhDb2xvcnMuVGllcnMuV2VhayB9LFxuICAgIGF0dHJpYnV0ZXM6IHsgYWM6IC0xLCBzcGVlZDogMTAsIGxldmVsOiAyLCBraWxsWHA6ICcyZDEwJywgc3Bhd25IcDogJzFkNScgfSxcbiAgICBzdGF0czogeyBuYW1lOiAnZmxvYXRpbmcgZXllJywgcmFjZTogJ1Nwb3JlJyxcbiAgICAgIGJlaGF2aW9yczogW0JlaGF2aW9ycy5QYXJhbHl6ZXNXaGVuSGl0KDUwKSwgQmVoYXZpb3JzLldhbmRlcnMoKV1cbiAgICB9IH0pIH07XG5cbmV4cG9ydCBjb25zdCBlbGVjdHJpY1NwaGVyZSA9IHsgZGlmZmljdWx0eTogOCwgc3Bhd25QYXR0ZXJuOiAnMWQxJywgZnJlcXVlbmN5OiAzLCBpbml0OiAoKSA9PlxuICAoeyBnbHlwaDogeyBrZXk6IEdseXBocy5TcG9yZSwgZmc6IEdseXBoQ29sb3JzLkVsZW1lbnRzLlNob2NrIH0sXG4gICAgYXR0cmlidXRlczogeyBhYzogLTYsIHNwZWVkOiAxMTAsIGxldmVsOiA2LCBraWxsWHA6ICcxNWQxMCcsIHNwYXduSHA6ICc1ZDQnIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ3Nob2NraW5nIHNwaGVyZScsIHJhY2U6ICdTcG9yZScsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCksIEJlaGF2aW9ycy5FbWl0c0xpZ2h0KEdseXBoQ29sb3JzLkVsZW1lbnRzLlNob2NrKV0sXG4gICAgICB0cmFpdHM6IFtUcmFpdHMuU2hvY2tSZXNpc3RhbmNlKCldLFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuRXhwbG9kZSh7IHJvbGw6ICc0ZDYnLCBlbGVtZW50OiAnU2hvY2snIH0pXVxuICAgIH0gfSkgfTtcblxuZXhwb3J0IGNvbnN0IGZpcmVTcGhlcmUgPSB7IGRpZmZpY3VsdHk6IDgsIHNwYXduUGF0dGVybjogJzFkMScsIGZyZXF1ZW5jeTogMywgaW5pdDogKCkgPT5cbiAgKHsgZ2x5cGg6IHsga2V5OiBHbHlwaHMuU3BvcmUsIGZnOiBHbHlwaENvbG9ycy5FbGVtZW50cy5GaXJlIH0sXG4gICAgYXR0cmlidXRlczogeyBhYzogLTYsIHNwZWVkOiAxMTAsIGxldmVsOiA2LCBraWxsWHA6ICcxNWQxMCcsIHNwYXduSHA6ICc1ZDQnIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ2J1cm5pbmcgc3BoZXJlJywgcmFjZTogJ1Nwb3JlJyxcbiAgICAgIGJlaGF2aW9yczogW0JlaGF2aW9ycy5TZWVrc1RhcmdldEluU2lnaHQoKSwgQmVoYXZpb3JzLkF0dGFja3MoKSwgQmVoYXZpb3JzLkVtaXRzTGlnaHQoR2x5cGhDb2xvcnMuRWxlbWVudHMuRmlyZSldLFxuICAgICAgdHJhaXRzOiBbVHJhaXRzLkZpcmVSZXNpc3RhbmNlKCldLFxuICAgICAgYXR0YWNrczogW0F0dGFja3MuRXhwbG9kZSh7IHJvbGw6ICc0ZDYnLCBlbGVtZW50OiAnRmlyZScgfSldXG4gICAgfSB9KSB9O1xuXG5leHBvcnQgY29uc3QgaWNlU3BoZXJlID0geyBkaWZmaWN1bHR5OiA4LCBzcGF3blBhdHRlcm46ICcxZDEnLCBmcmVxdWVuY3k6IDMsIGluaXQ6ICgpID0+XG4gICh7IGdseXBoOiB7IGtleTogR2x5cGhzLlNwb3JlLCBmZzogR2x5cGhDb2xvcnMuRWxlbWVudHMuSWNlIH0sXG4gICAgYXR0cmlidXRlczogeyBhYzogLTYsIHNwZWVkOiAxMTAsIGxldmVsOiA2LCBraWxsWHA6ICcxNWQxMCcsIHNwYXduSHA6ICc1ZDQnIH0sXG4gICAgc3RhdHM6IHsgbmFtZTogJ2ZyZWV6aW5nIHNwaGVyZScsIHJhY2U6ICdTcG9yZScsXG4gICAgICBiZWhhdmlvcnM6IFtCZWhhdmlvcnMuU2Vla3NUYXJnZXRJblNpZ2h0KCksIEJlaGF2aW9ycy5BdHRhY2tzKCksIEJlaGF2aW9ycy5FbWl0c0xpZ2h0KEdseXBoQ29sb3JzLkVsZW1lbnRzLkljZSldLFxuICAgICAgdHJhaXRzOiBbVHJhaXRzLkljZVJlc2lzdGFuY2UoKV0sXG4gICAgICBhdHRhY2tzOiBbQXR0YWNrcy5FeHBsb2RlKHsgcm9sbDogJzRkNicsIGVsZW1lbnQ6ICdJY2UnIH0pXVxuICAgIH0gfSkgfTsiLCJcbmltcG9ydCBBcmNoYWVvbG9naXN0IGZyb20gJy4vYXJjaGFlb2xvZ2lzdCc7XG5pbXBvcnQgQmFyYmFyaWFuIGZyb20gJy4vYmFyYmFyaWFuJztcbmltcG9ydCBDYXZlbWFuIGZyb20gJy4vY2F2ZW1hbic7XG5pbXBvcnQgRGV2ZWxvcGVyIGZyb20gJy4vZGV2ZWxvcGVyJztcbmltcG9ydCBIZWFsZXIgZnJvbSAnLi9oZWFsZXInO1xuaW1wb3J0IEtuaWdodCBmcm9tICcuL2tuaWdodCc7XG5pbXBvcnQgTW9uayBmcm9tICcuL21vbmsnO1xuaW1wb3J0IE1vbnN0ZXIgZnJvbSAnLi9tb25zdGVyJztcbmltcG9ydCBQcmllc3QgZnJvbSAnLi9wcmllc3QnO1xuaW1wb3J0IFJhbmdlciBmcm9tICcuL3Jhbmdlcic7XG5pbXBvcnQgUm9ndWUgZnJvbSAnLi9yb2d1ZSc7XG5pbXBvcnQgVG91cmlzdCBmcm9tICcuL3RvdXJpc3QnO1xuaW1wb3J0IFZhbGt5cmllIGZyb20gJy4vdmFsa3lyaWUnO1xuaW1wb3J0IFdpemFyZCBmcm9tICcuL3dpemFyZCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQXJjaGFlb2xvZ2lzdCwgQmFyYmFyaWFuLCBDYXZlbWFuLCBEZXZlbG9wZXIsIEhlYWxlciwgS25pZ2h0LFxuICBNb25rLCBNb25zdGVyLCBQcmllc3QsIFJhbmdlciwgUm9ndWUsIFRvdXJpc3QsIFZhbGt5cmllLCBXaXphcmRcbn07IiwiXG5pbXBvcnQgUHJvZmVzc2lvbiBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9wcm9mZXNzaW9uJztcblxuaW1wb3J0ICogYXMgRm9vZHMgZnJvbSAnLi4vaXRlbXMvZm9vZHMnO1xuaW1wb3J0ICogYXMgV2VhcG9ucyBmcm9tICcuLi9pdGVtcy9fd2VhcG9ucyc7XG5pbXBvcnQgKiBhcyBCb2R5cyBmcm9tICcuLi9pdGVtcy9ib2R5cyc7XG5pbXBvcnQgKiBhcyBIZWFkcyBmcm9tICcuLi9pdGVtcy9oZWFkcyc7XG5pbXBvcnQgKiBhcyBUaHJlc2hvbGRzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9za2lsbC10aHJlc2hvbGRzJztcbmltcG9ydCAqIGFzIFRyYWl0cyBmcm9tICcuLi90cmFpdHMvX2FsbCc7XG5cbmNvbnN0IGFyY2hhZW9sb2dpc3RDb25maWcgPSB7XG4gIGhwICA6ICc2ZDMnLFxuICBtcCAgOiAnMGQwJyxcbiAgc3RyIDogJzJkMicsXG4gIGNvbiA6ICcxZDQnLFxuICBpbnQgOiAnMWQyJyxcbiAgZGV4IDogJzNkMycsXG4gIHdpcyA6ICcxZDInLFxuICBjaGEgOiAnMWQxJyxcbiAgbGV2ZWxVcDoge1xuICAgIGhwICA6ICcxZDMnLFxuICAgIG1wICA6ICcwZDAnLFxuICAgIHN0ciA6ICcxZDInLFxuICAgIGNvbiA6ICcxZDInLFxuICAgIGludCA6ICcxZDEnLFxuICAgIGRleCA6ICcxZDMnLFxuICAgIHdpcyA6ICcxZDInLFxuICAgIGNoYSA6ICcxZDIgLSAxJ1xuICB9LFxuICB0aXRsZXM6IFsnRGlnZ2VyJywsICdGaWVsZCBXb3JrZXInLCwsICdJbnZlc3RpZ2F0b3InLCwsICdFeGh1bWVyJywsLCAnRXhjYXZhdG9yJywsLCAnU3BlbHVua2VyJywsLCAnU3BlbGVvbG9naXN0JywsLCAnQ29sbGVjdG9yJywsLCAnQ3VyYXRvciddLFxuICB0cmFpdHM6IFtUcmFpdHMuU3RlYWx0aCh7IGxldmVsOiAyIH0pLCBUcmFpdHMuSGFzdGUoeyBsZXZlbDogMiB9KV0sXG4gIHNraWxsQ2FwczogeyBiYXNoOiBUaHJlc2hvbGRzLlNraWxsZWQsIHN0YWI6IFRocmVzaG9sZHMuQmFzaWMsIHNsYXNoOiBUaHJlc2hvbGRzLlNraWxsZWQsIHVuYXJtZWQ6IFRocmVzaG9sZHMuRXhwZXJ0IH0sXG4gIHN0YXJ0aW5nSXRlbXM6IFtcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBXZWFwb25zLkJ1bGx3aGlwKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJywgZW5jaGFudG1lbnQ6IDIgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBGb29kcy5SYXRpb24oeyBjaGFyZ2VzOiAnM2QyJywgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IEJvZHlzLkxlYXRoZXJKYWNrZXQoeyBidWNOYW1lOiAndW5jdXJzZWQnLCBzdGFydElkZW50aWZpZWQ6IHRydWUgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBIZWFkcy5GZWRvcmEoeyBidWNOYW1lOiAndW5jdXJzZWQnLCBzdGFydElkZW50aWZpZWQ6IHRydWUgfSkgfVxuICBdXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmNoYWVvbG9naXN0IGV4dGVuZHMgUHJvZmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGFyY2hhZW9sb2dpc3RDb25maWcpO1xuICB9XG59IiwiXG5pbXBvcnQgUHJvZmVzc2lvbiBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9wcm9mZXNzaW9uJztcblxuaW1wb3J0ICogYXMgRm9vZHMgZnJvbSAnLi4vaXRlbXMvZm9vZHMnO1xuaW1wb3J0ICogYXMgV2VhcG9ucyBmcm9tICcuLi9pdGVtcy9fd2VhcG9ucyc7XG5pbXBvcnQgKiBhcyBCb2R5cyBmcm9tICcuLi9pdGVtcy9ib2R5cyc7XG5pbXBvcnQgKiBhcyBUaHJlc2hvbGRzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9za2lsbC10aHJlc2hvbGRzJztcbmltcG9ydCAqIGFzIFRyYWl0cyBmcm9tICcuLi90cmFpdHMvX2FsbCc7XG5cbmNvbnN0IGJhcmJhcmlhbkNvbmZpZyA9IHtcbiAgaHAgIDogJzJkMycsXG4gIG1wICA6ICcwZDAnLFxuICBzdHIgOiAnNGQzJyxcbiAgY29uIDogJzNkMicsXG4gIGludCA6ICcxZDEnLFxuICBkZXggOiAnMmQyJyxcbiAgd2lzIDogJzFkMScsXG4gIGNoYSA6ICcxZDEnLFxuICBsZXZlbFVwOiB7XG4gICAgaHAgIDogJzFkMicsXG4gICAgbXAgIDogJzBkMCcsXG4gICAgc3RyIDogJzFkMycsXG4gICAgY29uIDogJzFkMicsXG4gICAgaW50IDogJzFkMScsXG4gICAgZGV4IDogJzFkMicsXG4gICAgd2lzIDogJzFkMScsXG4gICAgY2hhIDogJzFkMiAtIDEnXG4gIH0sXG4gIHRpdGxlczogWydQbHVuZGVyZXgnLCwgJ1BpbGxhZ2VyJywsLCAnQmFuZGl0JywsLCAnQnJpZ2FuZCcsLCwgJ1JhaWRlcicsLCwgJ1JlYXZlcicsLCwgJ1NsYXllcicsLCwgJ0NoaWVmdGVyZXgnLCwsICdDb25xdWVyZXgnXSxcbiAgdHJhaXRzOiBbVHJhaXRzLlN0ZWFsdGgoeyBsZXZlbDogMywgcmVxOiAxNSB9KSwgVHJhaXRzLkhhc3RlKHsgbGV2ZWw6IDIsIHJlcTogNyB9KSwgVHJhaXRzLlBvaXNvblJlc2lzdGFuY2UoKV0sXG4gIHNraWxsQ2FwczogeyBiYXNoOiBUaHJlc2hvbGRzLlNraWxsZWQsIHN0YWI6IFRocmVzaG9sZHMuU2tpbGxlZCwgcmFuZ2VkOiBUaHJlc2hvbGRzLkJhc2ljLCBzaG90OiBUaHJlc2hvbGRzLkJhc2ljLCBzbGFzaDogVGhyZXNob2xkcy5Ta2lsbGVkLCB1bmFybWVkOiBUaHJlc2hvbGRzLk1hc3RlciB9LFxuICBzdGFydGluZ0l0ZW1zOiBbXG4gICAgeyBjaG9pY2VzOiB7IHN3b3JkYXhlOiAxLCBheGVzd29yZDogMSB9LFxuICAgICAgY2hvaWNlc0luaXQ6IHtcbiAgICAgICAgc3dvcmRheGU6ICgpID0+IFtuZXcgV2VhcG9ucy5Ccm9hZHN3b3JkKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSwgbmV3IFdlYXBvbnMuQXhlKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KV0sXG4gICAgICAgIGF4ZXN3b3JkOiAoKSA9PiBbbmV3IFdlYXBvbnMuQmF0dGxlQXhlKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSwgbmV3IFdlYXBvbnMuU2hvcnRzd29yZCh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSldXG4gICAgICB9XG4gICAgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBGb29kcy5SYXRpb24oeyBjaGFyZ2VzOiAnMWQyJywgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IEJvZHlzLlJpbmdNYWlsKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJywgc3RhcnRJZGVudGlmaWVkOiB0cnVlIH0pIH1cbiAgXVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyYmFyaWFuIGV4dGVuZHMgUHJvZmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGJhcmJhcmlhbkNvbmZpZyk7XG4gIH1cbn0iLCJcbmltcG9ydCBQcm9mZXNzaW9uIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3Byb2Zlc3Npb24nO1xuXG5pbXBvcnQgKiBhcyBXZWFwb25zIGZyb20gJy4uL2l0ZW1zL193ZWFwb25zJztcbmltcG9ydCAqIGFzIEJvZHlzIGZyb20gJy4uL2l0ZW1zL2JvZHlzJztcbmltcG9ydCAqIGFzIFByb2plY3RpbGVzIGZyb20gJy4uL2l0ZW1zL3Byb2plY3RpbGVzJztcbmltcG9ydCAqIGFzIFRocmVzaG9sZHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzL3NraWxsLXRocmVzaG9sZHMnO1xuaW1wb3J0ICogYXMgVHJhaXRzIGZyb20gJy4uL3RyYWl0cy9fYWxsJztcblxuY29uc3QgY2F2ZW1hbkNvbmZpZyA9IHtcbiAgaHAgIDogJzRkNCcsXG4gIG1wICA6ICcwZDAnLFxuICBzdHIgOiAnNmQyJyxcbiAgY29uIDogJzFkMicsXG4gIGludCA6ICcxZDEnLFxuICBkZXggOiAnMWQyJyxcbiAgd2lzIDogJzFkMScsXG4gIGNoYSA6ICcxZDEnLFxuICBsZXZlbFVwOiB7XG4gICAgaHAgIDogJzFkNCcsXG4gICAgbXAgIDogJzBkMCcsXG4gICAgc3RyIDogJzJkMicsXG4gICAgY29uIDogJzFkMicsXG4gICAgaW50IDogJzFkMScsXG4gICAgZGV4IDogJzFkMicsXG4gICAgd2lzIDogJzFkMScsXG4gICAgY2hhIDogJzBkMCdcbiAgfSxcbiAgdGl0bGVzOiBbJ1Ryb2dsb2R5dGUnLCwgJ0Fib3JpZ2luZScsLCwgJ1dhbmRlcmVyJywsLCAnVmFncmFudCcsLCwgJ1dheWZhcmVyJywsLCAnUm9hbWVyJywsLCAnTm9tYWQnLCwsICdSb3ZlcicsLCwgJ1Bpb25lZXInXSxcbiAgdHJhaXRzOiBbVHJhaXRzLldhcm5pbmcoeyBsZXZlbDogMywgcmVxOiAxNSB9KSwgVHJhaXRzLkhhc3RlKHsgbGV2ZWw6IDIsIHJlcTogNyB9KV0sXG4gIHNraWxsQ2FwczogeyBiYXNoOiBUaHJlc2hvbGRzLkV4cGVydCwgc3RhYjogVGhyZXNob2xkcy5CYXNpYywgcmFuZ2VkOiBUaHJlc2hvbGRzLkJhc2ljLCBzaG90OiBUaHJlc2hvbGRzLkJhc2ljLCB1bmFybWVkOiBUaHJlc2hvbGRzLk1hc3RlciB9LFxuICBzdGFydGluZ0l0ZW1zOiBbXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgV2VhcG9ucy5DbHViKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJywgZW5jaGFudG1lbnQ6IDEgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBXZWFwb25zLlNsaW5nKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJywgZW5jaGFudG1lbnQ6IDIgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBQcm9qZWN0aWxlcy5GbGludFN0b25lKHsgY2hhcmdlczogJzFkMTIgKyAxMCcsIGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBQcm9qZWN0aWxlcy5Sb2NrKHsgY2hhcmdlczogJzFkMTUgKyAxOCcsIGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBCb2R5cy5TdHVkZGVkTGVhdGhlckFybW9yKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJywgc3RhcnRJZGVudGlmaWVkOiB0cnVlIH0pIH1cbiAgXVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2F2ZW1hbiBleHRlbmRzIFByb2Zlc3Npb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihjYXZlbWFuQ29uZmlnKTtcbiAgfVxufSIsIlxuaW1wb3J0IFByb2Zlc3Npb24gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcHJvZmVzc2lvbic7XG5cbmltcG9ydCAqIGFzIEZvb2RzIGZyb20gJy4uL2l0ZW1zL2Zvb2RzJztcbmltcG9ydCAqIGFzIEhlYWRzIGZyb20gJy4uL2l0ZW1zL2hlYWRzJztcbmltcG9ydCAqIGFzIE5lY2tzIGZyb20gJy4uL2l0ZW1zL25lY2tzJztcbmltcG9ydCAqIGFzIFBvdGlvbnMgZnJvbSAnLi4vaXRlbXMvcG90aW9ucyc7XG5pbXBvcnQgKiBhcyBXZWFwb25zIGZyb20gJy4uL2l0ZW1zL193ZWFwb25zJztcbmltcG9ydCAqIGFzIFByb2plY3RpbGVzIGZyb20gJy4uL2l0ZW1zL3Byb2plY3RpbGVzJztcbmltcG9ydCAqIGFzIFRocmVzaG9sZHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzL3NraWxsLXRocmVzaG9sZHMnO1xuaW1wb3J0ICogYXMgVHJhaXRzIGZyb20gJy4uL3RyYWl0cy9fYWxsJztcblxuY29uc3QgZGV2Q2ZnID0ge1xuICBocCAgOiAnMWQxJyxcbiAgbXAgIDogJzlkNScsXG4gIHN0ciA6ICcxZDEnLFxuICBjb24gOiAnMWQxJyxcbiAgaW50IDogJzRkNScsXG4gIGRleCA6ICcxZDEnLFxuICB3aXMgOiAnNGQ1JyxcbiAgY2hhIDogJzRkNScsXG4gIGxldmVsVXA6IHtcbiAgICBocCAgOiAnMWQzJyxcbiAgICBtcCAgOiAnMGQwJyxcbiAgICBzdHIgOiAnMWQyJyxcbiAgICBjb24gOiAnMWQyJyxcbiAgICBpbnQgOiAnMWQxJyxcbiAgICBkZXggOiAnMWQzJyxcbiAgICB3aXMgOiAnMWQyJyxcbiAgICBjaGEgOiAnMWQxJ1xuICB9LFxuICB0aXRsZXM6IFsnRGV2ZWxvcGVyJ10sXG4gIHRyYWl0czogW1RyYWl0cy5JbmZyYXZpc2lvbih7IGxldmVsOiAzIH0pLCBUcmFpdHMuVGVsZXBhdGh5KHsgbGV2ZWw6IDEwIH0pLCBUcmFpdHMuQ2xhaXJ2b3lhbmNlKHsgbGV2ZWw6IDEsIHJlcTogMiB9KSwgVHJhaXRzLlN0ZWFsdGgoeyBsZXZlbDogOCB9KV0sXG4gIHNraWxsQ2FwczogeyBzaG90OiBUaHJlc2hvbGRzLkV4cGVydCwgc3RhYjogVGhyZXNob2xkcy5Ta2lsbGVkIH0sXG4gIHN0YXJ0aW5nSXRlbXM6IFtcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBXZWFwb25zLkJvdyh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBQcm9qZWN0aWxlcy5BcnJvdyh7IGNoYXJnZXM6ICcxZDEnLCBidWNOYW1lOiAndW5jdXJzZWQnIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgSGVhZHMuTmlnaHRHb2dnbGVzKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IE5lY2tzLkFtdWxldE9mTGlmZVNhdmluZyh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBGb29kcy5SYXRpb24oeyBjaGFyZ2VzOiAnMWQzJywgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IFBvdGlvbnMuSGVhbGluZyh7IGNoYXJnZXM6ICcxZDEnLCBidWNOYW1lOiAndW5jdXJzZWQnLCBzdGFydElkZW50aWZpZWQ6IHRydWUgfSkgfVxuICBdXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXZlbG9wZXIgZXh0ZW5kcyBQcm9mZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoZGV2Q2ZnKTtcbiAgfVxufSIsIlxuaW1wb3J0IFByb2Zlc3Npb24gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcHJvZmVzc2lvbic7XG5cbmltcG9ydCBSb2xsIGZyb20gJy4uLy4uL2xpYi9kaWNlLXJvbGxlcic7XG5pbXBvcnQgeyBHb2xkIH0gZnJvbSAnLi4vaXRlbXMvX3NwZWNpYWwnO1xuaW1wb3J0ICogYXMgRm9vZHMgZnJvbSAnLi4vaXRlbXMvZm9vZHMnO1xuaW1wb3J0ICogYXMgUG90aW9ucyBmcm9tICcuLi9pdGVtcy9wb3Rpb25zJztcbmltcG9ydCAqIGFzIFNwZWxsYm9va3MgZnJvbSAnLi4vaXRlbXMvc3BlbGxib29rcyc7XG5pbXBvcnQgKiBhcyBXZWFwb25zIGZyb20gJy4uL2l0ZW1zL193ZWFwb25zJztcbmltcG9ydCAqIGFzIFdyaXN0cyBmcm9tICcuLi9pdGVtcy93cmlzdHMnO1xuaW1wb3J0ICogYXMgVGhyZXNob2xkcyBmcm9tICcuLi8uLi9jb25zdGFudHMvc2tpbGwtdGhyZXNob2xkcyc7XG5pbXBvcnQgKiBhcyBUcmFpdHMgZnJvbSAnLi4vdHJhaXRzL19hbGwnO1xuXG5jb25zdCBoZWFsZXJDb25maWcgPSB7XG4gIGhwICA6ICcyZDUnLFxuICBtcCAgOiAnM2QzJyxcbiAgc3RyIDogJzFkMicsXG4gIGNvbiA6ICcxZDInLFxuICBpbnQgOiAnMmQyJyxcbiAgZGV4IDogJzFkMicsXG4gIHdpcyA6ICcyZDMnLFxuICBjaGEgOiAnMWQxJyxcbiAgbGV2ZWxVcDoge1xuICAgIGhwICA6ICcxZDUnLFxuICAgIG1wICA6ICcyZDInLFxuICAgIHN0ciA6ICcxZDEnLFxuICAgIGNvbiA6ICcxZDInLFxuICAgIGludCA6ICcxZDInLFxuICAgIGRleCA6ICcxZDInLFxuICAgIHdpcyA6ICcxZDMnLFxuICAgIGNoYSA6ICcxZDIgLSAxJ1xuICB9LFxuICB0aXRsZXM6IFsnUmhpem90b21pc3QnLCwgJ0VtcGlyaWMnLCwsICdFbWJhbG1lcicsLCwgJ0RyZXNzZXInLCwsICdNZWRpY3VzIG9zc2l1bScsLCwgJ0hlcmJhbGlzdCcsLCwgJ01hZ2lzdGVyZXgnLCwsICdQaHlzaWNpYW4nLCwsICdDaGlydXJnZW9uJ10sXG4gIHRyYWl0czogW1RyYWl0cy5XYXJuaW5nKHsgbGV2ZWw6IDMsIHJlcTogMTUgfSksIFRyYWl0cy5Qb2lzb25SZXNpc3RhbmNlKCldLFxuICBza2lsbENhcHM6IHsgYmFzaDogVGhyZXNob2xkcy5FeHBlcnQsIHN0YWI6IFRocmVzaG9sZHMuU2tpbGxlZCwgcmFuZ2VkOiBUaHJlc2hvbGRzLkJhc2ljLCBzbGFzaDogVGhyZXNob2xkcy5CYXNpYywgdW5hcm1lZDogVGhyZXNob2xkcy5CYXNpYyB9LFxuICBzdGFydGluZ0l0ZW1zOiBbXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgR29sZChSb2xsKCcxZDEwMDAgKyAxMDAwJykpIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgV2VhcG9ucy5TY2FscGVsKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IFdyaXN0cy5MZWF0aGVyR2xvdmVzKHsgZW5jaGFudG1lbnQ6IDIsIGJ1Y05hbWU6ICd1bmN1cnNlZCcsIHN0YXJ0SWRlbnRpZmllZDogdHJ1ZSB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IFNwZWxsYm9va3MuQ3VyZVNlbGYoeyBidWNOYW1lOiAnYmxlc3NlZCcsIHN0YXJ0SWRlbnRpZmllZDogdHJ1ZSB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IFNwZWxsYm9va3MuRXh0cmFDdXJlU2VsZih7IGJ1Y05hbWU6ICdibGVzc2VkJywgc3RhcnRJZGVudGlmaWVkOiB0cnVlIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgRm9vZHMuQXBwbGUoeyBjaGFyZ2VzOiAnMWQ0ICsgNCcsIGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBQb3Rpb25zLkhlYWxpbmcoeyBjaGFyZ2VzOiAnNGQxJywgYnVjTmFtZTogJ3VuY3Vyc2VkJywgc3RhcnRJZGVudGlmaWVkOiB0cnVlIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgUG90aW9ucy5FeHRyYUhlYWxpbmcoeyBjaGFyZ2VzOiAnNGQxJywgYnVjTmFtZTogJ3VuY3Vyc2VkJywgc3RhcnRJZGVudGlmaWVkOiB0cnVlIH0pIH1cbiAgXVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhbGVyIGV4dGVuZHMgUHJvZmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGhlYWxlckNvbmZpZyk7XG4gIH1cbn0iLCJcbmltcG9ydCBQcm9mZXNzaW9uIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3Byb2Zlc3Npb24nO1xuXG5pbXBvcnQgKiBhcyBGb29kcyBmcm9tICcuLi9pdGVtcy9mb29kcyc7XG5pbXBvcnQgKiBhcyBCb2R5cyBmcm9tICcuLi9pdGVtcy9ib2R5cyc7XG5pbXBvcnQgKiBhcyBIZWFkcyBmcm9tICcuLi9pdGVtcy9oZWFkcyc7XG5pbXBvcnQgKiBhcyBXZWFwb25zIGZyb20gJy4uL2l0ZW1zL193ZWFwb25zJztcbmltcG9ydCAqIGFzIFdyaXN0cyBmcm9tICcuLi9pdGVtcy93cmlzdHMnO1xuaW1wb3J0ICogYXMgVGhyZXNob2xkcyBmcm9tICcuLi8uLi9jb25zdGFudHMvc2tpbGwtdGhyZXNob2xkcyc7XG5pbXBvcnQgKiBhcyBUcmFpdHMgZnJvbSAnLi4vdHJhaXRzL19hbGwnO1xuXG5jb25zdCBrbmlnaHRDb25maWcgPSB7XG4gIGhwICA6ICcyZDcnLFxuICBtcCAgOiAnMGQwJyxcbiAgc3RyIDogJzNkMicsXG4gIGNvbiA6ICczZDInLFxuICBpbnQgOiAnM2QyJyxcbiAgZGV4IDogJzNkMicsXG4gIHdpcyA6ICczZDInLFxuICBjaGEgOiAnM2QyJyxcbiAgbGV2ZWxVcDoge1xuICAgIGhwICA6ICcxZDYnLFxuICAgIG1wICA6ICcwZDAnLFxuICAgIHN0ciA6ICcxZDMnLFxuICAgIGNvbiA6ICcxZDMnLFxuICAgIGludCA6ICcxZDInLFxuICAgIGRleCA6ICcxZDMnLFxuICAgIHdpcyA6ICcxZDEnLFxuICAgIGNoYSA6ICcxZDIgLSAxJ1xuICB9LFxuICB0aXRsZXM6IFsnR2FsbGFudCcsLCAnRXNxdWlyZScsLCwgJ0JhY2hlbG9yJywsLCAnU2VyZ2VhbnQnLCwsICdLbmlnaHQnLCwsICdCYW5uZXJldCcsLCwgJ0NoZXZhbGllcmV4JywsLCAnU2VpZ25pZXVyJywsLCAnUGFsYWRpbiddLFxuICB0cmFpdHM6IFtUcmFpdHMuSGFzdGUoeyBsZXZlbDogMiwgcmVxOiA3IH0pXSxcbiAgc2tpbGxDYXBzOiB7IGJhc2g6IFRocmVzaG9sZHMuRXhwZXJ0LCBzdGFiOiBUaHJlc2hvbGRzLkJhc2ljLCByYW5nZWQ6IFRocmVzaG9sZHMuQmFzaWMsIHNsYXNoOiBUaHJlc2hvbGRzLkV4cGVydCwgdW5hcm1lZDogVGhyZXNob2xkcy5FeHBlcnQsIGZvcmNlOiBUaHJlc2hvbGRzLkJhc2ljIH0sXG4gIHN0YXJ0aW5nSXRlbXM6IFtcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBXZWFwb25zLkxvbmdzd29yZCh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcsIGVuY2hhbnRtZW50OiAxIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgV2VhcG9ucy5TcGVhcih7IGJ1Y05hbWU6ICd1bmN1cnNlZCcsIGVuY2hhbnRtZW50OiAxIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgQm9keXMuUmluZ01haWwoeyBidWNOYW1lOiAndW5jdXJzZWQnLCBlbmNoYW50bWVudDogMSB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IFdyaXN0cy5MZWF0aGVyR2xvdmVzKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJywgc3RhcnRJZGVudGlmaWVkOiB0cnVlIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgSGVhZHMuSGVsbSh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcsIHN0YXJ0SWRlbnRpZmllZDogdHJ1ZSB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IEZvb2RzLkFwcGxlKHsgY2hhcmdlczogJzFkMTAgKyAxMCcsIGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBGb29kcy5DYXJyb3QoeyBjaGFyZ2VzOiAnMWQxMCArIDEwJywgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9XG4gIF1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtuaWdodCBleHRlbmRzIFByb2Zlc3Npb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihrbmlnaHRDb25maWcpO1xuICB9XG59IiwiXG5pbXBvcnQgUHJvZmVzc2lvbiBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9wcm9mZXNzaW9uJztcblxuaW1wb3J0ICogYXMgRm9vZHMgZnJvbSAnLi4vaXRlbXMvZm9vZHMnO1xuaW1wb3J0ICogYXMgUG90aW9ucyBmcm9tICcuLi9pdGVtcy9wb3Rpb25zJztcbmltcG9ydCAqIGFzIEJvZHlzIGZyb20gJy4uL2l0ZW1zL2JvZHlzJztcbmltcG9ydCAqIGFzIFdyaXN0cyBmcm9tICcuLi9pdGVtcy93cmlzdHMnO1xuaW1wb3J0ICogYXMgVGhyZXNob2xkcyBmcm9tICcuLi8uLi9jb25zdGFudHMvc2tpbGwtdGhyZXNob2xkcyc7XG5pbXBvcnQgKiBhcyBUcmFpdHMgZnJvbSAnLi4vdHJhaXRzL19hbGwnO1xuXG5jb25zdCBtb25rQ29uZmlnID0ge1xuICBocCAgOiAnMmQ1JyxcbiAgbXAgIDogJzFkNycsXG4gIHN0ciA6ICc0ZDInLFxuICBjb24gOiAnMmQyJyxcbiAgaW50IDogJzFkMicsXG4gIGRleCA6ICc0ZDInLFxuICB3aXMgOiAnMWQyJyxcbiAgY2hhIDogJzFkMScsXG4gIGxldmVsVXA6IHtcbiAgICBocCAgOiAnMWQ0JyxcbiAgICBtcCAgOiAnMWQzJyxcbiAgICBzdHIgOiAnMmQyJyxcbiAgICBjb24gOiAnMWQyJyxcbiAgICBpbnQgOiAnMWQyJyxcbiAgICBkZXggOiAnMmQyJyxcbiAgICB3aXMgOiAnMWQxJyxcbiAgICBjaGEgOiAnMWQyIC0gMSdcbiAgfSxcbiAgdGl0bGVzOiBbJ0NhbmRpZGF0ZScsLCAnTm92aWNlJywsLCAnSW5pdGlhdGUnLCwsICdTdHVkZW50IG9mIFN0b25lcycsLCwgJ1N0dWRlbnQgb2YgV2F0ZXJzJywsLCAnU3R1ZGVudCBvZiBNZXRhbHMnLCwsICdTdHVkZW50IG9mIFdpbmRzJywsLCAnU3R1ZGVudCBvZiBGaXJlJywsLCAnTWFzdGVyJ10sXG4gIHRyYWl0czogW1xuICAgIFRyYWl0cy5Qb2lzb25SZXNpc3RhbmNlKHsgcmVxOiAzIH0pLCBUcmFpdHMuU3RlYWx0aCh7IGxldmVsOiAzLCByZXE6IDUgfSksIFRyYWl0cy5XYXJuaW5nKHsgbGV2ZWw6IDIsIHJlcTogNyB9KSxcbiAgICBUcmFpdHMuSGFzdGUoeyBsZXZlbDogNCwgcmVxOiA5IH0pLCBUcmFpdHMuRmlyZVJlc2lzdGFuY2UoeyByZXE6IDExIH0pLCBUcmFpdHMuSWNlUmVzaXN0YW5jZSh7IHJlcTogMTMgfSksXG4gICAgVHJhaXRzLlNob2NrUmVzaXN0YW5jZSh7IHJlcTogMTUgfSksIFRyYWl0cy5JbmZyYXZpc2lvbih7IGxldmVsOiAzLCByZXE6IDE3IH0pLCBUcmFpdHMuUHJvdGVjdGlvbih7IGxldmVsOiAxLCByZXE6IDE5IH0pXG4gIF0sXG4gIHNraWxsQ2FwczogeyBiYXNoOiBUaHJlc2hvbGRzLkJhc2ljLCB1bmFybWVkOiBUaHJlc2hvbGRzLkdyYW5kbWFzdGVyLCBmb3JjZTogVGhyZXNob2xkcy5CYXNpYyB9LFxuICBzdGFydGluZ0l0ZW1zOiBbXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgQm9keXMuUm9iZSh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcsIGVuY2hhbnRtZW50OiAyIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgV3Jpc3RzLkxlYXRoZXJHbG92ZXMoeyBidWNOYW1lOiAndW5jdXJzZWQnLCBlbmNoYW50bWVudDogMiwgc3RhcnRJZGVudGlmaWVkOiB0cnVlIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgUG90aW9ucy5IZWFsaW5nKHsgY2hhcmdlczogJzFkMScsIGJ1Y05hbWU6ICd1bmN1cnNlZCcsIHN0YXJ0SWRlbnRpZmllZDogdHJ1ZSB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IEZvb2RzLlJhdGlvbih7IGNoYXJnZXM6ICcxZDMgKyAzJywgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IEZvb2RzLkFwcGxlKHsgY2hhcmdlczogJzFkNSArIDUnLCBidWNOYW1lOiAndW5jdXJzZWQnIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgRm9vZHMuQ2Fycm90KHsgY2hhcmdlczogJzFkNSArIDUnLCBidWNOYW1lOiAndW5jdXJzZWQnIH0pIH1cbiAgXVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9uayBleHRlbmRzIFByb2Zlc3Npb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihtb25rQ29uZmlnKTtcbiAgfVxufSIsIlxuaW1wb3J0IFByb2Zlc3Npb24gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcHJvZmVzc2lvbic7XG5pbXBvcnQgKiBhcyBUcmFpdHMgZnJvbSAnLi4vdHJhaXRzL19hbGwnO1xuXG5jb25zdCBtb25zdGVyQ2ZnID0ge1xuICBocCAgOiAnMWQxJyxcbiAgc3RyIDogJzFkMScsXG4gIGNvbiA6ICcxZDEnLFxuICBpbnQgOiAnMWQxJyxcbiAgZGV4IDogJzFkMScsXG4gIHdpcyA6ICcxZDEnLFxuICBjaGEgOiAnMWQxJyxcbiAgbGV2ZWxVcDoge1xuICAgIGhwICA6ICcyZDEnLFxuICAgIHN0ciA6ICcyZDEnLFxuICAgIGNvbiA6ICcyZDEnLFxuICAgIGludCA6ICcyZDEnLFxuICAgIGRleCA6ICcyZDEnLFxuICAgIHdpcyA6ICcyZDEnLFxuICAgIGNoYSA6ICcyZDEnXG4gIH0sXG4gIHRpdGxlczogWydNb25zdGVyJ10sXG4gIHRyYWl0czogW1RyYWl0cy5JbmZyYXZpc2lvbih7IGxldmVsOiA3IH0pXVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9uc3RlciBleHRlbmRzIFByb2Zlc3Npb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihtb25zdGVyQ2ZnKTtcbiAgfVxufSIsIlxuaW1wb3J0IFByb2Zlc3Npb24gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcHJvZmVzc2lvbic7XG5cbmltcG9ydCAqIGFzIFBvdGlvbnMgZnJvbSAnLi4vaXRlbXMvcG90aW9ucyc7XG5pbXBvcnQgKiBhcyBXZWFwb25zIGZyb20gJy4uL2l0ZW1zL193ZWFwb25zJztcbmltcG9ydCAqIGFzIEJvZHlzIGZyb20gJy4uL2l0ZW1zL2JvZHlzJztcbmltcG9ydCAqIGFzIFRocmVzaG9sZHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzL3NraWxsLXRocmVzaG9sZHMnO1xuaW1wb3J0ICogYXMgVHJhaXRzIGZyb20gJy4uL3RyYWl0cy9fYWxsJztcblxuY29uc3QgcHJpZXN0Q29uZmlnID0ge1xuICBocCAgOiAnMWQ1JyxcbiAgbXAgIDogJzNkNScsXG4gIHN0ciA6ICcxZDInLFxuICBjb24gOiAnMWQyJyxcbiAgaW50IDogJzJkMicsXG4gIGRleCA6ICcxZDInLFxuICB3aXMgOiAnM2QyJyxcbiAgY2hhIDogJzFkMicsXG4gIGxldmVsVXA6IHtcbiAgICBocCAgOiAnMWQzJyxcbiAgICBtcCAgOiAnMWQ1JyxcbiAgICBzdHIgOiAnMWQyIC0gMScsXG4gICAgY29uIDogJzFkMScsXG4gICAgaW50IDogJzFkMicsXG4gICAgZGV4IDogJzFkMiAtIDEnLFxuICAgIHdpcyA6ICcxZDInLFxuICAgIGNoYSA6ICcxZDIgLSAxJ1xuICB9LFxuICB0aXRsZXM6IFsnQXNwaXJhbnQnLCwgJ0Fjb2x5dGUnLCwsICdBZGVwdCcsLCwgJ1ByaWVzdCcsLCwgJ0N1cmF0ZScsLCwgJ0Nhbm9uJywsLCAnTGFtYScsLCwgJ1BhdHJpYXJjaCcsLCwgJ0hpZ2ggUHJpZXN0J10sXG4gIHRyYWl0czogW1xuICAgIFRyYWl0cy5XYXJuaW5nKHsgbGV2ZWw6IDMsIHJlcTogMTUgfSksIFRyYWl0cy5GaXJlUmVzaXN0YW5jZSh7IHJlcTogMjAgfSlcbiAgXSxcbiAgc2tpbGxDYXBzOiB7IGJhc2g6IFRocmVzaG9sZHMuRXhwZXJ0LCB1bmFybWVkOiBUaHJlc2hvbGRzLkJhc2ljLCBzdGFiOiBUaHJlc2hvbGRzLlNraWxsZWQsIHJhbmdlZDogVGhyZXNob2xkcy5CYXNpYywgc21hc2g6IFRocmVzaG9sZHMuU2tpbGxlZCwgdGhydXN0OiBUaHJlc2hvbGRzLlNraWxsZWQgfSxcbiAgc3RhcnRpbmdJdGVtczogW1xuICAgIHsgaW5pdDogKCkgPT4gbmV3IFdlYXBvbnMuTWFjZSh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcsIGVuY2hhbnRtZW50OiAxIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgQm9keXMuUm9iZSh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcsIGVuY2hhbnRtZW50OiAxIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgUG90aW9ucy5IZWFsaW5nKHsgY2hhcmdlczogJzFkMScsIGJ1Y05hbWU6ICd1bmN1cnNlZCcsIHN0YXJ0SWRlbnRpZmllZDogdHJ1ZSB9KSB9XG4gIF1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByaWVzdCBleHRlbmRzIFByb2Zlc3Npb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihwcmllc3RDb25maWcpO1xuICB9XG59IiwiXG5pbXBvcnQgUHJvZmVzc2lvbiBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9wcm9mZXNzaW9uJztcblxuaW1wb3J0ICogYXMgRm9vZHMgZnJvbSAnLi4vaXRlbXMvZm9vZHMnO1xuaW1wb3J0ICogYXMgV2VhcG9ucyBmcm9tICcuLi9pdGVtcy9fd2VhcG9ucyc7XG5pbXBvcnQgKiBhcyBQb3Rpb25zIGZyb20gJy4uL2l0ZW1zL3BvdGlvbnMnO1xuaW1wb3J0ICogYXMgUHJvamVjdGlsZXMgZnJvbSAnLi4vaXRlbXMvcHJvamVjdGlsZXMnO1xuaW1wb3J0ICogYXMgVGhyZXNob2xkcyBmcm9tICcuLi8uLi9jb25zdGFudHMvc2tpbGwtdGhyZXNob2xkcyc7XG5cbmNvbnN0IHJhbmdlckNmZyA9IHtcbiAgaHAgIDogJzNkNCcsXG4gIG1wICA6ICcwZDAnLFxuICBzdHIgOiAnMmQzJyxcbiAgY29uIDogJzFkNScsXG4gIGludCA6ICcxZDMnLFxuICBkZXggOiAnMmQ1JyxcbiAgd2lzIDogJzBkMCcsXG4gIGNoYSA6ICcxZDEnLFxuICBsZXZlbFVwOiB7XG4gICAgaHAgIDogJzFkNCcsXG4gICAgbXAgIDogJzBkMCcsXG4gICAgc3RyIDogJzFkMicsXG4gICAgY29uIDogJzFkMicsXG4gICAgaW50IDogJzFkMicsXG4gICAgZGV4IDogJzFkNCcsXG4gICAgd2lzIDogJzBkMCcsXG4gICAgY2hhIDogJzFkMiAtIDEnXG4gIH0sXG4gIHRpdGxlczogWydUZW5kZXJmb290JywsICdMb29rb3V0JywsLCAnVHJhaWxibGF6ZXInLCwsICdSZWNvbm5vaXRlcmV4JywsLCAnU2NvdXQnLCwsICdBcmJhbGVzdGVyJywsLCAnQXJjaGVyJywsLCAnU2hhcnBzaG9vdGVyJywsLCAnTWFya3NyZXgnXSxcbiAgc2tpbGxDYXBzOiB7IHJhbmdlZDogVGhyZXNob2xkcy5FeHBlcnQsIHNob3Q6IFRocmVzaG9sZHMuRXhwZXJ0LCBzdGFiOiBUaHJlc2hvbGRzLlNraWxsZWQgfSxcbiAgc3RhcnRpbmdJdGVtczogW1xuICAgIHsgY2hvaWNlczogeyBsZXNzOiA1LCBtb3JlOiAxIH0sXG4gICAgICBjaG9pY2VzSW5pdDoge1xuICAgICAgICBsZXNzOiAoKSA9PiBuZXcgUHJvamVjdGlsZXMuQXJyb3coeyBjaGFyZ2VzOiAnMWQxMCArIDUnLCBidWNOYW1lOiAndW5jdXJzZWQnIH0pLFxuICAgICAgICBtb3JlOiAoKSA9PiBuZXcgUHJvamVjdGlsZXMuQXJyb3coeyBjaGFyZ2VzOiAnMmQxMCArIDEwJywgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgV2VhcG9ucy5Cb3coeyBidWNOYW1lOiAndW5jdXJzZWQnIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgRm9vZHMuUmF0aW9uKHsgY2hhcmdlczogJzFkMycsIGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBQb3Rpb25zLkhlYWxpbmcoeyBjaGFyZ2VzOiAnMWQyJywgYnVjTmFtZTogJ3VuY3Vyc2VkJywgc3RhcnRJZGVudGlmaWVkOiB0cnVlIH0pIH1cbiAgXVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZ2VyIGV4dGVuZHMgUHJvZmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHJhbmdlckNmZyk7XG4gIH1cbn0iLCJcbmltcG9ydCBQcm9mZXNzaW9uIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3Byb2Zlc3Npb24nO1xuXG5pbXBvcnQgKiBhcyBCb2R5cyBmcm9tICcuLi9pdGVtcy9ib2R5cyc7XG5pbXBvcnQgKiBhcyBXZWFwb25zIGZyb20gJy4uL2l0ZW1zL193ZWFwb25zJztcbmltcG9ydCAqIGFzIFByb2plY3RpbGVzIGZyb20gJy4uL2l0ZW1zL3Byb2plY3RpbGVzJztcbmltcG9ydCAqIGFzIFRocmVzaG9sZHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzL3NraWxsLXRocmVzaG9sZHMnO1xuaW1wb3J0ICogYXMgVHJhaXRzIGZyb20gJy4uL3RyYWl0cy9fYWxsJztcblxuY29uc3Qgcm9ndWVDb25maWcgPSB7XG4gIGhwICA6ICcyZDYnLFxuICBtcCAgOiAnMGQwJyxcbiAgc3RyIDogJzNkMycsXG4gIGNvbiA6ICcxZDQnLFxuICBpbnQgOiAnMWQyJyxcbiAgZGV4IDogJzJkNScsXG4gIHdpcyA6ICcxZDInLFxuICBjaGEgOiAnMWQyJyxcbiAgbGV2ZWxVcDoge1xuICAgIGhwICA6ICcxZDQnLFxuICAgIG1wICA6ICcwZDAnLFxuICAgIHN0ciA6ICcxZDMnLFxuICAgIGNvbiA6ICcxZDInLFxuICAgIGludCA6ICcxZDIgLSAxJyxcbiAgICBkZXggOiAnMWQzJyxcbiAgICB3aXMgOiAnMWQyIC0gMScsXG4gICAgY2hhIDogJzFkMiAtIDEnXG4gIH0sXG4gIHRpdGxlczogWydGb290cGFkJywsICdDdXRwdXJzZScsLCwgJ1JvZ3VlJywsLCAnUGlsZmVyZXInLCwsICdSb2JiZXInLCwsICdCdXJnbGFyJywsLCAnRmlsY2hlcicsLCwgJ01hZ3NyZXgnLCwsICdUaGllZiddLFxuICB0cmFpdHM6IFtUcmFpdHMuU3RlYWx0aCh7IGxldmVsOiA0IH0pXSxcbiAgc2tpbGxDYXBzOiB7IGJhc2g6IFRocmVzaG9sZHMuRXhwZXJ0LCBzdGFiOiBUaHJlc2hvbGRzLkJhc2ljLCByYW5nZWQ6IFRocmVzaG9sZHMuQmFzaWMsIHNsYXNoOiBUaHJlc2hvbGRzLkV4cGVydCwgdW5hcm1lZDogVGhyZXNob2xkcy5FeHBlcnQsIGZvcmNlOiBUaHJlc2hvbGRzLkJhc2ljIH0sXG4gIHN0YXJ0aW5nSXRlbXM6IFtcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBXZWFwb25zLlNob3J0c3dvcmQoeyBidWNOYW1lOiAndW5jdXJzZWQnLCBlbmNoYW50bWVudDogMSB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IFByb2plY3RpbGVzLlN0aWxldHRvKHsgY2hhcmdlczogJzFkMTAgKyA1JywgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IFdlYXBvbnMuU3BlYXIoeyBidWNOYW1lOiAndW5jdXJzZWQnLCBlbmNoYW50bWVudDogMSB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IEJvZHlzLkxlYXRoZXJKYWNrZXQoeyBidWNOYW1lOiAndW5jdXJzZWQnLCBlbmNoYW50bWVudDogMSB9KSB9XG4gIF1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvZ3VlIGV4dGVuZHMgUHJvZmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHJvZ3VlQ29uZmlnKTtcbiAgfVxufSIsIlxuaW1wb3J0IFByb2Zlc3Npb24gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcHJvZmVzc2lvbic7XG5cbmltcG9ydCBSb2xsIGZyb20gJy4uLy4uL2xpYi9kaWNlLXJvbGxlcic7XG5pbXBvcnQgeyBHb2xkIH0gZnJvbSAnLi4vaXRlbXMvX3NwZWNpYWwnO1xuaW1wb3J0ICogYXMgRm9vZHMgZnJvbSAnLi4vaXRlbXMvZm9vZHMnO1xuaW1wb3J0ICogYXMgUG90aW9ucyBmcm9tICcuLi9pdGVtcy9wb3Rpb25zJztcbmltcG9ydCAqIGFzIFByb2plY3RpbGVzIGZyb20gJy4uL2l0ZW1zL3Byb2plY3RpbGVzJztcbmltcG9ydCAqIGFzIFRocmVzaG9sZHMgZnJvbSAnLi4vLi4vY29uc3RhbnRzL3NraWxsLXRocmVzaG9sZHMnO1xuXG5jb25zdCB0b3VyaXN0Q2ZnID0ge1xuICBocCAgOiAnMWQ1JyxcbiAgbXAgIDogJzFkMiArIDEnLFxuICBzdHIgOiAnMWQzJyxcbiAgY29uIDogJzFkMicsXG4gIGludCA6ICcxZDMnLFxuICBkZXggOiAnMWQyJyxcbiAgd2lzIDogJzFkMicsXG4gIGNoYSA6ICcxZDMgKyAxJyxcbiAgbHVrIDogJzFkMycsXG4gIGxldmVsVXA6IHtcbiAgICBocCAgOiAnMWQ1JyxcbiAgICBtcCAgOiAnMWQyJyxcbiAgICBzdHIgOiAnMWQyIC0gMScsXG4gICAgY29uIDogJzFkMicsXG4gICAgaW50IDogJzFkMiAtIDEnLFxuICAgIGRleCA6ICcxZDEnLFxuICAgIHdpcyA6ICcxZDIgLSAxJyxcbiAgICBjaGEgOiAnMWQyJyxcbiAgICBsdWsgOiAnMWQyIC0gMSdcbiAgfSxcbiAgdGl0bGVzOiBbJ1JhbWJsZXInLCwgJ1NpZ2h0c2VlcicsLCwgJ0V4Y3Vyc2lvbmlzdCcsLCwgJ1BlcmlncmluYXRvcicsLCwgJ1RyYXZlbGVyJywsLCAnSm91cm5leWVyJywsLCAnVm95YWdlcicsLCwgJ0V4cGxvcmVyJywsLCAnQWR2ZW50dXJlciddLFxuICBza2lsbENhcHM6IHsgYmFzaDogVGhyZXNob2xkcy5Db21wZXRlbnQsIHNsYXNoOiBUaHJlc2hvbGRzLkNvbXBldGVudCwgc21hc2g6IFRocmVzaG9sZHMuQ29tcGV0ZW50LCBzdGFiOiBUaHJlc2hvbGRzLkNvbXBldGVudCwgdGhydXN0OiBUaHJlc2hvbGRzLkNvbXBldGVudCwgdW5hcm1lZDogVGhyZXNob2xkcy5Db21wZXRlbnQgfSxcbiAgc3RhcnRpbmdJdGVtczogW1xuICAgIHsgaW5pdDogKCkgPT4gbmV3IEdvbGQoUm9sbCgnMWQxMDAwJykpIH0sXG4gICAgeyBjaG9pY2VzOiB7IGxlc3M6IDUsIG1vcmU6IDEgfSxcbiAgICAgIGNob2ljZXNJbml0OiB7XG4gICAgICAgIGxlc3M6ICgpID0+IG5ldyBQcm9qZWN0aWxlcy5EYXJ0KHsgY2hhcmdlczogJzFkNSArIDUnLCBidWNOYW1lOiAndW5jdXJzZWQnIH0pLFxuICAgICAgICBtb3JlOiAoKSA9PiBuZXcgUHJvamVjdGlsZXMuRGFydCh7IGNoYXJnZXM6ICc1ZDEwICsgMTAnLCBidWNOYW1lOiAndW5jdXJzZWQnIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBGb29kcy5SYXRpb24oeyBjaGFyZ2VzOiAnMWQ1ICsgNScsIGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBQb3Rpb25zLkhlYWxpbmcoeyBjaGFyZ2VzOiAnMWQzICsgMScsIGJ1Y05hbWU6ICdibGVzc2VkJywgc3RhcnRJZGVudGlmaWVkOiB0cnVlIH0pIH1cbiAgXVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG91cmlzdCBleHRlbmRzIFByb2Zlc3Npb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih0b3VyaXN0Q2ZnKTtcbiAgfVxufSIsIlxuaW1wb3J0IFByb2Zlc3Npb24gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcHJvZmVzc2lvbic7XG5cbmltcG9ydCAqIGFzIEZvb2RzIGZyb20gJy4uL2l0ZW1zL2Zvb2RzJztcbmltcG9ydCAqIGFzIFdlYXBvbnMgZnJvbSAnLi4vaXRlbXMvX3dlYXBvbnMnO1xuaW1wb3J0ICogYXMgVGhyZXNob2xkcyBmcm9tICcuLi8uLi9jb25zdGFudHMvc2tpbGwtdGhyZXNob2xkcyc7XG5pbXBvcnQgKiBhcyBUcmFpdHMgZnJvbSAnLi4vdHJhaXRzL19hbGwnO1xuXG5jb25zdCB2YWxreXJpZUNvbmZpZyA9IHtcbiAgaHAgIDogJzJkNScsXG4gIG1wICA6ICcwZDAnLFxuICBzdHIgOiAnMmQzJyxcbiAgY29uIDogJzFkNScsXG4gIGludCA6ICcxZDMnLFxuICBkZXggOiAnM2QyJyxcbiAgd2lzIDogJzFkMicsXG4gIGNoYSA6ICcxZDInLFxuICBsZXZlbFVwOiB7XG4gICAgaHAgIDogJzFkNCcsXG4gICAgbXAgIDogJzBkMCcsXG4gICAgc3RyIDogJzFkMicsXG4gICAgY29uIDogJzFkMicsXG4gICAgaW50IDogJzFkMiAtIDEnLFxuICAgIGRleCA6ICcxZDInLFxuICAgIHdpcyA6ICcxZDEnLFxuICAgIGNoYSA6ICcxZDIgLSAxJ1xuICB9LFxuICB0aXRsZXM6IFsnU3RyaXBsaW5nJywsICdTa2lybWlzaGVyJywsLCAnRmlnaHRlcicsLCwgJ01hbi1hdC1hcm1zJywsLCAnV2FycmlvcicsLCwgJ1N3YXNoYnVja2xlcicsLCwgJ0hlcm8nLCwsICdDaGFtcGlvbicsLCwgJ0xvcmQnXSxcbiAgdHJhaXRzOiBbVHJhaXRzLkljZVJlc2lzdGFuY2UoKSwgVHJhaXRzLlN0ZWFsdGgoeyBsZXZlbDogMiB9KSwgVHJhaXRzLkhhc3RlKHsgbGV2ZWw6IDMsIHJlcTogNyB9KV0sXG4gIHNraWxsQ2FwczogeyBiYXNoOiBUaHJlc2hvbGRzLkV4cGVydCwgc3RhYjogVGhyZXNob2xkcy5Ta2lsbGVkLCByYW5nZWQ6IFRocmVzaG9sZHMuRXhwZXJ0LCBzbWFzaDogVGhyZXNob2xkcy5FeHBlcnQsIHRocnVzdDogVGhyZXNob2xkcy5FeHBlcnQsIHNsYXNoOiBUaHJlc2hvbGRzLkV4cGVydCwgdW5hcm1lZDogVGhyZXNob2xkcy5FeHBlcnQgfSxcbiAgc3RhcnRpbmdJdGVtczogW1xuICAgIHsgaW5pdDogKCkgPT4gbmV3IFdlYXBvbnMuU3BlYXIoeyBidWNOYW1lOiAndW5jdXJzZWQnLCBlbmNoYW50bWVudDogMyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IFdlYXBvbnMuRGFnZ2VyKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJywgZW5jaGFudG1lbnQ6IDEgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBGb29kcy5SYXRpb24oeyBjaGFyZ2VzOiAnMWQzJywgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9XG4gIF1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZhbGt5cmllIGV4dGVuZHMgUHJvZmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHZhbGt5cmllQ29uZmlnKTtcbiAgfVxufSIsIlxuaW1wb3J0IFByb2Zlc3Npb24gZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcHJvZmVzc2lvbic7XG5cbmltcG9ydCBGYWN0aW9ucyBmcm9tICcuLi8uLi9jb25zdGFudHMvZmFjdGlvbnMnO1xuXG5pbXBvcnQgKiBhcyBGb29kcyBmcm9tICcuLi9pdGVtcy9mb29kcyc7XG5pbXBvcnQgKiBhcyBXZWFwb25zIGZyb20gJy4uL2l0ZW1zL193ZWFwb25zJztcbmltcG9ydCAqIGFzIFBvdGlvbnMgZnJvbSAnLi4vaXRlbXMvcG90aW9ucyc7XG5pbXBvcnQgKiBhcyBTcGVsbGJvb2tzIGZyb20gJy4uL2l0ZW1zL3NwZWxsYm9va3MnO1xuaW1wb3J0ICogYXMgUmFuZG9tIGZyb20gJy4uLy4uL2NvbnN0YW50cy9yYW5kb20nO1xuaW1wb3J0ICogYXMgVGhyZXNob2xkcyBmcm9tICcuLi8uLi9jb25zdGFudHMvc2tpbGwtdGhyZXNob2xkcyc7XG5cbmNvbnN0IHdpemFyZENmZyA9IHtcbiAgaHAgIDogJzFkMiArIDEnLFxuICBtcCAgOiAnMWQ1ICsgNScsXG4gIHN0ciA6ICcxZDInLFxuICBjb24gOiAnMWQyJyxcbiAgaW50IDogJzJkMyArIDEnLFxuICBkZXggOiAnMWQyIC0gMScsXG4gIHdpcyA6ICcxZDInLFxuICBjaGEgOiAnMWQzIC0gMScsXG4gIGxldmVsVXA6IHtcbiAgICBocCAgOiAnMWQyIC0gMScsXG4gICAgbXAgIDogJzFkNCArIDEnLFxuICAgIHN0ciA6ICcxZDIgLSAxJyxcbiAgICBjb24gOiAnMWQyIC0gMScsXG4gICAgaW50IDogJzFkMicsXG4gICAgZGV4IDogJzFkMiAtIDEnLFxuICAgIHdpcyA6ICcxZDEnLFxuICAgIGNoYSA6ICcxZDIgLSAxJ1xuICB9LFxuICByZWdlbkhwOiAyMCxcbiAgcmVnZW5NcDogLTMsXG4gIHRpdGxlczogWydFdm9rZXInLCwgJ0Nvbmp1cmVyJywsLCAnVGhhdW1hdHVyZ2UnLCwsICdNYWdpY2lhbicsLCwgJ0VuY2hhbnRyZXgnLCwsICdTb3JjZXJleCcsLCwgJ05lY3JvbWFuY2VyJywsLCAnV2l6YXJkJywsLCAnTWFnZSddLFxuICBza2lsbENhcHM6IHsgYmFzaDogVGhyZXNob2xkcy5Ta2lsbGVkLCBzdGFiOiBUaHJlc2hvbGRzLlNraWxsZWQsIGZvcmNlOiBUaHJlc2hvbGRzLkV4cGVydCB9LFxuICBhZGRGYWN0aW9uczogW0ZhY3Rpb25zLk1BR0lDXSxcbiAgc3RhcnRpbmdJdGVtczogW1xuICAgIHsgaW5pdDogKCkgPT4gUmFuZG9tLlJpbmcoeyBidWNOYW1lOiAndW5jdXJzZWQnIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBSYW5kb20uV2FuZCh7IGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfSxcbiAgICB7IGluaXQ6ICgpID0+IG5ldyBTcGVsbGJvb2tzLkZvcmNlQm9sdCh7IGJ1Y05hbWU6ICdibGVzc2VkJyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IFdlYXBvbnMuUXVhcnRlcnN0YWZmKHsgYnVjTmFtZTogJ3VuY3Vyc2VkJyB9KSB9LFxuICAgIHsgaW5pdDogKCkgPT4gbmV3IEZvb2RzLlJhdGlvbih7IGNoYXJnZXM6ICcxZDInLCBidWNOYW1lOiAndW5jdXJzZWQnIH0pIH0sXG4gICAgeyBpbml0OiAoKSA9PiBuZXcgUG90aW9ucy5IZWFsaW5nKHsgY2hhcmdlczogJzFkMicsIGJ1Y05hbWU6ICd1bmN1cnNlZCcgfSkgfVxuICBdXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXphcmQgZXh0ZW5kcyBQcm9mZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIod2l6YXJkQ2ZnKTtcbiAgfVxufSIsIlxuaW1wb3J0IENhbmluZSBmcm9tICcuL2NhbmluZSc7XG5pbXBvcnQgRGVtb24gZnJvbSAnLi9kZW1vbic7XG5pbXBvcnQgRWxlbWVudGFsIGZyb20gJy4vZWxlbWVudGFsJztcbmltcG9ydCBFbGYgZnJvbSAnLi9lbGYnO1xuaW1wb3J0IEdub21lIGZyb20gJy4vZ25vbWUnO1xuaW1wb3J0IEh1bWFuIGZyb20gJy4vaHVtYW4nO1xuaW1wb3J0IEluc2VjdCBmcm9tICcuL2luc2VjdCc7XG5pbXBvcnQgSmVsbHkgZnJvbSAnLi9qZWxseSc7XG5pbXBvcnQgS29ib2xkIGZyb20gJy4va29ib2xkJztcbmltcG9ydCBNYW50aWNvcmUgZnJvbSAnLi9tYW50aWNvcmUnO1xuaW1wb3J0IE9yYyBmcm9tICcuL29yYyc7XG5pbXBvcnQgUHNpb25pYyBmcm9tICcuL3BzaW9uaWMnO1xuaW1wb3J0IFB1ZGRpbmcgZnJvbSAnLi9wdWRkaW5nJztcbmltcG9ydCBSYXQgZnJvbSAnLi9yYXQnO1xuaW1wb3J0IExpemFyZCBmcm9tICcuL2xpemFyZCc7XG5pbXBvcnQgTGl6YXJkbWFuIGZyb20gJy4vbGl6YXJkbWFuJztcbmltcG9ydCBTbmFrZSBmcm9tICcuL3NuYWtlJztcbmltcG9ydCBTcGlkZXIgZnJvbSAnLi9zcGlkZXInO1xuaW1wb3J0IFNwb3JlIGZyb20gJy4vc3BvcmUnO1xuXG5leHBvcnQgZGVmYXVsdCB7IENhbmluZSwgRGVtb24sIEVsZW1lbnRhbCwgRWxmLCBHbm9tZSxcbiAgSHVtYW4sIEluc2VjdCwgSmVsbHksIEtvYm9sZCwgTGl6YXJkLCBMaXphcmRtYW4sIE1hbnRpY29yZSwgT3JjLCBQdWRkaW5nLCBQc2lvbmljLCBSYXQsXG4gIFNuYWtlLCBTcGlkZXIsIFNwb3JlIH07IiwiXG5pbXBvcnQgUmFjZSBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9yYWNlJztcbmltcG9ydCAqIGFzIEJlaGF2aW9ycyBmcm9tICcuLi9iZWhhdmlvcnMvX2FsbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEh1bWFub2lkIGV4dGVuZHMgUmFjZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBvcHRzLnN0YXRzID0gb3B0cy5zdGF0cyB8fCB7fTtcbiAgICBvcHRzLnN0YXRzLmFkZEJlaGF2aW9ycyA9IFtCZWhhdmlvcnMuSW50ZXJhY3RzKCksIEJlaGF2aW9ycy5QaWNrVXBJdGVtcygpLCBCZWhhdmlvcnMuRHJvcHNJdGVtcygpXTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufSIsIlxuaW1wb3J0IFJhY2UgZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcmFjZSc7XG5cbmNvbnN0IG9wdHMgPSB7IHN0YXRzOiB7IGRleDogMiwgc3RyOiAyLCBjb246IDEsIGludDogLTEsIHdpczogLTEgfSB9O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FuaW5lIGV4dGVuZHMgUmFjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59IiwiXG5pbXBvcnQgSHVtYW5vaWQgZnJvbSAnLi9faHVtYW5vaWQnO1xuaW1wb3J0ICogYXMgVHJhaXRzIGZyb20gJy4uL3RyYWl0cy9fYWxsJztcbmltcG9ydCAqIGFzIEF0dGFja3MgZnJvbSAnLi4vYXR0YWNrcy9fYWxsJztcblxuY29uc3QgYXR0YWNrUHJvcHMgPSB7XG4gIHJvbGw6ICcxZDMnLFxuICBzcGF3bkNoYW5jZTogMSxcbiAgc3Bhd246IHtcbiAgICB3YXRlckRlbW9uOiAxMDBcbiAgfVxufTtcblxuY29uc3Qgb3B0cyA9IHsgc3RhdHM6IHtcbiAgc3RyOiAtMiwgY29uOiAtMiwgZGV4OiAtMiwgaW50OiAtMiwgd2lzOiAtMiwgY2hhOiAtMiwgbHVrOiAtMixcbiAgdHJhaXRzOiBbVHJhaXRzLlBvaXNvblJlc2lzdGFuY2UoKSwgVHJhaXRzLkluZnJhdmlzaW9uKHsgbGV2ZWw6IDEwIH0pLCBUcmFpdHMuUHJvdGVjdGlvbih7IGxldmVsOiAxIH0pXSxcbiAgYXR0YWNrczogW0F0dGFja3MuVW5hcm1lZChhdHRhY2tQcm9wcyksIEF0dGFja3MuQml0ZShhdHRhY2tQcm9wcyksIEF0dGFja3MuQ2xhdyhhdHRhY2tQcm9wcyldXG59IH07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZW1vbiBleHRlbmRzIEh1bWFub2lkIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBSYWNlIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3JhY2UnO1xuXG5jb25zdCBvcHRzID0ge307XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50YWwgZXh0ZW5kcyBSYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBIdW1hbm9pZCBmcm9tICcuL19odW1hbm9pZCc7XG5pbXBvcnQgKiBhcyBUaHJlc2hvbGRzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9za2lsbC10aHJlc2hvbGRzJztcbmltcG9ydCAqIGFzIFRyYWl0cyBmcm9tICcuLi90cmFpdHMvX2FsbCc7XG5cbmNvbnN0IG9wdHMgPSB7IHN0YXRzOiB7IGludDogMiwgZGV4OiAyLCB3aXM6IDEsIHNpZ2h0OiAxLFxuICBza2lsbEJvbnVzOiB7IHNob3Q6IFRocmVzaG9sZHMuQmFzaWMsIHN0YWI6IFRocmVzaG9sZHMuQmFzaWMgfSxcbiAgdHJhaXRzOiBbVHJhaXRzLkluZnJhdmlzaW9uKHsgbGV2ZWw6IDMgfSldXG59IH07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGYgZXh0ZW5kcyBIdW1hbm9pZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59IiwiXG5pbXBvcnQgSHVtYW5vaWQgZnJvbSAnLi9faHVtYW5vaWQnO1xuaW1wb3J0ICogYXMgVGhyZXNob2xkcyBmcm9tICcuLi8uLi9jb25zdGFudHMvc2tpbGwtdGhyZXNob2xkcyc7XG5pbXBvcnQgKiBhcyBUcmFpdHMgZnJvbSAnLi4vdHJhaXRzL19hbGwnO1xuXG5jb25zdCBvcHRzID0geyBzdGF0czogeyBzdHI6IC0yLCBjb246IC0yLCBkZXg6IC0xLCBpbnQ6IDMsIHdpczogMywgY2hhOiAtMSwgc2lnaHQ6IDEsXG4gIHNraWxsQm9udXM6IHsgYmFzaDogVGhyZXNob2xkcy5CYXNpYywgc21hc2g6IFRocmVzaG9sZHMuQmFzaWMgfSxcbiAgdHJhaXRzOiBbVHJhaXRzLkluZnJhdmlzaW9uKHsgbGV2ZWw6IDIgfSldXG59IH07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHbm9tZSBleHRlbmRzIEh1bWFub2lkIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBIdW1hbm9pZCBmcm9tICcuL19odW1hbm9pZCc7XG5pbXBvcnQgKiBhcyBUaHJlc2hvbGRzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9za2lsbC10aHJlc2hvbGRzJztcblxuY29uc3Qgb3B0cyA9IHsgc3RhdHM6IHsgc3RyOiAxLCBjb246IDEsIGRleDogMSwgaW50OiAxLCB3aXM6IDEsIGNoYTogMSwgbHVrOiAxLCBzaWdodDogLTEsXG4gIHNraWxsQm9udXM6IHsgYmFzaWM6IFRocmVzaG9sZHMuQmFzaWMsIHNsYXNoOiBUaHJlc2hvbGRzLkJhc2ljLCBzbWFzaDogVGhyZXNob2xkcy5CYXNpYywgc3RhYjogVGhyZXNob2xkcy5CYXNpYywgdGhydXN0OiBUaHJlc2hvbGRzLkJhc2ljLCB1bmFybWVkOiBUaHJlc2hvbGRzLkJhc2ljIH1cbn0gfTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEh1bWFuIGV4dGVuZHMgSHVtYW5vaWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufSIsIlxuaW1wb3J0IFJhY2UgZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcmFjZSc7XG5cbmNvbnN0IG9wdHMgPSB7IHN0YXRzOiB7IGRleDogLTIsIHN0cjogLTIsIGNvbjogLTIgfSB9O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5zZWN0IGV4dGVuZHMgUmFjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59IiwiXG5pbXBvcnQgUmFjZSBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9yYWNlJztcblxuY29uc3Qgb3B0cyA9IHt9O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSmVsbHkgZXh0ZW5kcyBSYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBIdW1hbm9pZCBmcm9tICcuL19odW1hbm9pZCc7XG5pbXBvcnQgKiBhcyBUaHJlc2hvbGRzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9za2lsbC10aHJlc2hvbGRzJztcbmltcG9ydCAqIGFzIFRyYWl0cyBmcm9tICcuLi90cmFpdHMvX2FsbCc7XG5cbmNvbnN0IG9wdHMgPSB7IHN0YXRzOiB7IGRleDogMSwgc3RyOiAxLCBjb246IDEsIGludDogLTQsIHdpczogLTIsIHNpZ2h0OiAxLFxuICBza2lsbEJvbnVzOiB7IHNtYXNoOiBUaHJlc2hvbGRzLkJhc2ljLCBzdGFiOiBUaHJlc2hvbGRzLkJhc2ljLCB0aHJ1c3Q6IFRocmVzaG9sZHMuQmFzaWMgfSxcbiAgdHJhaXRzOiBbVHJhaXRzLkluZnJhdmlzaW9uKHsgbGV2ZWw6IDIgfSldXG59IH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtvYm9sZCBleHRlbmRzIEh1bWFub2lkIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBSYWNlIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3JhY2UnO1xuXG5jb25zdCBvcHRzID0geyBzbG90czogeyBoYW5kczogMCwgYm9keTogMSwgZmVldDogNCwgaGVhZHM6IDEsIG5lY2s6IDAsIHJpbmc6IDAsIGNsb2FrOiAwLCB3cmlzdDogMCB9LCBzdGF0czogeyBjb246IDEsIGludDogMSB9IH07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXphcmQgZXh0ZW5kcyBSYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBIdW1hbm9pZCBmcm9tICcuL19odW1hbm9pZCc7XG5pbXBvcnQgKiBhcyBUaHJlc2hvbGRzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9za2lsbC10aHJlc2hvbGRzJztcblxuY29uc3Qgb3B0cyA9IHsgc2xvdHM6IHsgaGFuZHM6IDMgfSwgc3RhdHM6IHsgZGV4OiAyLFxuICBza2lsbEJvbnVzOiB7IHNsYXNoOiBUaHJlc2hvbGRzLkJhc2ljLCBzdGFiOiBUaHJlc2hvbGRzLkJhc2ljLCB0aHJ1c3Q6IFRocmVzaG9sZHMuQmFzaWMgfVxufSB9O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl6YXJkbWFuIGV4dGVuZHMgSHVtYW5vaWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufSIsIlxuaW1wb3J0IFJhY2UgZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcmFjZSc7XG5cbmNvbnN0IG9wdHMgPSB7IHNsb3RzOiB7IGhhbmRzOiAwLCBib2R5OiAzLCBmZWV0OiAwLCBoZWFkOiAzLCBuZWNrOiAzLCByaW5nOiAwLCBjbG9hazogMCwgd3Jpc3Q6IDAgfSB9O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFudGljb3JlIGV4dGVuZHMgUmFjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG4iLCJcbmltcG9ydCBIdW1hbm9pZCBmcm9tICcuL19odW1hbm9pZCc7XG5pbXBvcnQgKiBhcyBUaHJlc2hvbGRzIGZyb20gJy4uLy4uL2NvbnN0YW50cy9za2lsbC10aHJlc2hvbGRzJztcbmltcG9ydCAqIGFzIFRyYWl0cyBmcm9tICcuLi90cmFpdHMvX2FsbCc7XG5cbmNvbnN0IG9wdHMgPSB7IHN0YXRzOiB7IGRleDogLTEsIHN0cjogMywgY29uOiAzLCBpbnQ6IC0zLCB3aXM6IC0yLCBzaWdodDogMSxcbiAgc2tpbGxCb251czogeyBzbWFzaDogVGhyZXNob2xkcy5Db21wZXRlbnQsIHVuYXJtZWQ6IFRocmVzaG9sZHMuQmFzaWMgfSxcbiAgdHJhaXRzOiBbVHJhaXRzLkluZnJhdmlzaW9uKHsgbGV2ZWw6IDIgfSldXG59IH07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcmMgZXh0ZW5kcyBIdW1hbm9pZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgSHVtYW5vaWQgZnJvbSAnLi9faHVtYW5vaWQnO1xuaW1wb3J0ICogYXMgVGhyZXNob2xkcyBmcm9tICcuLi8uLi9jb25zdGFudHMvc2tpbGwtdGhyZXNob2xkcyc7XG5cbmNvbnN0IG9wdHMgPSB7IHN0YXRzOiB7IGRleDogLTUsIHN0cjogLTUsIGNvbjogLTMsIGludDogNSwgd2lzOiA1IH0sXG4gIHNraWxsQm9udXM6IHsgZm9yY2U6IFRocmVzaG9sZHMuQ29tcGV0ZW50IH1cbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQc2lvbmljIGV4dGVuZHMgSHVtYW5vaWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxuICBjYW5FcXVpcChvd25lciwgaXRlbSkge1xuICAgIHJldHVybiBpdGVtICYmICFfLmNvbnRhaW5zKFsnd2VhcG9uJywgJ2hhbmRzJ10sIGl0ZW0uZ2V0UGFyZW50VHlwZSgpKSAmJiBzdXBlci5jYW5FcXVpcChvd25lciwgaXRlbSk7XG4gIH1cbn1cbiIsIlxuaW1wb3J0IFJhY2UgZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcmFjZSc7XG5cbmNvbnN0IG9wdHMgPSB7IHN0YXRzOiB7IGNvbjogNSwgaW50OiAtNSwgd2lzOiAtNSwgZGV4OiAtNSwgc3RyOiAtMSwgc2lnaHQ6IC0xIH0gfTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1ZGRpbmcgZXh0ZW5kcyBSYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBSYWNlIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3JhY2UnO1xuXG5jb25zdCBvcHRzID0geyBzdGF0czogeyBjb246IC0zLCBpbnQ6IC0zLCB3aXM6IC0zLCBkZXg6IC0zLCBzdHI6IC0zLCBjaGE6IC0zLCBsdWs6IC0zLCBzaWdodDogLTEgfSB9O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmF0IGV4dGVuZHMgUmFjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59IiwiXG5pbXBvcnQgUmFjZSBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy9yYWNlJztcblxuY29uc3Qgb3B0cyA9IHsgc2xvdHM6IHsgaGFuZHM6IDAsIGJvZHk6IDEsIGZlZXQ6IDAsIGhlYWRzOiAxLCBuZWNrOiAxLCByaW5nOiAxLCBjbG9hazogMCwgd3Jpc3Q6IDAgfSB9O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU25ha2UgZXh0ZW5kcyBSYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn0iLCJcbmltcG9ydCBSYWNlIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3JhY2UnO1xuXG5jb25zdCBvcHRzID0geyBzbG90czogeyBoYW5kczogMCwgYm9keTogMSwgZmVldDogOCwgaGVhZHM6IDEsIG5lY2s6IDEsIHJpbmc6IDAsIGNsb2FrOiAwLCB3cmlzdDogMCB9IH07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGlkZXIgZXh0ZW5kcyBSYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbn1cbiIsIlxuaW1wb3J0IFJhY2UgZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvcmFjZSc7XG5cbmNvbnN0IG9wdHMgPSB7IH07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcG9yZSBleHRlbmRzIFJhY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufSIsIlxuaW1wb3J0IFRyYWl0IGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3RyYWl0JztcblxuY2xhc3MgSW5mcmF2aXNpb25UcmFpdCBleHRlbmRzIFRyYWl0IHtcbiAgSW5mcmF2aXNpb24oKSB7IHJldHVybiB0aGlzLmxldmVsOyB9XG59XG5cbmV4cG9ydCBjb25zdCBJbmZyYXZpc2lvbiA9IChvcHRzKSA9PiBuZXcgSW5mcmF2aXNpb25UcmFpdChvcHRzKTtcblxuY2xhc3MgUHJvdGVjdGlvblRyYWl0IGV4dGVuZHMgVHJhaXQge1xuICBQcm90ZWN0aW9uKCkgeyByZXR1cm4gdGhpcy5sZXZlbDsgfVxufVxuXG5leHBvcnQgY29uc3QgUHJvdGVjdGlvbiA9IChvcHRzKSA9PiBuZXcgUHJvdGVjdGlvblRyYWl0KG9wdHMpO1xuXG5jbGFzcyBIYXN0ZVRyYWl0IGV4dGVuZHMgVHJhaXQge1xuICBIYXN0ZSgpIHsgcmV0dXJuIHRoaXMubGV2ZWwgKiAyNTsgfVxufVxuXG5leHBvcnQgY29uc3QgSGFzdGUgPSAob3B0cykgPT4gbmV3IEhhc3RlVHJhaXQob3B0cyk7XG5cbmNsYXNzIFRlbGVwYXRoeVRyYWl0IGV4dGVuZHMgVHJhaXQge1xuICBUZWxlcGF0aHkoKSB7IHJldHVybiB0aGlzLmxldmVsICogNTsgfVxufVxuXG5leHBvcnQgY29uc3QgVGVsZXBhdGh5ID0gKG9wdHMpID0+IG5ldyBUZWxlcGF0aHlUcmFpdChvcHRzKTtcblxuY2xhc3MgQ2xhaXJ2b3lhbmNlVHJhaXQgZXh0ZW5kcyBUcmFpdCB7XG4gIENsYWlydm95YW5jZSgpIHsgcmV0dXJuIHRoaXMubGV2ZWwgKiA1OyB9XG59XG5cbmV4cG9ydCBjb25zdCBDbGFpcnZveWFuY2UgPSAob3B0cykgPT4gbmV3IENsYWlydm95YW5jZVRyYWl0KG9wdHMpO1xuXG5jbGFzcyBXYXJuaW5nVHJhaXQgZXh0ZW5kcyBUcmFpdCB7XG4gIFdhcm5pbmcoKSB7IHJldHVybiB0aGlzLmxldmVsICogNTsgfVxufVxuXG5leHBvcnQgY29uc3QgV2FybmluZyA9IChvcHRzKSA9PiBuZXcgV2FybmluZ1RyYWl0KG9wdHMpO1xuXG5jbGFzcyBJbnZpc2libGVUcmFpdCBleHRlbmRzIFRyYWl0IHtcbiAgSW52aXNpYmxlKCkgeyByZXR1cm4gdGhpcy5sZXZlbDsgfVxufVxuXG5leHBvcnQgY29uc3QgSW52aXNpYmxlID0gKG9wdHMpID0+IG5ldyBJbnZpc2libGVUcmFpdChvcHRzKTtcblxuY2xhc3MgU2VlSW52aXNpYmxlVHJhaXQgZXh0ZW5kcyBUcmFpdCB7XG4gIFNlZUludmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMubGV2ZWw7IH1cbn1cblxuZXhwb3J0IGNvbnN0IFNlZUludmlzaWJsZSA9IChvcHRzKSA9PiBuZXcgU2VlSW52aXNpYmxlVHJhaXQob3B0cyk7XG5cbmNsYXNzIFN0ZWFsdGhUcmFpdCBleHRlbmRzIFRyYWl0IHtcbiAgU3RlYWx0aCgpIHsgcmV0dXJuIHRoaXMubGV2ZWwgKiA1OyB9XG59XG5cbmV4cG9ydCBjb25zdCBTdGVhbHRoID0gKG9wdHMpID0+IG5ldyBTdGVhbHRoVHJhaXQob3B0cyk7XG5cbmNsYXNzIFBvaXNvblJlc2lzdGFuY2VUcmFpdCBleHRlbmRzIFRyYWl0IHtcbiAgUG9pc29uUmVzaXN0YW5jZSgpIHsgcmV0dXJuIDE7IH1cbn1cblxuZXhwb3J0IGNvbnN0IFBvaXNvblJlc2lzdGFuY2UgPSAoKSA9PiBuZXcgUG9pc29uUmVzaXN0YW5jZVRyYWl0KCk7XG5cbmNsYXNzIEZpcmVSZXNpc3RhbmNlVHJhaXQgZXh0ZW5kcyBUcmFpdCB7XG4gIEZpcmVSZXNpc3RhbmNlKCkgeyByZXR1cm4gMTsgfVxufVxuXG5leHBvcnQgY29uc3QgRmlyZVJlc2lzdGFuY2UgPSAoKSA9PiBuZXcgRmlyZVJlc2lzdGFuY2VUcmFpdCgpO1xuXG5jbGFzcyBTaG9ja1Jlc2lzdGFuY2VUcmFpdCBleHRlbmRzIFRyYWl0IHtcbiAgU2hvY2tSZXNpc3RhbmNlKCkgeyByZXR1cm4gMTsgfVxufVxuXG5leHBvcnQgY29uc3QgU2hvY2tSZXNpc3RhbmNlID0gKCkgPT4gbmV3IFNob2NrUmVzaXN0YW5jZVRyYWl0KCk7XG5cbmNsYXNzIEljZVJlc2lzdGFuY2VUcmFpdCBleHRlbmRzIFRyYWl0IHtcbiAgSWNlUmVzaXN0YW5jZSgpIHsgcmV0dXJuIDE7IH1cbn1cblxuZXhwb3J0IGNvbnN0IEljZVJlc2lzdGFuY2UgPSAoKSA9PiBuZXcgSWNlUmVzaXN0YW5jZVRyYWl0KCk7XG5cbmNsYXNzIEFjaWRSZXNpc3RhbmNlVHJhaXQgZXh0ZW5kcyBUcmFpdCB7XG4gIEFjaWRSZXNpc3RhbmNlKCkgeyByZXR1cm4gMTsgfVxufVxuXG5leHBvcnQgY29uc3QgQWNpZFJlc2lzdGFuY2UgPSAoKSA9PiBuZXcgQWNpZFJlc2lzdGFuY2VUcmFpdCgpOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWJzdHJhY3Qge1xuICBkaXN0QmV0d2Vlbih0YXJnZXQpIHtcbiAgICBjb25zdCBhID0gdGFyZ2V0LnggLSB0aGlzLng7XG4gICAgY29uc3QgYiA9IHRhcmdldC55IC0gdGhpcy55O1xuICAgIHJldHVybiBNYXRoLnNxcnQoYSphICsgYipiKTtcbiAgfVxuXG4gIGRpc3RCZXR3ZWVuWFkoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmRpc3RCZXR3ZWVuKHsgeCwgeSB9KTtcbiAgfVxuXG4gIGdldENhbm9uTmFtZSgpIHtcbiAgICByZXR1cm4gXy5zdGFydENhc2UodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBnZXRQYXJlbnRUeXBlKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKS5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBjbGVhblVwKCkge31cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUk9UIGZyb20gJ3JvdC1qcyc7XG5pbXBvcnQgZGljZSBmcm9tICdkaWNlLmpzJztcbmltcG9ydCBSb2xsIGZyb20gJy4uL2xpYi9kaWNlLXJvbGxlcic7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uL2luaXQvZ2FtZXN0YXRlJztcbmltcG9ydCBNZXNzYWdlUXVldWUsIHsgTWVzc2FnZVR5cGVzIH0gZnJvbSAnLi4vZGlzcGxheS9tZXNzYWdlLWhhbmRsZXInO1xuaW1wb3J0IEFic3RyYWN0IGZyb20gJy4vYWJzdHJhY3QnO1xuaW1wb3J0IEdseXBoIGZyb20gJy4vZ2x5cGgnO1xuaW1wb3J0IExvZyBmcm9tICcuLi9saWIvbG9nZ2VyJztcbmltcG9ydCB7IFdlaWdodGVkRXh0ZW5zaW9uIH0gZnJvbSAnLi4vbGliL3JvdC1leHRlbnNpb25zJztcbmltcG9ydCBNb25zdGVyU3Bhd25lciBmcm9tICcuLi93b3JsZGdlbi9tb25zdGVyLXNwYXduZXInO1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vY29uc3RhbnRzL3NldHRpbmdzJztcblxuZXhwb3J0IGNsYXNzIFByb2plY3RpbGUge1xuICBjb25zdHJ1Y3RvcihnbHlwaCkge1xuICAgIHRoaXMuZ2x5cGggPSBnbHlwaDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXR0YWNrIGV4dGVuZHMgQWJzdHJhY3Qge1xuICBcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgXy5leHRlbmQodGhpcywgeyByb2xsOiAnMWQ0JywgdG9IaXQ6ICcwZDAnLCByYW5nZTogMSwgY2hhbmNlOiAxMDAgfSwgb3B0cyk7XG4gICAgaWYodGhpcy5pbml0KSB0aGlzLmluaXQoKTtcbiAgfVxuICBcbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIGRpY2Uuc3RhdGlzdGljcyh0aGlzLnJvbGwpLm1lYW4gKyBkaWNlLnN0YXRpc3RpY3ModGhpcy50b0hpdCkgKyB0aGlzLnJhbmdlICogMztcbiAgfVxuICBcbiAgaW5SYW5nZShvd25lciwgdGFyZ2V0KSB7IFxuICAgIHJldHVybiBvd25lci5kaXN0QmV0d2Vlbih0YXJnZXQpIDw9IHRoaXMucmFuZ2U7XG4gIH1cbiAgXG4gIHBvc3NpYmxlVGFyZ2V0cyhvd25lcikge1xuICAgIGNvbnN0IHBvc3NpYmxlVGFyZ2V0cyA9IFtdO1xuICAgIEdhbWVTdGF0ZS53b3JsZC5mb3Zbb3duZXIuel0uY29tcHV0ZShcbiAgICAgIG93bmVyLngsIG93bmVyLnksIHRoaXMucmFuZ2UsIFxuICAgICAgKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgZW50aXR5ID0gR2FtZVN0YXRlLndvcmxkLmdldEVudGl0eSh4LCB5LCBvd25lci56KTtcbiAgICAgICAgaWYoIWVudGl0eSkgcmV0dXJuO1xuICAgICAgICAvLyBubyB0YXJnZXQsIGNhbid0IGF0dGFjayB0YXJnZXQsIG9yIHRoZSB0YXJnZXQgaXMgaW52aXNpYmxlIGFuZCBoYXNuJ3QgYXR0YWNrZWQgeW91IHlldFxuICAgICAgICBjb25zdCBjYW5Pd25lclNlZSA9IG93bmVyLmNhblNlZShlbnRpdHkpO1xuICAgICAgICBjb25zdCBzaWdodENoZWNrID0gY2FuT3duZXJTZWUgfHwgKCFjYW5Pd25lclNlZSAmJiBvd25lci5fYXR0YWNrZWRCeSAhPT0gZW50aXR5KTtcbiAgICAgICAgaWYoIW93bmVyLmNhbkF0dGFjayhlbnRpdHkpIHx8ICFzaWdodENoZWNrKSByZXR1cm47XG4gICAgICAgIHBvc3NpYmxlVGFyZ2V0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcG9zc2libGVUYXJnZXRzO1xuICB9XG4gIFxuICBjYW5Vc2Uob3duZXIpIHsgXG4gICAgaWYoUk9ULlJORy5nZXRQZXJjZW50YWdlKCkgPiB0aGlzLmNoYW5jZSkgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnBvc3NpYmxlVGFyZ2V0cyhvd25lcikubGVuZ3RoID4gMDsgXG4gIH1cbiAgXG4gIGNhbkhpdChvd25lciwgdGFyZ2V0LCBhdHRhY2tOdW0pIHtcbiAgICBpZihvd25lci5ocC5hdE1pbigpKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaGl0Um9sbCA9IFJvbGwoYDFkJHsyMCArIGF0dGFja051bX1gKTsgLy8gc3Vic2VxdWVudCBhdHRhY2tzIGFyZSBsZXNzIGxpa2VseSB0byBoaXRcbiAgICBjb25zdCB0YXJnZXRBQyA9IHRhcmdldC5nZXRBQygpO1xuICAgIGNvbnN0IG15VG9IaXRCb251cyA9IChSb2xsKHRoaXMudG9IaXQpIC0gb3duZXIuZ2V0VG9IaXQodGFyZ2V0KSAtIG93bmVyLmdldFNraWxsTGV2ZWxWYWx1ZSh0aGlzLmdldFR5cGUoKSkgLSAodGhpcy5faXRlbVJlZiA/IHRoaXMuX2l0ZW1SZWYuYnVjLTEgOiAwKSk7IC8vIGN1cnNlZDogLTIsIHVuY3Vyc2VkOiAwLCBibGVzc2VkOiArMVxuICAgIGxldCB0YXJnZXRBQ1JvbGwgPSAwO1xuXG4gICAgaWYodGFyZ2V0QUMgPj0gMCkge1xuICAgICAgdGFyZ2V0QUNSb2xsID0gdGFyZ2V0QUMgKyBvd25lci5sZXZlbCAtIG15VG9IaXRCb251cztcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0QUNSb2xsID0gU2V0dGluZ3MuZ2FtZS5iYXNlQUMgKyBST1QuUk5HLmdldFVuaWZvcm1JbnQodGFyZ2V0QUMsIC0xKSArIG93bmVyLmxldmVsIC0gbXlUb0hpdEJvbnVzO1xuICAgIH1cbiAgICByZXR1cm4gaGl0Um9sbCA8IHRhcmdldEFDUm9sbDtcbiAgfVxuICBcbiAgYW5pbWF0ZShvd25lciwgdGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIGlmKCF0aGlzLmdseXBoKSByZXR1cm4gY2FsbGJhY2soKTtcblxuICAgIGNvbnN0IGVuZ2luZSA9IEdhbWVTdGF0ZS5nYW1lLmVuZ2luZTtcbiAgICBlbmdpbmUubG9jaygpO1xuXG4gICAgY29uc3QgY2FuUGFzcyA9ICh4LCB5KSA9PiB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBHYW1lU3RhdGUud29ybGQuZ2V0RW50aXR5KHgsIHksIG93bmVyLnopO1xuICAgICAgY29uc3QgaXNBdHRhY2thYmxlID0gZW50aXR5ICYmIG93bmVyLmNhbkF0dGFjayhlbnRpdHkpO1xuICAgICAgY29uc3QgaXNNZSA9IG93bmVyLnggPT09IHggJiYgb3duZXIueSA9PT0geTtcbiAgICAgIHJldHVybiBHYW1lU3RhdGUud29ybGQuaXNUaWxlUGFzc2FibGUoeCwgeSwgb3duZXIueiwgZmFsc2UpIHx8IGlzTWUgfHwgaXNBdHRhY2thYmxlO1xuICAgIH07XG4gICAgY29uc3QgYXN0YXIgPSBuZXcgUk9ULlBhdGguQVN0YXIodGFyZ2V0LngsIHRhcmdldC55LCBjYW5QYXNzLCB7IHRvcG9sb2d5OiA4IH0pO1xuXG4gICAgbGV0IHBhdGggPSBbXTtcbiAgICBjb25zdCBwYXRoQ2FsbGJhY2sgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBwYXRoLnB1c2goeyB4LCB5IH0pO1xuICAgIH07XG4gICAgXG4gICAgYXN0YXIuY29tcHV0ZShvd25lci54LCBvd25lci55LCBwYXRoQ2FsbGJhY2spO1xuXG4gICAgcGF0aC5zaGlmdCgpO1xuXG4gICAgaWYoIXBhdGgubGVuZ3RoKSBwYXRoID0gW3sgeDogb3duZXIueCwgeTogb3duZXIueSB9XTtcblxuICAgIGNvbnN0IHByb2plY3RpbGUgPSBuZXcgUHJvamVjdGlsZSh0aGlzLmdseXBoKTtcblxuICAgIHByb2plY3RpbGUueiA9IG93bmVyLno7XG4gICAgcHJvamVjdGlsZS54ID0gcGF0aFswXS54O1xuICAgIHByb2plY3RpbGUueSA9IHBhdGhbMF0ueTtcblxuICAgIEdhbWVTdGF0ZS5wcm9qZWN0aWxlcy5wdXNoKHByb2plY3RpbGUpO1xuXG4gICAgY29uc3QgbW92ZVRvID0gKHgsIHkpID0+IHtcbiAgICAgIHByb2plY3RpbGUueCA9IHg7XG4gICAgICBwcm9qZWN0aWxlLnkgPSB5O1xuICAgICAgR2FtZVN0YXRlLmdhbWUucmVmcmVzaCgpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaW5hbGl6ZSA9ICgpID0+IHtcbiAgICAgIEdhbWVTdGF0ZS5wcm9qZWN0aWxlcyA9IF8ud2l0aG91dChHYW1lU3RhdGUucHJvamVjdGlsZXMsIHByb2plY3RpbGUpO1xuICAgICAgR2FtZVN0YXRlLmdhbWUucmVmcmVzaCgpO1xuICAgICAgY2FsbGJhY2soKTsgLy8gdGhpcyBoYXMgdG8gYmUgY2FsbGVkIGZpcnN0IHRvIHByZXZlbnQgcmFjZSBjb25kaXRpb25zIHdpdGggdW5sb2NraW5nIHRoZSBlbmdpbmUgYW5kIGRvdWJsZS1keWluZ1xuICAgICAgZW5naW5lLnVubG9jaygpO1xuICAgIH07XG4gICAgXG4gICAgbW92ZVRvKHByb2plY3RpbGUueCwgcHJvamVjdGlsZS55KTtcbiAgICBcbiAgICBfLmVhY2gocGF0aCwgZnVuY3Rpb24oc3RlcCwgaSkge1xuICAgICAgY29uc3QgY3VyU3RlcCA9IHN0ZXA7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBtb3ZlVG8oY3VyU3RlcC54LCBjdXJTdGVwLnkpO1xuICAgICAgICBpZihpID09PSBwYXRoLmxlbmd0aCAtIDEpIGZpbmFsaXplKCk7XG4gICAgICB9LCBpKihTZXR0aW5ncy5nYW1lLnR1cm5EZWxheS81KSk7XG4gICAgfSk7XG4gIH1cbiAgXG4gIHVzZShvd25lciwgdGFyZ2V0LCBhdHRhY2tOdW0pIHtcbiAgICB0YXJnZXQuX2F0dGFja2VkQnkgPSBvd25lcjtcbiAgICB0aGlzLnRyeUhpdChvd25lciwgdGFyZ2V0LCBhdHRhY2tOdW0pO1xuICB9XG4gIFxuICB0cnlIaXQob3duZXIsIHRhcmdldCwgYXR0YWNrTnVtKSB7XG4gICAgaWYoIXRhcmdldCkgcmV0dXJuO1xuICAgIGlmKHRoaXMuX2l0ZW1SZWYpIHRoaXMuX2l0ZW1SZWYudXNlKG93bmVyKTtcbiAgICBpZighdGhpcy5jYW5IaXQob3duZXIsIHRhcmdldCwgYXR0YWNrTnVtKSkge1xuICAgICAgY29uc3QgZXh0cmEgPSB0aGlzLm1pc3NDYWxsYmFjayhvd25lciwgdGFyZ2V0KTtcbiAgICAgIE1lc3NhZ2VRdWV1ZS5hZGQoeyBtZXNzYWdlOiB0aGlzLm1pc3NTdHJpbmcob3duZXIsIHRhcmdldCwgZXh0cmEpLCB0eXBlOiBNZXNzYWdlVHlwZXMuQ09NQkFUIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGUob3duZXIsIHRhcmdldCwgKCkgPT4gdGhpcy5oaXQob3duZXIsIHRhcmdldCkpO1xuICB9XG5cbiAgY2FsY0RhbWFnZShvd25lciwgdGFyZ2V0KSB7XG5cbiAgICAvLyB5b3UgY2FuIHJlc2lzdCBzb21lIGVsZW1lbnRhbCBkYW1hZ2UhXG4gICAgaWYodGhpcy5lbGVtZW50ICYmIHRhcmdldC5oYXNUcmFpdChgJHt0aGlzLmVsZW1lbnR9UmVzaXN0YW5jZWApKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBsZXQgZGFtYWdlQm9vc3QgPSAwO1xuICAgIGlmKHRoaXMuX2l0ZW1SZWYpIHtcbiAgICAgIGRhbWFnZUJvb3N0ICs9IHRoaXMuX2l0ZW1SZWYuZW5jaGFudG1lbnQ7XG4gICAgICBpZih0aGlzLl9pdGVtUmVmLl90ZW1wQXR0YWNrQm9vc3QpIGRhbWFnZUJvb3N0ICs9IFJvbGwodGhpcy5faXRlbVJlZi5fdGVtcEF0dGFja0Jvb3N0KTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gUm9sbCh0aGlzLnJvbGwpICsgb3duZXIuY2FsY1N0YXRCb251cygnc3RyJykgKyBkYW1hZ2VCb29zdCArIG93bmVyLmdldEJvbnVzRGFtYWdlKHRhcmdldCk7XG5cbiAgICBpZighXy5pc051bWJlcih2YWwpKSB7XG4gICAgICBMb2coJ0F0dGFjaycsIGBJbnZhbGlkIGF0dGFjayByb2xsXG4gICAgICBSb2xsOiAke3RoaXMucm9sbH1cbiAgICAgIFNUUjogJHtvd25lci5jYWxjU3RhdEJvbnVzKCdzdHInKX1cbiAgICAgIEJvb3N0OiAke2RhbWFnZUJvb3N0fVxuICAgICAgUmVmOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuX2l0ZW1SZWYpfVxuICAgICAgQm9udXM6ICR7b3duZXIuZ2V0Qm9udXNEYW1hZ2UodGFyZ2V0KX1cbiAgICAgIE15Qm9udXNEYW1hZ2U6ICR7b3duZXIuYm9udXNEYW1hZ2V9ICgke3R5cGVvZiBvd25lci5ib251c0RhbWFnZX0pICR7b3duZXIucm9sbE9yQWRkKG93bmVyLmJvbnVzRGFtYWdlKX1cbiAgICAgIE15UHJvZmVzc2lvbkJvbnVzRGFtYWdlOiAke293bmVyLnByb2Zlc3Npb25JbnN0LmJvbnVzRGFtYWdlfSAoJHt0eXBlb2Ygb3duZXIucHJvZmVzc2lvbkluc3QuYm9udXNEYW1hZ2V9KSAke293bmVyLnJvbGxPckFkZChvd25lci5wcm9mZXNzaW9uSW5zdC5ib251c0RhbWFnZSl9XG4gICAgICBNeVJhY2VCb251c0RhbWFnZTogJHtvd25lci5yYWNlSW5zdC5ib251c0RhbWFnZX0gKCR7dHlwZW9mIG93bmVyLnJhY2VJbnN0LmJvbnVzRGFtYWdlfSkgJHtvd25lci5yb2xsT3JBZGQob3duZXIucmFjZUluc3QuYm9udXNEYW1hZ2UpfVxuICAgICAgTXlUcmFpdFZhbHVlOiAke293bmVyLmdldFRyYWl0VmFsdWUoJ2JvbnVzRGFtYWdlJyl9XG4gICAgICBNeUZ1cnk6ICR7b3duZXIuZ2V0VHJhaXRWc09wcG9uZW50KHRhcmdldCwgJ0Z1cnknKX0gKCR7dHlwZW9mIG93bmVyLmdldFRyYWl0VnNPcHBvbmVudCh0YXJnZXQsICdGdXJ5Jyl9KVxuICAgICAgYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIFxuICBoaXQob3duZXIsIHRhcmdldCkge1xuICAgIGNvbnN0IGRhbWFnZSA9IHRoaXMuY2FsY0RhbWFnZShvd25lciwgdGFyZ2V0KTtcbiAgICBpZihkYW1hZ2UgPD0gMCkge1xuICAgICAgY29uc3QgZXh0cmFCbG9ja0RhdGEgPSB0aGlzLmJsb2NrQ2FsbGJhY2sob3duZXIsIHRhcmdldCk7XG4gICAgICBNZXNzYWdlUXVldWUuYWRkKHsgbWVzc2FnZTogdGhpcy5ibG9ja1N0cmluZyhvd25lciwgdGFyZ2V0LCBleHRyYUJsb2NrRGF0YSksIHR5cGU6IE1lc3NhZ2VUeXBlcy5DT01CQVQgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhID0gdGhpcy5oaXRDYWxsYmFjayhvd25lciwgdGFyZ2V0LCBkYW1hZ2UpO1xuICAgIE1lc3NhZ2VRdWV1ZS5hZGQoeyBtZXNzYWdlOiB0aGlzLmhpdFN0cmluZyhvd25lciwgdGFyZ2V0LCBkYW1hZ2UsIGV4dHJhKSwgdHlwZTogTWVzc2FnZVR5cGVzLkNPTUJBVCB9KTtcbiAgICB0YXJnZXQudGFrZURhbWFnZShkYW1hZ2UsIG93bmVyKTtcbiAgICB0aGlzLmFmdGVySGl0Q2FsbGJhY2sob3duZXIsIHRhcmdldCk7XG4gIH1cbiAgXG4gIGhpdFN0cmluZyhvd25lciwgdGFyZ2V0LCBkYW1hZ2UpIHsgcmV0dXJuIGAke293bmVyLm5hbWV9IGhpdCAke3RhcmdldC5uYW1lfSBmb3IgJHtkYW1hZ2V9IGRhbWFnZSFgOyB9XG4gIGhpdENhbGxiYWNrKG93bmVyKSB7XG4gICAgb3duZXIuYnJlYWtDb25kdWN0KCdwYWNpZmlzdCcpO1xuXG4gICAgLy8gVE9ETyB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSBhIGJlaGF2aW9yXG4gICAgaWYodGhpcy5zcGF3biAmJiBST1QuUk5HLmdldFBlcmNlbnRhZ2UoKSA8PSB0aGlzLnNwYXduQ2hhbmNlKSB7XG4gICAgICBjb25zdCBzcGF3bk1lID0gV2VpZ2h0ZWRFeHRlbnNpb24odGhpcy5zcGF3bikua2V5O1xuICAgICAgY29uc3QgdmFsaWRUaWxlID0gXy5zYW1wbGUoR2FtZVN0YXRlLndvcmxkLmdldFZhbGlkVGlsZXNJblJhbmdlKG93bmVyLngsIG93bmVyLnksIG93bmVyLnosIDEsICh0aWxlKSA9PiBHYW1lU3RhdGUud29ybGQuaXNUaWxlRW1wdHkodGlsZS54LCB0aWxlLnksIHRpbGUueikpKTtcbiAgICAgIGlmKCF2YWxpZFRpbGUpIHJldHVybjtcbiAgICAgIE1vbnN0ZXJTcGF3bmVyLnNwYXduU2luZ2xlKHNwYXduTWUsIHZhbGlkVGlsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJPVC5STkcuZ2V0UGVyY2VudGFnZSgpIDw9IHRoaXMucGVyY2VudDtcbiAgfVxuICBcbiAgYmxvY2tTdHJpbmcob3duZXIsIHRhcmdldCkgeyByZXR1cm4gYCR7dGFyZ2V0Lm5hbWV9IGJsb2NrZWQgJHtvd25lci5uYW1lfSdzIGF0dGFjayFgOyB9XG4gIGJsb2NrQ2FsbGJhY2soKSB7fVxuICBcbiAgbWlzc1N0cmluZyhvd25lciwgdGFyZ2V0KSB7IHJldHVybiBgJHtvd25lci5uYW1lfSBtaXNzZWQgJHt0YXJnZXQubmFtZX0hYDsgfVxuICBtaXNzQ2FsbGJhY2soKSB7fVxuXG4gIGFmdGVySGl0Q2FsbGJhY2soKSB7fVxuXG4gIGNsZWFuVXAoKSB7XG4gICAgdGhpcy5faXRlbVJlZiA9IG51bGw7XG4gIH1cbiAgXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBtZSA9IF8ub21pdCh0aGlzLCBbJ19pdGVtUmVmJ10pO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNraWxsZWRBdHRhY2sgZXh0ZW5kcyBBdHRhY2sge1xuICBoaXRDYWxsYmFjayhvd25lcikge1xuICAgIHN1cGVyLmhpdENhbGxiYWNrKG93bmVyKTtcbiAgICBpZih0aGlzLmdldFR5cGUoKSAhPT0gJ1VuYXJtZWQnKSB7XG4gICAgICBvd25lci5icmVha0NvbmR1Y3QoJ3dpZWxkZWRXZWFwb24nKTtcbiAgICB9XG4gICAgb3duZXIuaW5jcmVhc2VTa2lsbCh0aGlzLmdldFR5cGUoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlYWdlbnQgZXh0ZW5kcyBTa2lsbGVkQXR0YWNrIHtcblxuICBpc1ZhbGlkUmFuZ2VkQXR0YWNrKG93bmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1SZWYgJiYgdGhpcy5faXRlbVJlZi5jYW5Vc2Uob3duZXIpICYmIHRoaXMuX2l0ZW1SZWYuaGFzVmFsaWRBbW1vKG93bmVyKTtcbiAgfVxuXG4gIHVzZShvd25lciwgdGFyZ2V0LCBhdHRhY2tOdW0pIHtcbiAgICBpZih0aGlzLmlzVmFsaWRSYW5nZWRBdHRhY2sob3duZXIpKSByZXR1cm4gdGhpcy5faXRlbVJlZi51c2Uob3duZXIpO1xuICAgIHJldHVybiBzdXBlci51c2Uob3duZXIsIHRhcmdldCwgYXR0YWNrTnVtKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWFnaWMgZXh0ZW5kcyBTa2lsbGVkQXR0YWNrIHtcbiAgaW5pdCgpIHtcbiAgICB0aGlzLmdseXBoID0gbmV3IEdseXBoKCcpJywgJyNmMDAnKTtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuLy8gYmVoYXZpb3JzIGFyZSBmdW5jdGlvbmFsaXR5IHRoYXQgY2FzY2FkZSwgaWUsIGEgbW9uc3RlciBjb3VsZCBoYXZlIDEwIGJlaGF2aW9ycyB0aGF0IG92ZXJyaWRlIGRpZSgpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKHByaW9yaXR5KSB7XG4gICAgaWYoIV8uaXNOdW1iZXIocHJpb3JpdHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBzaG91bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSBwcmlvcml0eS5gKTtcbiAgICB9XG4gICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICB9XG59XG5cbi8vIHByaW9yaXRpZXMgZGV0ZXJtaW5lIHRoZSBvcmRlcmluZyBvZiBiZWhhdmlvciBleGVjdXRpb25cbmV4cG9ydCBjb25zdCBQcmlvcml0eSA9IHtcbiAgQUxXQVlTOiAwLFxuICBTVFVOOiAxLFxuICBIRUFMOiAyLFxuICBERUZFTlNFOiAzLFxuICBJTlRFUkFDVDogNCxcbiAgVEFSR0VUOiA1LFxuICBNT1ZFOiA2LFxuICBERUZFUjogMTBcbn07IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJPVCBmcm9tICdyb3QtanMnO1xuaW1wb3J0IFJvbGwgZnJvbSAnLi4vbGliL2RpY2Utcm9sbGVyJztcbmltcG9ydCBFbnRpdHkgZnJvbSAnLi9lbnRpdHknO1xuaW1wb3J0IE51bWJlclJhbmdlIGZyb20gJy4uL2xpYi9udW1iZXItcmFuZ2UnO1xuaW1wb3J0IFByb2Zlc3Npb25zIGZyb20gJy4uL2NvbnRlbnQvcHJvZmVzc2lvbnMvX2FsbCc7XG5pbXBvcnQgUmFjZXMgZnJvbSAnLi4vY29udGVudC9yYWNlcy9fYWxsJztcbmltcG9ydCAqIGFzIEJlaGF2aW9ycyBmcm9tICcuLi9jb250ZW50L2JlaGF2aW9ycy9fYWxsJztcbmltcG9ydCAqIGFzIFRyYWl0cyBmcm9tICcuLi9jb250ZW50L3RyYWl0cy9fYWxsJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vaW5pdC9nYW1lc3RhdGUnO1xuaW1wb3J0IEF0dGFja3MgZnJvbSAnLi4vY29udGVudC9hdHRhY2tzL19hbGwnO1xuaW1wb3J0IE1lc3NhZ2VRdWV1ZSwgeyBNZXNzYWdlVHlwZXMgfSBmcm9tICcuLi9kaXNwbGF5L21lc3NhZ2UtaGFuZGxlcic7XG5cbmltcG9ydCBsb2FkVmFsdWUgZnJvbSAnLi4vbGliL3ZhbHVlLWFzc2lnbic7XG5pbXBvcnQgY2FsYyBmcm9tICcuLi9saWIvZGlyZWN0aW9uYWwtcHJvYmFiaWxpdHknO1xuaW1wb3J0IExvZyBmcm9tICcuLi9saWIvbG9nZ2VyJztcbmltcG9ydCBJZCBmcm9tICcuLi9saWIvZ2VuLWlkJztcblxuaW1wb3J0IFNraWxsVGhyZXNob2xkcywgKiBhcyBUaHJlc2hvbGRzIGZyb20gJy4uL2NvbnN0YW50cy9za2lsbC10aHJlc2hvbGRzJztcbmltcG9ydCB7IFNraWxsZWRBdHRhY2sgfSBmcm9tICcuLi9kZWZpbml0aW9ucy9hdHRhY2snO1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vY29uc3RhbnRzL3NldHRpbmdzJztcbmltcG9ydCBOYW1lcyBmcm9tICcuLi9jb250ZW50L2ZsYXZvci9uYW1lcyc7XG5cbmNvbnN0IGRlZmF1bHRCZWhhdmlvcnMgPSBbQmVoYXZpb3JzLlJlZ2VuZXJhdGVzSHAoKSwgQmVoYXZpb3JzLlJlZ2VuZXJhdGVzTXAoKV07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYXJhY3RlciBleHRlbmRzIEVudGl0eSB7XG5cbiAgY29uc3RydWN0b3IoZ2x5cGgsIHgsIHksIHosIG9wdHMgPSB7IHN0YXRzOiB7fSwgYXR0cmlidXRlczoge30sIHRlbXBsYXRlOiB7fSB9KSB7XG4gICAgc3VwZXIoZ2x5cGgsIHgsIHksIHopO1xuXG4gICAgdGhpcy5fX2lkID0gSWQoKTtcblxuICAgIHRoaXMuZmFjdGlvbnMgPSBbXTtcbiAgICB0aGlzLmFudGlGYWN0aW9ucyA9IFtdO1xuICAgIHRoaXMudHJhaXRzID0gW107XG4gICAgdGhpcy50cmFpdEhhc2ggPSB7fTtcbiAgICB0aGlzLnNraWxscyA9IHt9O1xuICAgIHRoaXMuYnJva2VuQ29uZHVjdCA9IHt9O1xuXG4gICAgdGhpcy5jdXJyZW50VHVybiA9IDA7XG5cbiAgICBfLmV4dGVuZCh0aGlzLCBTZXR0aW5ncy5nYW1lLmRlZmF1bHRTdGF0cy5hdHRyaWJ1dGVzLCBvcHRzLmF0dHJpYnV0ZXMsIGxvYWRWYWx1ZSk7XG4gICAgXy5leHRlbmQodGhpcywgU2V0dGluZ3MuZ2FtZS5kZWZhdWx0U3RhdHMuc3RhdHMsIG9wdHMuc3RhdHMpO1xuXG4gICAgdGhpcy5iZWhhdmlvcnMucHVzaCguLi5kZWZhdWx0QmVoYXZpb3JzKTtcblxuICAgIHRoaXMubG9hZEZyb21UZW1wbGF0ZShvcHRzLnRlbXBsYXRlKTtcblxuICAgIHRoaXMucHJvZmVzc2lvbkluc3QgPSBuZXcgUHJvZmVzc2lvbnNbdGhpcy5wcm9mZXNzaW9uXSgpO1xuICAgIGNvbnN0IFtwcm9mSHAsIHByb2ZNcF0gPSBbdGhpcy5wcm9mZXNzaW9uSW5zdC5ocCwgdGhpcy5wcm9mZXNzaW9uSW5zdC5tcF07XG4gICAgdGhpcy5ocCA9IG5ldyBOdW1iZXJSYW5nZSgwLCB0aGlzLnNwYXduSHArcHJvZkhwLCB0aGlzLnNwYXduSHArcHJvZkhwKTtcbiAgICB0aGlzLm1wID0gbmV3IE51bWJlclJhbmdlKDAsIHRoaXMuc3Bhd25NcCtwcm9mTXAsIHRoaXMuc3Bhd25NcCtwcm9mTXApO1xuICAgIHRoaXMueHAgPSBuZXcgTnVtYmVyUmFuZ2UoMCwgMCwgdGhpcy5jYWxjTGV2ZWxYcCh0aGlzLmxldmVsKSk7XG4gICAgdGhpcy5mYWN0aW9ucy5wdXNoKC4uLnRoaXMucHJvZmVzc2lvbkluc3QuYWRkRmFjdGlvbnMpO1xuICAgIHRoaXMuYmVoYXZpb3JzLnB1c2goLi4udGhpcy5wcm9mZXNzaW9uSW5zdC5hZGRCZWhhdmlvcnMpO1xuXG4gICAgdGhpcy5yYWNlSW5zdCA9IG5ldyBSYWNlc1t0aGlzLnJhY2VdKCk7XG4gICAgdGhpcy5mYWN0aW9ucy5wdXNoKC4uLnRoaXMucmFjZUluc3QuYWRkRmFjdGlvbnMpO1xuICAgIHRoaXMuYmVoYXZpb3JzLnB1c2goLi4udGhpcy5yYWNlSW5zdC5hZGRCZWhhdmlvcnMpO1xuXG4gICAgaWYob3B0cy5hZGRGYWN0aW9ucykgdGhpcy5mYWN0aW9ucy5wdXNoKC4uLm9wdHMuYWRkRmFjdGlvbnMpO1xuICAgIGlmKG9wdHMuYWRkQW50aUZhY3Rpb25zKSB0aGlzLmFudGlGYWN0aW9ucy5wdXNoKC4uLm9wdHMuYWRkQW50aUZhY3Rpb25zKTtcblxuICAgIHRoaXMuc29ydEJlaGF2aW9ycygpO1xuXG4gICAgdGhpcy5pbnZlbnRvcnkgPSBbXTtcbiAgICB0aGlzLmVxdWlwbWVudCA9IHt9O1xuXG4gICAgR2FtZVN0YXRlLndvcmxkLm1vdmVFbnRpdHkodGhpcywgdGhpcy54LCB0aGlzLnksIHRoaXMueik7XG5cbiAgICBHYW1lU3RhdGUuZ2FtZS5zY2hlZHVsZXIuYWRkKHRoaXMsIHRydWUpO1xuXG4gICAgdGhpcy5kb0JlaGF2aW9yKCdzcGF3bicpO1xuXG4gICAgdGhpcy5iZWhhdmlvcnMgPSBfLnVuaXEodGhpcy5iZWhhdmlvcnMsIGIgPT4gYi5jb25zdHJ1Y3Rvci5uYW1lKTtcblxuICAgIHRoaXMubG9hZFN0YXJ0aW5nRXF1aXBtZW50KCk7XG4gICAgdGhpcy5sb2FkU3RhcnRpbmdUcmFpdHMob3B0cy50ZW1wbGF0ZSk7XG4gICAgdGhpcy5sb2FkU3RhcnRpbmdTa2lsbHMoKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBsZXZlbHVwIGJvbnVzZXNcbiAgICBmb3IobGV0IGk9MTsgaTx0aGlzLmxldmVsOyBpKyspIHtcbiAgICAgIHRoaXMubGV2ZWx1cFN0YXRCb29zdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlZ2lvbiBTdGF0aWMgZnVuY3Rpb25zXG4gIGNhbGNMZXZlbFhwKGxldmVsKSB7XG4gICAgcmV0dXJuIDIwICogTWF0aC5wb3coMiwgbGV2ZWwpO1xuICB9XG5cbiAgcm9sbE9yQWRkKHZhbCkge1xuICAgIHZhbCA9IF8uaXNTdHJpbmcodmFsKSA/IFJvbGwodmFsKSA6IHZhbDtcbiAgICByZXR1cm4gIXZhbCB8fCBfLmlzTmFOKHZhbCkgfHwgIV8uaXNOdW1iZXIodmFsKSA/IDAgOiB2YWw7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFRyYWl0IGZ1bmN0aW9uc1xuICBnZXRUcmFpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhaXRzLmNvbmNhdCh0aGlzLnJhY2VJbnN0LnRyYWl0cykuY29uY2F0KHRoaXMucHJvZmVzc2lvbkluc3QudHJhaXRzKS5jb25jYXQoXy5mbGF0dGVuKF8udmFsdWVzKHRoaXMuZXF1aXBtZW50KSkpO1xuICB9XG5cbiAgaGFzVHJhaXQocHJvcGVydHlOYW1lKSB7XG4gICAgaWYodGhpcy50cmFpdEhhc2hbcHJvcGVydHlOYW1lXSkgcmV0dXJuIHRoaXMudHJhaXRIYXNoW3Byb3BlcnR5TmFtZV07XG4gICAgcmV0dXJuIF8uY29udGFpbnMoXy5wbHVjayh0aGlzLmdldFRyYWl0cygpLCAnY29uc3RydWN0b3IubmFtZScpLCBgJHtwcm9wZXJ0eU5hbWV9VHJhaXRgKTtcbiAgfVxuXG4gIGdldFRyYWl0VmFsdWUocHJvcGVydHksIGRlZmF1bHRWYWwgPSAwKSB7XG4gICAgaWYodGhpcy50cmFpdEhhc2hbcHJvcGVydHldKSByZXR1cm4gdGhpcy50cmFpdEhhc2hbcHJvcGVydHldO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLmdldFRyYWl0cygpO1xuICAgIGNvbnN0IHZhbHVlID0gXy5yZWR1Y2UocHJvcGVydGllcywgKChwcmV2LCBwcm9wKSA9PiBwcmV2ICsgKHByb3BbcHJvcGVydHldICYmIHByb3AuY2FuVXNlKHRoaXMpID8gdGhpcy5yb2xsT3JBZGQocHJvcFtwcm9wZXJ0eV0oKSkgOiBkZWZhdWx0VmFsKSksIGRlZmF1bHRWYWwpO1xuICAgIHRoaXMudHJhaXRIYXNoW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGFkZFRyYWl0KHByb3BlcnR5KSB7XG4gICAgdGhpcy50cmFpdHMucHVzaChwcm9wZXJ0eSk7XG4gICAgdGhpcy5mbHVzaFRyYWl0cyhwcm9wZXJ0eS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfVxuXG4gIHJlbW92ZVRyYWl0KHByb3BlcnR5KSB7XG4gICAgdGhpcy50cmFpdHMgPSBfLndpdGhvdXQodGhpcy50cmFpdHMsIHByb3BlcnR5KTtcbiAgICB0aGlzLmZsdXNoVHJhaXRzKHByb3BlcnR5LmNvbnN0cnVjdG9yLm5hbWUpO1xuICB9XG5cbiAgZmx1c2hUcmFpdHMoa2V5KSB7XG4gICAgaWYoa2V5KSByZXR1cm4gZGVsZXRlIHRoaXMudHJhaXRIYXNoW2tleV07XG4gICAgdGhpcy50cmFpdEhhc2ggPSB7fTtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gU2tpbGwtcmVsYXRlZCBmdW5jdGlvbnNcbiAgaW5jcmVhc2VTa2lsbCh0eXBlKSB7XG4gICAgaWYoIXRoaXMuc2tpbGxzW3R5cGVdKSByZXR1cm47XG4gICAgdGhpcy5za2lsbHNbdHlwZV0uYWRkKDEpO1xuICB9XG5cbiAgZ2V0U2tpbGxMZXZlbCh0eXBlKSB7XG4gICAgaWYoIXRoaXMuc2tpbGxzW3R5cGVdKSByZXR1cm47XG4gICAgY29uc3QgY3VyTnVtID0gdGhpcy5za2lsbHNbdHlwZV0uY3VyO1xuICAgIGNvbnN0IGxldmVsID0gXy5yZWplY3QoU2tpbGxUaHJlc2hvbGRzLCB0aHJlc2hvbGQgPT4gdGhyZXNob2xkLm1heCA8IGN1ck51bSlbMF07XG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG5cbiAgZ2V0U2tpbGxMZXZlbFZhbHVlKHR5cGUpIHtcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuZ2V0U2tpbGxMZXZlbCh0eXBlKTtcbiAgICByZXR1cm4gbGV2ZWwgPyBUaHJlc2hvbGRzW2xldmVsLm5hbWVdIDogMDtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gTG9hZGluZyBmdW5jdGlvbnMgKHNraWxscywgZXF1aXBtZW50KVxuICBsb2FkRnJvbVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgaWYoIXRlbXBsYXRlKSByZXR1cm47XG4gICAgdGVtcGxhdGUgPSBfLmNsb25lKHRlbXBsYXRlKTtcbiAgICBpZighdGVtcGxhdGUucHJvZmVzc2lvbikgdGVtcGxhdGUucHJvZmVzc2lvbiA9IF8uc2FtcGxlKEdhbWVTdGF0ZS51bmxvY2tlZC5wcm9mZXNzaW9uKSB8fCAnVG91cmlzdCc7XG4gICAgaWYoIXRlbXBsYXRlLnJhY2UpIHRlbXBsYXRlLnJhY2UgPSBfLnNhbXBsZShHYW1lU3RhdGUudW5sb2NrZWQucmFjZSkgfHwgJ0h1bWFuJztcbiAgICBpZighdGVtcGxhdGUuYWxpZ24pIHRlbXBsYXRlLmFsaWduID0gXy5yYW5kb20oLTIwMCwgMjAwKTtcbiAgICBpZighdGVtcGxhdGUuZ2VuZGVyKSB0ZW1wbGF0ZS5nZW5kZXIgPSBfLnNhbXBsZShbJ01hbGUnLCAnRmVtYWxlJ10pO1xuICAgIGlmKCF0ZW1wbGF0ZS5uYW1lKSB0ZW1wbGF0ZS5uYW1lID0gXy5zYW1wbGUoTmFtZXMpO1xuICAgIGlmKCF0ZW1wbGF0ZS5jb2xvcikgdGVtcGxhdGUuY29sb3IgPSAnI2ZmZic7XG4gICAgaWYoIXRlbXBsYXRlLmFpKSB0ZW1wbGF0ZS5haSA9ICdXYW5kZXInO1xuXG4gICAgdGhpcy5nbHlwaC5mZyA9IHRlbXBsYXRlLmNvbG9yO1xuXG4gICAgXy5leHRlbmQodGhpcywgdGVtcGxhdGUpO1xuICB9XG5cbiAgbG9hZFN0YXJ0aW5nVHJhaXRzKHRlbXBsYXRlKSB7XG4gICAgaWYoIXRlbXBsYXRlIHx8ICF0ZW1wbGF0ZS50cmFpdCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgdXRpbGl0eSwgYnVmZiB9ID0gdGVtcGxhdGUudHJhaXQ7XG4gICAgbGV0IHsgZ3JlYXRlciwgbGVzc2VyIH0gPSB0ZW1wbGF0ZS50cmFpdDtcblxuICAgIGlmKGdyZWF0ZXIpIHtcbiAgICAgIGdyZWF0ZXIgPSBncmVhdGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aGlzW2dyZWF0ZXJdICs9IDM7XG4gICAgfVxuICAgIGlmKGxlc3Nlcikge1xuICAgICAgbGVzc2VyID0gbGVzc2VyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aGlzW2xlc3Nlcl0gKz0gMTtcbiAgICB9XG4gICAgaWYodXRpbGl0eSkgdGhpcy5hZGRUcmFpdChUcmFpdHNbdXRpbGl0eV0oeyBsZXZlbDogMSB9KSk7XG4gICAgaWYoYnVmZikgdGhpcy5oYW5kbGVTdGFydGluZ0J1ZmYoYnVmZik7XG4gIH1cblxuICBoYW5kbGVTdGFydGluZ0J1ZmYoYnVmZikge1xuICAgIGNvbnN0IGFjdHMgPSB7XG4gICAgICAnQ2hhcmdlZCBHZWFyJzogKCkgPT4gXy5lYWNoKHRoaXMuaW52ZW50b3J5LCBpdGVtID0+IGl0ZW0uY2hhcmdlcyA/IGl0ZW0uY2hhcmdlcyArPSAzIDogbnVsbCksXG4gICAgICAnRW5jaGFudGVkIEdlYXInOiAoKSA9PiBfLmVhY2goXy5mbGF0dGVuKF8udmFsdWVzKHRoaXMuZXF1aXBtZW50KSksIGl0ZW0gPT4gaXRlbS5lbmNoYW50bWVudCA/IGl0ZW0uZW5jaGFudG1lbnQgKz0gMSA6IGl0ZW0uZW5jaGFudG1lbnQgPSAxKSxcbiAgICAgICdIaWdoZXIgTGV2ZWwnOiAoKSA9PiB0aGlzLmxldmVsICs9IDJcbiAgICB9O1xuICAgIGlmKGFjdHNbYnVmZl0pIGFjdHNbYnVmZl0oKTtcbiAgfVxuXG4gIGxvYWRTdGFydGluZ1NraWxscygpIHtcbiAgICBjb25zdCBza2lsbENhcHMgPSB0aGlzLnByb2Zlc3Npb25JbnN0LnNraWxsQ2FwcztcbiAgICBjb25zdCBza2lsbEJvbnVzID0gdGhpcy5yYWNlSW5zdC5za2lsbEJvbnVzO1xuICAgIGNvbnN0IGRlZmF1bHRMZXZlbCA9IFRocmVzaG9sZHMuQmFzaWM7XG4gICAgXy5lYWNoKF8udmFsdWVzKEF0dGFja3MpLCAoYXRrKSA9PiB7XG4gICAgICBpZighKGF0ay5yZWFsLnByb3RvdHlwZSBpbnN0YW5jZW9mIFNraWxsZWRBdHRhY2spKSByZXR1cm47XG4gICAgICBjb25zdCBhdGtOYW1lID0gYXRrLnJlYWwubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbGV0IG1heExldmVsID0gZGVmYXVsdExldmVsICsgKHNraWxsQ2Fwc1thdGtOYW1lXSB8fCAwKTtcbiAgICAgIG1heExldmVsID0gTWF0aC5taW4obWF4TGV2ZWwsIFRocmVzaG9sZHMuTGVnZW5kYXJ5KTtcbiAgICAgIGxldCBsZXZlbCA9IHNraWxsQm9udXNbYXRrTmFtZV0gfHwgMDtcbiAgICAgIGlmKHRoaXMudHJhaXQgJiYgdGhpcy50cmFpdC5idWZmID09PSAnUHJvZmljaWVudCcpIHtcbiAgICAgICAgbGV2ZWwgKz0gMjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2tpbGxzW2F0a05hbWVdID0gbmV3IE51bWJlclJhbmdlKDAsIFNraWxsVGhyZXNob2xkc1tsZXZlbF0ubWF4LCBTa2lsbFRocmVzaG9sZHNbbWF4TGV2ZWxdLm1heCk7XG4gICAgfSk7XG4gIH1cblxuICBsb2FkU3RhcnRpbmdFcXVpcG1lbnQobGlzdCA9IHRoaXMucHJvZmVzc2lvbkluc3Quc3RhcnRpbmdJdGVtcykge1xuICAgIGlmKCFsaXN0KSByZXR1cm47XG4gICAgXy5lYWNoKGxpc3QsIChpdGVtKSA9PiB7XG4gICAgICBpZihpdGVtLnByb2JhYmlsaXR5ICYmIFJPVC5STkcuZ2V0UGVyY2VudGFnZSgpID4gaXRlbS5wcm9iYWJpbGl0eSkgcmV0dXJuO1xuXG4gICAgICBsZXQgaW5zdCA9IG51bGw7XG4gICAgICBpZihpdGVtLmNob2ljZXMpIHtcbiAgICAgICAgY29uc3QgY2hvaWNlID0gUk9ULlJORy5nZXRXZWlnaHRlZFZhbHVlKGl0ZW0uY2hvaWNlcyk7XG4gICAgICAgIGluc3QgPSBpdGVtLmNob2ljZXNJbml0W2Nob2ljZV0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QgPSBpdGVtLmluaXQoKTtcbiAgICAgIH1cblxuICAgICAgaWYoIV8uaXNBcnJheShpbnN0KSkge1xuICAgICAgICBpbnN0ID0gW2luc3RdO1xuICAgICAgfVxuXG4gICAgICBfLmVhY2goaW5zdCwgaXRlbSA9PiB0aGlzLmFkZFRvSW52ZW50b3J5KGl0ZW0pKTtcbiAgICB9KTtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gSW52ZW50b3J5IGZ1bmN0aW9ucyAoc3RhY2tpbmcsIGFkZCwgcmVtb3ZlLCBldGMpXG4gIHRyeVRvU3RhY2soaXRlbSkge1xuICAgIGlmKCFpdGVtLmNhblN0YWNrKSByZXR1cm47XG4gICAgbGV0IGRpZFN0YWNrID0gZmFsc2U7XG4gICAgXy5lYWNoKHRoaXMuaW52ZW50b3J5LCAodGVzdEl0ZW0pID0+IHtcbiAgICAgIGlmKGRpZFN0YWNrKSByZXR1cm47XG5cbiAgICAgIGlmKHRlc3RJdGVtLm5hbWUgIT09IGl0ZW0ubmFtZSB8fFxuICAgICAgICAgdGVzdEl0ZW0uYnVjICE9PSBpdGVtLmJ1YyB8fFxuICAgICAgICAgdGVzdEl0ZW0uZW5jaGFudG1lbnQgIT09IGl0ZW0uZW5jaGFudG1lbnQpIHJldHVybjtcblxuICAgICAgaWYoIXRlc3RJdGVtLmNoYXJnZXMpIHRlc3RJdGVtLmNoYXJnZXMgPSAxO1xuXG4gICAgICB0ZXN0SXRlbS5jaGFyZ2VzICs9IGl0ZW0uY2hhcmdlcyA/IGl0ZW0uY2hhcmdlcyA6IDE7XG4gICAgICBkaWRTdGFjayA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRpZFN0YWNrO1xuICB9XG5cbiAgaGFzSW5JbnZlbnRvcnkoaXRlbVByb3RvKSB7XG4gICAgcmV0dXJuIF8uZmluZCh0aGlzLmludmVudG9yeSwgKGl0ZW0pID0+IGl0ZW0uZ2V0VHlwZSgpID09PSBpdGVtUHJvdG8ubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIGRyb3BJdGVtKGl0ZW0pIHtcbiAgICBpZih0aGlzLmlzRXF1aXBwZWQoaXRlbSkpIHtcbiAgICAgIHRoaXMudW5lcXVpcChpdGVtKTtcbiAgICB9XG4gICAgaXRlbS5fY2FuUGlja1VwVHVybiA9IHRoaXMuY3VycmVudFR1cm4gKyA1O1xuICAgIHRoaXMucmVtb3ZlRnJvbUludmVudG9yeShpdGVtKTtcbiAgICBHYW1lU3RhdGUud29ybGQubW92ZUl0ZW0oaXRlbSwgdGhpcy54LCB0aGlzLnksIHRoaXMueik7XG4gIH1cblxuICBhZGRUb0ludmVudG9yeShpdGVtKSB7XG4gICAgaWYoaXRlbS5nb2xkVmFsdWUpIHtcbiAgICAgIHRoaXMuZ29sZCArPSBpdGVtLmdvbGRWYWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYodGhpcy50cnlUb1N0YWNrKGl0ZW0pKSByZXR1cm47XG4gICAgaWYodGhpcy50cnlFcXVpcChpdGVtKSkgcmV0dXJuO1xuICAgIHRoaXMuaW52ZW50b3J5LnB1c2goaXRlbSk7XG4gIH1cblxuICByZW1vdmVGcm9tSW52ZW50b3J5KGl0ZW0pIHtcbiAgICB0aGlzLmludmVudG9yeSA9IF8ud2l0aG91dCh0aGlzLmludmVudG9yeSwgaXRlbSk7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIEVxdWlwLXJlbGF0ZWQgKHNsb3QtY2hlY2tpbmcsIGVxdWlwLCB1bmVxdWlwLCBldGMpXG4gIGlzRXF1aXBwZWQoaXRlbSkge1xuICAgIGNvbnN0IHNsb3QgPSBpdGVtLmdldFBhcmVudFR5cGUoKTtcbiAgICByZXR1cm4gXy5jb250YWlucyh0aGlzLmVxdWlwbWVudFtzbG90XSwgaXRlbSk7XG4gIH1cblxuICBzbG90c1Rha2VuKHNsb3QpIHtcbiAgICBpZighdGhpcy5lcXVpcG1lbnRbc2xvdF0pIHJldHVybiAwO1xuICAgIHJldHVybiBfLnJlZHVjZSh0aGlzLmVxdWlwbWVudFtzbG90XSwgKChwcmV2LCBpdGVtKSA9PiBwcmV2ICsgaXRlbS5zbG90c1Rha2VuKSwgMCk7XG4gIH1cblxuICBjYW5FcXVpcChpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMucmFjZUluc3QuY2FuRXF1aXAodGhpcywgaXRlbSk7XG4gIH1cblxuICBlcXVpcChpdGVtKSB7XG4gICAgY29uc3Qgc2xvdCA9IGl0ZW0uZ2V0UGFyZW50VHlwZSgpO1xuICAgIGlmKCF0aGlzLmVxdWlwbWVudFtzbG90XSkgdGhpcy5lcXVpcG1lbnRbc2xvdF0gPSBbXTtcbiAgICB0aGlzLmVxdWlwbWVudFtzbG90XS5wdXNoKGl0ZW0pO1xuICAgIHRoaXMuYnJlYWtDb25kdWN0KCdzdHViYm9ybicpO1xuICAgIGlmKHRoaXMuZ2V0UGFyZW50VHlwZSgpICE9PSAnaGFuZHMnKSB7XG4gICAgICB0aGlzLmJyZWFrQ29uZHVjdCgnbnVkaXN0Jyk7XG4gICAgfVxuICAgIGlmKGl0ZW0uZXF1aXApIGl0ZW0uZXF1aXAodGhpcyk7XG4gICAgdGhpcy5mbHVzaFRyYWl0cygpO1xuICB9XG5cbiAgZ2V0V29yc2VJdGVtc1RoYW4oaXRlbSkge1xuICAgIGNvbnN0IHNsb3QgPSBpdGVtLmdldFBhcmVudFR5cGUoKTtcbiAgICByZXR1cm4gXyh0aGlzLmVxdWlwbWVudFtzbG90XSkuZmlsdGVyKChlcXVpcCkgPT4gZXF1aXAudmFsdWUoKSA8IGl0ZW0udmFsdWUoKSAmJiBpdGVtLmJ1Y05hbWUgIT09ICdjdXJzZWQnKTtcbiAgfVxuXG4gIHNob3VsZEVxdWlwKGl0ZW0pIHtcbiAgICBjb25zdCBzbG90ID0gaXRlbS5nZXRQYXJlbnRUeXBlKCk7XG4gICAgaWYodGhpcy5yYWNlSW5zdC5zbG90c1tzbG90XSA+IDAgJiYgdGhpcy5jYW5FcXVpcChpdGVtKSkgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgbG93ZXJJdGVtcyA9IHRoaXMuZ2V0V29yc2VJdGVtc1RoYW4oaXRlbSk7XG4gICAgcmV0dXJuIGxvd2VySXRlbXMubGVuZ3RoIDwgaXRlbS5zbG90c1Rha2VuO1xuICB9XG5cbiAgdHJ5RXF1aXAoaXRlbSkge1xuICAgIGlmKCF0aGlzLmNhbkVxdWlwKGl0ZW0pIHx8ICF0aGlzLnNob3VsZEVxdWlwKGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgd29yc2VJdGVtcyA9IHRoaXMuZ2V0V29yc2VJdGVtc1RoYW4oaXRlbSk7XG4gICAgaWYod29yc2VJdGVtcy5sZW5ndGggPCBpdGVtLnNsb3RzVGFrZW4pIHJldHVybiBmYWxzZTsgLy8gY3Vyc2VkIGl0ZW1zXG5cbiAgICBpZih3b3JzZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvcihsZXQgaT0wOyBpPGl0ZW0uc2xvdHNUYWtlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMudW5lcXVpcCh3b3JzZUl0ZW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lcXVpcChpdGVtKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHVuZXF1aXAoaXRlbSkge1xuICAgIGlmKGl0ZW0uaXNDdXJzZWQoKSkgcmV0dXJuO1xuICAgIGNvbnN0IHNsb3QgPSBpdGVtLmdldFBhcmVudFR5cGUoKTtcbiAgICB0aGlzLmVxdWlwbWVudFtzbG90XSA9IF8ud2l0aG91dCh0aGlzLmVxdWlwbWVudFtzbG90XSwgaXRlbSk7XG4gICAgdGhpcy5pbnZlbnRvcnkucHVzaChpdGVtKTtcbiAgICBpZihpdGVtLnVuZXF1aXApIGl0ZW0udW5lcXVpcCh0aGlzKTtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gQmVoYXZpb3ItcmVsYXRlZCBmdW5jdGlvbnNcbiAgZG9CZWhhdmlvcihhY3Rpb24sIGFyZ3MgPSBbXSkge1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBfLmVhY2godGhpcy5iZWhhdmlvcnMsIChiZWhhdmlvcikgPT4geyBpZihiZWhhdmlvclthY3Rpb25dKSByZXR1cm4gYmVoYXZpb3JbYWN0aW9uXS5hcHBseShiZWhhdmlvciwgYXJncyk7IH0pOyAvLyByZXR1cm5pbmcgZmFsc2UgZnJvbSBhbnkgYmVoYXZpb3Igd2lsbCBjYW5jZWwgc3Vic2VxdWVudCBvbmVzXG4gIH1cblxuICBzb3J0QmVoYXZpb3JzKCkge1xuICAgIHRoaXMuYmVoYXZpb3JzID0gXy5zb3J0QnkodGhpcy5iZWhhdmlvcnMsICdwcmlvcml0eScpO1xuICB9XG5cbiAgYWRkQmVoYXZpb3IoYmVoYXZpb3IpIHtcbiAgICB0aGlzLmJlaGF2aW9ycy5wdXNoKGJlaGF2aW9yKTtcbiAgICB0aGlzLnNvcnRCZWhhdmlvcnMoKTtcbiAgfVxuXG4gIGhhc0JlaGF2aW9yKGJlaGF2aW9yKSB7XG4gICAgaWYoIV8uY29udGFpbnMoYmVoYXZpb3IsICdCZWhhdmlvcicpKSBiZWhhdmlvciA9IGAke2JlaGF2aW9yfUJlaGF2aW9yYDtcbiAgICByZXR1cm4gXy5jb250YWlucyhfLnBsdWNrKHRoaXMuYmVoYXZpb3JzLCAnY29uc3RydWN0b3IubmFtZScpLCBiZWhhdmlvcik7XG4gIH1cblxuICBhZGRVbmlxdWVCZWhhdmlvcihiZWhhdmlvcikge1xuICAgIGlmKHRoaXMuaGFzQmVoYXZpb3IoYmVoYXZpb3IuY29uc3RydWN0b3IubmFtZSkpIHJldHVybjtcbiAgICB0aGlzLmFkZEJlaGF2aW9yKGJlaGF2aW9yKTtcbiAgfVxuXG4gIHJlbW92ZUJlaGF2aW9yKGJlaGF2aW9yKSB7XG4gICAgdGhpcy5iZWhhdmlvcnMgPSBfLndpdGhvdXQodGhpcy5iZWhhdmlvcnMsIGJlaGF2aW9yKTtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gRGFtYWdlIC8gZHlpbmcgLyB0YXJnZXR0aW5nXG4gIHRha2VEYW1hZ2UoZGFtYWdlLCBhdHRhY2tlcikge1xuICAgIHRoaXMuaHAuc3ViKGRhbWFnZSk7XG4gICAgdGhpcy5kb0JlaGF2aW9yKCd0YWtlRGFtYWdlJywgW2F0dGFja2VyXSk7XG4gICAgaWYodGhpcy5ocC5hdE1pbigpKSB7XG4gICAgICB0aGlzLmRpZShhdHRhY2tlcik7XG4gICAgfVxuICB9XG5cbiAgZGllKGtpbGxlcikge1xuICAgIHRoaXMuaHAudG9NaW4oKTtcbiAgICBpZih0aGlzLmtpbGxlck5hbWUpIHtcbiAgICAgIExvZygnUGxheWVyJywgYEVycm9yOiBBdHRlbXB0aW5nIHRvIGRpZSB0d2ljZS4gUHJldmlvdXMga2lsbGVyOiAke3RoaXMua2lsbGVyTmFtZX0gKCR7dGhpcy5fX2tpbGxlcklkfSksIFVzdXJwZXI6ICR7a2lsbGVyLm5hbWV9ICgke2tpbGxlci5fX2lkfSlgLCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kb0JlaGF2aW9yKCdkaWUnKTtcbiAgICBNZXNzYWdlUXVldWUuYWRkKHsgbWVzc2FnZTogYCR7dGhpcy5uYW1lfSB3YXMga2lsbGVkIGJ5ICR7a2lsbGVyLm5hbWV9IWAsIHR5cGU6IE1lc3NhZ2VUeXBlcy5DT01CQVQgfSk7XG4gICAgaWYoa2lsbGVyLmtpbGwpIGtpbGxlci5raWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fX2tpbGxlcklkID0ga2lsbGVyLl9faWQ7XG4gICAgdGhpcy5raWxsZXJOYW1lID0ga2lsbGVyLm5hbWU7XG4gICAgdGhpcy5yZW1vdmVTZWxmKCk7XG4gIH1cblxuICByZW1vdmVTZWxmKCkge1xuICAgIEdhbWVTdGF0ZS53b3JsZC5yZW1vdmVFbnRpdHkodGhpcyk7XG4gICAgR2FtZVN0YXRlLmdhbWUuc2NoZWR1bGVyLnJlbW92ZSh0aGlzKTtcbiAgfVxuXG4gIGNsZWFuVXAoKSB7XG4gICAgXy5lYWNoKHRoaXMuYXR0YWNrcywgYSA9PiBhLmNsZWFuVXAoKSk7XG4gICAgdGhpcy5iZWhhdmlvcnMgPSBudWxsO1xuICAgIHRoaXMuaW52ZW50b3J5ID0gbnVsbDtcbiAgICB0aGlzLmVxdWlwbWVudCA9IG51bGw7XG4gICAgdGhpcy5hdHRhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wYXRoID0gbnVsbDtcbiAgICB0aGlzLl9hdHRhY2tlZEJ5ID0gbnVsbDtcblxuICAgIHRoaXMucHJvZmVzc2lvbkluc3QgPSBudWxsO1xuICAgIHRoaXMucmFjZUluc3QgPSBudWxsO1xuXG4gICAgdGhpcy5jb25xdWVzdCA9IG51bGw7XG4gICAgdGhpcy50cmFpdHMgPSBudWxsO1xuICAgIHRoaXMudHJhaXRIYXNoID0gbnVsbDtcbiAgICB0aGlzLnNraWxscyA9IG51bGw7XG4gIH1cblxuICBraWxsKGRlYWQpIHtcbiAgICB0aGlzLmdhaW5YcChkZWFkLmtpbGxYcCk7XG4gICAgdGhpcy5kb0JlaGF2aW9yKCdraWxsJyk7XG4gIH1cblxuICBzZXRUYXJnZXQobmV3VGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXQgPSBuZXdUYXJnZXQ7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIE1vdmVtZW50IChwYXRoZmluZGluZywgc3RlcHBpbmcpXG4gIHN0ZXBSYW5kb21seSgpIHtcbiAgICBjb25zdCB0aWxlcyA9IEdhbWVTdGF0ZS53b3JsZC5nZXRBbGxUaWxlc0luUmFuZ2UodGhpcy54LCB0aGlzLnksIHRoaXMueiwgMSk7XG4gICAgY29uc3QgdmFsaWRUaWxlcyA9IF8ubWFwKHRpbGVzLCAodGlsZSwgaSkgPT4gR2FtZVN0YXRlLndvcmxkLmlzVGlsZUVtcHR5KHRpbGUueCwgdGlsZS55LCB0aWxlLnopID8gaSsxIDogbnVsbCk7IC8vIDEtOSBpbnN0ZWFkIG9mIDAtOFxuICAgIGxldCBkaXJlY3Rpb24gPSBfKHZhbGlkVGlsZXMpLmNvbXBhY3QoKS5zYW1wbGUoKSAtIDE7IC8vIGFkanVzdG1lbnQgZm9yIGFycmF5XG4gICAgbGV0IG5ld1RpbGUgPSB0aWxlc1tkaXJlY3Rpb25dOyAvLyBkZWZhdWx0IHRvIGEgcmFuZG9tIHRpbGVcblxuICAgIGlmKHRoaXMubGFzdERpcmVjdGlvbikge1xuICAgICAgY29uc3QgcHJvYnMgPSBjYWxjKHRoaXMubGFzdERpcmVjdGlvbiArIDEpOyAvLyBhZGp1c3QgZm9yIGFycmF5XG4gICAgICBjb25zdCBjaG9pY2VzID0gXyh2YWxpZFRpbGVzKS5tYXAodGlsZUluZGV4ID0+IHRpbGVJbmRleCA/IFt0aWxlSW5kZXgsIHByb2JzW3RpbGVJbmRleF1dIDogbnVsbCkuY29tcGFjdCgpLnppcE9iamVjdCgpLnZhbHVlKCk7XG4gICAgICBkaXJlY3Rpb24gPSBwYXJzZUludChST1QuUk5HLmdldFdlaWdodGVkVmFsdWUoY2hvaWNlcykpIC0gMTtcbiAgICAgIG5ld1RpbGUgPSB0aWxlc1tkaXJlY3Rpb25dO1xuICAgIH1cblxuICAgIGlmKCFuZXdUaWxlKSByZXR1cm47IC8vIHN1cnJvdW5kZWRcbiAgICB0aGlzLm1vdmUobmV3VGlsZSk7XG4gICAgdGhpcy5sYXN0RGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHRoaXMuZG9CZWhhdmlvcignc3RlcCcpO1xuICB9XG5cbiAgc3RlcFRvd2FyZHModGFyZ2V0LCBiYXNlUGF0aCA9IHRhcmdldC5fcGF0aCkge1xuXG4gICAgLy8gZmlyc3QgY2hlY2sgaWYgaXQncyBqdXN0IGEgY29vcmRpbmF0ZSBwYWlyXG4gICAgaWYoXy5rZXlzKHRhcmdldCkubGVuZ3RoID4gMiAmJiAhdGhpcy5jYW5TZWUodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RlcFJhbmRvbWx5KCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9IFtdO1xuICAgIGNvbnN0IGFkZFBhdGggPSAoeCwgeSkgPT4gcGF0aC5wdXNoKHsgeCwgeSB9KTtcbiAgICBiYXNlUGF0aC5jb21wdXRlKHRoaXMueCwgdGhpcy55LCBhZGRQYXRoKTtcblxuICAgIHBhdGguc2hpZnQoKTtcbiAgICBjb25zdCBzdGVwID0gcGF0aC5zaGlmdCgpO1xuICAgIGlmKCFzdGVwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBibG9ja2luZ0VudGl0eUluZm8gPSAocGF0aCkgPT4ge1xuICAgICAgbGV0IGVudGl0eSA9IG51bGw7XG4gICAgICBsZXQgc3RlcCA9IG51bGw7XG4gICAgICBfLmVhY2gocGF0aCwgKG5ld1N0ZXAsIGkpID0+IHtcbiAgICAgICAgY29uc3QgdGVzdEVudGl0eSA9IEdhbWVTdGF0ZS53b3JsZC5nZXRFbnRpdHkobmV3U3RlcC54LCBuZXdTdGVwLnksIHRoaXMueik7XG4gICAgICAgIGlmKHRlc3RFbnRpdHkgJiYgIXRoaXMuY2FuQXR0YWNrKHRlc3RFbnRpdHkpKSB7XG4gICAgICAgICAgZW50aXR5ID0gdGVzdEVudGl0eTtcbiAgICAgICAgICBzdGVwID0gaTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgZW50aXR5LCBzdGVwIH07XG4gICAgfTtcblxuICAgIGNvbnN0IG1haW5CbG9ja2luZ0luZm8gPSBibG9ja2luZ0VudGl0eUluZm8ocGF0aCk7XG5cbiAgICAvLyB0aGUgbWFpbiBwYXRoIGlzIGJsb2NrZWRcbiAgICBpZihtYWluQmxvY2tpbmdJbmZvLmVudGl0eSkge1xuICAgICAgY29uc3QgYWx0UGF0aCA9IHRoaXMuZ2V0QWx0ZXJuYXRlUGF0aFRvKHRhcmdldCk7XG5cbiAgICAgIC8vIG5vIGFsdGVybmF0ZSBwYXRoIGNvdWxkIGJlIGdlbmVyYXRlZFxuICAgICAgaWYoIWFsdFBhdGgpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oc3RlcC54LCBzdGVwLnkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWx0QmxvY2tpbmdJbmZvID0gYmxvY2tpbmdFbnRpdHlJbmZvKGFsdFBhdGgpO1xuXG4gICAgICAvLyBib3RoIGFyZSBibG9ja2VkLCB0YWtlIHRoZSBzaG9ydGVzdCBwYXRoXG4gICAgICBpZihtYWluQmxvY2tpbmdJbmZvLmVudGl0eSAmJiBhbHRCbG9ja2luZ0luZm8uZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBfLm1pbihbcGF0aCwgYWx0UGF0aF0sICh0ZXN0UGF0aCkgPT4gdGVzdFBhdGgubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbmV3U3RlcCA9IG5ld1BhdGguc2hpZnQoKTtcbiAgICAgICAgdGhpcy5tb3ZlVG8obmV3U3RlcC54LCBuZXdTdGVwLnkpO1xuXG4gICAgICAvLyB0aGUgYWx0IHBhdGggaXNuJ3QgYmxvY2tlZCwgdGFrZSB0aGF0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdTdGVwID0gYWx0UGF0aC5zaGlmdCgpO1xuICAgICAgICB0aGlzLm1vdmVUbyhuZXdTdGVwLngsIG5ld1N0ZXAueSk7XG4gICAgICB9XG5cbiAgICAvLyBubyBibG9ja2Vycywga2VlcCBtb3Zpbmcgb25cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlVG8oc3RlcC54LCBzdGVwLnkpO1xuICAgIH1cblxuICAgIHRoaXMuZG9CZWhhdmlvcignc3RlcCcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0QWx0ZXJuYXRlUGF0aFRvKHRhcmdldCkge1xuICAgIGNvbnN0IGNhblBhc3MgPSAoeCwgeSkgPT4ge1xuICAgICAgY29uc3QgZW50aXR5ID0gR2FtZVN0YXRlLndvcmxkLmdldEVudGl0eSh4LCB5LCB0aGlzLnopO1xuICAgICAgY29uc3QgaXNBdHRhY2thYmxlID0gZW50aXR5ICYmIHRoaXMuY2FuQXR0YWNrKGVudGl0eSk7XG4gICAgICBjb25zdCBpc01lID0gdGhpcy54ID09PSB4ICYmIHRoaXMueSA9PT0geTtcbiAgICAgIHJldHVybiBHYW1lU3RhdGUud29ybGQuaXNUaWxlUGFzc2FibGUoeCwgeSwgdGhpcy56KSB8fCBpc01lIHx8IGlzQXR0YWNrYWJsZTtcbiAgICB9O1xuICAgIGNvbnN0IGFzdGFyID0gbmV3IFJPVC5QYXRoLkFTdGFyKHRhcmdldC54LCB0YXJnZXQueSwgY2FuUGFzcyk7XG5cbiAgICBjb25zdCBwYXRoID0gW107XG4gICAgYXN0YXIuY29tcHV0ZSh0aGlzLngsIHRoaXMueSwgKHgsIHkpID0+IHBhdGgucHVzaCh7IHgsIHkgfSkpO1xuXG4gICAgcGF0aC5zaGlmdCgpO1xuICAgIGNvbnN0IHN0ZXAgPSBwYXRoLnNoaWZ0KCk7XG4gICAgaWYoIXN0ZXApIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICByZXR1cm4gR2FtZVN0YXRlLndvcmxkLm1vdmVFbnRpdHkodGhpcywgeCwgeSwgdGhpcy56KTtcbiAgfVxuXG4gIG1vdmUobmV3VGlsZSkge1xuICAgIHJldHVybiBHYW1lU3RhdGUud29ybGQubW92ZUVudGl0eSh0aGlzLCBuZXdUaWxlLngsIG5ld1RpbGUueSwgbmV3VGlsZS56KTtcbiAgfVxuXG4gIGFsZXJ0QWxsSW5SYW5nZShzb3VuZFJhbmdlID0gdGhpcy5nZXRTb3VuZEVtaXNzaW9uKCkpIHtcbiAgICBjb25zdCBlbnRpdGllcyA9IEdhbWVTdGF0ZS53b3JsZC5nZXRWYWxpZEVudGl0aWVzSW5SYW5nZSh0aGlzLngsIHRoaXMueSwgdGhpcy56LCBzb3VuZFJhbmdlLCAoZW50aXR5KSA9PiBlbnRpdHkuY2FuQXR0YWNrKHRoaXMpKTtcbiAgICBfLmVhY2goZW50aXRpZXMsIChlbnRpdHkpID0+IHtcbiAgICAgIGVudGl0eS5kb0JlaGF2aW9yKCdoZWFyJywgW3RoaXNdKTtcbiAgICB9KTtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gQXR0YWNrLXJlbGF0ZWQgKHZpc2lvbiwgYXR0YWNraW5nLCBldGMpXG4gIGdldEF0dGFja3MoKSB7XG4gICAgY29uc3QgYmFzZUF0dGFja3MgPSB0aGlzLmF0dGFja3MgfHwgW107XG4gICAgY29uc3QgcmFjaWFsQXR0YWNrcyA9IGJhc2VBdHRhY2tzLmNvbmNhdCh0aGlzLnJhY2VJbnN0LmF0dGFja3MpO1xuICAgIGxldCBhdHRhY2tzID0gcmFjaWFsQXR0YWNrcy5jb25jYXQoXyh0aGlzLmVxdWlwbWVudCkudmFsdWVzKCkuZmxhdHRlbigpLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5jYW5Vc2UodGhpcykgJiYgaXRlbS5hdHRhY2tzKS5wbHVjaygnYXR0YWNrcycpLmZsYXR0ZW4oKS52YWx1ZSgpKTtcbiAgICBpZihhdHRhY2tzLmxlbmd0aCA9PT0gMCkgYXR0YWNrcyA9IFtBdHRhY2tzLlVuYXJtZWQoKV07XG4gICAgY29uc3QgaW52ZW50b3J5QXR0YWNrcyA9IF8odGhpcy5pbnZlbnRvcnkpLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5jYW5Vc2UodGhpcykgJiYgaXRlbS5hdHRhY2tzKS5wbHVjaygnYXR0YWNrcycpLmZsYXR0ZW4oKS52YWx1ZSgpO1xuXG4gICAgLy8gYWxsIG1lbGVlIGF0dGFja3MgYXJlIHZhbGlkLCBidXQgb25seSBvbmUgcmFuZ2VkIGludmVudG9yeSBhdHRhY2sgY2FuIGJlIHVzZWRcbiAgICBpZihfLnNvbWUoYXR0YWNrcywgKGF0aykgPT4gYXRrLmNhblVzZSh0aGlzKSkpIHJldHVybiBhdHRhY2tzO1xuICAgIHJldHVybiBfLmNvbXBhY3QoW18oaW52ZW50b3J5QXR0YWNrcykuZmlsdGVyKChhdGspID0+IGF0ay5jYW5Vc2UodGhpcykpLnNhbXBsZSgpXSk7XG4gIH1cblxuICBjYW5TZWUoZW50aXR5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhaXRWYWx1ZSgnU2VlSW52aXNpYmxlJykgPj0gZW50aXR5LmdldFRyYWl0VmFsdWUoJ0ludmlzaWJsZScpO1xuICB9XG5cbiAgY2FuQXR0YWNrKGVudGl0eSkge1xuICAgIGlmKGVudGl0eS5ocC5hdE1pbigpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYoXy5jb250YWlucyh0aGlzLmZhY3Rpb25zLCAnUGxheWVyJykgJiYgXy5jb250YWlucyhlbnRpdHkuZmFjdGlvbnMsICdQbGF5ZXInKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIHRoZXkgaGF2ZSBhIGZhY3Rpb24gdGhhdCB5b3UgYXJlIGFnYWluc3RcbiAgICByZXR1cm4gXy5pbnRlcnNlY3Rpb24oZW50aXR5LmZhY3Rpb25zLCB0aGlzLmFudGlGYWN0aW9ucykubGVuZ3RoID4gMCB8fFxuXG4gICAgICAvLyBvciB5b3UgYXR0YWNrIGV2ZXJ5dGhpbmcgYnV0IHlvdXIgb3duIGZhY3Rpb25cbiAgICAgIChfLmNvbnRhaW5zKHRoaXMuYW50aUZhY3Rpb25zLCAnYWxsJykgJiYgXy5pbnRlcnNlY3Rpb24oZW50aXR5LmZhY3Rpb25zLCB0aGlzLmZhY3Rpb25zKS5sZW5ndGggPT09IDApO1xuICB9XG5cbiAgZG9BdHRhY2soYXR0YWNrLCBoaXROdW0pIHtcbiAgICBjb25zdCB0YXJnZXQgPSBhdHRhY2sucG9zc2libGVUYXJnZXRzKHRoaXMpWzBdO1xuICAgIGlmKCF0YXJnZXQpIHJldHVybjsgLy8gcG9zc2libHkgYSBtdWx0aS1zaG90IGF0dGFjayB0aGF0IGhhcyBraWxsZWQgZWFybHlcbiAgICBhdHRhY2sudXNlKHRoaXMsIHRhcmdldCwgaGl0TnVtKTtcbiAgfVxuXG4gIHRyeUF0dGFjaygpIHtcbiAgICBjb25zdCBhdHRhY2tzID0gdGhpcy5nZXRBdHRhY2tzKCk7XG4gICAgaWYoYXR0YWNrcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIF8uZWFjaChhdHRhY2tzLCAoYXRrLCBpKSA9PiB0aGlzLmRvQXR0YWNrKGF0aywgaSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8vIHJlZ2lvbiBMZXZlbHVwL1hQIGZ1bmN0aW9uc1xuICBjYWxjTGV2ZWxIcEJvbnVzKCkge1xuICAgIHJldHVybiBSb2xsKHRoaXMucHJvZmVzc2lvbkluc3QuY29uZmlnLmhwKSArIHRoaXMuY2FsY1N0YXRCb251cygnY29uJyk7XG4gIH1cblxuICBjYWxjTGV2ZWxNcEJvbnVzKCkge1xuICAgIHJldHVybiBSb2xsKHRoaXMucHJvZmVzc2lvbkluc3QuY29uZmlnLm1wKSArIHRoaXMuY2FsY1N0YXRCb251cygnaW50Jyk7XG4gIH1cblxuICBnYWluWHAobnVtYmVyKSB7XG4gICAgaWYodGhpcy5ocC5hdE1pbigpKSByZXR1cm47XG4gICAgdGhpcy54cC5hZGQobnVtYmVyKTtcbiAgICBpZih0aGlzLnhwLmF0TWF4KCkpIHtcbiAgICAgIHRoaXMubGV2ZWx1cCgpO1xuICAgIH1cbiAgfVxuXG4gIGxldmVsdXAoKSB7XG4gICAgdGhpcy5sZXZlbCArPSAxO1xuICAgIHRoaXMueHAubWF4ID0gdGhpcy5jYWxjTGV2ZWxYcCh0aGlzLmxldmVsKTtcbiAgICB0aGlzLmxldmVsdXBTdGF0Qm9vc3QoKTtcblxuICAgIC8vIHJlc2V0c1xuICAgIHRoaXMueHAudG9NaW4oKTtcbiAgICB0aGlzLmhwLnRvTWF4KCk7XG4gICAgdGhpcy5tcC50b01heCgpO1xuXG4gICAgdGhpcy5mbHVzaFRyYWl0cygpO1xuICAgIE1lc3NhZ2VRdWV1ZS5hZGQoeyBtZXNzYWdlOiBgJHt0aGlzLm5hbWV9IGhhcyByZWFjaGVkIGV4cGVyaWVuY2UgbGV2ZWwgJHt0aGlzLmxldmVsfSFgLCB0eXBlOiBNZXNzYWdlVHlwZXMuQ0hBUkFDVEVSIH0pO1xuICB9XG5cbiAgbGV2ZWx1cFN0YXRCb29zdCgpIHtcbiAgICB0aGlzLnByb2Zlc3Npb25JbnN0LmxldmVsdXAoKTtcbiAgICB0aGlzLmhwLm1heCArPSB0aGlzLmNhbGNMZXZlbEhwQm9udXMoKTtcbiAgICB0aGlzLm1wLm1heCArPSB0aGlzLmNhbGNMZXZlbE1wQm9udXMoKTtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gU3RhdCBtYW5pcHVsYXRpb25cbiAgYWJ1c2Uoc3RhdCwgbG9zcyA9ICcxZDEnKSB7XG4gICAgdGhpc1tzdGF0XSA9IE1hdGgubWF4KHRoaXNbc3RhdF0tKFJvbGwobG9zcykpLCBTZXR0aW5ncy5nYW1lLm1pblN0YXRWYWx1ZSk7XG4gIH1cblxuICBleGVyY2lzZShzdGF0LCBnYWluID0gJzFkMScpIHtcbiAgICB0aGlzW3N0YXRdICs9IChSb2xsKGdhaW4pKTtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gR2V0dGVycyAoU3RhdHMsIGV0YylcbiAgZ2V0VHJhaXRWc09wcG9uZW50KHRhcmdldCwgdHJhaXQpIHtcbiAgICBpZighdGFyZ2V0KSByZXR1cm4gMDtcbiAgICByZXR1cm4gXy5yZWR1Y2UodGFyZ2V0LmZhY3Rpb25zLCAocHJldiwgY3VyKSA9PiBwcmV2ICsgdGhpcy5nZXRUcmFpdFZhbHVlKGAke2N1cn0ke3RyYWl0fWApLCAwKTtcbiAgfVxuXG4gIGdldEFsaWduKCkge1xuICAgIGlmKHRoaXMuYWxpZ24gPD0gLVNldHRpbmdzLmdhbWUuYWxpZ25UaHJlc2hvbGQpIHJldHVybiAnRXZpbCc7XG4gICAgaWYodGhpcy5hbGlnbiA+PSBTZXR0aW5ncy5nYW1lLmFsaWduVGhyZXNob2xkKSByZXR1cm4gJ0dvb2QnO1xuICAgIHJldHVybiAnTmV1dHJhbCc7XG4gIH1cblxuICBnZXRTdGF0KHN0YXQpIHtcbiAgICByZXR1cm4gdGhpcy5yb2xsT3JBZGQodGhpc1tzdGF0XSkgK1xuICAgICAgICAgICB0aGlzLnJvbGxPckFkZCh0aGlzLnByb2Zlc3Npb25JbnN0W3N0YXRdKSArXG4gICAgICAgICAgIHRoaXMucm9sbE9yQWRkKHRoaXMucmFjZUluc3Rbc3RhdF0pICtcbiAgICAgICAgICAgdGhpcy5nZXRUcmFpdFZhbHVlKHN0YXQpO1xuICB9XG5cbiAgZ2V0U3RhdFdpdGhNaW4oc3RhdCwgbWluID0gMCkge1xuICAgIHJldHVybiBNYXRoLm1heChtaW4sIHRoaXMuZ2V0U3RhdChzdGF0KSk7XG4gIH1cblxuICBnZXRSZWdlbkhwKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRXaXRoTWluKCdyZWdlbkhwJywgMSk7XG4gIH1cblxuICBnZXRSZWdlbk1wKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRXaXRoTWluKCdyZWdlbk1wJywgMSk7XG4gIH1cblxuICBnZXRCb251c0RhbWFnZSh0YXJnZXQgPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdCgnYm9udXNEYW1hZ2UnKSArIHRoaXMuZ2V0VHJhaXRWc09wcG9uZW50KHRhcmdldCwgJ0Z1cnknKTtcbiAgfVxuXG4gIGdldFRvSGl0KHRhcmdldCA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0KCd0b0hpdCcpICsgdGhpcy5nZXRUcmFpdFZzT3Bwb25lbnQodGFyZ2V0LCAnQmFuZScpO1xuICB9XG5cbiAgZ2V0U2lnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdFdpdGhNaW4oJ3NpZ2h0JykgKyB0aGlzLmdldFRyYWl0VmFsdWUoJ0luZnJhdmlzaW9uJyk7XG4gIH1cblxuICBnZXRTcGVlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0V2l0aE1pbignc3BlZWQnKSArIHRoaXMuZ2V0VHJhaXRWYWx1ZSgnSGFzdGUnKTtcbiAgfVxuXG4gIGdldFNvdW5kRW1pc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdFdpdGhNaW4oJ3NvdW5kJykgLSB0aGlzLmdldFRyYWl0VmFsdWUoJ1N0ZWFsdGgnKTtcbiAgfVxuXG4gIGdldEFDKCkge1xuICAgIHJldHVybiBTZXR0aW5ncy5nYW1lLmJhc2VBQyArIHRoaXMuZ2V0U3RhdCgnYWMnKSAtIHRoaXMuY2FsY1N0YXRCb251cygnZGV4JykgLSB0aGlzLmdldFRyYWl0VmFsdWUoJ1Byb3RlY3Rpb24nKTtcbiAgfVxuXG4gIGdldFN0cigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0V2l0aE1pbignc3RyJyk7XG4gIH1cblxuICBnZXREZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdFdpdGhNaW4oJ2RleCcpO1xuICB9XG5cbiAgZ2V0Q29uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRXaXRoTWluKCdjb24nKTtcbiAgfVxuXG4gIGdldEludCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0V2l0aE1pbignaW50Jyk7XG4gIH1cblxuICBnZXRXaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdFdpdGhNaW4oJ3dpcycpO1xuICB9XG5cbiAgZ2V0Q2hhKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRXaXRoTWluKCdjaGEnKTtcbiAgfVxuXG4gIGdldEx1aygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0V2l0aE1pbignbHVrJyk7XG4gIH1cblxuICBoYXNGYWN0aW9uKGZhY3Rpb24pIHtcbiAgICByZXR1cm4gXy5jb250YWlucyh0aGlzLmZhY3Rpb25zLCBmYWN0aW9uKTtcbiAgfVxuICAvLyBlbmRyZWdpb24gKFN0YXRzLCBldGMpXG5cbiAgYWN0KCkge1xuICAgIHRoaXMuY3VycmVudFR1cm4rKztcbiAgICB0aGlzLmRvQmVoYXZpb3IoJ2FjdCcpO1xuICB9XG5cbiAgYnJlYWtDb25kdWN0KGNvbmR1Y3QpIHtcbiAgICB0aGlzLmJyb2tlbkNvbmR1Y3RbY29uZHVjdF0gPSB0cnVlO1xuICB9XG5cbiAgY2FsY0RpZmZpY3VsdHkoZW50aXR5KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDEsIE1hdGgubWluKDUsIE1hdGguZmxvb3IoKGVudGl0eS5sZXZlbCAtIHRoaXMubGV2ZWwpIC8gMikpKTtcbiAgfVxuXG4gIGhlYWwodmFsdWUpIHtcbiAgICBpZighdmFsdWUgfHwgIV8uaXNOdW1iZXIodmFsdWUpIHx8IF8uaXNOYU4odmFsdWUpKSB7XG4gICAgICBMb2coJ0NoYXJhY3RlcicsIGBWYWx1ZSBnaXZlbiB0byBoZWFsIHdhcyBub3Qgd2VsbCBmb3JtZWQ6ICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIHRoaXMuaHAuYWRkKHZhbHVlKTtcbiAgfVxuXG4gIC8vIC0yID0gNC81LCAtMSA9IDYvNywgMCA9IDgsICsxID0gOS8xMCwgKzIgPSAxMC8xMSAoZXRjKVxuICBjYWxjU3RhdEJvbnVzKHN0YXQpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzW2BnZXQke18uY2FwaXRhbGl6ZShzdGF0KX1gXSgpIC8gMikgLSA0O1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IG1lID0gXy5vbWl0KHRoaXMsIFsnZ2FtZScsICdfcGF0aCcsICd0cmFpdEhhc2gnLCAnX2F0dGFja2VkQnknLCAnX19pZCcsICdfX2tpbGxlcklkJ10pO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtZSk7XG4gIH1cbn1cbiIsIlxuaW1wb3J0IE1lc3NhZ2VRdWV1ZSwgeyBNZXNzYWdlVHlwZXMgfSBmcm9tICcuLi9kaXNwbGF5L21lc3NhZ2UtaGFuZGxlcic7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uL2luaXQvZ2FtZXN0YXRlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWZmZWN0IHtcbiAgc3RhdGljIGdldCBwcm9iYWJpbGl0eSgpIHsgcmV0dXJuIDE7IH1cbiAgc3RhdGljIHVzZSgpIHt9XG4gIHN0YXRpYyBtc2coZW50aXR5LCBtZXNzYWdlKSB7IE1lc3NhZ2VRdWV1ZS5hZGQoeyBlbnRpdHksIG1lc3NhZ2UsIHR5cGU6IE1lc3NhZ2VUeXBlcy5EVU5HRU9OIH0pOyB9XG4gIHN0YXRpYyBnZXRFbXB0eVRpbGVzSW5SYW5nZShlbnRpdHksIHJhbmdlID0gMykge1xuICAgIHJldHVybiBHYW1lU3RhdGUud29ybGQuZ2V0VmFsaWRUaWxlc0luUmFuZ2UoXG4gICAgICBlbnRpdHkueCwgZW50aXR5LnksIGVudGl0eS56LCByYW5nZSxcbiAgICAgICh0aWxlKSA9PiBHYW1lU3RhdGUud29ybGQuaXNUaWxlRW1wdHkodGlsZS54LCB0aWxlLnksIHRpbGUueilcbiAgICApO1xuICB9XG59IiwiXG5pbXBvcnQgR2x5cGggZnJvbSAnLi9nbHlwaCc7XG5pbXBvcnQgQWJzdHJhY3QgZnJvbSAnLi9hYnN0cmFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eSBleHRlbmRzIEFic3RyYWN0IHtcbiAgY29uc3RydWN0b3IoZ2x5cGhPcHRzLCB4ID0gMCwgeSA9IDAsIHogPSAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlbnNpdHkgPSAxO1xuICAgIHRoaXMub3BhY2l0eSA9IDA7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy5zZXRHbHlwaChnbHlwaE9wdHMpO1xuICB9XG4gIFxuICBzZXRHbHlwaChnbHlwaE9wdHMpIHtcbiAgICB0aGlzLmdseXBoID0gbmV3IEdseXBoKGdseXBoT3B0cy5rZXksIGdseXBoT3B0cy5mZywgZ2x5cGhPcHRzLmJnKTtcbiAgfVxuICBcbiAgaXNEZW5zZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLmRlbnNpdHk7XG4gIH1cbiAgXG4gIGlzQmxvY2tpbmdMaWdodCgpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cbn0iLCJcbmltcG9ydCB7IEl0ZW0gfSBmcm9tICcuL2l0ZW0nO1xuaW1wb3J0ICogYXMgRmFrZXMgZnJvbSAnLi4vY29uc3RhbnRzL2Zha2V0eXBlcyc7XG5pbXBvcnQgTWVzc2FnZVF1ZXVlLCB7IE1lc3NhZ2VUeXBlcyB9IGZyb20gJy4uL2Rpc3BsYXkvbWVzc2FnZS1oYW5kbGVyJztcbmltcG9ydCB7IEl0ZW1zIGFzIEdseXBocyB9IGZyb20gJy4uL2NvbnN0YW50cy9nbHlwaHMnO1xuaW1wb3J0IE1hdGVyaWFscyBmcm9tICcuLi9jb25zdGFudHMvbWF0ZXJpYWxzJztcbmltcG9ydCB7IHJhcml0eSwgbWF0ZXJpYWwgfSBmcm9tICcuLi9jb25zdGFudHMvZGVjb3JhdG9ycyc7XG5cbmNsYXNzIEVxdWlwbWVudCBleHRlbmRzIEl0ZW0ge1xufVxuXG5leHBvcnQgY2xhc3MgU3BlY2lhbCBleHRlbmRzIEl0ZW0ge31cblxuQG1hdGVyaWFsKE1hdGVyaWFscy5Gb29kKVxuZXhwb3J0IGNsYXNzIENvbWVzdGlibGUgZXh0ZW5kcyBJdGVtIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgb3B0cy5hdXRvUmVtb3ZlID0gdHJ1ZTtcbiAgICBvcHRzLnN5bWJvbCA9IEdseXBocy5Db21lc3RpYmxlO1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMuY2FuU3RhY2sgPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBcm1vciBleHRlbmRzIEVxdWlwbWVudCB7fVxuXG5leHBvcnQgY2xhc3MgV2VhcG9uIGV4dGVuZHMgRXF1aXBtZW50IHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMucmVhbE5hbWUgPSB0aGlzLmZha2VOYW1lID0gdGhpcy5nZXRDYW5vbk5hbWUoKTtcbiAgfVxufVxuXG5AcmFyaXR5KDI1KVxuZXhwb3J0IGNsYXNzIEJvZHkgZXh0ZW5kcyBBcm1vciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIG9wdHMuc3ltYm9sID0gR2x5cGhzLkJvZHk7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy5yZWFsTmFtZSA9IHRoaXMuZmFrZU5hbWUgPSB0aGlzLmdldENhbm9uTmFtZSgpO1xuICB9XG59XG5cbkByYXJpdHkoMylcbmV4cG9ydCBjbGFzcyBSaW5nIGV4dGVuZHMgQXJtb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBvcHRzLmJ1Y1Byb2IgPSB7IGN1cnNlZDogNywgYmxlc3NlZDogMiwgdW5jdXJzZWQ6IDkxIH07XG4gICAgb3B0cy5zeW1ib2wgPSBHbHlwaHMuUmluZztcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLnJlYWxOYW1lID0gYCR7dGhpcy5nZXRDYW5vbk5hbWUoKX1gO1xuICAgIHRoaXMuZmFrZU5hbWUgPSBgJHt0aGlzLnBpY2tGYWtlTmFtZShGYWtlcy5SaW5nKX0gcmluZ2A7XG4gIH1cbn1cblxuQHJhcml0eSgyNSlcbmV4cG9ydCBjbGFzcyBIYW5kcyBleHRlbmRzIFdlYXBvbiB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIG9wdHMuc3ltYm9sID0gR2x5cGhzLkhhbmRzO1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMucmVhbE5hbWUgPSB0aGlzLmZha2VOYW1lID0gdGhpcy5nZXRDYW5vbk5hbWUoKTtcbiAgfVxufVxuXG5AcmFyaXR5KDUpXG5leHBvcnQgY2xhc3MgV3Jpc3QgZXh0ZW5kcyBBcm1vciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIG9wdHMuc3ltYm9sID0gR2x5cGhzLldyaXN0O1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMucmVhbE5hbWUgPSB0aGlzLmZha2VOYW1lID0gdGhpcy5nZXRDYW5vbk5hbWUoKTtcbiAgfVxufVxuXG5AcmFyaXR5KDUpXG5leHBvcnQgY2xhc3MgRmVldCBleHRlbmRzIEFybW9yIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgb3B0cy5zeW1ib2wgPSBHbHlwaHMuRmVldDtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLnJlYWxOYW1lID0gdGhpcy5mYWtlTmFtZSA9IHRoaXMuZ2V0Q2Fub25OYW1lKCk7XG4gICAgdGhpcy5zbG90c1Rha2VuID0gMjtcbiAgfVxufVxuXG5AcmFyaXR5KDUpXG5leHBvcnQgY2xhc3MgSGVhZCBleHRlbmRzIEFybW9yIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgb3B0cy5zeW1ib2wgPSBHbHlwaHMuSGVhZDtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLnJlYWxOYW1lID0gdGhpcy5mYWtlTmFtZSA9IHRoaXMuZ2V0Q2Fub25OYW1lKCk7XG4gIH1cbn1cblxuQHJhcml0eSgzKVxuZXhwb3J0IGNsYXNzIENsb2FrIGV4dGVuZHMgQXJtb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBvcHRzLnN5bWJvbCA9IEdseXBocy5DbG9haztcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLnJlYWxOYW1lID0gdGhpcy5mYWtlTmFtZSA9IHRoaXMuZ2V0Q2Fub25OYW1lKCk7XG4gIH1cbn1cblxuQHJhcml0eSgxKVxuZXhwb3J0IGNsYXNzIE5lY2sgZXh0ZW5kcyBBcm1vciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIG9wdHMuc3ltYm9sID0gR2x5cGhzLk5lY2s7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy5yZWFsTmFtZSA9IHRoaXMuZmFrZU5hbWUgPSB0aGlzLmdldENhbm9uTmFtZSgpO1xuICB9XG59XG5cbkByYXJpdHkoMCkgLy8gYWN0dWFsbHkgYSB2YWx1ZSBvZiA4IGJ1dCB0aGV5J3JlIG5vdCBpbXBsZW1lbnRlZCB5ZXRcbkBtYXRlcmlhbChNYXRlcmlhbHMuR2xhc3MpXG5leHBvcnQgY2xhc3MgR2VtIGV4dGVuZHMgSXRlbSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIG9wdHMuc3ltYm9sID0gR2x5cGhzLkdlbTtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLnJlYWxOYW1lID0gdGhpcy5mYWtlTmFtZSA9IGAke3RoaXMuZ2V0Q2Fub25OYW1lKCl9YDtcbiAgICB0aGlzLmNhblN0YWNrID0gdHJ1ZTtcbiAgfVxufVxuXG5AcmFyaXR5KDApIC8vIGFjdHVhbGx5IGEgdmFsdWUgb2YgMTUgYnV0IHRoZXkncmUgbm90IGltcGxlbWVudGVkIHlldFxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBTY3JvbGwgZXh0ZW5kcyBJdGVtIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgb3B0cy5zeW1ib2wgPSBHbHlwaHMuU2Nyb2xsO1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMucmVhbE5hbWUgPSB0aGlzLmZha2VOYW1lID0gYCR7dGhpcy5nZXRDYW5vbk5hbWUoKX1gO1xuICAgIHRoaXMuY2FuU3RhY2sgPSB0cnVlO1xuICB9XG59XG5cbkByYXJpdHkoMilcbkBtYXRlcmlhbChNYXRlcmlhbHMuV29vZClcbmV4cG9ydCBjbGFzcyBXYW5kIGV4dGVuZHMgV2VhcG9uIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgb3B0cy5zeW1ib2wgPSBHbHlwaHMuV2FuZDtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLnJlYWxOYW1lID0gdGhpcy5mYWtlTmFtZSA9IHRoaXMuZ2V0Q2Fub25OYW1lKCk7XG4gIH1cbn1cblxuQHJhcml0eSgxKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5DbG90aClcbmV4cG9ydCBjbGFzcyBTcGVsbGJvb2sgZXh0ZW5kcyBXZWFwb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBvcHRzLm1hbmFDb3N0ID0gb3B0cy5tYW5hQ29zdCB8fCAzO1xuICAgIG9wdHMuc3ltYm9sID0gR2x5cGhzLlNwZWxsYm9vaztcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxufVxuXG5AcmFyaXR5KDIwKVxuQG1hdGVyaWFsKE1hdGVyaWFscy5HbGFzcylcbmV4cG9ydCBjbGFzcyBQb3Rpb24gZXh0ZW5kcyBFcXVpcG1lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBvcHRzLnN5bWJvbCA9IEdseXBocy5Qb3Rpb247XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy5yZWFsTmFtZSA9IGBwb3Rpb24gb2YgJHt0aGlzLmdldENhbm9uTmFtZSgpfWA7XG4gICAgY29uc3QgZmFrZSA9IHRoaXMucGlja0Zha2VOYW1lKEZha2VzLlBvdGlvbik7XG4gICAgdGhpcy5jb2xvciA9IGZha2U7XG4gICAgdGhpcy5mYWtlTmFtZSA9IGAke2Zha2V9IHBvdGlvbmA7XG4gICAgdGhpcy5jYW5TdGFjayA9IHRydWU7XG4gIH1cbiAgdXNlKGVudGl0eSwgZXh0cmEpIHtcbiAgICBzdXBlci51c2UoZW50aXR5LCBleHRyYSk7XG4gICAgTWVzc2FnZVF1ZXVlLmFkZCh7IG1lc3NhZ2U6IGAke2VudGl0eS5uYW1lfSBkcmFuayAke3RoaXMuY29sb3J9IGxpcXVpZCBhbmQgJHtleHRyYS5tZXNzYWdlRmluaXNofSFgLCB0eXBlOiBNZXNzYWdlVHlwZXMuRFVOR0VPTiB9KTtcbiAgfVxufVxuXG5AcmFyaXR5KDApXG5AbWF0ZXJpYWwoTWF0ZXJpYWxzLklyb24pXG5leHBvcnQgY2xhc3MgVG9vbCBleHRlbmRzIEl0ZW0ge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBvcHRzLnN5bWJvbCA9IEdseXBocy5Ub29sO1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG59XG4iLCJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdseXBoIHtcbiAgY29uc3RydWN0b3Ioa2V5LCBmZywgYmcpIHtcbiAgICB0aGlzLmtleSA9IGtleSA/IGtleS5zdWJzdHJpbmcoMCwgMSkgOiAnJztcbiAgICB0aGlzLmZnID0gZmc7XG4gICAgdGhpcy5iZyA9IGJnO1xuICB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJPVCBmcm9tICdyb3QtanMnO1xuaW1wb3J0IFJvbGwgZnJvbSAnLi4vbGliL2RpY2Utcm9sbGVyJztcbmltcG9ydCBHbHlwaCBmcm9tICcuL2dseXBoJztcbmltcG9ydCB7IEdldENvbG9yIH0gZnJvbSAnLi4vbGliL3ZhbGlkLWNvbG9ycyc7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uL2luaXQvZ2FtZXN0YXRlJztcbmltcG9ydCBBYnN0cmFjdCBmcm9tICcuL2Fic3RyYWN0JztcbmltcG9ydCBMb2cgZnJvbSAnLi4vbGliL2xvZ2dlcic7XG5pbXBvcnQgTWVzc2FnZVF1ZXVlLCB7IE1lc3NhZ2VUeXBlcyB9IGZyb20gJy4uL2Rpc3BsYXkvbWVzc2FnZS1oYW5kbGVyJztcblxuZXhwb3J0IGNsYXNzIEl0ZW0gZXh0ZW5kcyBBYnN0cmFjdCB7XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgbGV0IG5hbWUgPSAhdGhpcy5pc0lkZW50aWZpZWQoKSAmJiB0aGlzLmZha2VOYW1lID8gdGhpcy5mYWtlTmFtZSA6IHRoaXMucmVhbE5hbWU7XG4gICAgaWYoIW5hbWUpIG5hbWUgPSB0aGlzLmdldENhbm9uTmFtZSgpO1xuICAgIGNvbnN0IGVuY2hhbnQgPSB0aGlzLmVuY2hhbnRtZW50ID8gYCske3RoaXMuZW5jaGFudG1lbnR9ICR7bmFtZX1gIDogbmFtZTtcbiAgICBjb25zdCBidWMgPSB0aGlzLmJ1Y05hbWUgIT09ICd1bmN1cnNlZCcgPyBgJHt0aGlzLmJ1Y05hbWV9ICR7ZW5jaGFudH1gIDogZW5jaGFudDtcbiAgICByZXR1cm4gYnVjO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIG9wdHMuZ2x5cGggPSBfLmV4dGVuZCh7IGZnOiBHZXRDb2xvcigpLCBrZXk6IG9wdHMuc3ltYm9sIH0sIG9wdHMuZ2x5cGgpO1xuICAgIF8uZXh0ZW5kKHRoaXMsIG9wdHMpO1xuICAgIHRoaXMuZW5jaGFudG1lbnQgPSB0aGlzLmVuY2hhbnRtZW50IHx8IDA7XG4gICAgdGhpcy5zbG90c1Rha2VuID0gdGhpcy5zbG90c1Rha2VuIHx8IDE7XG4gICAgaWYodGhpcy5hdHRhY2tzKSB7XG4gICAgICBfLmVhY2godGhpcy5hdHRhY2tzLCAoYXR0YWNrKSA9PiBhdHRhY2suX2l0ZW1SZWYgPSB0aGlzKTtcbiAgICB9XG4gICAgaWYodGhpcy5yYW5nZSkge1xuICAgICAgdGhpcy5yYW5nZSA9IF8uZXh0ZW5kKHsgbnVtU2hvdHM6IDEsIGRhbWFnZUJvb3N0OiAnMGQwJywgYW1tbzogW10gfSwgdGhpcy5yYW5nZSk7XG4gICAgfVxuICAgIGlmKHRoaXMuY2hhcmdlcykgdGhpcy5jaGFyZ2VzID0gUm9sbCh0aGlzLmNoYXJnZXMpO1xuICAgIGlmKHRoaXMuc3RhcnRJZGVudGlmaWVkKSB0aGlzLmlkZW50aWZ5KCk7XG4gICAgdGhpcy5nbHlwaCA9IG5ldyBHbHlwaChvcHRzLmdseXBoLmtleSwgb3B0cy5nbHlwaC5mZyk7XG4gICAgdGhpcy5nZW5lcmF0ZUJVQyhvcHRzLmJ1Y1Byb2IpO1xuICAgIGlmKCF0aGlzLm1hdGVyaWFsKSB7XG4gICAgICBMb2coJ0l0ZW0nLCBgJHt0aGlzLmdldFR5cGUoKX0gaGFzIG5vIG1hdGVyaWFsIHNldC5gKTtcbiAgICB9XG4gIH1cbiAgXG4gIGlzSWRlbnRpZmllZCgpIHtcbiAgICBjb25zdCBteVR5cGUgPSB0aGlzLmdldFBhcmVudFR5cGUoKTtcbiAgICByZXR1cm4gR2FtZVN0YXRlLmlkZW50aWZpY2F0aW9uW215VHlwZV07XG4gIH1cbiAgXG4gIGlkZW50aWZ5KCkge1xuICAgIGNvbnN0IG15VHlwZSA9IHRoaXMuZ2V0UGFyZW50VHlwZSgpO1xuICAgIEdhbWVTdGF0ZS5pZGVudGlmaWNhdGlvbltteVR5cGVdID0gdGhpcy5yZWFsTmFtZTtcbiAgfVxuICBcbiAgcGlja0Zha2VOYW1lKGNob2ljZXMpIHtcbiAgICBjb25zdCBteVR5cGUgPSB0aGlzLmdldFBhcmVudFR5cGUoKTtcbiAgICBpZihHYW1lU3RhdGUuX2lkTWFwW3RoaXMucmVhbE5hbWVdKSB7XG4gICAgICByZXR1cm4gR2FtZVN0YXRlLl9pZE1hcFt0aGlzLnJlYWxOYW1lXTsgLy8gdGhpcyBpdGVtIGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkXG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUeXBlcyA9IF8ua2V5cyhHYW1lU3RhdGUuaWRlbnRpZmljYXRpb25bbXlUeXBlXSk7XG4gICAgY29uc3QgdmFsaWRUeXBlcyA9IF8uZGlmZmVyZW5jZShjaG9pY2VzLCBjdXJyZW50VHlwZXMpO1xuICAgIGNvbnN0IG5hbWUgPSBfLnNhbXBsZSh2YWxpZFR5cGVzKTtcbiAgICBHYW1lU3RhdGUuX2lkTWFwW3RoaXMucmVhbE5hbWVdID0gbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBcbiAgY2FuVXNlKG93bmVyKSB7XG4gICAgaWYodGhpcy5tYW5hQ29zdCkgcmV0dXJuIG93bmVyLm1wLmd0ZSh0aGlzLm1hbmFDb3N0KTtcbiAgICBpZih0aGlzLmNoYXJnZXMpIHJldHVybiB0aGlzLmNoYXJnZXMgPiAwO1xuICAgIHJldHVybiBvd25lci5pc0VxdWlwcGVkKHRoaXMpO1xuICB9XG4gIFxuICBoYXNWYWxpZEFtbW8ob3duZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWxpZEFtbW8ob3duZXIpLmxlbmd0aCA+IDA7XG4gIH1cbiAgXG4gIGdldFZhbGlkQW1tbyhvd25lcikge1xuICAgIHJldHVybiBfLmZpbHRlcihvd25lci5pbnZlbnRvcnksIChpdGVtKSA9PiBpdGVtLmNhblVzZShvd25lcikgJiYgXy5jb250YWlucyh0aGlzLnJhbmdlLmFtbW8sIGl0ZW0uZ2V0VHlwZSgpKSk7XG4gIH1cbiAgXG4gIHVzZShvd25lciwgZXh0cmEgPSB7IGhlYWxWYWw6IDEgfSkge1xuICAgIGlmKHRoaXMubWFuYUNvc3QpIG93bmVyLm1wLnN1Yih0aGlzLm1hbmFDb3N0KTtcbiAgICBpZih0aGlzLmhlYWxSb2xsKSBvd25lci5oZWFsKGV4dHJhLmhlYWxWYWwpO1xuICAgIGlmKHRoaXMuY2hhcmdlcykge1xuICAgICAgdGhpcy5jaGFyZ2VzLS07XG4gICAgICBpZih0aGlzLmNoYXJnZXMgPD0gMCAmJiB0aGlzLmF1dG9SZW1vdmUpIHRoaXMuZGlzaW50ZWdyYXRlKG93bmVyKTtcbiAgICB9XG4gICAgaWYodGhpcy5yYW5nZSAmJiB0aGlzLmhhc1ZhbGlkQW1tbyhvd25lcikpIHtcbiAgICAgIHRoaXMucGV3cGV3KG93bmVyKTsgIFxuICAgIH1cbiAgfVxuICBcbiAgcGV3cGV3KG93bmVyKSB7XG4gICAgZm9yKGxldCBpPTA7IGk8dGhpcy5yYW5nZS5udW1TaG90czsgaSsrKSB7XG4gICAgICBjb25zdCBjaG9zZW5BbW1vID0gXy5zYW1wbGUodGhpcy5nZXRWYWxpZEFtbW8ob3duZXIpKTtcbiAgICAgIGNob3NlbkFtbW8uX3RlbXBBdHRhY2tCb29zdCA9IHRoaXMucmFuZ2UuZGFtYWdlQm9vc3Q7XG4gICAgICBjb25zdCBhdHRhY2sgPSBfLnNhbXBsZShjaG9zZW5BbW1vLmF0dGFja3MpO1xuICAgICAgb3duZXIuZG9BdHRhY2soYXR0YWNrLCBpKTtcbiAgICAgIGRlbGV0ZSBjaG9zZW5BbW1vLl90ZW1wQXR0YWNrQm9vc3Q7XG4gICAgfVxuICB9XG5cbiAgZGlzaW50ZWdyYXRlKG93bmVyKSB7XG4gICAgb3duZXIudW5lcXVpcCh0aGlzKTtcbiAgICBvd25lci5kcm9wSXRlbSh0aGlzKTtcbiAgICBHYW1lU3RhdGUud29ybGQucmVtb3ZlSXRlbSh0aGlzKTtcbiAgICBNZXNzYWdlUXVldWUuYWRkKHsgbWVzc2FnZTogYCR7dGhpcy5uYW1lfSBjcnVtYmxlZCB0byBkdXN0LmAsIHR5cGU6IE1lc3NhZ2VUeXBlcy5JVEVNIH0pO1xuICB9XG5cbiAgaXNDdXJzZWQoKSB7IHJldHVybiB0aGlzLmJ1Y05hbWUgPT09ICdjdXJzZWQnOyB9XG5cbiAgY3Vyc2UoKSB7XG4gICAgdGhpcy5idWNOYW1lID0gJ2N1cnNlZCc7XG4gICAgdGhpcy5zZXRCVUMoKTtcbiAgfVxuXG4gIHVuY3Vyc2UoKSB7XG4gICAgdGhpcy5idWNOYW1lID0gJ3VuY3Vyc2VkJztcbiAgICB0aGlzLnNldEJVQygpO1xuICB9XG5cbiAgYmxlc3MoKSB7XG4gICAgdGhpcy5idWNOYW1lID0gJ2JsZXNzZWQnO1xuICAgIHRoaXMuc2V0QlVDKCk7XG4gIH1cblxuICBzZXRCVUMoKSB7XG4gICAgY29uc3QgaGFzaCA9IHsgY3Vyc2VkOiAtMSwgdW5jdXJzZWQ6IDEsIGJsZXNzZWQ6IDIgfTtcbiAgICB0aGlzLmJ1YyA9IGhhc2hbdGhpcy5idWNOYW1lXTtcbiAgfVxuICBcbiAgZ2VuZXJhdGVCVUMob3B0cyA9IHsgY3Vyc2VkOiA1LCBibGVzc2VkOiA1LCB1bmN1cnNlZDogOTAgfSkge1xuICAgIGlmKCF0aGlzLmJ1Y05hbWUpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IFJPVC5STkcuZ2V0V2VpZ2h0ZWRWYWx1ZShvcHRzKTtcbiAgICAgIHRoaXMuYnVjTmFtZSA9IHN0YXR1cztcbiAgICB9XG4gICAgdGhpcy5zZXRCVUMoKTtcbiAgfVxuICBcbiAgdmFsdWUoKSB7XG4gICAgY29uc3QgYXRrVmFsdWUgPSBfLnJlZHVjZSh0aGlzLmF0dGFja3MsICgocHJldiwgY3VyKSA9PiBwcmV2ICsgY3VyLnZhbHVlKCkpLCAwKTtcbiAgICByZXR1cm4gdGhpcy5idWMgKiAoMTAwIC0gdGhpcy5yYXJpdHkpICsgdGhpcy5lbmNoYW50bWVudCo1ICsgYXRrVmFsdWU7XG4gIH1cbiAgXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBtZSA9IF8ub21pdCh0aGlzLCBbJ2J1Y1Byb2InLCAnc3RhcnRJZGVudGlmaWVkJywgJ190ZW1wQXR0YWNrQm9vc3QnLCAnc3ltYm9sJ10pO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtZSk7XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQ2hhcmFjdGVyIGZyb20gJy4vY2hhcmFjdGVyJztcbmltcG9ydCBGYWN0aW9ucyBmcm9tICcuLi9jb25zdGFudHMvZmFjdGlvbnMnO1xuaW1wb3J0IEdhbWVTdGF0ZSBmcm9tICcuLi9pbml0L2dhbWVzdGF0ZSc7XG5cbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9jb25zdGFudHMvc2V0dGluZ3MnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb25zdGVyIGV4dGVuZHMgQ2hhcmFjdGVyIHtcbiAgY29uc3RydWN0b3IoeCwgeSwgeiwgb3B0cykge1xuICAgIG9wdHMuc3RhdHMucHJvZmVzc2lvbiA9ICdNb25zdGVyJztcbiAgICBvcHRzLmF0dHJpYnV0ZXMgPSBfLmV4dGVuZCh7fSwgU2V0dGluZ3MuZ2FtZS5kZWZhdWx0U3RhdHMubW9uc3Rlciwgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICBzdXBlcihvcHRzLmdseXBoLCB4LCB5LCB6LCBvcHRzKTtcbiAgICB0aGlzLmRpZmZpY3VsdHkgPSBvcHRzLmRpZmZpY3VsdHk7XG4gICAgdGhpcy5hbnRpRmFjdGlvbnMucHVzaChGYWN0aW9ucy5QTEFZRVIpO1xuICAgIGlmKG9wdHMuYWRkRmFjdGlvbnMpIHRoaXMuZmFjdGlvbnMucHVzaCguLi5vcHRzLmFkZEZhY3Rpb25zKTtcbiAgICBpZihvcHRzLnN0YXJ0aW5nRXF1aXBtZW50KSB0aGlzLmxvYWRTdGFydGluZ0VxdWlwbWVudChvcHRzLnN0YXJ0aW5nRXF1aXBtZW50KTtcbiAgICBpZihvcHRzLmltcG9ydGFudCkgdGhpcy5pbXBvcnRhbnQgPSB0cnVlO1xuXG4gICAgR2FtZVN0YXRlLm1vbnN0ZXJzLnB1c2godGhpcyk7XG4gIH1cblxuICBhcmVQbGF5ZXJzQVBvc3NpYmlsaXR5KCkge1xuICAgIGNvbnN0IG1pblogPSBfLm1pbihHYW1lU3RhdGUucGxheWVycywgJ3onKS56O1xuICAgIHJldHVybiBtaW5aIDw9IHRoaXMuejtcbiAgfVxuXG4gIGFjdCgpIHtcbiAgICBpZighdGhpcy5hcmVQbGF5ZXJzQVBvc3NpYmlsaXR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZVNlbGYoKSAmJiB0aGlzLmNsZWFuVXAoKTtcbiAgICB9XG4gICAgc3VwZXIuYWN0KCk7XG4gIH1cblxuICBjbGVhblVwKCkge1xuICAgIHN1cGVyLmNsZWFuVXAoKTtcbiAgICB0aGlzLl9hdHRhY2tlZEJ5ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gIH1cblxuICByZW1vdmVTZWxmKCkge1xuICAgIHN1cGVyLnJlbW92ZVNlbGYoKTtcbiAgICBHYW1lU3RhdGUubW9uc3RlcnMgPSBfLndpdGhvdXQoR2FtZVN0YXRlLm1vbnN0ZXJzLCB0aGlzKTtcbiAgICB0aGlzLmNsZWFuVXAoKTtcbiAgfVxuICBcbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGJhc2UgPSBKU09OLnBhcnNlKHN1cGVyLnRvSlNPTigpKTtcbiAgICBjb25zdCBtZSA9IF8ub21pdChiYXNlLCAndGFyZ2V0Jyk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1lKTtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcbmltcG9ydCBDaGFyYWN0ZXIgZnJvbSAnLi9jaGFyYWN0ZXInO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL2NvbnN0YW50cy9zZXR0aW5ncyc7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uL2luaXQvZ2FtZXN0YXRlJztcbmltcG9ydCBNb25zdGVyU3Bhd25lciBmcm9tICcuLi93b3JsZGdlbi9tb25zdGVyLXNwYXduZXInO1xuaW1wb3J0ICogYXMgQmVoYXZpb3JzIGZyb20gJy4uL2NvbnRlbnQvYmVoYXZpb3JzL19hbGwnO1xuaW1wb3J0IEZhY3Rpb25zIGZyb20gJy4uL2NvbnN0YW50cy9mYWN0aW9ucyc7XG5pbXBvcnQgeyBFbnRpdGllcyBhcyBHbHlwaHMgfSBmcm9tICcuLi9jb25zdGFudHMvZ2x5cGhzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyIGV4dGVuZHMgQ2hhcmFjdGVyIHtcbiAgXG4gIGNvbnN0cnVjdG9yKHgsIHksIHosIG9wdHMgPSB7fSkge1xuICAgIG9wdHMuc3RhdHMgPSB7IGJlaGF2aW9yczogW1xuICAgICAgQmVoYXZpb3JzLkF0dGFja3MoKSwgQmVoYXZpb3JzLkludGVyYWN0cygpLCBCZWhhdmlvcnMuUGlja1VwSXRlbXMoKSxcbiAgICAgIEJlaGF2aW9ycy5Ecm9wc0dvbGQoJzBkMCcpLCBCZWhhdmlvcnMuSGVhbHNCZWxvd1BlcmNlbnQoNTApLFxuICAgICAgQmVoYXZpb3JzLkFsZXJ0c09uU3RlcCgpLCBCZWhhdmlvcnMuRHJvcHNJdGVtcygpXG4gICAgXSB9O1xuICAgIHN1cGVyKHsga2V5OiBHbHlwaHMuUGxheWVyIH0sIHgsIHksIHosIG9wdHMpO1xuICAgIHRoaXMuZmFjdGlvbnMucHVzaChGYWN0aW9ucy5QTEFZRVIpO1xuICAgIHRoaXMuYW50aUZhY3Rpb25zLnB1c2goRmFjdGlvbnMuTU9OU1RFUik7XG4gICAgdGhpcy5zcGF3blN0ZXBzID0gU2V0dGluZ3MuZ2FtZS5zcGF3blN0ZXBzOyAvLyBzcGF3biBjcmVhdHVyZXMgZXZlcnkgMTAwIHN0ZXBzXG4gICAgdGhpcy50b3RhbFhwRWFybmVkID0gMDtcbiAgICB0aGlzLnRvdGFsS3BFYXJuZWQgPSAwO1xuICAgIHRoaXMuY29ucXVlc3QgPSB7fTtcbiAgICBcbiAgICB0aGlzLm5hbWUgPSBfLnRydW5jKHRoaXMubmFtZSwgeyBsZW5ndGg6IFNldHRpbmdzLmdhbWUubmFtZUxlbmd0aCwgb21pc3Npb246ICcnIH0pO1xuICAgIHRoaXMuYnJva2VuQ29uZHVjdC5zdHViYm9ybiA9IGZhbHNlO1xuICAgIHRoaXMuZ2V0RGVmYXVsdEV4cGxvcmVCZWhhdmlvcihvcHRzLnRlbXBsYXRlKTtcbiAgfVxuXG4gIGdldERlZmF1bHRFeHBsb3JlQmVoYXZpb3IodGVtcGxhdGUpIHtcbiAgICBjb25zdCBiZWhhdmlvcnMgPSB7XG4gICAgICBXYW5kZXI6IEJlaGF2aW9ycy5XYW5kZXJzLFxuICAgICAgRXhwbG9yZTogQmVoYXZpb3JzLkV4cGxvcmVzRHVuZ2VvblxuICAgIH07XG4gICAgdGhpcy5iZWhhdmlvcnMucHVzaChiZWhhdmlvcnNbdGVtcGxhdGUuYWkgfHwgJ0V4cGxvcmUnXSgpKTtcbiAgfVxuICBcbiAgZ2V0U3Bhd25TdGVwcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0KCdzcGF3blN0ZXBzJyk7XG4gIH1cbiAgXG4gIGdhaW5YcCh4cCkge1xuICAgIHN1cGVyLmdhaW5YcCh4cCk7XG4gICAgdGhpcy50b3RhbFhwRWFybmVkICs9IHhwO1xuICB9XG4gIFxuICBraWxsKGRlYWQpIHtcbiAgICBzdXBlci5raWxsKGRlYWQpO1xuICAgIHRoaXMudG90YWxLcEVhcm5lZCArPSB+fihkZWFkLmRpZmZpY3VsdHkgKiBNYXRoLm1pbihkZWFkLmtpbGxYcC9TZXR0aW5ncy5nYW1lLmtpbGxYcERpdmlzb3IsIDEpKTtcbiAgICBpZighdGhpcy5jb25xdWVzdFtkZWFkLm5hbWVdKSB0aGlzLmNvbnF1ZXN0W2RlYWQubmFtZV0gPSAwO1xuICAgIHRoaXMuY29ucXVlc3RbZGVhZC5uYW1lXSsrO1xuICAgIFxuICAgIC8vIHByb2JhYmx5IHJlZmFjdG9yIHRoaXMgaW50byBhIGxvc2UvZ2FpbkFsaWduIGFuZCBzb21lIGNvbnN0YW50cyBmb3IgY29tbW9uIG9jY3VycmVuY2VzXG4gICAgaWYoZGVhZC5oYXNGYWN0aW9uKEZhY3Rpb25zLlBMQVlFUikpIHtcbiAgICAgIHRoaXMuYWxpZ24gLT0gNTA7XG4gICAgfVxuICB9XG4gIFxuICBhY3QoKSB7XG4gICAgaWYoR2FtZVN0YXRlLmdhbWUuY2hlY2tXaW4oKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgZW5naW5lID0gR2FtZVN0YXRlLmdhbWUuZW5naW5lO1xuICAgIGVuZ2luZS5sb2NrKCk7XG5cbiAgICBjb25zdCBsaXZpbmdQbGF5ZXJzID0gXy5yZWplY3QoR2FtZVN0YXRlLnBsYXllcnMsIChwbGF5ZXIpID0+IHBsYXllci5ocC5hdE1pbigpKTtcblxuICAgIGlmKCFHYW1lU3RhdGUubWFudWFsTW92ZSkge1xuICAgICAgc3VwZXIuYWN0KCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBlbmdpbmUudW5sb2NrKCk7IH0sIFNldHRpbmdzLmdhbWUudHVybkRlbGF5L2xpdmluZ1BsYXllcnMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXRoID0gdGhpcy5yZWJ1aWxkUGF0aGluZ01hcCgpO1xuICAgIFxuICAgIGlmKHRoaXMuY3VycmVudFR1cm4gJSB0aGlzLmdldFNwYXduU3RlcHMoKSA9PT0gMCkge1xuICAgICAgdGhpcy5zcGF3bk1vbnN0ZXIoKTtcbiAgICB9XG5cbiAgICAvLyByZWRyYXcgY291bnRlciwgc28gd2UgZG9uJ3QgcmVkcmF3IG9uY2UgcGVyIHBsYXllciB0dXJuLCBqdXN0IG9uY2UgZm9yIGV2ZXJ5IHBsYXllciB0dXJuXG4gICAgR2FtZVN0YXRlLnBsYXllclR1cm5zVGFrZW4rKztcblxuICAgIGlmKEdhbWVTdGF0ZS5wbGF5ZXJUdXJuc1Rha2VuID49IEdhbWVTdGF0ZS5saXZpbmdQbGF5ZXJzKSB7XG4gICAgICBHYW1lU3RhdGUuZ2FtZS5yZWZyZXNoKCk7XG4gICAgICBHYW1lU3RhdGUuZW1pdCgncmVkcmF3Jyk7XG5cbiAgICAgIEdhbWVTdGF0ZS5wbGF5ZXJUdXJuc1Rha2VuID0gMDtcbiAgICB9XG4gIH1cbiAgXG4gIHJlYnVpbGRQYXRoaW5nTWFwKHRhcmdldFggPSB0aGlzLngsIHRhcmdldFkgPSB0aGlzLnkpIHtcbiAgICBjb25zdCBjYW5QYXNzID0gKHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IEdhbWVTdGF0ZS53b3JsZC5nZXRFbnRpdHkoeCwgeSwgdGhpcy56KTtcbiAgICAgIGNvbnN0IGlzQXR0YWNrYWJsZSA9IGVudGl0eSAmJiB0aGlzLmNhbkF0dGFjayhlbnRpdHkpO1xuICAgICAgY29uc3QgaXNNZSA9IHRoaXMueCA9PT0geCAmJiB0aGlzLnkgPT09IHk7XG4gICAgICBjb25zdCBpc1BsYXllciA9IGVudGl0eSAmJiBlbnRpdHkuY29uc3RydWN0b3IubmFtZSA9PT0gJ1BsYXllcic7XG4gICAgICByZXR1cm4gR2FtZVN0YXRlLndvcmxkLmlzVGlsZVBhc3NhYmxlKHgsIHksIHRoaXMueikgfHwgaXNQbGF5ZXIgfHwgaXNNZSB8fCBpc0F0dGFja2FibGU7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gbmV3IFJPVC5QYXRoLkRpamtzdHJhKHRhcmdldFgsIHRhcmdldFksIGNhblBhc3MsIHsgdG9wb2xvZ3k6IDggfSk7XG4gIH1cblxuICBzaW1wbGVQYXRoaW5nTWFwKHRhcmdldFggPSB0aGlzLngsIHRhcmdldFkgPSB0aGlzLnkpIHtcbiAgICBjb25zdCBjYW5QYXNzID0gKHgsIHkpID0+IEdhbWVTdGF0ZS53b3JsZC5pc1RpbGVQYXNzYWJsZSh4LCB5LCB0aGlzLnopO1xuICAgIHJldHVybiBuZXcgUk9ULlBhdGguRGlqa3N0cmEodGFyZ2V0WCwgdGFyZ2V0WSwgY2FuUGFzcywgeyB0b3BvbG9neTogOCB9KTtcbiAgfVxuICBcbiAgZGllKGtpbGxlcikge1xuICAgIHN1cGVyLmRpZShraWxsZXIpO1xuXG4gICAgR2FtZVN0YXRlLmVtaXQoJ3JlZHJhdycpO1xuICAgIEdhbWVTdGF0ZS5lbWl0KCdkaWUnLCB0aGlzKTtcbiAgICBHYW1lU3RhdGUubGl2aW5nUGxheWVycy0tO1xuXG4gICAgaWYoXy5ldmVyeShHYW1lU3RhdGUucGxheWVycywgKHBsYXllcikgPT4gcGxheWVyLmhwLmF0TWluKCkpKSB7XG4gICAgICBHYW1lU3RhdGUuZ2FtZS5nYW1lT3ZlcigpO1xuICAgICAgR2FtZVN0YXRlLmdhbWUuZW5naW5lLmxvY2soKTtcbiAgICB9XG4gIH1cblxuICBjbGVhblVwKCkge1xuICAgIHN1cGVyLmNsZWFuVXAoKTtcbiAgICB0aGlzLl9wYXRoID0gbnVsbDtcbiAgfVxuICBcbiAgc3Bhd25Nb25zdGVyKCkge1xuICAgIE1vbnN0ZXJTcGF3bmVyLnNwYXduKHRoaXMpO1xuICB9XG4gIFxuICBkZXNjZW5kKCkge1xuICAgIGlmKEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3IrMSA9PT0gR2FtZVN0YXRlLndvcmxkLmRlcHRoKSByZXR1cm47XG4gICAgY29uc3QgbmV3Rmxvb3IgPSBHYW1lU3RhdGUuY3VycmVudEZsb29yID0gR2FtZVN0YXRlLmN1cnJlbnRGbG9vcisxO1xuICAgIGNvbnN0IHN0YWlycyA9IEdhbWVTdGF0ZS53b3JsZC5zdGFpcnNbbmV3Rmxvb3JdLnVwO1xuXG4gICAgXy5lYWNoKEdhbWVTdGF0ZS5wbGF5ZXJzLCAocGxheWVyKSA9PiB7XG4gICAgICBpZihwbGF5ZXIuaHAuYXRNaW4oKSkgcmV0dXJuO1xuICAgICAgR2FtZVN0YXRlLndvcmxkLm1vdmVFbnRpdHkocGxheWVyLCBzdGFpcnNbMF0sIHN0YWlyc1sxXSwgbmV3Rmxvb3IpO1xuICAgICAgcGxheWVyLnN0ZXBSYW5kb21seSgpO1xuICAgICAgcGxheWVyLmRvQmVoYXZpb3IoJ2Rlc2NlbmQnKTtcbiAgICB9KTtcblxuICAgIEdhbWVTdGF0ZS53b3JsZC5kZXNjZW5kKCk7XG4gICAgR2FtZVN0YXRlLmVtaXQoJ2Rlc2NlbmQnKTtcbiAgfVxuICBcbiAgYXNjZW5kKCkge1xuICAgIEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3ItLTtcbiAgfVxuICBcbiAgZ2V0U2NvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFR1cm4gKyB0aGlzLmdvbGQgKyB0aGlzLnRvdGFsWHBFYXJuZWQ7XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbG9hZFZhbHVlIGZyb20gJy4uL2xpYi92YWx1ZS1hc3NpZ24nO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL2NvbnN0YW50cy9zZXR0aW5ncyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2Zlc3Npb24ge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIGNvbmZpZyA9IF8uZXh0ZW5kKHt9LCBfLmNsb25lRGVlcChTZXR0aW5ncy5nYW1lLmRlZmF1bHRTdGF0cy5wcm9mZXNzaW9uKSwgY29uZmlnKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICBfLmV4dGVuZCh0aGlzLCBjb25maWcsIGxvYWRWYWx1ZSk7XG4gICAgY29uZmlnLmFkZEZhY3Rpb25zLnB1c2godGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICB0aGlzLmxldmVsID0gMTtcbiAgICB0aGlzLnRpdGxlID0gdGhpcy50aXRsZXNbMF07XG4gIH1cbiAgbGV2ZWx1cCgpIHtcbiAgICB0aGlzLmxldmVsKys7XG4gICAgaWYodGhpcy50aXRsZXNbdGhpcy5sZXZlbC0xXSkge1xuICAgICAgdGhpcy50aXRsZSA9IHRoaXMudGl0bGVzW3RoaXMubGV2ZWwtMV07XG4gICAgfVxuICAgIF8odGhpcy5jb25maWcubGV2ZWxVcClcbiAgICAgIC5rZXlzKClcbiAgICAgIC52YWx1ZSgpXG4gICAgICAuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBsb2FkVmFsdWUobnVsbCwgdGhpcy5jb25maWdba2V5XSk7XG4gICAgICAgIHRoaXNba2V5XSArPSB2YWw7XG4gICAgICB9KTtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2FkVmFsdWUgZnJvbSAnLi4vbGliL3ZhbHVlLWFzc2lnbic7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vY29uc3RhbnRzL3NldHRpbmdzJztcbmltcG9ydCBMb2cgZnJvbSAnLi4vbGliL2xvZ2dlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhY2Uge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICB0aGlzLnNsb3RzID0gXy5leHRlbmQoe30sIFNldHRpbmdzLmdhbWUuZGVmYXVsdFN0YXRzLmVxdWlwbWVudFNsb3RzLCBvcHRzLnNsb3RzKTtcbiAgICBfLmV4dGVuZCh0aGlzLCBfLmNsb25lRGVlcChTZXR0aW5ncy5nYW1lLmRlZmF1bHRTdGF0cy5yYWNlKSwgb3B0cy5zdGF0cywgbG9hZFZhbHVlKTtcbiAgICB0aGlzLmFkZEZhY3Rpb25zLnB1c2godGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfVxuICBjYW5FcXVpcChvd25lciwgaXRlbSkge1xuICAgIGlmKCFpdGVtKSB7XG4gICAgICBMb2coJ1JhY2UnLCAnSW52YWxpZCBpdGVtJyk7XG4gICAgfVxuICAgIGNvbnN0IHNsb3QgPSBpdGVtLmdldFBhcmVudFR5cGUoKTtcbiAgICBjb25zdCBzbG90c1Rha2VuID0gb3duZXIuc2xvdHNUYWtlbihzbG90KTtcbiAgICBjb25zdCB0b3RhbFNsb3RzID0gdGhpcy5zbG90c1tzbG90XTtcbiAgICBjb25zdCBpdGVtU2xvdHMgPSBpdGVtLnNsb3RzVGFrZW47XG4gICAgcmV0dXJuIGl0ZW1TbG90cyA8PSB0b3RhbFNsb3RzIC0gc2xvdHNUYWtlbjtcbiAgfVxufSIsIlxuaW1wb3J0IEVudGl0eSBmcm9tICcuL2VudGl0eSc7XG5pbXBvcnQgeyBXZWlnaHRlZEV4dGVuc2lvbiB9IGZyb20gJy4uL2xpYi9yb3QtZXh0ZW5zaW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGUgZXh0ZW5kcyBFbnRpdHkge1xuICBjb25zdHJ1Y3RvcihrZXksIGZnLCBiZykge1xuICAgIHN1cGVyKHsga2V5OiBrZXksIGZnOiBmZywgYmc6IGJnIH0pO1xuICAgIHRoaXMuZGVuc2l0eSA9IDA7XG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLnJlZmxlY3QgPSAwLjM7XG4gIH1cblxuICBjZWFzZUV4aXN0aW5nKCkge1xuICAgIHRoaXMuZ2x5cGgua2V5ID0gJy4nO1xuICAgIHRoaXMuZ2x5cGguZmcgPSAnJztcbiAgICB0aGlzLmdseXBoLmJnID0gJyc7XG4gICAgdGhpcy5jYW5JbnRlcmFjdCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldFJhbmRvbUVmZmVjdChlZmZlY3RzKSB7XG4gICAgcmV0dXJuIFdlaWdodGVkRXh0ZW5zaW9uKGVmZmVjdHMpLnZhbHVlO1xuICB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFpdCB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBfLmV4dGVuZCh0aGlzLCB7IGxldmVsOiAxLCByZXE6IDAgfSwgb3B0cyk7XG4gIH1cblxuICBjYW5Vc2UoZW50aXR5KSB7XG4gICAgcmV0dXJuIGVudGl0eS5sZXZlbCA+PSB0aGlzLnJlcTtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vaW5pdC9nYW1lc3RhdGUnO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL2NvbnN0YW50cy9zZXR0aW5ncyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc3NhZ2VRdWV1ZSB7XG4gIHN0YXRpYyBhZGQobWVzc2FnZU9iaikge1xuXG4gICAgLy8gYXR0ZW1wdCB0byBoaWRlIG1lc3NhZ2VzIGZyb20gZW5lbWllcyB0aGF0IGFyZSB0b28gZmFyIGF3YXkgdGhhdCBpbnRlcmFjdCB3aXRoIHN0dWZmLCBpZiBhcHBsaWNhYmxlXG4gICAgaWYobWVzc2FnZU9iai5lbnRpdHkpIHtcbiAgICAgIGxldCBpc0luUmFuZ2UgPSBmYWxzZTtcbiAgICAgIF8uZWFjaChHYW1lU3RhdGUucGxheWVycywgcGxheWVyID0+IHtcbiAgICAgICAgaWYocGxheWVyLmRpc3RCZXR3ZWVuKG1lc3NhZ2VPYmouZW50aXR5KSA8PSBwbGF5ZXIuZ2V0U2lnaHQoKSkgaXNJblJhbmdlID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYoIWlzSW5SYW5nZSkgcmV0dXJuO1xuICAgIH1cbiAgICBHYW1lU3RhdGUubWVzc2FnZXMudW5zaGlmdCh7IHR1cm5zTGVmdDogU2V0dGluZ3MuZ2FtZS5kaXNwbGF5LnR1cm5zLCBtZXNzYWdlOiBtZXNzYWdlT2JqLm1lc3NhZ2UgfSk7XG4gICAgR2FtZVN0YXRlLm1lc3NhZ2VzLmxlbmd0aCA9IFNldHRpbmdzLmdhbWUuZGlzcGxheS5sb2c7IC8vIGNhcCB0aGUgbWVzc2FnZXMgb2ZmIGF0IHRoZSBsYXN0IDUwXG4gICAgbWVzc2FnZU9iai50dXJuID0gXy5tYXgoXy5wbHVjayhHYW1lU3RhdGUucGxheWVycywgJ2N1cnJlbnRUdXJuJykpO1xuICAgIEdhbWVTdGF0ZS5lbWl0KCdsb2cnLCBtZXNzYWdlT2JqKTtcbiAgfVxuICBcbiAgc3RhdGljIHZpZXdBbGxNZXNzYWdlcygpIHtcbiAgICBHYW1lU3RhdGUubWVzc2FnZXMgPSBfKEdhbWVTdGF0ZS5tZXNzYWdlcylcbiAgICAgIC5jb21wYWN0KClcbiAgICAgIC5lYWNoKChtc2cpID0+IG1zZy50dXJuc0xlZnQtLSlcbiAgICAgIC5yZWplY3QoKG1zZykgPT4gbXNnLnR1cm5zTGVmdCA8PSAwKVxuICAgICAgLnZhbHVlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VUeXBlcyA9IHtcbiAgQ09NQkFUOiAnQ29tYmF0JyxcbiAgQ0hBUkFDVEVSOiAnQ2hhcmFjdGVyJyxcbiAgRFVOR0VPTjogJ0R1bmdlb24nLFxuICBNRVRBOiAnTWV0YScsXG4gIElURU06ICdJdGVtJ1xufTsiLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgU0VUVElOR1MgZnJvbSAnLi4vY29uc3RhbnRzL3NldHRpbmdzJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vaW5pdC9nYW1lc3RhdGUnO1xuXG5leHBvcnQgY2xhc3MgU2NyZWVuIHtcbiAgc3RhdGljIGVudGVyKCkge31cbiAgc3RhdGljIGV4aXQoKSAge31cbiAgc3RhdGljIHJlbmRlcigpIHt9XG4gIHN0YXRpYyBoYW5kbGVJbnB1dCgpIHt9XG4gIHN0YXRpYyBkcmF3Q2VudGVyVGV4dChkaXNwbGF5LCB5LCB0ZXh0LCBkaXZpc29yID0gMiwgeE9mZnNldCA9IDApIHtcbiAgICBjb25zdCB4ID0geE9mZnNldCArIE1hdGguZmxvb3IoU0VUVElOR1Muc2NyZWVuLndpZHRoL2Rpdmlzb3IpIC0gTWF0aC5mbG9vcih0ZXh0Lmxlbmd0aC8yKTtcbiAgICBkaXNwbGF5LmRyYXdUZXh0KHgsIHksIHRleHQpO1xuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfVxuICBzdGF0aWMgZHJhd0xlZnRDZW50ZXJUZXh0KGRpc3BsYXksIHksIHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5kcmF3Q2VudGVyVGV4dChkaXNwbGF5LCB5LCB0ZXh0LCA0KTtcbiAgfVxuICBzdGF0aWMgZHJhd1JpZ2h0Q2VudGVyVGV4dChkaXNwbGF5LCB5LCB0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd0NlbnRlclRleHQoZGlzcGxheSwgeSwgdGV4dCwgNCwgU0VUVElOR1Muc2NyZWVuLndpZHRoLzIpO1xuICB9XG4gIHN0YXRpYyBkcmF3TGVmdFRleHQoZGlzcGxheSwgeSwgdGV4dCwgeE9mZnNldCA9IDApIHtcbiAgICBkaXNwbGF5LmRyYXdUZXh0KHhPZmZzZXQsIHksIHRleHQpO1xuICB9XG4gIHN0YXRpYyBkcmF3TGVmdFRleHROb1RyaW0oZGlzcGxheSwgeSwgdGV4dCA9ICcnLCB4T2Zmc2V0ID0gMCkge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkaXNwbGF5LmRyYXcoaSt4T2Zmc2V0LCB5LCB0ZXh0W2ldKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHBhZFRleHQodGV4dCwgd2lkdGgpIHtcbiAgICByZXR1cm4gXy5wYWQodGV4dCwgd2lkdGgpO1xuICB9XG4gIHN0YXRpYyBnZXRNYWluUGxheWVyKCkge1xuICAgIHJldHVybiBfLm1heChHYW1lU3RhdGUucGxheWVycywgJ2N1cnJlbnRUdXJuJyk7XG4gIH1cbiAgc3RhdGljIGNoYW5nZVNjcmVlbldpdGhEZWxheShuZXdTY3JlZW4sIGRlbGF5KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBtdWx0aUNob2ljZSA9IEdhbWVTdGF0ZS5zcGxpdFNjcmVlbiA/IG5ld1NjcmVlbi5tdWx0aSA6IG5ld1NjcmVlbi5zaW5nbGU7XG4gICAgICBjb25zdCBzY3JlZW4gPSBuZXdTY3JlZW4uc2luZ2xlICYmIG5ld1NjcmVlbi5tdWx0aSA/IG11bHRpQ2hvaWNlIDogbmV3U2NyZWVuO1xuICAgICAgR2FtZVN0YXRlLmdhbWUuc3dpdGNoU2NyZWVuKHNjcmVlbik7XG4gICAgfSwgZGVsYXkpO1xuICB9XG59XG5cbmNsYXNzIFNjcm9sbGluZ1NjcmVlbiBleHRlbmRzIFNjcmVlbiB7fVxuZXhwb3J0IGNsYXNzIFNpbmdsZVNjcm9sbGluZ1NjcmVlbiBleHRlbmRzIFNjcm9sbGluZ1NjcmVlbiB7XG4gIHN0YXRpYyBlbnRlcigpIHtcbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IDA7XG4gIH1cbiAgc3RhdGljIHJlbmRlcihkaXNwbGF5KSB7XG4gICAgZGlzcGxheS5jbGVhcigpO1xuICAgIHRoaXMuZHJhd0xlZnRUZXh0KGRpc3BsYXksIDAsIHRoaXMudGl0bGUpO1xuICAgIHRoaXMuZHJhd0xlZnRUZXh0KGRpc3BsYXksIDEsIF8ucmVwZWF0KCctJywgdGhpcy50aXRsZS5sZW5ndGgpKTtcblxuICAgIGNvbnN0IHJlbWFpbmluZ0hlaWdodCA9IFNFVFRJTkdTLnNjcmVlbi5oZWlnaHQgLSAzO1xuICAgIGNvbnN0IHNsaWNlID0gdGhpcy5zY3JvbGxDb250ZW50LnNsaWNlKHRoaXMuY3VycmVudEluZGV4LCByZW1haW5pbmdIZWlnaHQrdGhpcy5jdXJyZW50SW5kZXgpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCByZW1haW5pbmdIZWlnaHQ7IGkrKykge1xuICAgICAgdGhpcy5kcmF3TGVmdFRleHROb1RyaW0oZGlzcGxheSwgaSsyLCBzbGljZVtpXSk7XG4gICAgfVxuICAgIFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYoc2xpY2UubGVuZ3RoIDwgcmVtYWluaW5nSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU2NyZWVuV2l0aERlbGF5KHRoaXMubmV4dFNjcmVlbiwgNDAwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCsrO1xuICAgICAgICB0aGlzLnJlbmRlcihkaXNwbGF5KTtcbiAgICAgIH1cbiAgICB9LCAyMDAwKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3BsaXRTY3JvbGxpbmdTY3JlZW4gZXh0ZW5kcyBTY3JvbGxpbmdTY3JlZW4ge1xuICBzdGF0aWMgZW50ZXIoKSB7XG4gICAgdGhpcy5jdXJyZW50SW5kaWNlcyA9IF8ubWFwKEdhbWVTdGF0ZS5wbGF5ZXJzLCAoKSA9PiAwKTtcblxuICAgIGNvbnN0IHdpZHRoID0gU0VUVElOR1Muc2NyZWVuLndpZHRoIC8gMjtcbiAgICBjb25zdCBoZWlnaHQgPSBHYW1lU3RhdGUucGxheWVycy5sZW5ndGggPiAyID8gKFNFVFRJTkdTLnNjcmVlbi5oZWlnaHQgLyAyKTogU0VUVElOR1Muc2NyZWVuLmhlaWdodDtcblxuICAgIHRoaXMudGxDb29yZHMgPSBbXG4gICAgICB7IHg6IDAsIHk6IDAgfSxcbiAgICAgIHsgeDogd2lkdGgrMSwgeTogMCB9LFxuICAgICAgeyB4OiAwLCB5OiBoZWlnaHQrMSB9LFxuICAgICAgeyB4OiB3aWR0aCsxLCB5OiBoZWlnaHQrMSB9XG4gICAgXTtcbiAgfVxuICBzdGF0aWMgaXNEb25lKCkge1xuICAgIHJldHVybiBfLmV2ZXJ5KHRoaXMuY3VycmVudEluZGljZXMsIChpbmRleCkgPT4gaW5kZXggPT09IHRydWUpO1xuICB9XG5cbiAgc3RhdGljIGRyYXdCb3JkZXIoZGlzcGxheSkge1xuXG4gICAgY29uc3QgbWlkZGxlWCA9IFNFVFRJTkdTLnNjcmVlbi53aWR0aCAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBTRVRUSU5HUy5zY3JlZW4uaGVpZ2h0OyBpKyspIHtcbiAgICAgIGRpc3BsYXkuZHJhdyhtaWRkbGVYLCBpLCAn4oCWJyk7XG4gICAgfVxuXG4gICAgaWYgKEdhbWVTdGF0ZS5wbGF5ZXJzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGNvbnN0IG1pZGRsZVkgPSBTRVRUSU5HUy5zY3JlZW4uaGVpZ2h0IC8gMjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU0VUVElOR1Muc2NyZWVuLndpZHRoOyBpKyspIHtcbiAgICAgICAgZGlzcGxheS5kcmF3KGksIG1pZGRsZVksICc9Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRyYXdMaXN0KGRpc3BsYXksIHBsYXllckluZGV4KSB7XG5cbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnRsQ29vcmRzW3BsYXllckluZGV4XTtcblxuICAgIHRoaXMuZHJhd0xlZnRUZXh0KGRpc3BsYXksIG9mZnNldC55LCB0aGlzLnRpdGxlW3BsYXllckluZGV4XSwgb2Zmc2V0LngpO1xuICAgIHRoaXMuZHJhd0xlZnRUZXh0KGRpc3BsYXksIG9mZnNldC55KzEsIF8ucmVwZWF0KCctJywgdGhpcy50aXRsZVtwbGF5ZXJJbmRleF0ubGVuZ3RoKSwgb2Zmc2V0LngpO1xuXG4gICAgY29uc3QgcmVtYWluaW5nSGVpZ2h0ID0gKEdhbWVTdGF0ZS5wbGF5ZXJzLmxlbmd0aCA+IDIgPyAoU0VUVElOR1Muc2NyZWVuLmhlaWdodCAvIDIpOiBTRVRUSU5HUy5zY3JlZW4uaGVpZ2h0KSAtIDM7XG4gICAgY29uc3Qgc2xpY2UgPSB0aGlzLnNjcm9sbENvbnRlbnRbcGxheWVySW5kZXhdLnNsaWNlKHRoaXMuY3VycmVudEluZGljZXNbcGxheWVySW5kZXhdLCByZW1haW5pbmdIZWlnaHQrdGhpcy5jdXJyZW50SW5kaWNlc1twbGF5ZXJJbmRleF0pO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCByZW1haW5pbmdIZWlnaHQ7IGkrKykge1xuICAgICAgdGhpcy5kcmF3TGVmdFRleHROb1RyaW0oZGlzcGxheSwgb2Zmc2V0LnkraSsyLCBzbGljZVtpXSwgb2Zmc2V0LngpO1xuICAgIH1cblxuICAgIGlmKHNsaWNlLmxlbmd0aCA8IHJlbWFpbmluZ0hlaWdodCkgdGhpcy5jdXJyZW50SW5kaWNlc1twbGF5ZXJJbmRleF0gPSB0cnVlO1xuICB9XG5cbiAgc3RhdGljIHJlbmRlcihkaXNwbGF5KSB7XG4gICAgZGlzcGxheS5jbGVhcigpO1xuXG4gICAgXy5lYWNoKHRoaXMuY3VycmVudEluZGljZXMsICh2YWx1ZSwgaSkgPT4ge1xuICAgICAgdGhpcy5kcmF3TGlzdChkaXNwbGF5LCBpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZHJhd0JvcmRlcihkaXNwbGF5KTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYodGhpcy5pc0RvbmUoKSkge1xuICAgICAgICB0aGlzLmNoYW5nZVNjcmVlbldpdGhEZWxheSh0aGlzLm5leHRTY3JlZW4sIDYwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kaWNlcyA9IF8ubWFwKHRoaXMuY3VycmVudEluZGljZXMsIChpbmRleCkgPT4gaW5kZXggPT09IHRydWUgPyB0cnVlIDogaW5kZXggKyAxKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoZGlzcGxheSk7XG4gICAgICB9XG4gICAgfSwgMjAwMCk7XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBTaW5nbGVTY3JvbGxpbmdTY3JlZW4sIFNwbGl0U2Nyb2xsaW5nU2NyZWVuIH0gZnJvbSAnLi4vc2NyZWVuJztcbmltcG9ydCBSZXNwYXduU2NyZWVuIGZyb20gJy4vcmVzcGF3bic7XG5pbXBvcnQgQ29uZHVjdENhbGMgZnJvbSAnLi4vLi4vY29uc3RhbnRzL2NvbmR1Y3RzJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vaW5pdC9nYW1lc3RhdGUnO1xuXG5leHBvcnQgY2xhc3MgU2luZ2xlQ29uZHVjdFNjcmVlbiBleHRlbmRzIFNpbmdsZVNjcm9sbGluZ1NjcmVlbiB7XG4gIHN0YXRpYyBlbnRlcigpIHtcbiAgICBzdXBlci5lbnRlcigpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0TWFpblBsYXllcigpO1xuICAgIGNvbnN0IHNvcnRlZENvbmR1Y3QgPSBDb25kdWN0Q2FsYyh0YXJnZXQpO1xuICAgIHRoaXMuc2Nyb2xsQ29udGVudCA9IHNvcnRlZENvbmR1Y3Q7XG4gICAgdGhpcy50aXRsZSA9IGAke3RhcmdldC5uYW1lfSdzIFRyYWl0cyAoJHtzb3J0ZWRDb25kdWN0Lmxlbmd0aH0pYDsgLy8gc2hvcnRlbiB0aGlzIGZvciBzcGxpdHNjcmVlblxuICAgIHRoaXMubmV4dFNjcmVlbiA9IFJlc3Bhd25TY3JlZW47XG4gIH1cbiAgLy8gc3RhdGljIGdldCBzcGxpdCgpIHsgcmV0dXJuIFNwbGl0Q29uZHVjdFNjcmVlbjsgfVxufVxuXG5leHBvcnQgY2xhc3MgU3BsaXRDb25kdWN0U2NyZWVuIGV4dGVuZHMgU3BsaXRTY3JvbGxpbmdTY3JlZW4ge1xuICBzdGF0aWMgZW50ZXIoKSB7XG4gICAgc3VwZXIuZW50ZXIoKTtcbiAgICB0aGlzLnNjcm9sbENvbnRlbnQgPSBbXTtcbiAgICB0aGlzLnRpdGxlID0gW107XG5cbiAgICBfLmVhY2goR2FtZVN0YXRlLnBsYXllcnMsICh0YXJnZXQsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNvcnRlZENvbmR1Y3QgPSBDb25kdWN0Q2FsYyh0YXJnZXQpO1xuICAgICAgdGhpcy5zY3JvbGxDb250ZW50W2ldID0gc29ydGVkQ29uZHVjdDtcbiAgICAgIHRoaXMudGl0bGVbaV0gPSBgJHt0YXJnZXQubmFtZX0ncyBUcmFpdHMgKCR7c29ydGVkQ29uZHVjdC5sZW5ndGh9KWA7IC8vIHNob3J0ZW4gdGhpcyBmb3Igc3BsaXRzY3JlZW5cbiAgICB9KTtcblxuICAgIHRoaXMubmV4dFNjcmVlbiA9IFJlc3Bhd25TY3JlZW47XG4gIH1cbiAgLy8gc3RhdGljIGdldCBzcGxpdCgpIHsgcmV0dXJuIFNpbmdsZUNvbmR1Y3RTY3JlZW47IH1cbn1cbiIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFNjcmVlbiB9IGZyb20gJy4uL3NjcmVlbic7XG5pbXBvcnQgeyBTaW5nbGVWYW5xdWlzaGVkU2NyZWVuLCBTcGxpdFZhbnF1aXNoZWRTY3JlZW4gfSBmcm9tICcuL3ZhbnF1aXNoZWQnO1xuaW1wb3J0IEdhbWVTdGF0ZSBmcm9tICcuLi8uLi9pbml0L2dhbWVzdGF0ZSc7XG5pbXBvcnQgQ2hhbmdlVGl0bGUgZnJvbSAnLi4vLi4vbGliL3BhZ2UtdGl0bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWFkU2NyZWVuIGV4dGVuZHMgU2NyZWVuIHtcbiAgc3RhdGljIGVudGVyKCkge1xuICAgIEdhbWVTdGF0ZS5nYW1lLmVuZ2luZS5sb2NrKCk7XG4gICAgdGhpcy5jaGFuZ2VTY3JlZW5XaXRoRGVsYXkoeyBzaW5nbGU6IFNpbmdsZVZhbnF1aXNoZWRTY3JlZW4sIG11bHRpOiBTcGxpdFZhbnF1aXNoZWRTY3JlZW4gfSwgNTAwMCk7XG4gIH1cbiAgc3RhdGljIHJlbmRlcihkaXNwbGF5KSB7XG4gICAgY29uc3QgVE9NQlNUT05FX1dJRFRIID0gMjY7XG4gICAgY29uc3QgZ29vZGJ5ZXMgPSBbJ0dvb2RieWUnLCAnU2F5b25hcmEnLCAnQ2lhbycsICdBZGlvcycsICdUb29kbGVzJywgJ1RhIHRhJywgJ0ZhcmV3ZWxsJywgJ0J5ZS1ieWUnLCAnQnllJywgJ1NvIGxvbmcnLCAnUklQJ107XG5cbiAgICBjb25zdCBsYXRlc3REZWF0aCA9IHRoaXMuZ2V0TWFpblBsYXllcigpO1xuICAgIGNvbnN0IHNjb3JlID0gbGF0ZXN0RGVhdGguZ2V0U2NvcmUoKTtcbiAgICBjb25zdCBmbG9vciA9IEdhbWVTdGF0ZS5jdXJyZW50Rmxvb3IgKyAxO1xuICAgIGNvbnN0IHBhZGRlZE5hbWUgPSB0aGlzLnBhZFRleHQobGF0ZXN0RGVhdGgubmFtZSwgVE9NQlNUT05FX1dJRFRIKTtcbiAgICBjb25zdCBwYWRkZWRTY29yZSA9IHRoaXMucGFkVGV4dChgU2NvcmU6ICR7c2NvcmV9YCwgVE9NQlNUT05FX1dJRFRIKTtcbiAgICBjb25zdCBwYWRkZWRLaWxsZXIgPSB0aGlzLnBhZFRleHQobGF0ZXN0RGVhdGgua2lsbGVyTmFtZSwgVE9NQlNUT05FX1dJRFRIKTtcblxuICAgIGNvbnN0IGdvb2RieWUgPSBfLnNhbXBsZShnb29kYnllcyk7XG4gICAgY29uc3QgbWFwTmFtZSA9IEdhbWVTdGF0ZS53b3JsZC50aWxlc1tHYW1lU3RhdGUuY3VycmVudEZsb29yXS5tYXBOYW1lO1xuICAgIGxldCBpID0gMztcblxuICAgIHRoaXMuZHJhd0NlbnRlclRleHQoZGlzcGxheSwgaSsrLCAgICAgICAgICAgICAgICBgLS0tLS0tLS0tLS0tLS0tLS0tYCk7XG4gICAgdGhpcy5kcmF3Q2VudGVyVGV4dChkaXNwbGF5LCBpKyssICAgICAgICAgICAgICAgJy8gICAgICAgICAgICAgICAgICBcXFxcJyk7XG4gICAgdGhpcy5kcmF3Q2VudGVyVGV4dChkaXNwbGF5LCBpKyssICAgICAgICAgICAgICAnLyAgICAgICAgUkVTVCAgICAgICAgXFxcXCcpO1xuICAgIHRoaXMuZHJhd0NlbnRlclRleHQoZGlzcGxheSwgaSsrLCAgICAgICAgICAgICAnLyAgICAgICAgICBJTiAgICAgICAgICBcXFxcJyk7XG4gICAgdGhpcy5kcmF3Q2VudGVyVGV4dChkaXNwbGF5LCBpKyssICAgICAgICAgICAgJy8gICAgICAgICBQT0lOVFMgICAgICAgICBcXFxcJyk7XG4gICAgdGhpcy5kcmF3Q2VudGVyVGV4dChkaXNwbGF5LCBpKyssICAgICAgICAgICAnLyAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXCcpO1xuICAgIHRoaXMuZHJhd0NlbnRlclRleHQoZGlzcGxheSwgaSsrLCAgICAgICAgICAgYHwke3BhZGRlZE5hbWV9fGApO1xuICAgIHRoaXMuZHJhd0NlbnRlclRleHQoZGlzcGxheSwgaSsrLCAgICAgICAgICAgYHwke3BhZGRlZFNjb3JlfXxgKTtcbiAgICB0aGlzLmRyYXdDZW50ZXJUZXh0KGRpc3BsYXksIGkrKywgICAgICAgICAgIGB8ICAgICAgICAgICAgICAgICAgICAgICAgICB8YCk7XG4gICAgdGhpcy5kcmF3Q2VudGVyVGV4dChkaXNwbGF5LCBpKyssICAgICAgICAgICBgfCAgICAgICAgIHNsYWluIGJ5ICAgICAgICAgfGApO1xuICAgIHRoaXMuZHJhd0NlbnRlclRleHQoZGlzcGxheSwgaSsrLCAgICAgICAgICAgYHwke3BhZGRlZEtpbGxlcn18YCk7XG4gICAgdGhpcy5kcmF3Q2VudGVyVGV4dChkaXNwbGF5LCBpKyssICAgICAgICAgICBgfCAgICAgICAgICAgICAgICAgICAgICAgICAgfGApO1xuICAgIHRoaXMuZHJhd0NlbnRlclRleHQoZGlzcGxheSwgaSsrLCAgICAgIGAmICAqIHwgICAgICAqICAgICAgICAgICAgICAgICAgICQgICAgICpgKTtcbiAgICB0aGlzLmRyYXdDZW50ZXJUZXh0KGRpc3BsYXksIGkrKywgICBgX19cXFxcXFxcXCkvX11ffF9fX19cXFxcXFxcXChcXFxcXFxcXF9fX19fLy9cXFxcL19fX19fX19cXFxcey9fX19ffF9fX19gKTtcblxuICAgIGkrKztcblxuICAgIHRoaXMuZHJhd0xlZnRUZXh0KGRpc3BsYXksIGkrKywgICAgIGAke2dvb2RieWV9LCAke2xhdGVzdERlYXRoLm5hbWV9IHRoZSAke2xhdGVzdERlYXRoLmdldEFsaWduKCl9ICR7bGF0ZXN0RGVhdGguZ2VuZGVyfSAke2xhdGVzdERlYXRoLnJhY2V9ICR7bGF0ZXN0RGVhdGgucHJvZmVzc2lvbn0uLi5gKTtcbiAgICB0aGlzLmRyYXdMZWZ0VGV4dChkaXNwbGF5LCBpKyssICAgICBgWW91IHdlcmUgbGV2ZWwgJHtsYXRlc3REZWF0aC5sZXZlbH0gYWZ0ZXIgZWFybmluZyAke2xhdGVzdERlYXRoLnRvdGFsWHBFYXJuZWR9IGV4cGVyaWVuY2UuYCk7XG4gICAgdGhpcy5kcmF3TGVmdFRleHQoZGlzcGxheSwgaSsrLCAgICAgYFlvdSBkaWVkIGluICR7bWFwTmFtZX0gb24gZHVuZ2VvbiBsZXZlbCAke2Zsb29yfS5gKTtcbiAgICB0aGlzLmRyYXdMZWZ0VGV4dChkaXNwbGF5LCBpKyssICAgICBgWW91IHNjb3JlZCAke3Njb3JlfSBwb2ludHMgYW5kICR7bGF0ZXN0RGVhdGguZ29sZH0gZ29sZCBvdmVyICR7bGF0ZXN0RGVhdGguY3VycmVudFR1cm59IHN0ZXBzLmApO1xuICAgIHRoaXMuZHJhd0xlZnRUZXh0KGRpc3BsYXksIGkrKywgICAgIGBZb3UgZWFybmVkICR7R2FtZVN0YXRlLnNwRWFybmVkfSBTUCBhbmQgJHtHYW1lU3RhdGUua3BFYXJuZWR9IEtQLmApO1xuXG4gICAgQ2hhbmdlVGl0bGUoJ0RlYWQnKTtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcbmltcG9ydCB7IFNjcmVlbiB9IGZyb20gJy4uL3NjcmVlbic7XG5pbXBvcnQgTWVzc2FnZVF1ZXVlIGZyb20gJy4uL21lc3NhZ2UtaGFuZGxlcic7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uLy4uL2luaXQvZ2FtZXN0YXRlJztcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi8uLi9jb25zdGFudHMvc2V0dGluZ3MnO1xuaW1wb3J0IENoYW5nZVRpdGxlIGZyb20gJy4uLy4uL2xpYi9wYWdlLXRpdGxlJztcblxuZXhwb3J0IGNsYXNzIEdhbWVTY3JlZW4gZXh0ZW5kcyBTY3JlZW4ge1xuXG4gIHN0YXRpYyBnZXRTY3JlZW5PZmZzZXRzKGNlbnRlclBvaW50ID0gR2FtZVN0YXRlLnBsYXllcnNbMF0sIHdpZHRoID0gU2V0dGluZ3Muc2NyZWVuLndpZHRoLCBoZWlnaHQgPSBTZXR0aW5ncy5zY3JlZW4uaGVpZ2h0KSB7XG4gICAgbGV0IHRvcExlZnRYID0gTWF0aC5tYXgoMCwgY2VudGVyUG9pbnQueCAtIE1hdGgucm91bmQod2lkdGgvMikpO1xuICAgIHRvcExlZnRYID0gTWF0aC5taW4odG9wTGVmdFgsIEdhbWVTdGF0ZS53b3JsZC53aWR0aCAtIHdpZHRoKTtcblxuICAgIGxldCB0b3BMZWZ0WSA9IE1hdGgubWF4KDAsIGNlbnRlclBvaW50LnkgLSBNYXRoLnJvdW5kKGhlaWdodC8yKSk7XG4gICAgdG9wTGVmdFkgPSBNYXRoLm1pbih0b3BMZWZ0WSwgR2FtZVN0YXRlLndvcmxkLmhlaWdodCAtIGhlaWdodCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogdG9wTGVmdFgsXG4gICAgICB5OiB0b3BMZWZ0WVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZHJhd1RpbGVzKGRpc3BsYXksIGNlbnRlclBvaW50LCBvcHRpb25zID0geyB3aWR0aDogU2V0dGluZ3Muc2NyZWVuLndpZHRoLCBoZWlnaHQ6IFNldHRpbmdzLnNjcmVlbi5oZWlnaHQsIG9mZnNldDogdGhpcy5nZXRTY3JlZW5PZmZzZXRzKCksIGdhbWVPZmZzZXQ6IHsgeDogMCwgeTogMCB9IH0pIHtcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgb2Zmc2V0LCBnYW1lT2Zmc2V0IH0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgdmlzaWJsZSA9IFtdO1xuXG4gICAgY29uc3Qgd29ybGQgPSBHYW1lU3RhdGUud29ybGQ7XG4gICAgY29uc3QgekxldmVsID0gY2VudGVyUG9pbnQuejtcblxuICAgIGNvbnN0IGlzRGVhZCA9IGNlbnRlclBvaW50LmhwLmF0TWluKCk7XG5cbiAgICBjb25zdCBmb3YgPSB3b3JsZC5mb3ZbekxldmVsXTtcbiAgICBmb3YuY29tcHV0ZShcbiAgICAgIGNlbnRlclBvaW50LngsIGNlbnRlclBvaW50LnksIGlzRGVhZCA/IDEgOiBjZW50ZXJQb2ludC5nZXRTaWdodCgpLFxuICAgICAgKHgsIHkpID0+IHtcbiAgICAgICAgaWYoIXZpc2libGVbeF0pIHZpc2libGVbeF0gPSBbXTtcbiAgICAgICAgdmlzaWJsZVt4XVt5XSA9IHRydWU7XG4gICAgICAgIHdvcmxkLnNldEV4cGxvcmVkKHgsIHksIHpMZXZlbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIGxldCBjYWNoZSA9IHt9O1xuICAgIF8uZWFjaChbJ1RlbGVwYXRoeScsICdDbGFpcnZveWFuY2UnLCAnV2FybmluZyddLCAodHJhaXQpID0+IGNhY2hlW3RyYWl0XSA9IGNlbnRlclBvaW50LmdldFRyYWl0VmFsdWUodHJhaXQpKTtcblxuICAgIGxldCBwcm9qZWN0aWxlQ2FjaGUgPSB7fTtcbiAgICBfLmVhY2goR2FtZVN0YXRlLnByb2plY3RpbGVzLCAocHJvaikgPT4gcHJvamVjdGlsZUNhY2hlW2Ake3Byb2oueH0sJHtwcm9qLnl9YF0gPSBwcm9qKTtcblxuICAgIGxldCBsaWdodGluZ0NhY2hlID0ge307XG5cbiAgICBjb25zdCBsaWdodHMgPSBHYW1lU3RhdGUud29ybGQubGlnaHRpbmdbekxldmVsXTtcbiAgICBpZihsaWdodHMgJiYgbGlnaHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlZmxlY3Rpdml0eSA9ICh4LCB5KSA9PiBHYW1lU3RhdGUud29ybGQuZ2V0VGlsZSh4LCB5LCB6TGV2ZWwpLnJlZmxlY3Q7XG4gICAgICBjb25zdCBsaWdodGluZyA9IG5ldyBST1QuTGlnaHRpbmcocmVmbGVjdGl2aXR5LCB7IHJhbmdlOiA1LCBwYXNzZXM6IDIgfSk7XG4gICAgICBsaWdodGluZy5zZXRGT1YoZm92KTtcblxuICAgICAgXy5lYWNoKGxpZ2h0cywgbGlnaHQgPT4gbGlnaHRpbmcuc2V0TGlnaHQobGlnaHQueCwgbGlnaHQueSwgbGlnaHQuX2xpZ2h0Q29sb3IpKTtcblxuICAgICAgY29uc3QgbGlnaHRDYWxsYmFjayA9ICh4LCB5LCBjb2xvcikgPT4gbGlnaHRpbmdDYWNoZVtgJHt4fSwke3l9YF0gPSBjb2xvcjtcbiAgICAgIGxpZ2h0aW5nLmNvbXB1dGUobGlnaHRDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNWaXNpYmxlID0gKHgsIHkpID0+IHtcbiAgICAgIHJldHVybiB2aXNpYmxlW3hdICYmIHZpc2libGVbeF1beV07XG4gICAgfTtcblxuICAgIGNvbnN0IGhhc1ZhbGlkID0gKHRyYWl0LCB4LCB5KSA9PiB7XG4gICAgICByZXR1cm4gIWlzRGVhZCAmJiBjYWNoZVt0cmFpdF0gJiYgY2VudGVyUG9pbnQuZGlzdEJldHdlZW5YWSh4LCB5KSA8PSBjYWNoZVt0cmFpdF07XG4gICAgfTtcblxuICAgIC8vIHdoaXRlIChkb2Vzbid0IGNvdW50KSwgZ3JlZW4sIHllbGxvdywgb3JhbmdlLCByZWQsIHB1cnBsZVxuICAgIGNvbnN0IHdhcm5pbmdDb2xvcnMgPSBbJyNmZmYnLCAnIzBmMCcsICcjZmYwJywgJyNmZmE1MDAnLCAnI2YwMCcsICcjZmYwJ107XG4gICAgY29uc3QgYW1iaWVudExpZ2h0ID0gWzMwLCAzMCwgMzBdO1xuXG4gICAgZm9yKGxldCB4ID0gb2Zmc2V0Lng7IHggPCBvZmZzZXQueCArIHdpZHRoOyB4KyspIHtcbiAgICAgIGZvcihsZXQgeSA9IG9mZnNldC55OyB5IDwgb2Zmc2V0LnkgKyBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCBoYXNUZWxlcGF0aHkgPSBoYXNWYWxpZCgnVGVsZXBhdGh5JywgeCwgeSk7XG4gICAgICAgIGNvbnN0IGhhc0NsYWlydm95YW5jZSA9IGhhc1ZhbGlkKCdDbGFpcnZveWFuY2UnLCB4LCB5KTtcbiAgICAgICAgY29uc3QgaGFzV2FybmluZyA9IGhhc1ZhbGlkKCdXYXJuaW5nJywgeCwgeSk7XG4gICAgICAgIGNvbnN0IGhhc1NlZW4gPSBHYW1lU3RhdGUud29ybGQuaXNFeHBsb3JlZCh4LCB5LCBjZW50ZXJQb2ludC56KTtcbiAgICAgICAgaWYoIWhhc1NlZW4gJiYgIUdhbWVTdGF0ZS5yZW5kZXJBbGwgJiYgIWhhc1RlbGVwYXRoeSAmJiAhaGFzQ2xhaXJ2b3lhbmNlICYmICFoYXNXYXJuaW5nKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCB0aWxlID0gd29ybGQuZ2V0VGlsZSh4LCB5LCB6TGV2ZWwpO1xuICAgICAgICBpZighdGlsZSkgY29udGludWU7IC8vIG5vIG91dCBvZiBib3VuZHMgZHJhd2luZ1xuXG4gICAgICAgIGxldCBnbHlwaCA9IHsga2V5OiBudWxsIH07XG4gICAgICAgIGxldCBmb3JlZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgbGV0IGJhY2tncm91bmQgPSBST1QuQ29sb3IuZnJvbVN0cmluZygnIzAwMCcpO1xuXG4gICAgICAgIGNvbnN0IGJhc2VJc1Zpc2libGUgPSBpc1Zpc2libGUoeCwgeSkgfHwgaGFzQ2xhaXJ2b3lhbmNlO1xuXG4gICAgICAgIGlmKGJhc2VJc1Zpc2libGUgfHwgaGFzU2Vlbikge1xuICAgICAgICAgIGdseXBoID0gdGlsZS5nbHlwaDtcbiAgICAgICAgICBmb3JlZ3JvdW5kID0gZ2x5cGguZmc7XG4gICAgICAgICAgaWYoZ2x5cGguYmcpIGJhY2tncm91bmQgPSBST1QuQ29sb3IuZnJvbVN0cmluZyhnbHlwaC5iZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihiYXNlSXNWaXNpYmxlKSB7XG4gICAgICAgICAgY29uc3QgaXRlbXMgPSB3b3JsZC5nZXRJdGVtc0F0KHgsIHksIHpMZXZlbCk7XG4gICAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdseXBoID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0uZ2x5cGg7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kID0gZ2x5cGguZmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoYmFzZUlzVmlzaWJsZSB8fCBoYXNUZWxlcGF0aHkgfHwgaGFzV2FybmluZykge1xuICAgICAgICAgIGNvbnN0IGVudGl0eSA9IHdvcmxkLmdldEVudGl0eSh4LCB5LCB6TGV2ZWwpO1xuICAgICAgICAgIGlmKGVudGl0eSkge1xuXG4gICAgICAgICAgICBpZihiYXNlSXNWaXNpYmxlIHx8IGhhc1RlbGVwYXRoeSkge1xuICAgICAgICAgICAgICBnbHlwaCA9IGVudGl0eS5nbHlwaDtcbiAgICAgICAgICAgICAgZm9yZWdyb3VuZCA9IGdseXBoLmZnO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYoaGFzV2FybmluZyAmJiBjZW50ZXJQb2ludC5jYW5BdHRhY2soZW50aXR5KSkge1xuICAgICAgICAgICAgICBjb25zdCBkaWZmaWN1bHR5ID0gY2VudGVyUG9pbnQuY2FsY0RpZmZpY3VsdHkoZW50aXR5KTtcbiAgICAgICAgICAgICAgZ2x5cGggPSB7IGtleTogZGlmZmljdWx0eSB9O1xuICAgICAgICAgICAgICBmb3JlZ3JvdW5kID0gd2FybmluZ0NvbG9yc1tkaWZmaWN1bHR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9qZWN0aWxlID0gcHJvamVjdGlsZUNhY2hlW2Ake3h9LCR7eX1gXTtcbiAgICAgICAgaWYoYmFzZUlzVmlzaWJsZSAmJiBwcm9qZWN0aWxlKSB7XG4gICAgICAgICAgZ2x5cGggPSBwcm9qZWN0aWxlLmdseXBoO1xuICAgICAgICAgIGZvcmVncm91bmQgPSBnbHlwaC5mZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZpc2libGUgdGhpbmdzIGhhdmUgYSBibGFjayBiYWNrZ3JvdW5kXG4gICAgICAgIGlmKGJhc2VJc1Zpc2libGUpIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kID0gUk9ULkNvbG9yLmZyb21TdHJpbmcoJyMzMzMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpZ2h0ID0gbGlnaHRpbmdDYWNoZVtgJHt4fSwke3l9YF07XG4gICAgICAgIGlmKGJhc2VJc1Zpc2libGUgJiYgbGlnaHQpIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kID0gUk9ULkNvbG9yLmFkZChsaWdodCwgYW1iaWVudExpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgdGFraW5nIGNvbG9yIGF3YXkgZnJvbSB0aGluZ3MgdGhhdCBoYXZlIGl0XG4gICAgICAgIGlmKCFiYXNlSXNWaXNpYmxlICYmICFmb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgZm9yZWdyb3VuZCA9ICcjNTU1JztcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXkuZHJhdyhnYW1lT2Zmc2V0LnggKyB4IC0gb2Zmc2V0LngsIGdhbWVPZmZzZXQueSArIHkgLSBvZmZzZXQueSwgZ2x5cGgua2V5LCBmb3JlZ3JvdW5kLCBST1QuQ29sb3IudG9SR0IoYmFja2dyb3VuZCkpO1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FjaGUgPSBudWxsO1xuICAgIHByb2plY3RpbGVDYWNoZSA9IG51bGw7XG4gICAgbGlnaHRpbmdDYWNoZSA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgcmVuZGVyKCkge1xuICAgIGNvbnN0IGxpdmluZ1BsYXllcnMgPSBfLnJlamVjdChHYW1lU3RhdGUucGxheWVycywgKHBsYXllcikgPT4gcGxheWVyLmhwLmF0TWluKCkpO1xuICAgIGNvbnN0IHBsYXllclN0cmluZyA9IEdhbWVTdGF0ZS5wbGF5ZXJzLmxlbmd0aCA+IDEgPyBgICgke2xpdmluZ1BsYXllcnMubGVuZ3RofS8ke0dhbWVTdGF0ZS5wbGF5ZXJzLmxlbmd0aH0pYCA6ICcnO1xuICAgIENoYW5nZVRpdGxlKGBEdW5nZW9uZWVyaW5nJHtwbGF5ZXJTdHJpbmd9YCk7XG4gIH1cblxuICBzdGF0aWMgcmVkcmF3SHAoZGlzcGxheSwgZm9yZWdyb3VuZCwgcGxheWVyLCBzdHJpbmcsIHggPSAwLCB5ID0gU2V0dGluZ3Muc2NyZWVuLmhlaWdodCAtIDEpIHtcbiAgICBjb25zdCBzdHIgPSAoJycrcGxheWVyLmhwLmN1cik7XG4gICAgY29uc3QgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihgSFA6JHtwbGF5ZXIuaHAuY3VyfWApKzM7XG4gICAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICBjb25zdCBzdHJJZHggPSAwO1xuICAgIGZvcihsZXQgaSA9IGluZGV4OyBpIDwgaW5kZXgrbGVuZ3RoOyBpKyspIHtcbiAgICAgIGRpc3BsYXkuZHJhdyh4K2ksIHksIHN0cltzdHJJZHhdLCBmb3JlZ3JvdW5kKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNpbmdsZUdhbWVTY3JlZW4gZXh0ZW5kcyBHYW1lU2NyZWVuIHtcblxuICBzdGF0aWMgZHJhd01lc3NhZ2VzKGRpc3BsYXksIHBsYXllcikge1xuXG4gICAgaWYoIUdhbWVTdGF0ZS5tZXNzYWdlcykgcmV0dXJuO1xuXG4gICAgZm9yKGxldCB5ID0gMDsgeSA8IDM7IHkrKykge1xuXG4gICAgICBmb3IobGV0IHggPSAwOyB4IDwgU2V0dGluZ3Muc2NyZWVuLndpZHRoOyB4KyspIHtcbiAgICAgICAgZGlzcGxheS5kcmF3VGV4dCh4LCB5LCAnICcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvcihsZXQgeSA9IDA7IHkgPCAzOyB5KyspIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VPYmogPSBHYW1lU3RhdGUubWVzc2FnZXNbeV07XG4gICAgICBpZighbWVzc2FnZU9iaiB8fCBtZXNzYWdlT2JqLnR1cm4gPCBwbGF5ZXIuY3VycmVudFR1cm4gLSA0KSBjb250aW51ZTtcbiAgICAgIGRpc3BsYXkuZHJhd1RleHQoMCwgeSwgbWVzc2FnZU9iai5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICBNZXNzYWdlUXVldWUudmlld0FsbE1lc3NhZ2VzKCk7XG4gIH1cblxuICBzdGF0aWMgZHJhd0hVRChkaXNwbGF5LCBwbGF5ZXIpIHtcbiAgICBjb25zdCB0YWcgPSBgJHtwbGF5ZXIubmFtZX0gdGhlICR7cGxheWVyLmdldEFsaWduKCl9ICR7cGxheWVyLmdlbmRlcn0gbGV2ZWwgJHtwbGF5ZXIubGV2ZWx9ICR7cGxheWVyLnJhY2V9ICR7cGxheWVyLnByb2Zlc3Npb25JbnN0LnRpdGxlfSAoJHtwbGF5ZXIueHAuY3VyfS8ke3BsYXllci54cC5tYXh9KWA7XG4gICAgY29uc3Qgc3RhdHMgPSBgU1RSOiR7cGxheWVyLmdldFN0cigpfSBERVg6JHtwbGF5ZXIuZ2V0RGV4KCl9IENPTjoke3BsYXllci5nZXRDb24oKX0gSU5UOiR7cGxheWVyLmdldEludCgpfSBXSVM6JHtwbGF5ZXIuZ2V0V2lzKCl9IENIQToke3BsYXllci5nZXRDaGEoKX0gQUM6JHtwbGF5ZXIuZ2V0QUMoKX1gO1xuICAgIGNvbnN0IG1pc2NJbmZvID0gYEZsb29yOiR7MStHYW1lU3RhdGUuY3VycmVudEZsb29yfSAoJHtHYW1lU3RhdGUud29ybGQudGlsZXNbR2FtZVN0YXRlLmN1cnJlbnRGbG9vcl0uc2hvcnRNYXBOYW1lfSkgJDoke3BsYXllci5nb2xkfSBIUDoke3BsYXllci5ocC5jdXJ9LyR7cGxheWVyLmhwLm1heH0gTVA6JHtwbGF5ZXIubXAuY3VyfS8ke3BsYXllci5tcC5tYXh9IFR1cm46JHtwbGF5ZXIuY3VycmVudFR1cm59YDtcblxuICAgIGZvcihsZXQgeSA9IDE7IHkgPD0gMzsgeSsrKSB7XG4gICAgICBmb3IobGV0IHggPSAwOyB4IDwgU2V0dGluZ3Muc2NyZWVuLndpZHRoOyB4KyspIHtcbiAgICAgICAgZGlzcGxheS5kcmF3VGV4dCh4LCBTZXR0aW5ncy5zY3JlZW4uaGVpZ2h0IC0geSwgJyAnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNwbGF5LmRyYXdUZXh0KDAsIFNldHRpbmdzLnNjcmVlbi5oZWlnaHQgLSAzLCB0YWcpO1xuICAgIGRpc3BsYXkuZHJhd1RleHQoMCwgU2V0dGluZ3Muc2NyZWVuLmhlaWdodCAtIDIsIHN0YXRzKTtcbiAgICBkaXNwbGF5LmRyYXdUZXh0KDAsIFNldHRpbmdzLnNjcmVlbi5oZWlnaHQgLSAxLCBtaXNjSW5mbyk7XG5cbiAgICBpZihwbGF5ZXIuaHAubHRlUGVyY2VudCgyMCkpIHtcbiAgICAgIHRoaXMucmVkcmF3SHAoZGlzcGxheSwgJyM3ZjAwMDAnLCBwbGF5ZXIsIG1pc2NJbmZvKTtcbiAgICB9IGVsc2UgaWYocGxheWVyLmhwLmx0ZVBlcmNlbnQoNTApKSB7XG4gICAgICB0aGlzLnJlZHJhd0hwKGRpc3BsYXksICcjZmZkNzAwJywgcGxheWVyLCBtaXNjSW5mbyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHJlbmRlcihkaXNwbGF5KSB7XG4gICAgc3VwZXIucmVuZGVyKGRpc3BsYXkpO1xuICAgIGNvbnN0IHBsYXllciA9IEdhbWVTdGF0ZS5wbGF5ZXJzWzBdO1xuICAgIHRoaXMuZHJhd1RpbGVzKGRpc3BsYXksIHBsYXllcik7XG4gICAgdGhpcy5kcmF3SFVEKGRpc3BsYXksIHBsYXllcik7XG4gICAgdGhpcy5kcmF3TWVzc2FnZXMoZGlzcGxheSwgcGxheWVyKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3BsaXQoKSB7IHJldHVybiBTcGxpdEdhbWVTY3JlZW47IH1cbn1cblxuZXhwb3J0IGNsYXNzIFNwbGl0R2FtZVNjcmVlbiBleHRlbmRzIEdhbWVTY3JlZW4ge1xuXG4gIHN0YXRpYyBlbnRlcigpIHtcbiAgICB0aGlzLndpZHRoID0gR2FtZVN0YXRlLnBsYXllcnMubGVuZ3RoID4gMiA/IChTZXR0aW5ncy5zY3JlZW4ud2lkdGggLyAyKSA6IFNldHRpbmdzLnNjcmVlbi53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IFNldHRpbmdzLnNjcmVlbi5oZWlnaHQgLyAyO1xuXG4gICAgdGhpcy50bENvb3JkcyA9IFtcbiAgICAgIHsgeDogMCwgeTogMCB9LFxuICAgICAgeyB4OiAwLCB5OiB0aGlzLmhlaWdodCsxIH0sXG4gICAgICB7IHg6IHRoaXMud2lkdGgrMSwgeTogMCB9LFxuICAgICAgeyB4OiB0aGlzLndpZHRoKzEsIHk6IHRoaXMuaGVpZ2h0KzEgfVxuICAgIF07XG5cbiAgICB0aGlzLmh1ZENvb3JkcyA9IFtcbiAgICAgIHsgeDogMCwgeTogdGhpcy5oZWlnaHQtMSB9LFxuICAgICAgeyB4OiAwLCB5OiAodGhpcy5oZWlnaHQqMiktMSB9LFxuICAgICAgeyB4OiB0aGlzLndpZHRoKzEsIHk6IHRoaXMuaGVpZ2h0LTEgfSxcbiAgICAgIHsgeDogdGhpcy53aWR0aCsxLCB5OiAodGhpcy5oZWlnaHQqMiktMSB9XG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyByZW5kZXIoZGlzcGxheSkge1xuICAgIHN1cGVyLnJlbmRlcihkaXNwbGF5KTtcblxuICAgIF8uZWFjaChHYW1lU3RhdGUucGxheWVycywgKHBsYXllciwgaSkgPT4ge1xuICAgICAgdGhpcy5kcmF3VGlsZXMoZGlzcGxheSwgcGxheWVyLCB7IHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0LCBvZmZzZXQ6IHRoaXMuZ2V0U2NyZWVuT2Zmc2V0cyhwbGF5ZXIsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSwgZ2FtZU9mZnNldDogdGhpcy50bENvb3Jkc1tpXSB9KTtcbiAgICAgIHRoaXMuZHJhd0hVRHMoZGlzcGxheSwgcGxheWVyLCB0aGlzLmh1ZENvb3Jkc1tpXSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYXdCb3JkZXIoZGlzcGxheSk7XG4gIH1cblxuICBzdGF0aWMgZHJhd0JvcmRlcihkaXNwbGF5KSB7XG5cbiAgICBjb25zdCBtaWRkbGVZID0gU2V0dGluZ3Muc2NyZWVuLmhlaWdodCAvIDI7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IFNldHRpbmdzLnNjcmVlbi53aWR0aDsgaSsrKSB7XG4gICAgICBkaXNwbGF5LmRyYXcoaSwgbWlkZGxlWSwgJz0nKTtcbiAgICB9XG5cbiAgICBpZihHYW1lU3RhdGUucGxheWVycy5sZW5ndGggPiAyKSB7XG4gICAgICBjb25zdCBtaWRkbGVYID0gU2V0dGluZ3Muc2NyZWVuLndpZHRoIC8gMjtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBTZXR0aW5ncy5zY3JlZW4uaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgZGlzcGxheS5kcmF3KG1pZGRsZVgsIGksICfigJYnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRyYXdMZWZ0Q2VudGVyVGV4dChkaXNwbGF5LCBtaWRkbGVZLCBgRmxvb3I6JHtHYW1lU3RhdGUuY3VycmVudEZsb29yKzF9ICgke0dhbWVTdGF0ZS53b3JsZC50aWxlc1tHYW1lU3RhdGUuY3VycmVudEZsb29yXS5zaG9ydE1hcE5hbWV9KWApO1xuICAgIHRoaXMuZHJhd1JpZ2h0Q2VudGVyVGV4dChkaXNwbGF5LCBtaWRkbGVZLCBgVHVybnM6JHtfLm1heChHYW1lU3RhdGUucGxheWVycywgJ2N1cnJlbnRUdXJuJykuY3VycmVudFR1cm59YCk7XG4gIH1cblxuICBzdGF0aWMgc3RyaXBUbzMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMCwgMyk7XG4gIH1cblxuICBzdGF0aWMgZHJhd0hVRHMoZGlzcGxheSwgcGxheWVyLCBodWRDb29yZHMpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGh1ZENvb3JkcztcblxuICAgIGNvbnN0IHRvcFN0cmluZyA9IGAke3BsYXllci5uYW1lfSAke3RoaXMuc3RyaXBUbzMocGxheWVyLmdldEFsaWduKCkpfSAke3RoaXMuc3RyaXBUbzMocGxheWVyLmdlbmRlcil9ICR7dGhpcy5zdHJpcFRvMyhwbGF5ZXIucmFjZSl9ICR7dGhpcy5zdHJpcFRvMyhwbGF5ZXIucHJvZmVzc2lvbil9YDtcbiAgICBjb25zdCBib3R0b21TdHJpbmcgPSBgTHYuJHtwbGF5ZXIubGV2ZWx9ICgke3BsYXllci54cC5jdXJ9LyR7cGxheWVyLnhwLm1heH0pIEhQOiR7cGxheWVyLmhwLmN1cn0vJHtwbGF5ZXIuaHAubWF4fSBNUDoke3BsYXllci5tcC5jdXJ9LyR7cGxheWVyLm1wLm1heH1gO1xuXG4gICAgZGlzcGxheS5kcmF3VGV4dCh4LCB5LTEsIHRvcFN0cmluZyk7XG4gICAgZGlzcGxheS5kcmF3VGV4dCh4LCB5LCBib3R0b21TdHJpbmcpO1xuXG4gICAgaWYocGxheWVyLmhwLmx0ZVBlcmNlbnQoMjApKSB7XG4gICAgICB0aGlzLnJlZHJhd0hwKGRpc3BsYXksICcjN2YwMDAwJywgcGxheWVyLCBib3R0b21TdHJpbmcsIHgsIHkpO1xuICAgIH0gZWxzZSBpZihwbGF5ZXIuaHAubHRlUGVyY2VudCg1MCkpIHtcbiAgICAgIHRoaXMucmVkcmF3SHAoZGlzcGxheSwgJyNmZmQ3MDAnLCBwbGF5ZXIsIGJvdHRvbVN0cmluZywgeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBzcGxpdCgpIHsgcmV0dXJuIFNpbmdsZUdhbWVTY3JlZW47IH1cbn1cbiIsIlxuaW1wb3J0IHsgU2NyZWVuIH0gZnJvbSAnLi4vc2NyZWVuJztcblxuZXhwb3J0IGNsYXNzIExvYWRTY3JlZW4gZXh0ZW5kcyBTY3JlZW4ge1xuICBzdGF0aWMgZW50ZXIoZGlzcGxheSkge1xuICAgIHRoaXMuZmxpY2tlciA9IDA7XG5cbiAgICBjb25zdCBkb3RTdGF0dXMgPSBbJy4gICcsICcuLiAnLCAnLi4uJywgJyAuLicsICcgIC4nXTtcblxuICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBkaXNwbGF5LmNsZWFyKCk7XG4gICAgICB0aGlzLnJlbmRlcihkaXNwbGF5KTtcblxuICAgICAgdGhpcy5kcmF3Q2VudGVyVGV4dChkaXNwbGF5LCAxMiwgYEdlbmVyYXRpbmcgJHtkb3RTdGF0dXNbdGhpcy5mbGlja2VyXX1gKTtcblxuICAgICAgdGhpcy5mbGlja2VyID0gKyt0aGlzLmZsaWNrZXIgJSBkb3RTdGF0dXMubGVuZ3RoO1xuICAgIH0sIDUwMCk7XG4gIH1cblxuICBzdGF0aWMgZXhpdCgpIHtcbiAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgfVxuXG4gIHN0YXRpYyByZW5kZXIoZGlzcGxheSkge1xuICAgIHRoaXMuZHJhd0NlbnRlclRleHQoZGlzcGxheSwgIDExLCAnLVdlbGNvbWUgdG8gUm9ndWF0aGlhLScpO1xuICB9XG59IiwiXG5pbXBvcnQgeyBTY3JlZW4gfSBmcm9tICcuLi9zY3JlZW4nO1xuaW1wb3J0IFN0YXJ0IGZyb20gJy4uLy4uL2luaXQvZ2FtZS1zdGFydGVyJztcblxuLy8gdGhpcyBleGlzdHMgc29sZWx5IHRvIHRyYW5zaXRpb24gYW5kIHN0YXJ0IGEgbmV3IGdhbWUuIEknbSBiYWQuIDooXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZXdHYW1lU2NyZWVuIGV4dGVuZHMgU2NyZWVuIHtcbiAgc3RhdGljIGVudGVyKCkge1xuICAgIFN0YXJ0KCk7XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUk9UIGZyb20gJ3JvdC1qcyc7XG5pbXBvcnQgU0VUVElOR1MgZnJvbSAnLi4vLi4vY29uc3RhbnRzL3NldHRpbmdzJztcbmltcG9ydCB7IFNjcmVlbiB9IGZyb20gJy4uL3NjcmVlbic7XG5pbXBvcnQgTmV3R2FtZVNjcmVlbiBmcm9tICcuL25ld2dhbWUnO1xuaW1wb3J0IEdhbWVTdGF0ZSBmcm9tICcuLi8uLi9pbml0L2dhbWVzdGF0ZSc7XG5pbXBvcnQgQ2hhbmdlVGl0bGUgZnJvbSAnLi4vLi4vbGliL3BhZ2UtdGl0bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNwYXduU2NyZWVuIGV4dGVuZHMgU2NyZWVuIHtcbiAgc3RhdGljIGVudGVyKCkge1xuICAgIC8vIHdvdWxkIGJlIG5pY2UgaWYgaXQgcmVkcmV3IHByb3Blcmx5IHdpdGhvdXQgbmVlZGluZyBkdXBsaWNhdGVzIGluIHRoZSBsaXN0XG4gICAgdGhpcy5waGFzZXMgPSBbJy8nLCAnLycsICd8JywgJ3wnLCAnXFxcXCcsICdcXFxcJywgJy0nLCAnLSddO1xuICAgIHRoaXMuc3RhcnMgPSBbXTtcbiAgICB0aGlzLnRpbWVyID0gMTUgLSBHYW1lU3RhdGUuZXh0cmEucmVzcGF3blRpbWU7XG5cbiAgICAvLyBvbmUgdGljayBwZXIgc3RhciBtb3ZlLCA0IHRpY2tzID0gbmV3IHN0YXIgYW5kIHRpbWVyIGNvdW50ZG93blxuICAgIHRoaXMudGlja3MgPSB0aGlzLnRpbWVyICogdGhpcy5waGFzZXMubGVuZ3RoO1xuICB9XG5cbiAgc3RhdGljIGFkZFN0YXIoeCwgeSwgbGVuZ3RoKSB7XG4gICAgY29uc3QgbWluWCA9IHggLSAxO1xuICAgIGNvbnN0IG1heFggPSB4ICsgbGVuZ3RoICsgMTtcbiAgICBjb25zdCBtaW5ZID0geSAtIDE7XG4gICAgY29uc3QgbWF4WSA9IHkgKyAxO1xuXG4gICAgbGV0IGluQmFkWm9uZSA9IHRydWU7XG4gICAgbGV0IHN0YXIgPSBudWxsO1xuXG4gICAgY29uc3QgZGlzdEJldHdlZW4gPSAobWUsIHRhcmdldCkgPT4ge1xuICAgICAgY29uc3QgYSA9IHRhcmdldC54IC0gbWUueDtcbiAgICAgIGNvbnN0IGIgPSB0YXJnZXQueSAtIG1lLnk7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGEqYSArIGIqYik7XG4gICAgfTtcblxuICAgIHdoaWxlKGluQmFkWm9uZSkge1xuICAgICAgY29uc3QgbXlYID0gUk9ULlJORy5nZXRVbmlmb3JtSW50KDAsIFNFVFRJTkdTLnNjcmVlbi53aWR0aCk7XG4gICAgICBjb25zdCBteVkgPSBST1QuUk5HLmdldFVuaWZvcm1JbnQoMCwgU0VUVElOR1Muc2NyZWVuLmhlaWdodCk7XG4gICAgICBjb25zdCBtZSA9IHsgeDogbXlYLCB5OiBteVkgfTtcblxuICAgICAgaWYoXy5maWx0ZXIodGhpcy5zdGFycywgKHN0YXIpID0+IGRpc3RCZXR3ZWVuKG1lLCBzdGFyKSA8IDQpLmxlbmd0aCAhPT0gMCB8fFxuICAgICAgICBteVggPj0gbWluWCAmJiBteVggPD0gbWF4WCAmJlxuICAgICAgICBteVkgPj0gbWluWSAmJiBteVkgPD0gbWF4WSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaW5CYWRab25lID0gZmFsc2U7XG4gICAgICBzdGFyID0geyB4OiBteVgsIHk6IG15WSwgcGhhc2U6IFJPVC5STkcuZ2V0VW5pZm9ybUludCgwLCB0aGlzLnBoYXNlcy5sZW5ndGgtMSkgfTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXJzLnB1c2goc3Rhcik7XG4gIH1cblxuICBzdGF0aWMgZHJhd1N0YXJzKGRpc3BsYXkpIHtcbiAgICBfLmVhY2godGhpcy5zdGFycywgKHN0YXIpID0+IHtcbiAgICAgIGRpc3BsYXkuZHJhdyhzdGFyLngsIHN0YXIueSwgdGhpcy5waGFzZXNbc3Rhci5waGFzZV0pO1xuICAgICAgc3Rhci5waGFzZSsrO1xuICAgICAgaWYoc3Rhci5waGFzZSA+IHRoaXMucGhhc2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc3Rhci5waGFzZSA9IDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgcmVuZGVyKGRpc3BsYXkpIHtcbiAgICBkaXNwbGF5LmNsZWFyKCk7XG4gICAgY29uc3QgdGV4dCA9IGBSZXNwYXduaW5nIGluICR7dGhpcy50aW1lcn0gc2Vjb25kcy4uLmA7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLmRyYXdDZW50ZXJUZXh0KGRpc3BsYXksICAxMSwgdGV4dCk7XG5cbiAgICBDaGFuZ2VUaXRsZShgUmVzcGF3bmluZyAoJHt0aGlzLnRpbWVyfXMpYCk7XG5cbiAgICBpZih0aGlzLnRpY2tzICUgdGhpcy5waGFzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmFkZFN0YXIoeCwgeSwgdGV4dC5sZW5ndGgpO1xuICAgICAgdGhpcy50aW1lci0tO1xuICAgIH1cblxuICAgIHRoaXMudGlja3MtLTtcblxuICAgIGlmKHRoaXMudGlja3MgPD0gMCkge1xuICAgICAgR2FtZVN0YXRlLmdhbWUuc2FmZVN3aXRjaFNjcmVlbih0aGlzLCBOZXdHYW1lU2NyZWVuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyYXdTdGFycyhkaXNwbGF5KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVuZGVyKGRpc3BsYXkpLCAxMDAwL3RoaXMucGhhc2VzLmxlbmd0aCk7XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBTaW5nbGVTY3JvbGxpbmdTY3JlZW4sIFNwbGl0U2Nyb2xsaW5nU2NyZWVuIH0gZnJvbSAnLi4vc2NyZWVuJztcbmltcG9ydCB7IFNpbmdsZUNvbmR1Y3RTY3JlZW4sIFNwbGl0Q29uZHVjdFNjcmVlbiB9IGZyb20gJy4vY29uZHVjdCc7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uLy4uL2luaXQvZ2FtZXN0YXRlJztcblxuZXhwb3J0IGNsYXNzIFNpbmdsZVZhbnF1aXNoZWRTY3JlZW4gZXh0ZW5kcyBTaW5nbGVTY3JvbGxpbmdTY3JlZW4ge1xuICBzdGF0aWMgZW50ZXIoKSB7XG4gICAgc3VwZXIuZW50ZXIoKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldE1haW5QbGF5ZXIoKTtcbiAgICBjb25zdCBraWxsSGFzaCA9IHRhcmdldC5jb25xdWVzdDtcbiAgICBjb25zdCBzb3J0ZWRLaWxscyA9IF8oa2lsbEhhc2gpLmtleXMoKS5tYXAoKG1vbikgPT4gKHsgbmFtZTogbW9uLCBudW06IGtpbGxIYXNoW21vbl0gfSkpLnNvcnRCeSgnbmFtZScpLnZhbHVlKCk7XG4gICAgdGhpcy5zY3JvbGxDb250ZW50ID0gXy5tYXAoc29ydGVkS2lsbHMsIChraWxsKSA9PiBgJHtfLnBhZExlZnQoa2lsbC5udW0sIDQpfSAke2tpbGwubmFtZX1gKTtcbiAgICBjb25zdCB0b3RhbEtpbGxzID0gXy5yZWR1Y2Uoc29ydGVkS2lsbHMsICgocHJldiwgY3VyKSA9PiBwcmV2ICsgY3VyLm51bSksIDApO1xuICAgIHRoaXMudGl0bGUgPSBgJHt0YXJnZXQubmFtZX0ncyBDb25xdWVzdCAoJHtzb3J0ZWRLaWxscy5sZW5ndGh9IHR5cGVzfCR7dG90YWxLaWxsc30gdG90YWwpYDsgLy8gc2hvcnRlbiB0aGlzIGZvciBzcGxpdHNjcmVlblxuICAgIGlmKCF0aGlzLnNjcm9sbENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnNjcm9sbENvbnRlbnQgPSBbJ05vIGtpbGxzLiddO1xuICAgIH1cbiAgICB0aGlzLm5leHRTY3JlZW4gPSBTaW5nbGVDb25kdWN0U2NyZWVuO1xuICB9XG5cbiAgLy8gc3RhdGljIGdldCBzcGxpdCgpIHsgcmV0dXJuIFNwbGl0VmFucXVpc2hlZFNjcmVlbjsgfVxufVxuXG5leHBvcnQgY2xhc3MgU3BsaXRWYW5xdWlzaGVkU2NyZWVuIGV4dGVuZHMgU3BsaXRTY3JvbGxpbmdTY3JlZW4ge1xuICBzdGF0aWMgZW50ZXIoKSB7XG4gICAgc3VwZXIuZW50ZXIoKTtcblxuICAgIHRoaXMuc2Nyb2xsQ29udGVudCA9IFtdO1xuICAgIHRoaXMudGl0bGUgPSBbXTtcblxuICAgIF8uZWFjaChHYW1lU3RhdGUucGxheWVycywgKHRhcmdldCwgaSkgPT4ge1xuICAgICAgY29uc3Qga2lsbEhhc2ggPSB0YXJnZXQuY29ucXVlc3Q7XG4gICAgICBjb25zdCBzb3J0ZWRLaWxscyA9IF8oa2lsbEhhc2gpLmtleXMoKS5tYXAoKG1vbikgPT4gKHsgbmFtZTogbW9uLCBudW06IGtpbGxIYXNoW21vbl0gfSkpLnNvcnRCeSgnbmFtZScpLnZhbHVlKCk7XG4gICAgICB0aGlzLnNjcm9sbENvbnRlbnRbaV0gPSBfLm1hcChzb3J0ZWRLaWxscywgKGtpbGwpID0+IGAke18ucGFkTGVmdChraWxsLm51bSwgNCl9ICR7a2lsbC5uYW1lfWApO1xuICAgICAgY29uc3QgdG90YWxLaWxscyA9IF8ucmVkdWNlKHNvcnRlZEtpbGxzLCAoKHByZXYsIGN1cikgPT4gcHJldiArIGN1ci5udW0pLCAwKTtcbiAgICAgIHRoaXMudGl0bGVbaV0gPSBgJHt0YXJnZXQubmFtZX0ncyBDb25xdWVzdCAoJHtzb3J0ZWRLaWxscy5sZW5ndGh9IHR5cGVzfCR7dG90YWxLaWxsc30gdG90YWwpYDsgLy8gc2hvcnRlbiB0aGlzIGZvciBzcGxpdHNjcmVlblxuICAgICAgaWYoIXRoaXMuc2Nyb2xsQ29udGVudFtpXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250ZW50W2ldID0gWydObyBraWxscy4nXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV4dFNjcmVlbiA9IFNwbGl0Q29uZHVjdFNjcmVlbjtcbiAgfVxuICAvLyBzdGF0aWMgZ2V0IHNwbGl0KCkgeyByZXR1cm4gU2luZ2xlVmFucXVpc2hlZFNjcmVlbjsgfVxufVxuIiwiXG5pbXBvcnQgeyBTY3JlZW4gfSBmcm9tICcuLi9zY3JlZW4nO1xuaW1wb3J0IHsgU2luZ2xlVmFucXVpc2hlZFNjcmVlbiwgU3BsaXRWYW5xdWlzaGVkU2NyZWVuIH0gZnJvbSAnLi92YW5xdWlzaGVkJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi4vLi4vaW5pdC9nYW1lc3RhdGUnO1xuaW1wb3J0IENoYW5nZVRpdGxlIGZyb20gJy4uLy4uL2xpYi9wYWdlLXRpdGxlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2luU2NyZWVuIGV4dGVuZHMgU2NyZWVuIHtcbiAgc3RhdGljIGVudGVyKCkge1xuICAgIEdhbWVTdGF0ZS5nYW1lLmVuZ2luZS5sb2NrKCk7XG4gICAgdGhpcy5jaGFuZ2VTY3JlZW5XaXRoRGVsYXkoeyBzaW5nbGU6IFNpbmdsZVZhbnF1aXNoZWRTY3JlZW4sIG11bHRpOiBTcGxpdFZhbnF1aXNoZWRTY3JlZW4gfSwgNTAwMCk7XG4gIH1cbiAgc3RhdGljIHJlbmRlcihkaXNwbGF5KSB7XG4gICAgdGhpcy5kcmF3Q2VudGVyVGV4dChkaXNwbGF5LCAxMSwgJ1lvdSBoYXZlIHdvbiEnKTtcbiAgICB0aGlzLmRyYXdDZW50ZXJUZXh0KGRpc3BsYXksIDEyLCBHYW1lU3RhdGUud2luQ29uZGl0aW9uLm1lc3NhZ2UpO1xuICAgIHRoaXMuZHJhd0NlbnRlclRleHQoZGlzcGxheSwgMTMsIGBZb3UgZWFybmVkICR7R2FtZVN0YXRlLnNwRWFybmVkfSBTUCwgJHtHYW1lU3RhdGUua3BFYXJuZWR9IEtQIGFuZCAke0dhbWVTdGF0ZS52cEVhcm5lZH0gVlAuYCk7XG4gICAgQ2hhbmdlVGl0bGUoJ1ZpY3RvcnknKTtcbiAgfVxufSIsIlxuaW1wb3J0IFJPVCBmcm9tICdyb3QtanMnO1xuaW1wb3J0IEdhbWVTdGF0ZSBmcm9tICcuL2dhbWVzdGF0ZSc7XG5cbndpbmRvdy5HYW1lU3RhdGUgPSBHYW1lU3RhdGU7XG5cbmxldCBkZWJ1Z0luaXRpYWxpemVkID0gZmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgaWYoZGVidWdJbml0aWFsaXplZCkgcmV0dXJuO1xuICBkZWJ1Z0luaXRpYWxpemVkID0gdHJ1ZTtcblxuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgIGlmKGUua2V5Q29kZSAhPT0gUk9ULlZLX1ApIHJldHVybjtcbiAgICBcbiAgICBHYW1lU3RhdGUuaXNQYXVzZWQgPSAhR2FtZVN0YXRlLmlzUGF1c2VkO1xuICAgIFxuICAgIGlmKEdhbWVTdGF0ZS5pc1BhdXNlZCkge1xuICAgICAgR2FtZVN0YXRlLmdhbWUuZW5naW5lLmxvY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgR2FtZVN0YXRlLmdhbWUuZW5naW5lLnVubG9jaygpO1xuICAgIH1cbiAgfSk7XG4gIFxuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgIGlmKGUua2V5Q29kZSAhPT0gUk9ULlZLX1IpIHJldHVybjtcbiAgICBcbiAgICBHYW1lU3RhdGUucmVuZGVyQWxsID0gIUdhbWVTdGF0ZS5yZW5kZXJBbGw7XG4gIH0pO1xuXG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gICAgaWYoZS5rZXlDb2RlICE9PSBST1QuVktfTCkgcmV0dXJuO1xuXG4gICAgR2FtZVN0YXRlLmdhbWUuY2hhbmdlU3BsaXRTY3JlZW4oKTtcbiAgfSk7XG5cbiAgLypcbiAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICBpZihlLmtleUNvZGUgIT09IFJPVC5WS19EKSByZXR1cm47XG5cbiAgICBHYW1lU3RhdGUucGxheWVyc1swXS5kZXNjZW5kKCk7XG4gIH0pO1xuICAqL1xuXG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gICAgaWYoZS5rZXlDb2RlICE9PSBST1QuVktfTSkgcmV0dXJuO1xuXG4gICAgR2FtZVN0YXRlLm1hbnVhbE1vdmUgPSAhR2FtZVN0YXRlLm1hbnVhbE1vdmU7XG4gICAgaWYoIUdhbWVTdGF0ZS5tYW51YWxNb3ZlKSB7XG4gICAgICBHYW1lU3RhdGUuZ2FtZS5lbmdpbmUudW5sb2NrKCk7XG4gICAgfVxuICB9KTtcblxuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuXG4gICAgY29uc3Qgb2Zmc2V0cyA9IHtcbiAgICAgIFtST1QuVktfV106IHsgeDogMCwgeTogLTEgfSxcbiAgICAgIFtST1QuVktfU106IHsgeDogMCwgeTogMSB9LFxuICAgICAgW1JPVC5WS19BXTogeyB4OiAtMSwgeTogMCB9LFxuICAgICAgW1JPVC5WS19EXTogeyB4OiAxLCB5OiAwIH0sXG5cbiAgICAgIFtST1QuVktfTlVNUEFEOF06IHsgeDogMCwgeTogLTEgfSxcbiAgICAgIFtST1QuVktfTlVNUEFEMl06IHsgeDogMCwgeTogMSB9LFxuICAgICAgW1JPVC5WS19OVU1QQUQ0XTogeyB4OiAtMSwgeTogMCB9LFxuICAgICAgW1JPVC5WS19OVU1QQUQ2XTogeyB4OiAxLCB5OiAwIH0sXG5cbiAgICAgIFtST1QuVktfTlVNUEFEN106IHsgeDogLTEsIHk6IC0xIH0sXG4gICAgICBbUk9ULlZLX05VTVBBRDNdOiB7IHg6IDEsIHk6IDEgfSxcbiAgICAgIFtST1QuVktfTlVNUEFEMV06IHsgeDogLTEsIHk6IDEgfSxcbiAgICAgIFtST1QuVktfTlVNUEFEOV06IHsgeDogMSwgeTogLTEgfVxuICAgIH07XG5cbiAgICBpZighb2Zmc2V0c1tlLmtleUNvZGVdIHx8ICFHYW1lU3RhdGUubWFudWFsTW92ZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgcGxheWVyID0gR2FtZVN0YXRlLnBsYXllcnNbMF07XG4gICAgcGxheWVyLm1vdmVUbyhwbGF5ZXIueCtvZmZzZXRzW2Uua2V5Q29kZV0ueCwgcGxheWVyLnkrb2Zmc2V0c1tlLmtleUNvZGVdLnkpO1xuICAgIEdhbWVTdGF0ZS5nYW1lLmVuZ2luZS51bmxvY2soKTtcbiAgfSk7XG59OyIsIlxuaW1wb3J0IEdhbWUgZnJvbSAnLi9nYW1lJztcbmltcG9ydCBHYW1lU3RhdGUsIHsgRnJlc2hHYW1lIH0gZnJvbSAnLi9nYW1lc3RhdGUnO1xuaW1wb3J0IHsgTG9hZFNjcmVlbiB9IGZyb20gJy4uL2Rpc3BsYXkvc2NyZWVucy9sb2FkJztcbmltcG9ydCBJbml0RGVidWcgZnJvbSAnLi9kZWJ1Zyc7XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NhbnZhcycpKS5mb3JFYWNoKFxuICAgIChpdGVtKSA9PiB7XG4gICAgICBpdGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaXRlbSk7XG4gICAgfVxuICApO1xuICBcbiAgRnJlc2hHYW1lKCk7XG4gIGNvbnN0IGdhbWUgPSBHYW1lU3RhdGUuZ2FtZSA9IG5ldyBHYW1lKCk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYW1lLWFyZWEnKS5hcHBlbmRDaGlsZChnYW1lLmRpc3BsYXkuZ2V0Q29udGFpbmVyKCkpO1xuICBnYW1lLnN3aXRjaFNjcmVlbihMb2FkU2NyZWVuKTtcblxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBnYW1lLnNldHVwKCk7XG4gICAgSW5pdERlYnVnKCk7XG4gIH0sIDMwMCk7XG59OyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcbmltcG9ydCBTRVRUSU5HUyBmcm9tICcuLi9jb25zdGFudHMvc2V0dGluZ3MnO1xuaW1wb3J0IFdvcmxkIGZyb20gJy4uL3dvcmxkZ2VuL3dvcmxkJztcbmltcG9ydCBHYW1lU3RhdGUgZnJvbSAnLi9nYW1lc3RhdGUnO1xuXG5pbXBvcnQgeyBTaW5nbGVHYW1lU2NyZWVuIH0gZnJvbSAnLi4vZGlzcGxheS9zY3JlZW5zL2dhbWUnO1xuaW1wb3J0IERlYWRTY3JlZW4gZnJvbSAnLi4vZGlzcGxheS9zY3JlZW5zL2RlYWQnO1xuaW1wb3J0IFdpblNjcmVlbiBmcm9tICcuLi9kaXNwbGF5L3NjcmVlbnMvd2luJztcblxuaW1wb3J0IFBsYXllciBmcm9tICcuLi9kZWZpbml0aW9ucy9wbGF5ZXInO1xuaW1wb3J0ICogYXMgVmljdG9yaWVzIGZyb20gJy4uL2NvbnN0YW50cy92aWN0b3JpZXMnO1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uL2xpYi9sb2dnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kaXNwbGF5ID0gbmV3IFJPVC5EaXNwbGF5KHtcbiAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgIGZvbnRTdHlsZTogJ2JvbGQnLFxuICAgICAgZm9udDogJ0ZpeGVkc3lzNTAwYycsXG4gICAgICB3aWR0aDogU0VUVElOR1Muc2NyZWVuLndpZHRoLFxuICAgICAgaGVpZ2h0OiBTRVRUSU5HUy5zY3JlZW4uaGVpZ2h0XG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50U2NyZWVuID0gbnVsbDtcblxuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG5cbiAgICBjb25zdCBiaW5kVG9TY3JlZW4gPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIChlKSA9PiB7XG4gICAgICAgIGlmKHRoaXMuY3VycmVudFNjcmVlbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jdXJyZW50U2NyZWVuLmhhbmRsZUlucHV0KGV2ZW50LCBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIFxuICAgIF8uZWFjaChbJ2tleWRvd24nLCAna2V5cHJlc3MnXSwgKGV2ZW50KSA9PiBiaW5kVG9TY3JlZW4oZXZlbnQpKTtcbiAgfVxuICBcbiAgcmVmcmVzaCgpIHtcbiAgICBpZighdGhpcy5kaXNwbGF5KSByZXR1cm47XG4gICAgdGhpcy5kaXNwbGF5LmNsZWFyKCk7XG4gICAgdGhpcy5jdXJyZW50U2NyZWVuLnJlbmRlcih0aGlzLmRpc3BsYXkpO1xuICB9XG4gIFxuICBnYW1lT3ZlcigpIHtcbiAgICBHYW1lU3RhdGUuZW1pdCgnZ2FtZWVuZC5nYW1lb3ZlcicpO1xuICAgIHRoaXMuc3dpdGNoU2NyZWVuKERlYWRTY3JlZW4pO1xuICB9XG5cbiAgY2hlY2tXaW4oKSB7XG4gICAgY29uc3QgZGlkV2luID0gR2FtZVN0YXRlLndpbkNvbmRpdGlvbi5jaGVjaygpO1xuICAgIGlmKGRpZFdpbikgdGhpcy53aW4oKTtcbiAgICByZXR1cm4gZGlkV2luO1xuICB9XG5cbiAgd2luKCkge1xuICAgIEdhbWVTdGF0ZS5lbWl0KCdnYW1lZW5kLnZpY3RvcnknKTtcbiAgICB0aGlzLnN3aXRjaFNjcmVlbihXaW5TY3JlZW4pO1xuICB9XG4gIFxuICBzYWZlU3dpdGNoU2NyZWVuKG1lLCBuZXdTY3JlZW4pIHtcbiAgICBpZih0aGlzLmN1cnJlbnRTY3JlZW4gIT09IG1lKSByZXR1cm47XG4gICAgdGhpcy5zd2l0Y2hTY3JlZW4obmV3U2NyZWVuKTtcbiAgfVxuXG4gIGNoYW5nZVNwbGl0U2NyZWVuKCkge1xuICAgIGlmKCF0aGlzLmN1cnJlbnRTY3JlZW4uc3BsaXQgfHwgR2FtZVN0YXRlLnBsYXllcnMubGVuZ3RoID09PSAxKSByZXR1cm47XG4gICAgR2FtZVN0YXRlLnNwbGl0U2NyZWVuID0gIUdhbWVTdGF0ZS5zcGxpdFNjcmVlbjtcbiAgICB0aGlzLnN3aXRjaFNjcmVlbih0aGlzLmN1cnJlbnRTY3JlZW4uc3BsaXQpO1xuICB9XG4gIFxuICBzd2l0Y2hTY3JlZW4oc2NyZWVuKSB7XG4gICAgaWYodGhpcy5jdXJyZW50U2NyZWVuKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTY3JlZW4uZXhpdCh0aGlzLmRpc3BsYXkpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmN1cnJlbnRTY3JlZW4gPSBzY3JlZW47XG5cbiAgICBpZih0aGlzLmN1cnJlbnRTY3JlZW4pIHtcbiAgICAgIHRoaXMuY3VycmVudFNjcmVlbi5lbnRlcih0aGlzLmRpc3BsYXkpO1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICB9XG4gIFxuICBzZXR1cCgpIHtcbiAgICB0aGlzLnNjaGVkdWxlciA9IG5ldyBST1QuU2NoZWR1bGVyLlNwZWVkKCk7XG4gICAgdGhpcy5lbmdpbmUgPSBuZXcgUk9ULkVuZ2luZSh0aGlzLnNjaGVkdWxlcik7XG4gICAgXG4vKiAgICBpZihmYWxzZSkge1xuICAgICAgdGhpcy5sb2FkT2xkRGF0YSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiovXG5cbiAgICB0aGlzLnN0YXJ0TmV3R2FtZSgpO1xuICB9XG4gIFxuICBsb2FkT2xkRGF0YSgpIHt9XG4gIFxuICBzdGFydE5ld0dhbWUoKSB7XG4gICAgR2FtZVN0YXRlLndpbkNvbmRpdGlvbiA9IF8oVmljdG9yaWVzKS52YWx1ZXMoKS5zYW1wbGUoKTtcblxuICAgIEdhbWVTdGF0ZS53b3JsZCA9IG5ldyBXb3JsZCgpO1xuICAgIEdhbWVTdGF0ZS53b3JsZC5nZW5lcmF0ZVdvcmxkKHsgZGVwdGg6IEdhbWVTdGF0ZS51cGdyYWRlcy5kZXB0aCwgaGVpZ2h0OiBHYW1lU3RhdGUudXBncmFkZXMuc3F1YXJpdHksIHdpZHRoOiBHYW1lU3RhdGUudXBncmFkZXMuc3F1YXJpdHkgfSk7XG4gICAgY29uc3QgemVyb1N0YXJ0U3RhaXJzID0gR2FtZVN0YXRlLndvcmxkLnN0YWlyc1swXS51cDtcbiAgICBcbiAgICBjb25zdCBwbGF5ZXJMb2NhdGlvbnMgPSBHYW1lU3RhdGUud29ybGQuZ2V0VmFsaWRUaWxlc0luUmFuZ2UoXG4gICAgICB6ZXJvU3RhcnRTdGFpcnNbMF0sIHplcm9TdGFydFN0YWlyc1sxXSwgMCwgMiwgKHRpbGUpID0+IHRpbGUuZ2x5cGgua2V5ID09PSAnLidcbiAgICApO1xuXG4gICAgaWYoR2FtZVN0YXRlLnBsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgTG9nKCdHYW1lJywgJ0Egc2Vjb25kIGdhbWUgc3RhcnRlZCBzb21laG93LicpO1xuICAgIH1cblxuICAgIGNvbnN0IHNwYXduZWRQbGF5ZXJzID0gTWF0aC5taW4oNCwgTWF0aC5tYXgoMSwgR2FtZVN0YXRlLmV4dHJhLnBsYXllcnMpKTtcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzcGF3bmVkUGxheWVyczsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydFRpbGUgPSBwbGF5ZXJMb2NhdGlvbnMuc2hpZnQoKTtcbiAgICAgIGNvbnN0IHBsYXllciA9IG5ldyBQbGF5ZXIoMCwgMCwgMCwgeyB0ZW1wbGF0ZTogR2FtZVN0YXRlLnRlbXBsYXRlc1tpXSB8fCB7fSB9KTtcblxuICAgICAgR2FtZVN0YXRlLndvcmxkLm1vdmVFbnRpdHkocGxheWVyLCBzdGFydFRpbGUueCwgc3RhcnRUaWxlLnksIDApO1xuICAgICAgR2FtZVN0YXRlLnBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgIH1cblxuICAgIEdhbWVTdGF0ZS5saXZpbmdQbGF5ZXJzID0gR2FtZVN0YXRlLnBsYXllcnMubGVuZ3RoO1xuICAgIEdhbWVTdGF0ZS5wbGF5ZXJUdXJuc1Rha2VuID0gMDtcblxuICAgIHRoaXMuZW5naW5lLnN0YXJ0KCk7XG4gICAgR2FtZVN0YXRlLmVtaXQoJ3N0YXJ0Jyk7XG4gICAgXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZih0aGlzLmN1cnJlbnRTY3JlZW4ubmFtZSA9PT0gJ0RlYWRTY3JlZW4nKSByZXR1cm47IC8vIHR1cm4gMSBkZWF0aCAoeW91IHNwYXduZWQgd2l0aCBhbiBhbXVsZXQgb2Ygc3RyYW5ndWxhdGlvbiwgZXRjKVxuICAgICAgdGhpcy5zd2l0Y2hTY3JlZW4oU2luZ2xlR2FtZVNjcmVlbik7XG4gICAgICBpZihHYW1lU3RhdGUucGxheWVycy5sZW5ndGggPiAxKSB0aGlzLmNoYW5nZVNwbGl0U2NyZWVuKCk7XG4gICAgfSwgMTAwKTtcbiAgfVxuXG4gIGNsZWFuVXAoKSB7XG4gICAgdGhpcy5kaXNwbGF5Ll9kYXRhID0gbnVsbDtcbiAgICB0aGlzLmRpc3BsYXkgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuICAgIHRoaXMuZW5naW5lID0gbnVsbDtcblxuICAgIF8uZWFjaChbJ2tleWRvd24nLCAna2V5cHJlc3MnXSwgZXZlbnQgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMubGlzdGVuZXJzW2V2ZW50XSkpO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbDtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9jb25zdGFudHMvc2V0dGluZ3MnO1xuaW1wb3J0IHsgQ3VycmVudCB9IGZyb20gJy4vZ2FtZXVwZ3JhZGVzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlcjIgfSBmcm9tICdldmVudGVtaXR0ZXIyJztcblxuY2xhc3MgR2FtZVN0YXRlIGV4dGVuZHMgRXZlbnRFbWl0dGVyMiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgaWYodGhpcy5wbGF5ZXJzKSB7XG4gICAgICBfLmVhY2godGhpcy5wbGF5ZXJzLCBwID0+IHAuY2xlYW5VcCgpKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLndvcmxkKSB7XG4gICAgICB0aGlzLndvcmxkLmNsZWFuVXAoKTtcbiAgICAgIHRoaXMud29ybGQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmKHRoaXMuZ2FtZSkge1xuICAgICAgdGhpcy5nYW1lLmNsZWFuVXAoKTtcbiAgICAgIHRoaXMuZ2FtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5pZGVudGlmaWNhdGlvbiA9IHt9O1xuICAgIHRoaXMuX2lkTWFwID0ge307XG4gICAgdGhpcy5wbGF5ZXJzID0gW107XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMucHJvamVjdGlsZXMgPSBbXTtcbiAgICB0aGlzLm1vbnN0ZXJzID0gW107XG4gICAgdGhpcy5zcGxpdFNjcmVlbiA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEZsb29yID0gMDtcblxuICAgIHRoaXMubG9hZEV4dGVybmFsT3B0aW9ucygpO1xuICB9XG5cbiAgbG9hZEV4dGVybmFsT3B0aW9ucygpIHtcbiAgICBjb25zdCBHYW1lVXBncmFkZXMgPSBDdXJyZW50KCk7XG5cbiAgICB0aGlzLnVwZ3JhZGVzID0ge307XG4gICAgXy5rZXlzKFNldHRpbmdzLnVwZ3JhZGVzKVxuICAgICAgLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgdGhpcy51cGdyYWRlc1trZXldID0gU2V0dGluZ3MudXBncmFkZXNba2V5XSArIH5+R2FtZVVwZ3JhZGVzLmR1bmdlb25ba2V5XTtcbiAgICAgICAgaWYoU2V0dGluZ3MudXBncmFkZXNNYXhba2V5XSkge1xuICAgICAgICAgIHRoaXMudXBncmFkZXNba2V5XSA9IE1hdGgubWluKFNldHRpbmdzLnVwZ3JhZGVzTWF4W2tleV0sIHRoaXMudXBncmFkZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgdGhpcy50ZW1wbGF0ZXMgPSBHYW1lVXBncmFkZXMudGVtcGxhdGVzO1xuICAgIHRoaXMudW5sb2NrZWQgPSBHYW1lVXBncmFkZXMudW5sb2NrZWQ7XG4gICAgdGhpcy5leHRyYSA9IEdhbWVVcGdyYWRlcy5leHRyYTtcbiAgfVxuXG4gIGdldCB2cEVhcm5lZCgpIHsgcmV0dXJuIHRoaXMud2luQ29uZGl0aW9uLmNoZWNrKCkgPyB0aGlzLndpbkNvbmRpdGlvbi52cCgpIDogMDsgfVxuICBnZXQga3BFYXJuZWQoKSB7IHJldHVybiBfLnJlZHVjZSh0aGlzLnBsYXllcnMsICgocHJldiwgY3VyKSA9PiBwcmV2ICsgY3VyLnRvdGFsS3BFYXJuZWQpLCAwKTsgfVxuICBnZXQgc3BFYXJuZWQoKSB7IHJldHVybiBfLnJlZHVjZSh0aGlzLnBsYXllcnMsICgocHJldiwgY3VyKSA9PiBwcmV2ICsgY3VyLmdldFNjb3JlKCkpLCAwKTsgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXy5vbWl0KHRoaXMsICdnYW1lJykpO1xuICB9XG59XG5cbmNvbnN0IGV4cG9ydGVkU3RhdGUgPSB3aW5kb3cuR2FtZVN0YXRlID0gbmV3IEdhbWVTdGF0ZSgpO1xuXG5leHBvcnQgY29uc3QgRnJlc2hHYW1lID0gKCkgPT4ge1xuICBmb3IoY29uc3Qga2V5IGluIGV4cG9ydGVkU3RhdGUpIHtcbiAgICBpZighZXhwb3J0ZWRTdGF0ZS5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IF8uY29udGFpbnMoWydfZXZlbnRzJywgJ25ld0xpc3RlbmVyJ10sIGtleSkpIGNvbnRpbnVlO1xuICAgIGRlbGV0ZSBleHBvcnRlZFN0YXRlW2tleV07XG4gIH1cblxuICBleHBvcnRlZFN0YXRlLnJlc2V0KCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHBvcnRlZFN0YXRlOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgYmFzZVN0YXRlID0ge1xuICBkdW5nZW9uOiB7XG4gICAgaXRlbXNJbkR1bmdlb246IDAsXG4gICAgaXRlbURyb3BDaGFuY2U6IDAsXG4gICAgYWx0YXJTcGF3bkNoYW5jZTogMCxcbiAgICB0aHJvbmVTcGF3bkNoYW5jZTogMCxcbiAgICBncmF2ZVNwYXduQ2hhbmNlOiAwLFxuICAgIGZvdW50YWluU3Bhd25DaGFuY2U6IDAsXG4gICAgc2lua1NwYXduQ2hhbmNlOiAwLFxuICAgIG1vbnN0ZXJMaW1pdDogMTAsXG4gICAgbWF4RGlmZmljdWx0eTogNSxcbiAgICBkZXB0aDogMTAsXG4gICAgc3F1YXJpdHk6IDcwXG5cbiAgIC8qIGl0ZW1Ecm9wQ2hhbmNlOiAxMDAsXG4gICAgYWx0YXJTcGF3bkNoYW5jZTogMTAwMCxcbiAgICB0ZW1wbGVTcGF3bkNoYW5jZTogMTAwLFxuICAgIHRocm9uZVNwYXduQ2hhbmNlOiAxMDAwLFxuICAgIHRocm9uZVJvb21TcGF3bkNoYW5jZTogMTAwLFxuICAgIGdyYXZlU3Bhd25DaGFuY2U6IDEwMDAsXG4gICAgZ3JhdmV5YXJkU3Bhd25DaGFuY2U6IDEwMCxcbiAgICBmb3VudGFpblNwYXduQ2hhbmNlOiAxMDAwLFxuICAgIG9yYWNsZVJvb21DaGFuY2U6IDEwMCxcbiAgICBzaW5rU3Bhd25DaGFuY2U6IDEwMDAsXG4gICAgYmF0aHJvb21TcGF3bkNoYW5jZTogMTAwKi9cblxuICB9LFxuXG4gIHRlbXBsYXRlczogW10sXG5cbiAgdW5sb2NrZWQ6IHtcbiAgICByYWNlOiBbJ0VsZicsICdIdW1hbicsICdHbm9tZSddLFxuICAgIHByb2Zlc3Npb246IFsnVG91cmlzdCddXG4gIH0sXG5cbiAgc2VsZWN0YWJsZToge1xuICAgIHJhY2U6IFtdLFxuICAgIHByb2Zlc3Npb246IFtdXG4gIH0sXG5cbiAgZXh0cmE6IHtcbiAgICBwbGF5ZXJzOiAxLFxuICAgIHJlc3Bhd25UaW1lOiAwXG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBOZXdTdGF0ZSA9ICgpID0+IF8uY2xvbmVEZWVwKGJhc2VTdGF0ZSk7XG5cbmxldCBjdXJTdGF0ZSA9IE5ld1N0YXRlKCk7XG5cbmV4cG9ydCBjb25zdCBTZXRTdGF0ZSA9IChuZXdTdGF0ZSkgPT4gY3VyU3RhdGUgPSBuZXdTdGF0ZTtcblxuZXhwb3J0IGNvbnN0IEN1cnJlbnQgPSAoKSA9PiBjdXJTdGF0ZTtcblxuZXhwb3J0IGRlZmF1bHQgY3VyU3RhdGU7IiwiXG5pbXBvcnQgUk9UIGZyb20gJ3JvdC1qcyc7XG5pbXBvcnQgU3RhcnQgZnJvbSAnLi9nYW1lLXN0YXJ0ZXInO1xuXG5sZXQgZ2FtZVN0YXJ0ZWQgPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IFN0YXJ0R2FtZUN5Y2xlID0gKCkgPT4ge1xuICBpZihnYW1lU3RhcnRlZCkgcmV0dXJuO1xuXG4gIGlmKCFST1QuaXNTdXBwb3J0ZWQoKSkge1xuICAgIGFsZXJ0KGByb3QuanMgaXNuJ3Qgc3VwcG9ydGVkIDooYCk7XG4gIH0gZWxzZSB7XG4gICAgZ2FtZVN0YXJ0ZWQgPSB0cnVlO1xuICAgIFN0YXJ0KCk7XG4gIH1cbn07XG4iLCJcbmV4cG9ydCBjb25zdCBBQyA9IChpdGVtLCBhYyA9IDEpID0+IChpdGVtLmJ1YyAqIC1hYykgLSBpdGVtLmVuY2hhbnRtZW50OyIsIlxuaW1wb3J0IGRpY2UgZnJvbSAnZGljZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChyb2xsKSA9PiArZGljZS5yb2xsKHJvbGwpOyIsIlxuLy8gdGhhbmsgeW91IGJhc2VkIHN0YWNrZXhjaGFuZ2UgaHR0cDovL2NvZGVyZXZpZXcuc3RhY2tleGNoYW5nZS5jb20vYS85NzMxMC82NDM2MlxuY29uc3QgSU5ESUNFUyA9IFsxLCAyLCAzLCA2LCA5LCA4LCA3LCA0XTtcbmNvbnN0IFBST0JBQklMSVRJRVMgPSBbMTAwMDAsIDIwMDAsIDUwMCwgNTAsIDEwLCA1MCwgNTAwLCAyMDAwXTtcblxuZXhwb3J0IGRlZmF1bHQgKGxhc3ROdW1wYWREaXJlY3Rpb24pID0+IHtcbiAgY29uc3QgbGFzdEluZGV4RGlyZWN0aW9uID0gSU5ESUNFUy5pbmRleE9mKGxhc3ROdW1wYWREaXJlY3Rpb24pO1xuICBjb25zdCBzaGlmdGVkID0gUFJPQkFCSUxJVElFUy5zbGljZShQUk9CQUJJTElUSUVTLmxlbmd0aCAtIGxhc3RJbmRleERpcmVjdGlvbilcbiAgICAuY29uY2F0KFBST0JBQklMSVRJRVMuc2xpY2UoMCwgUFJPQkFCSUxJVElFUy5sZW5ndGggLSBsYXN0SW5kZXhEaXJlY3Rpb24pKTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvcihsZXQgaSA9IDAsIGwgPSBJTkRJQ0VTLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJlc3VsdFtJTkRJQ0VTW2ldXSA9IHNoaWZ0ZWRbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwiXG5sZXQgaWQgPSAwO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIHJldHVybiBpZCsrO1xufTsiLCJcbmltcG9ydCBCUkFHSSBmcm9tICdicmFnaS1icm93c2VyJztcblxuLy8gcmVtb3ZlIGV4dHJhIGxvZyBsaW5lXG5CUkFHSS50cmFuc3BvcnRzLmdldCgnQ29uc29sZScpLnByb3BlcnR5KHsgc2hvd01ldGE6IGZhbHNlIH0pO1xuZXhwb3J0IGRlZmF1bHQgKGdyb3VwLCBtZXNzYWdlLCBpc0Vycm9yID0gdHJ1ZSkgPT4ge1xuICBpZihpc0Vycm9yKSBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjayk7XG4gIEJSQUdJLmxvZyhncm91cCwgbWVzc2FnZSk7XG59OyIsIlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTnVtYmVyUmFuZ2Uge1xuICBjb25zdHJ1Y3RvcihtaW4sIGN1ciwgbWF4KSB7XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gICAgdGhpcy5fc2V0KGN1cik7XG4gIH1cbiAgXG4gIGF0TWluKCkgeyByZXR1cm4gdGhpcy5jdXIgPT09IHRoaXMubWluOyB9XG4gIGF0TWF4KCkgeyByZXR1cm4gdGhpcy5jdXIgPT09IHRoaXMubWF4OyB9XG5cbiAgdG9NaW4oKSB7IHRoaXMuY3VyID0gdGhpcy5taW47IH1cbiAgdG9NYXgoKSB7IHRoaXMuY3VyID0gdGhpcy5tYXg7IH1cbiAgXG4gIHBlcmNlbnQoKSAgICAgICB7IHJldHVybiB+figodGhpcy5jdXIgLyB0aGlzLm1heCkqMTAwKTsgfVxuICBndFBlcmNlbnQocGN0KSAgeyByZXR1cm4gdGhpcy5wZXJjZW50KCkgPiBwY3Q7IH1cbiAgbHRQZXJjZW50KHBjdCkgIHsgcmV0dXJuIHRoaXMucGVyY2VudCgpIDwgcGN0OyB9XG4gIGVQZXJjZW50KHBjdCkgICB7IHJldHVybiB0aGlzLnBlcmNlbnQoKSA9PT0gcGN0OyB9XG4gIGd0ZVBlcmNlbnQocGN0KSB7IHJldHVybiB0aGlzLnBlcmNlbnQoKSA+PSBwY3Q7IH1cbiAgbHRlUGVyY2VudChwY3QpIHsgcmV0dXJuIHRoaXMucGVyY2VudCgpIDw9IHBjdDsgfVxuICBcbiAgZ3QobnVtKSAgeyByZXR1cm4gdGhpcy5jdXIgPiBudW07IH1cbiAgbHQobnVtKSAgeyByZXR1cm4gdGhpcy5jdXIgPCBudW07IH1cbiAgZShudW0pICAgeyByZXR1cm4gdGhpcy5jdXIgPT09IG51bTsgfVxuICBndGUobnVtKSB7IHJldHVybiB0aGlzLmN1ciA+PSBudW07IH1cbiAgbHRlKG51bSkgeyByZXR1cm4gdGhpcy5jdXIgPD0gbnVtOyB9XG4gIFxuICBfc2V0KG51bSkgeyB0aGlzLmN1ciA9IE1hdGgubWF4KHRoaXMubWluLCBNYXRoLm1pbih0aGlzLm1heCwgbnVtKSk7IH1cbiAgYWRkKG51bSkgeyB0aGlzLl9zZXQobnVtICsgdGhpcy5jdXIpOyB9XG4gIHN1YihudW0pIHsgdGhpcy5hZGQoLW51bSk7IH1cbn0iLCJcbmV4cG9ydCBkZWZhdWx0IChuZXdUaXRsZSkgPT4ge1xuICBkb2N1bWVudC50aXRsZSA9IGAke25ld1RpdGxlfSAtIFJvZ3VhdGhpYWA7XG59OyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcblxuZXhwb3J0IGNvbnN0IFdlaWdodGVkRXh0ZW5zaW9uID0gKGhhc2gsIGZpbHRlcktleSA9ICdwcm9iYWJpbGl0eScsIHByZWRpY2F0ZSA9ICgpID0+IHRydWUpID0+IHtcblxuICBjb25zdCB2YWxpZCA9IF8oaGFzaCkua2V5cygpLmZpbHRlcihwcmVkaWNhdGUpLnJlZHVjZSgocHJldiwga2V5KSA9PiB7XG5cbiAgICAvLyBoYW5kbGUgcHJlLWZvcm1hdHRlZCBwcm9iYWJpbGl0eSBoYXNoZXNcbiAgICBpZihfLmlzTnVtYmVyKGhhc2hba2V5XSkpIHtcbiAgICAgIHByZXZba2V5XSA9IGhhc2hba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldltrZXldID0gaGFzaFtrZXldW2ZpbHRlcktleV07XG4gICAgfVxuICAgIHJldHVybiBwcmV2O1xuICB9LCB7fSk7XG5cbiAgY29uc3QgY2hvaWNlID0gUk9ULlJORy5nZXRXZWlnaHRlZFZhbHVlKHZhbGlkKTtcbiAgcmV0dXJuIHsga2V5OiBjaG9pY2UsIHZhbHVlOiBoYXNoW2Nob2ljZV0gfTtcbn07IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgY29uc3QgQ29sb3JzID0gW1xuICAnIzAwZicsICAgLy8gYmx1ZVxuICAnIzBmMCcsICAgLy8gZ3JlZW5cbiAgJyNmMDAnLCAgIC8vIHJlZFxuICAnIzBmZicsICAgLy8gY3lhblxuICAnI2YwZicsICAgLy8gbWFnZW50YVxuICAnI2ZmMCcsICAgLy8geWVsbG93XG4gIFxuICAnI2FhZicsICAgLy8gbGlnaHRibHVlXG4gICcjYWZhJywgICAvLyBsaWdodGdyZWVuXG4gICcjZmFhJywgICAvLyBsaWdodHJlZFxuICAnI2FhZicsICAgLy8gbGlnaHRjeWFuXG4gICcjZmFmJywgICAvLyBsaWdodG1hZ2VudGFcbiAgJyNmZmEnICAgIC8vIGxpZ2h0eWVsbG93XG5dO1xuXG5leHBvcnQgY29uc3QgR2V0Q29sb3IgPSAoKSA9PiBfLnNhbXBsZShDb2xvcnMpOyIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSb2xsIGZyb20gJy4vZGljZS1yb2xsZXInO1xuXG5leHBvcnQgZGVmYXVsdCAodmFsdWUsIG90aGVyKSA9PiB7XG4gIGlmKF8uaXNTdHJpbmcob3RoZXIpICYmIF8uY29udGFpbnMob3RoZXIsICdkJykpIHtcbiAgICByZXR1cm4gUm9sbChvdGhlcik7XG4gIH1cbiAgcmV0dXJuIG90aGVyO1xufTsiLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUk9UIGZyb20gJ3JvdC1qcyc7XG5pbXBvcnQgKiBhcyBUaWxlcyBmcm9tICcuL3RpbGVzL19hbGwnO1xuaW1wb3J0IEdhbWVTdGF0ZSBmcm9tICcuLi9pbml0L2dhbWVzdGF0ZSc7XG5cbmNvbnN0IGZlYXR1cmVUeXBlcyA9IFtcbiAgeyBuYW1lOiAndGhyb25lJywgcHJvdG86IFRpbGVzLlRocm9uZSB9LFxuICB7IG5hbWU6ICdzaW5rJywgcHJvdG86IFRpbGVzLlNpbmsgfSxcbiAgeyBuYW1lOiAnZm91bnRhaW4nLCBwcm90bzogVGlsZXMuRm91bnRhaW4gfS8qICxcbiAgeyBuYW1lOiAnZ3JhdmUnIH0sKi9cbl07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdlbmVyYXRvciB7XG4gIHN0YXRpYyBnZW5lcmF0ZSgpIHt9XG5cbiAgc3RhdGljIHBsYWNlVGlsZShtYXAsIHR5cGUsIHgsIHksIHopIHtcbiAgICBtYXBbeF1beV0gPSBuZXcgdHlwZSgpO1xuICAgIG1hcFt4XVt5XS54ID0geDtcbiAgICBtYXBbeF1beV0ueSA9IHk7XG4gICAgbWFwW3hdW3ldLnogPSB6O1xuICAgIHJldHVybiBtYXBbeF1beV07XG4gIH1cblxuICBzdGF0aWMgZHJhd0hvcml6b250YWxXYWxscyhtYXAsIHJvb20sIHopIHtcbiAgICBmb3IobGV0IGkgPSByb29tLmdldExlZnQoKS0xOyBpIDw9IHJvb20uZ2V0UmlnaHQoKSsxOyBpKyspIHtcbiAgICAgIGlmKCFtYXBbaV1bcm9vbS5nZXRUb3AoKSAtIDFdLmdseXBoLmtleSkge1xuICAgICAgICB0aGlzLnBsYWNlVGlsZShtYXAsIFRpbGVzLkR1bmdlb25Ib3Jpem9udGFsV2FsbCwgaSwgcm9vbS5nZXRUb3AoKSAtIDEsIHopO1xuICAgICAgfVxuXG4gICAgICBpZighbWFwW2ldW3Jvb20uZ2V0Qm90dG9tKCkgKyAxXS5nbHlwaC5rZXkpIHtcbiAgICAgICAgdGhpcy5wbGFjZVRpbGUobWFwLCBUaWxlcy5EdW5nZW9uSG9yaXpvbnRhbFdhbGwsIGksIHJvb20uZ2V0Qm90dG9tKCkgKyAxLCB6KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZHJhd1ZlcnRpY2FsV2FsbHMobWFwLCByb29tLCB6KSB7XG4gICAgZm9yKGxldCBpID0gcm9vbS5nZXRUb3AoKTsgaSA8PSByb29tLmdldEJvdHRvbSgpOyBpKyspIHtcblxuICAgICAgY29uc3QgbGVmdFRpbGUgPSBtYXBbcm9vbS5nZXRMZWZ0KCktMV1baV0uZ2x5cGgua2V5O1xuICAgICAgY29uc3QgcmlnaHRUaWxlID0gbWFwW3Jvb20uZ2V0UmlnaHQoKSsxXVtpXS5nbHlwaC5rZXk7XG5cbiAgICAgIC8vIHRoZXNlIHRpbGVzIHRha2UgcHJlY2VkZW5jZSwgb3RoZXJ3aXNlIHNvbWUgd2FsbHMgbG9vayB1Z2dvXG4gICAgICBpZighbGVmdFRpbGUgfHwgbGVmdFRpbGUgPT09ICctJykge1xuICAgICAgICB0aGlzLnBsYWNlVGlsZShtYXAsIFRpbGVzLkR1bmdlb25WZXJ0aWNhbFdhbGwsIHJvb20uZ2V0TGVmdCgpLTEsIGksIHopO1xuICAgICAgfVxuXG4gICAgICBpZighcmlnaHRUaWxlIHx8IHJpZ2h0VGlsZSA9PT0gJy0nKSB7XG4gICAgICAgIHRoaXMucGxhY2VUaWxlKG1hcCwgVGlsZXMuRHVuZ2VvblZlcnRpY2FsV2FsbCwgcm9vbS5nZXRSaWdodCgpKzEsIGksIHopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRSYW5kb21GbG9vclRpbGUobWFwKSB7XG4gICAgcmV0dXJuIF8obWFwKS5mbGF0dGVuKCkuZmlsdGVyKHRpbGUgPT4gdGlsZS5nbHlwaC5rZXkgPT09ICcuJykuc2FtcGxlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0UmFuZG9tQ29vcmRzSW5Sb29tKHJvb20pIHtcbiAgICByZXR1cm4gW1xuICAgICAgTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSoocm9vbS5feDIgLSByb29tLl94MSkpICsgcm9vbS5feDEsXG4gICAgICBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpKihyb29tLl95MiAtIHJvb20uX3kxKSkgKyByb29tLl95MVxuICAgIF07XG4gIH1cblxuICBzdGF0aWMgcGxhY2VTdGFpcnNJblJvb20obWFwLCByb29tLCB6LCBzdGFpcnMpIHtcbiAgICB0aGlzLm1hcmtSb29tSW5lbGxpZ2libGUocm9vbSk7XG4gICAgY29uc3Qgc2V0U3RhaXJzID0gKHN0YWlycywgeCwgeSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucGxhY2VUaWxlKG1hcCwgc3RhaXJzLCB4LCB5LCB6KTtcbiAgICB9O1xuXG4gICAgY29uc3QgW3gsIHldID0gdGhpcy5nZXRSYW5kb21Db29yZHNJblJvb20ocm9vbSk7XG4gICAgcmV0dXJuIHNldFN0YWlycyhzdGFpcnMsIHgsIHkpO1xuICB9XG5cbiAgc3RhdGljIGdldFN0YWlycyh6KSB7XG4gICAgcmV0dXJuIEdhbWVTdGF0ZS53aW5Db25kaXRpb24ubWFwU3RhaXJzKHopO1xuICB9XG5cbiAgc3RhdGljIG1hcmtSb29tSW5lbGxpZ2libGUocm9vbSkge1xuICAgIGlmKCFyb29tKSByZXR1cm47XG4gICAgcm9vbS5fbm9Nb3JlRmVhdHVyZXMgPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBhdHRlbXB0RmVhdHVyZVBsYWNlbWVudChtYXAsIHosIHJvb21zKSB7XG4gICAgY29uc3QgdmFsaWRSb29tcyA9IF8ucmVqZWN0KHJvb21zLCByb29tID0+IHJvb20uX25vTW9yZUZlYXR1cmVzKTtcbiAgICBfLmVhY2godmFsaWRSb29tcywgcm9vbSA9PiB7XG4gICAgICBfLmVhY2goZmVhdHVyZVR5cGVzLCB0eXBlID0+IHtcbiAgICAgICAgaWYoUk9ULlJORy5nZXRVbmlmb3JtSW50KDEsIDEwMDAwKSA8PSBHYW1lU3RhdGUudXBncmFkZXNbYCR7dHlwZS5uYW1lfVNwYXduQ2hhbmNlYF0pIHtcbiAgICAgICAgICBjb25zdCBbeCwgeV0gPSB0aGlzLmdldFJhbmRvbUNvb3Jkc0luUm9vbShyb29tKTtcbiAgICAgICAgICB0aGlzLnBsYWNlVGlsZShtYXAsIHR5cGUucHJvdG8sIHgsIHksIHopO1xuICAgICAgICAgIHRoaXMubWFya1Jvb21JbmVsbGlnaWJsZShyb29tKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG4iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUk9UIGZyb20gJ3JvdC1qcyc7XG5cbmltcG9ydCAqIGFzIEVxdWlwbWVudFR5cGVzIGZyb20gJy4uL2RlZmluaXRpb25zL2VxdWlwbWVudCc7XG5cbmltcG9ydCAqIGFzIEZvb2QgZnJvbSAnLi4vY29udGVudC9pdGVtcy9mb29kcyc7XG5pbXBvcnQgKiBhcyBGZWV0IGZyb20gJy4uL2NvbnRlbnQvaXRlbXMvZmVldHMnO1xuaW1wb3J0ICogYXMgSGVhZCBmcm9tICcuLi9jb250ZW50L2l0ZW1zL2hlYWRzJztcbmltcG9ydCAqIGFzIEJvZHkgZnJvbSAnLi4vY29udGVudC9pdGVtcy9ib2R5cyc7XG5pbXBvcnQgKiBhcyBSaW5nIGZyb20gJy4uL2NvbnRlbnQvaXRlbXMvcmluZ3MnO1xuaW1wb3J0ICogYXMgTmVjayBmcm9tICcuLi9jb250ZW50L2l0ZW1zL25lY2tzJztcbmltcG9ydCAqIGFzIFdhbmQgZnJvbSAnLi4vY29udGVudC9pdGVtcy93YW5kcyc7XG5pbXBvcnQgKiBhcyBXcmlzdCBmcm9tICcuLi9jb250ZW50L2l0ZW1zL3dyaXN0cyc7XG5pbXBvcnQgKiBhcyBDbG9hayBmcm9tICcuLi9jb250ZW50L2l0ZW1zL2Nsb2Frcyc7XG5pbXBvcnQgKiBhcyBXZWFwb24gZnJvbSAnLi4vY29udGVudC9pdGVtcy9fd2VhcG9ucyc7XG5pbXBvcnQgKiBhcyBQb3Rpb24gZnJvbSAnLi4vY29udGVudC9pdGVtcy9wb3Rpb25zJztcbmltcG9ydCAqIGFzIFNwZWxsYm9vayBmcm9tICcuLi9jb250ZW50L2l0ZW1zL3NwZWxsYm9va3MnO1xuaW1wb3J0ICogYXMgUHJvamVjdGlsZSBmcm9tICcuLi9jb250ZW50L2l0ZW1zL3Byb2plY3RpbGVzJztcblxuY29uc3QgaXRlbVR5cGVIYXNoID0ge1xuICBGb29kLCBGZWV0LCBIZWFkLCBCb2R5LCBSaW5nLCBOZWNrLCBXYW5kLCBXcmlzdCwgQ2xvYWssIFBvdGlvbiwgU3BlbGxib29rLCBIYW5kczogXy5leHRlbmQoe30sIFByb2plY3RpbGUsIFdlYXBvbilcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEl0ZW1HZW5lcmF0b3Ige1xuXG4gIHN0YXRpYyBnZXRWYWxpZFR5cGVzKHR5cGVzKSB7XG4gICAgcmV0dXJuIF8odHlwZXMpXG4gICAgICAua2V5cygpXG4gICAgICAuZmlsdGVyKGtleSA9PiB0eXBlc1trZXldLnJhcml0eSlcbiAgICAgIC5tYXAoa2V5ID0+IFtrZXksIHR5cGVzW2tleV0ucmFyaXR5XSlcbiAgICAgIC56aXBPYmplY3QoKVxuICAgICAgLnZhbHVlKCk7XG4gIH1cblxuICBzdGF0aWMgc3Bhd24oKSB7XG4gICAgY29uc3QgdmFsaWRUeXBlcyA9IHRoaXMuZ2V0VmFsaWRUeXBlcyhFcXVpcG1lbnRUeXBlcyk7XG4gICAgY29uc3QgY2hvc2VuVHlwZSA9IFJPVC5STkcuZ2V0V2VpZ2h0ZWRWYWx1ZSh2YWxpZFR5cGVzKTtcbiAgICBjb25zdCB2YWxpZEl0ZW1zID0gdGhpcy5nZXRWYWxpZFR5cGVzKGl0ZW1UeXBlSGFzaFtjaG9zZW5UeXBlXSk7XG4gICAgY29uc3QgY2hvc2VuSXRlbSA9IFJPVC5STkcuZ2V0V2VpZ2h0ZWRWYWx1ZSh2YWxpZEl0ZW1zKTtcbiAgICByZXR1cm4gbmV3IGl0ZW1UeXBlSGFzaFtjaG9zZW5UeXBlXVtjaG9zZW5JdGVtXSgpO1xuICB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJPVCBmcm9tICdyb3QtanMnO1xuaW1wb3J0ICogYXMgVGlsZXMgZnJvbSAnLi4vdGlsZXMvX2FsbCc7XG5pbXBvcnQgR2VuZXJhdG9yIGZyb20gJy4uL2dlbmVyYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFsdGFyIGV4dGVuZHMgR2VuZXJhdG9yIHtcblxuICBzdGF0aWMgZ2VuZXJhdGUob3B0cykge1xuICAgIGNvbnN0IHsgdywgaCwgeiB9ID0gXy5leHRlbmQoeyB3OiAxNSwgaDogMTUgfSwgb3B0cyk7XG4gICAgY29uc3QgbWFwID0gW107XG4gICAgXG4gICAgY29uc3QgYXJlbmEgPSBuZXcgUk9ULk1hcC5BcmVuYSh3LCBoKTtcbiAgICBcbiAgICBhcmVuYS5jcmVhdGUoKHgsIHksIHZhbHVlKSA9PiB7XG4gICAgICBpZighbWFwW3hdKSBtYXBbeF0gPSBbXTtcblxuICAgICAgbGV0IHByb3RvID0gVGlsZXMuVm9pZDtcbiAgICAgIGlmKCF2YWx1ZSkgcHJvdG8gPSBUaWxlcy5EdW5nZW9uRmxvb3I7XG4gICAgICBcbiAgICAgIHRoaXMucGxhY2VUaWxlKG1hcCwgcHJvdG8sIHgsIHksIHopO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgcm9vbSA9IG5ldyBST1QuTWFwLkZlYXR1cmUuUm9vbSgxLCAxLCB3LTIsIGgtMik7XG5cbiAgICB0aGlzLmRyYXdWZXJ0aWNhbFdhbGxzKG1hcCwgcm9vbSwgeik7XG4gICAgdGhpcy5kcmF3SG9yaXpvbnRhbFdhbGxzKG1hcCwgcm9vbSwgeik7XG5cbiAgICBjb25zdCBzdGFpcnMgPSBbXG4gICAgICB0aGlzLnBsYWNlU3RhaXJzSW5Sb29tKG1hcCwgcm9vbSwgeiwgVGlsZXMuU3RhaXJzVXApXG4gICAgXTtcblxuICAgIGNvbnN0IGFsdGFyVGlsZSA9IHRoaXMuZ2V0UmFuZG9tRmxvb3JUaWxlKG1hcCk7XG4gICAgdGhpcy5wbGFjZVRpbGUobWFwLCBUaWxlcy5TZWx5a0FsdGFyLCBhbHRhclRpbGUueCwgYWx0YXJUaWxlLnksIHopO1xuICAgIFxuICAgIHJldHVybiB7IG1hcCwgc3RhaXJzLCByb29tczogW3Jvb21dLCBtYXBOYW1lOiBgU2VseWsncyBBbHRhcmAsIHNob3J0TWFwTmFtZTogJ0FsdGFyJyB9O1xuICB9XG59IiwiXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJPVCBmcm9tICdyb3QtanMnO1xuaW1wb3J0ICogYXMgVGlsZXMgZnJvbSAnLi4vdGlsZXMvX2FsbCc7XG5pbXBvcnQgR2VuZXJhdG9yIGZyb20gJy4uL2dlbmVyYXRvcic7XG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL2xpYi9sb2dnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEdW5nZW9uIGV4dGVuZHMgR2VuZXJhdG9yIHtcblxuICBzdGF0aWMgZ2VuZXJhdGUob3B0cykge1xuICAgIGNvbnN0IHsgdywgaCwgeiB9ID0gb3B0cztcbiAgICBjb25zdCBtYXAgPSBbXTtcbiAgICBcbiAgICAvLyAtMyB0byBhZGp1c3QgZm9yIHRoZSBVSSBjb21wb25lbnRzIGF0IHRoZSBib3R0b21cbiAgICBjb25zdCBkaWdnZXIgPSBuZXcgUk9ULk1hcC5EaWdnZXIodywgaC0zLCB7IHJvb21XaWR0aDogWzQsIDhdLCByb29tSGVpZ2h0OiBbNCwgN10sIGNvcnJpZG9yTGVuZ3RoOiBbNSwgMTNdLCBkdWdQZXJjZW50YWdlOiAwLjMgfSk7XG4gICAgXG4gICAgZGlnZ2VyLmNyZWF0ZSgoeCwgeSwgdmFsdWUpID0+IHtcbiAgICAgIGlmKCFtYXBbeF0pIG1hcFt4XSA9IFtdO1xuXG4gICAgICBsZXQgcHJvdG8gPSBUaWxlcy5Wb2lkO1xuICAgICAgaWYoIXZhbHVlKSBwcm90byA9IFRpbGVzLkR1bmdlb25GbG9vcjtcbiAgICAgIFxuICAgICAgdGhpcy5wbGFjZVRpbGUobWFwLCBwcm90bywgeCwgeSwgeik7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gcmVwbGFjZSBhbGwgY29ycmlkb3JzIHdpdGggY29ycmlkb3IgdGlsZXNcbiAgICBfLmVhY2goZGlnZ2VyLmdldENvcnJpZG9ycygpLCAoY29ycmlkb3IpID0+IHtcbiAgICAgIHRoaXMucGxhY2VDb3JyaWRvclRpbGVzKG1hcCwgY29ycmlkb3IsIHopO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgcm9vbXMgPSBkaWdnZXIuZ2V0Um9vbXMoKTtcblxuICAgIGlmKHJvb21zLmxlbmd0aCA8IDIpIHtcbiAgICAgIExvZygnRHVuZ2VvbkdlbmVyYXRvcicsICdPbmx5IG9uZSByb29tIHdhcyBnZW5lcmF0ZWQsIHRoaXMgaXMgcHJvYmFibHkgYSByYXJlIGJ1Zy4nKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcm9vbSBvdXRsaW5lcyBhbmQgZG9vcnNcbiAgICBfLmVhY2gocm9vbXMsIChyb29tKSA9PiB7XG5cbiAgICAgIC8vIGRyYXcgbGVmdCBhbmQgcmlnaHQgd2FsbHNcbiAgICAgIHRoaXMuZHJhd1ZlcnRpY2FsV2FsbHMobWFwLCByb29tLCB6KTtcbiAgICAgIFxuICAgICAgLy8gZHJhdyB0b3AgYW5kIGJvdHRvbSB3YWxsc1xuICAgICAgdGhpcy5kcmF3SG9yaXpvbnRhbFdhbGxzKG1hcCwgcm9vbSwgeik7XG4gICAgICBcbiAgICAgIC8vIG1heWJlIGRyYXcgc29tZSBkb29yc1xuICAgICAgdGhpcy5kcmF3RG9vcnMobWFwLCByb29tLCB6KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IFtzdGFpcnNVcCwgc3RhaXJzRG93bl0gPSB0aGlzLmdldFN0YWlycyh6KTtcbiAgICBjb25zdCBjaG9zZW5Sb29tcyA9IF8uc2FtcGxlKGRpZ2dlci5nZXRSb29tcygpLCAyKTtcbiAgICBjb25zdCBzdGFpcnMgPSBbXG4gICAgICB0aGlzLnBsYWNlU3RhaXJzSW5Sb29tKG1hcCwgY2hvc2VuUm9vbXNbMF0sIHosIHN0YWlyc1VwKSxcbiAgICAgIHN0YWlyc0Rvd24gPyB0aGlzLnBsYWNlU3RhaXJzSW5Sb29tKG1hcCwgY2hvc2VuUm9vbXNbMV0sIHosIHN0YWlyc0Rvd24pIDogbnVsbFxuICAgIF07XG5cbiAgICB0aGlzLmF0dGVtcHRGZWF0dXJlUGxhY2VtZW50KG1hcCwgeiwgcm9vbXMpO1xuICAgIFxuICAgIHJldHVybiB7IG1hcCwgc3RhaXJzLCByb29tcywgbWFwTmFtZTogJ1RoZSBEdW5nZW9ucyBvZiBEb29tJywgc2hvcnRNYXBOYW1lOiAnRHVuZ2VvbicgfTtcbiAgfVxuXG4gIHN0YXRpYyBwbGFjZUNvcnJpZG9yVGlsZXMobWFwLCBjb3JyaWRvciwgeikge1xuICAgIGxldCBbeFN0YXJ0LCB4RW5kXSA9IFtjb3JyaWRvci5fc3RhcnRYLCBjb3JyaWRvci5fZW5kWF07XG4gICAgaWYoeFN0YXJ0ID4geEVuZCkge1xuICAgICAgW3hTdGFydCwgeEVuZF0gPSBbeEVuZCwgeFN0YXJ0XTtcbiAgICB9XG5cbiAgICBsZXQgW3lTdGFydCwgeUVuZF0gPSBbY29ycmlkb3IuX3N0YXJ0WSwgY29ycmlkb3IuX2VuZFldO1xuICAgIGlmKHlTdGFydCA+IHlFbmQpIHtcbiAgICAgIFt5U3RhcnQsIHlFbmRdID0gW3lFbmQsIHlTdGFydF07XG4gICAgfVxuXG4gICAgZm9yKGxldCB4ID0geFN0YXJ0OyB4IDw9IHhFbmQ7IHgrKykge1xuICAgICAgZm9yKGxldCB5ID0geVN0YXJ0OyB5IDw9IHlFbmQ7IHkrKykge1xuICAgICAgICB0aGlzLnBsYWNlVGlsZShtYXAsIFRpbGVzLkNvcnJpZG9yLCB4LCB5LCB6KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZHJhd0Rvb3JzKG1hcCwgcm9vbSwgeikge1xuICAgIHJvb20uZ2V0RG9vcnMoKHgsIHkpID0+IHtcbiAgICAgIGlmKFJPVC5STkcuZ2V0UGVyY2VudGFnZSgpID4gMzApIHtcbiAgICAgICAgdGhpcy5wbGFjZVRpbGUobWFwLCBUaWxlcy5EdW5nZW9uRmxvb3IsIHgsIHksIHopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZG9vciA9IHRoaXMucGxhY2VUaWxlKG1hcCwgVGlsZXMuRG9vciwgeCwgeSwgeik7XG4gICAgICAgIGRvb3Iuc2V0UHJvcGVyQ2hhcmFjdGVyKG1hcFt4LTFdW3ldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSb2xsIGZyb20gJy4uL2xpYi9kaWNlLXJvbGxlcic7XG5pbXBvcnQgTW9uc3RlcnMgZnJvbSAnLi4vY29udGVudC9tb25zdGVycy9fYWxsJztcbmltcG9ydCBNb25zdGVyIGZyb20gJy4uL2RlZmluaXRpb25zL21vbnN0ZXInO1xuaW1wb3J0IEdhbWVTdGF0ZSBmcm9tICcuLi9pbml0L2dhbWVzdGF0ZSc7XG5pbXBvcnQgTG9nIGZyb20gJy4uL2xpYi9sb2dnZXInO1xuaW1wb3J0IHsgV2VpZ2h0ZWRFeHRlbnNpb24gfSBmcm9tICcuLi9saWIvcm90LWV4dGVuc2lvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb25zdGVyU3Bhd25lciB7XG4gIHN0YXRpYyBzcGF3bihiYXNlZE9uKSB7XG4gICAgY29uc3QgZHVuZ2VvbkxldmVsID0gYmFzZWRPbi56ICsgMTtcbiAgICBjb25zdCB0YXJnZXRMZXZlbCA9IGJhc2VkT24ubGV2ZWw7XG5cbiAgICBjb25zdCBoaWdoZXN0RGlmZmljdWx0eSA9IE1hdGgubWluKEdhbWVTdGF0ZS51cGdyYWRlcy5tYXhEaWZmaWN1bHR5LCA1ICogZHVuZ2VvbkxldmVsKTtcbiAgICBjb25zdCBsb3dlc3REaWZmaWN1bHR5ID0gTWF0aC5taW4oaGlnaGVzdERpZmZpY3VsdHksIE1hdGguZmxvb3IoKGR1bmdlb25MZXZlbCt0YXJnZXRMZXZlbCkvMikpO1xuXG4gICAgbGV0IGNob3Nlbk5hbWUgPSBXZWlnaHRlZEV4dGVuc2lvbihNb25zdGVycywgJ2ZyZXF1ZW5jeScsIG1vbnN0ZXJOYW1lID0+IE1vbnN0ZXJzW21vbnN0ZXJOYW1lXS5kaWZmaWN1bHR5ID49IGxvd2VzdERpZmZpY3VsdHkgJiYgTW9uc3RlcnNbbW9uc3Rlck5hbWVdLmRpZmZpY3VsdHkgPCBoaWdoZXN0RGlmZmljdWx0eSkua2V5O1xuXG4gICAgaWYoIWNob3Nlbk5hbWUgfHwgIU1vbnN0ZXJzW2Nob3Nlbk5hbWVdKSB7XG4gICAgICBMb2coJ01vbnN0ZXJTcGF3bmVyJywgYE1vbnN0ZXIgKCR7Y2hvc2VuTmFtZX0pIGNvdWxkIG5vdCBiZSBzcGF3bmVkOiBETHZsICR7ZHVuZ2VvbkxldmVsfSBUYXJnZXRMZXZlbCAke3RhcmdldExldmVsfSB8IGRpZmZpY3VsdHkgcmFuZ2UgJHtsb3dlc3REaWZmaWN1bHR5fS0ke2hpZ2hlc3REaWZmaWN1bHR5fSAtLSBwaWNraW5nIHJhbmRvbSBtb25zdGVyIHRvIHNwYXduLi4uYCwgZmFsc2UpO1xuICAgICAgY2hvc2VuTmFtZSA9IFdlaWdodGVkRXh0ZW5zaW9uKE1vbnN0ZXJzLCAnZnJlcXVlbmN5JywgbW9uc3Rlck5hbWUgPT4gTW9uc3RlcnNbbW9uc3Rlck5hbWVdLmRpZmZpY3VsdHkgPiAwICYmIE1vbnN0ZXJzW21vbnN0ZXJOYW1lXS5kaWZmaWN1bHR5IDwgaGlnaGVzdERpZmZpY3VsdHkpLmtleTtcbiAgICB9XG5cbiAgICBjb25zdCBudW1Nb25zdGVycyA9IFJvbGwoTW9uc3RlcnNbY2hvc2VuTmFtZV0uc3Bhd25QYXR0ZXJuKTtcbiAgICBcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbnVtTW9uc3RlcnM7IGkrKykge1xuICAgICAgY29uc3QgdGlsZSA9IF8uc2FtcGxlKEdhbWVTdGF0ZS53b3JsZC5nZXRWYWxpZFRpbGVzSW5SYW5nZShiYXNlZE9uLngsIGJhc2VkT24ueSwgYmFzZWRPbi56LCA1MCwgKHRpbGUpID0+IGJhc2VkT24uZGlzdEJldHdlZW4odGlsZSkgPiBiYXNlZE9uLmdldFNpZ2h0KCkpKTtcbiAgICAgIHRoaXMuc3Bhd25TaW5nbGUoY2hvc2VuTmFtZSwgdGlsZSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNwYXduU2luZ2xlKG1vbnN0ZXJOYW1lLCB0aWxlKSB7XG5cbiAgICB3aGlsZShHYW1lU3RhdGUubW9uc3RlcnMubGVuZ3RoID49IEdhbWVTdGF0ZS51cGdyYWRlcy5tb25zdGVyTGltaXQpIHtcblxuICAgICAgLy8gc29tZSBtb25zdGVycyBjYW4gYmUgbWFya2VkIGltcG9ydGFudCwgbGlrZSBTZWx5aywgc28gdGhleSB3aWxsIGFsd2F5cyBzcGF3biBhbmQgbmV2ZXIgZGVzcGF3blxuICAgICAgY29uc3QgZmlyc3RCYWRNb25zdGVyID0gXy5maW5kKEdhbWVTdGF0ZS5tb25zdGVycywgbW9uID0+ICFtb24uaW1wb3J0YW50KTtcblxuICAgICAgLy8gY2xlYW4gdXAgb2xkIG1vbnN0ZXJzXG4gICAgICBmaXJzdEJhZE1vbnN0ZXIuZGllKHsgbmFtZTogYFNlbHlrJ3MgRGl2aW5lIEhhbmRgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IG1vbnN0ZXIgPSBNb25zdGVyc1ttb25zdGVyTmFtZV07XG5cbiAgICBpZighbW9uc3Rlcikge1xuICAgICAgTG9nKCdNb25zdGVyU3Bhd25lcicsIGBCYWQgbW9uc3RlciAke21vbnN0ZXJOYW1lfTogJHtuZXcgRXJyb3IoKS5zdGFja31gKTtcbiAgICB9XG5cbiAgICBpZighdGlsZSkge1xuICAgICAgTG9nKCdNb25zdGVyU3Bhd25lcicsIGBCYWQgdGlsZSAke0pTT04uc3RyaW5naWZ5KHRpbGUpfWApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBtb25zdGVyT3B0cyA9IG1vbnN0ZXIuaW5pdCgpO1xuICAgICAgbW9uc3Rlck9wdHMuZGlmZmljdWx0eSA9IG1vbnN0ZXIuZGlmZmljdWx0eTtcbiAgICAgIGNvbnN0IG1vbnN0ZXJJbnN0YW5jZSA9IG5ldyBNb25zdGVyKHRpbGUueCwgdGlsZS55LCB0aWxlLnosIG1vbnN0ZXJPcHRzKTtcbiAgICAgIG1vbnN0ZXJJbnN0YW5jZS5fbmFtZSA9IG1vbnN0ZXJOYW1lO1xuXG4gICAgICByZXR1cm4gbW9uc3Rlckluc3RhbmNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIExvZygnTW9uc3RlclNwYXduZXInLCBgQ291bGQgbm90IHNwYXduIG1vbnN0ZXIgJHttb25zdGVyTmFtZX06ICR7ZS5zdGFja31gKTtcbiAgICB9XG4gIH1cbn0iLCJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBXYWxscyBmcm9tICcuL3dhbGxzJztcbmltcG9ydCAqIGFzIEZsb29ycyBmcm9tICcuL2Zsb29ycyc7XG5pbXBvcnQgKiBhcyBTdGFpcnMgZnJvbSAnLi9zdGFpcnMnO1xuaW1wb3J0ICogYXMgRmVhdHVyZXMgZnJvbSAnLi9mZWF0dXJlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IF8uZXh0ZW5kKHt9LCBXYWxscywgRmxvb3JzLCBTdGFpcnMsIEZlYXR1cmVzKTsiLCJcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcbmltcG9ydCBUaWxlIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3RpbGUnO1xuaW1wb3J0IEdhbWVTdGF0ZSBmcm9tICcuLi8uLi9pbml0L2dhbWVzdGF0ZSc7XG5pbXBvcnQgKiBhcyBGb3VudGFpbkVmZmVjdHMgZnJvbSAnLi4vLi4vY29udGVudC9lZmZlY3RzL2ZvdW50YWluJztcbmltcG9ydCAqIGFzIFRocm9uZUVmZmVjdHMgZnJvbSAnLi4vLi4vY29udGVudC9lZmZlY3RzL3Rocm9uZSc7XG5pbXBvcnQgKiBhcyBTaW5rRHJpbmtFZmZlY3RzIGZyb20gJy4uLy4uL2NvbnRlbnQvZWZmZWN0cy9zaW5rLWRyaW5rJztcbmltcG9ydCAqIGFzIFNpbmtLaWNrRWZmZWN0cyBmcm9tICcuLi8uLi9jb250ZW50L2VmZmVjdHMvc2luay1raWNrJztcbmltcG9ydCB7IFRpbGVzIGFzIEdseXBocyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaHMnO1xuaW1wb3J0IHsgU3BlY2lhbCBhcyBTcGVjaWFsR2x5cGhDb2xvcnMsIFRpbGVzIGFzIEdseXBoQ29sb3JzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBoQ29sb3JzJztcblxuZXhwb3J0IGNsYXNzIERvb3IgZXh0ZW5kcyBUaWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgaXNDbG9zZWQgPSAhIU1hdGgucm91bmQoUk9ULlJORy5nZXRVbmlmb3JtKCkpO1xuICAgIGNvbnN0IG9wZW5DaGFyID0gaXNDbG9zZWQgPyBHbHlwaHMuRG9vck9wZW5Ib3Jpem9udGFsIDogR2x5cGhzLkRvb3JDbG9zZWQ7XG4gICAgc3VwZXIob3BlbkNoYXIsIEdseXBoQ29sb3JzLkRvb3IpO1xuICAgIHRoaXMuX2lzQUlQYXNzYWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLm9wYWNpdHkgPSAhfn5pc0Nsb3NlZDtcbiAgICB0aGlzLmRlbnNpdHkgPSAhfn5pc0Nsb3NlZDtcbiAgfVxuXG4gIC8vIHRoZSBkb29yIHNob3VsZCBsb29rIGRpZmZlcmVudCB0aGFuIHRoZSB3YWxscyBuZXh0IHRvIGl0XG4gIGdldE9wZW5DaGFyKGJhc2VkT24pIHtcbiAgICBjb25zdCBsZWZ0VGlsZUdseXBoID0gYmFzZWRPbi5nbHlwaC5rZXk7XG4gICAgcmV0dXJuIGxlZnRUaWxlR2x5cGggPT09IEdseXBocy5Eb29yT3Blbkhvcml6b250YWwgPyBHbHlwaHMuRG9vck9wZW5WZXJ0aWNhbCA6IEdseXBocy5Eb29yT3Blbkhvcml6b250YWw7XG4gIH1cblxuICBjYW5JbnRlcmFjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZW5zaXR5O1xuICB9XG5cbiAgc2V0UHJvcGVyQ2hhcmFjdGVyKGJhc2VkT24gPSBHYW1lU3RhdGUud29ybGQuZ2V0VGlsZSh0aGlzLnggLSAxLCB0aGlzLnksIHRoaXMueikpIHtcbiAgICBjb25zdCBpc09wZW4gPSB0aGlzLmRlbnNpdHk7XG4gICAgY29uc3QgdG9nZ2xlQ2hhciA9IGlzT3BlbiA/IEdseXBocy5Eb29yQ2xvc2VkIDogdGhpcy5nZXRPcGVuQ2hhcihiYXNlZE9uKTtcbiAgICB0aGlzLmdseXBoLmtleSA9IHRvZ2dsZUNoYXI7XG4gIH1cblxuICBpbnRlcmFjdChlbnRpdHkpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSAhdGhpcy5vcGFjaXR5O1xuICAgIHRoaXMuZGVuc2l0eSA9ICF0aGlzLmRlbnNpdHk7XG4gICAgdGhpcy5zZXRQcm9wZXJDaGFyYWN0ZXIoKTtcblxuICAgIHJldHVybiBgJHtlbnRpdHkubmFtZX0gJHt0aGlzLmRlbnNpdHkgPyAnY2xvc2VkJzogJ29wZW5lZCd9IHRoZSBkb29yLmA7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNlbHlrQWx0YXIgZXh0ZW5kcyBUaWxlIHtcbiAgY29uc3RydWN0b3IoKSB7IHN1cGVyKEdseXBocy5BbHRhciwgU3BlY2lhbEdseXBoQ29sb3JzLlNlbHlrKTsgfVxuXG4gIGNhbkludGVyYWN0KGVudGl0eSkge1xuICAgIHJldHVybiB0aGlzLmRpc3RCZXR3ZWVuKGVudGl0eSkgPD0gMTtcbiAgfVxuXG4gIGludGVyYWN0KGVudGl0eSkge1xuICAgIGVudGl0eS5fYXNjZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBgJHtlbnRpdHkubmFtZX0gaGFzIGFjZW5kZWQgdG8gdGhlIFNlbHlraWFuIFBsYW5lLmA7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZvdW50YWluIGV4dGVuZHMgVGlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEdseXBocy5Gb3VudGFpbiwgR2x5cGhDb2xvcnMuRm91bnRhaW4pO1xuICAgIHRoaXMuZGVuc2l0eSA9IDE7XG4gIH1cblxuICBjYW5JbnRlcmFjdChlbnRpdHkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0QmV0d2VlbihlbnRpdHkpIDw9IDE7XG4gIH1cblxuICBpbnRlcmFjdChlbnRpdHkpIHtcbiAgICBjb25zdCBlZmZlY3QgPSB0aGlzLmdldFJhbmRvbUVmZmVjdChGb3VudGFpbkVmZmVjdHMpO1xuICAgIGVmZmVjdC51c2UoZW50aXR5LCB0aGlzKTtcbiAgICBpZihST1QuUk5HLmdldFBlcmNlbnRhZ2UoKSA8PSAzMykge1xuICAgICAgdGhpcy5jZWFzZUV4aXN0aW5nKCk7XG4gICAgICByZXR1cm4gYFRoZSBmb3VudGFpbiBkcmllZCB1cCFgO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGhyb25lIGV4dGVuZHMgVGlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKEdseXBocy5UaHJvbmUsIEdseXBoQ29sb3JzLlRocm9uZSk7XG4gIH1cblxuICBjYW5JbnRlcmFjdChlbnRpdHkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0QmV0d2VlbihlbnRpdHkpID09PSAwO1xuICB9XG5cbiAgaW50ZXJhY3QoZW50aXR5KSB7XG4gICAgY29uc3QgZWZmZWN0ID0gdGhpcy5nZXRSYW5kb21FZmZlY3QoVGhyb25lRWZmZWN0cyk7XG4gICAgZWZmZWN0LnVzZShlbnRpdHksIHRoaXMpO1xuICAgIGlmKFJPVC5STkcuZ2V0UGVyY2VudGFnZSgpIDw9IDMzKSB7XG4gICAgICB0aGlzLmNlYXNlRXhpc3RpbmcoKTtcbiAgICAgIHJldHVybiBgVGhlIHRocm9uZSB2YW5pc2hlcyBpbiBhIHB1ZmYgb2YgbG9naWMhYDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNpbmsgZXh0ZW5kcyBUaWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoR2x5cGhzLlNpbmssIEdseXBoQ29sb3JzLlNpbmspO1xuICAgIHRoaXMuZGVuc2l0eSA9IDE7XG4gIH1cblxuICBjYW5JbnRlcmFjdChlbnRpdHkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0QmV0d2VlbihlbnRpdHkpIDw9IDE7XG4gIH1cblxuICBiZWNvbWVGb3VudGFpbigpIHtcbiAgICBHYW1lU3RhdGUud29ybGQucGxhY2VOZXdUaWxlKEZvdW50YWluLCB0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcbiAgfVxuXG4gIGludGVyYWN0KGVudGl0eSkge1xuICAgIGlmKFJPVC5STkcuZ2V0UGVyY2VudGFnZSgpIDw9IDYwKSB7XG4gICAgICB0aGlzLmdldFJhbmRvbUVmZmVjdChTaW5rRHJpbmtFZmZlY3RzKS51c2UoZW50aXR5LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZXRSYW5kb21FZmZlY3QoU2lua0tpY2tFZmZlY3RzKS51c2UoZW50aXR5LCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBicmVhayBjaGFuY2VcbiAgICBpZihST1QuUk5HLmdldFBlcmNlbnRhZ2UoKSA8PSAzMCkge1xuXG4gICAgICAvLyBpdCBtaWdodCB0dXJuIGludG8gYSBmb3VudGFpbiwgYnV0IHByb2JhYmx5IG5vdFxuICAgICAgaWYoUk9ULlJORy5nZXRQZXJjZW50YWdlKCkgPD0gMjApIHtcbiAgICAgICAgdGhpcy5iZWNvbWVGb3VudGFpbigpO1xuICAgICAgICByZXR1cm4gYFRoZSBwaXBlcyBleHBsb2RlISBXYXRlciBzcHVydHMgb3V0IWA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2Vhc2VFeGlzdGluZygpO1xuICAgICAgcmV0dXJuIGBUaGUgc2luayBzdG9wcyBwcm92aWRpbmcgd2F0ZXIuYDtcbiAgICB9XG4gIH1cbn0iLCJcbmltcG9ydCBUaWxlIGZyb20gJy4uLy4uL2RlZmluaXRpb25zL3RpbGUnO1xuaW1wb3J0IHsgVGlsZXMgYXMgR2x5cGhzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBocyc7XG5cbmV4cG9ydCBjbGFzcyBWb2lkIGV4dGVuZHMgVGlsZSB7IGNvbnN0cnVjdG9yKCkgeyBzdXBlcigpOyB0aGlzLm9wYWNpdHkgPSAxOyB0aGlzLnJlZmxlY3QgPSAwOyB9fVxuXG5leHBvcnQgY2xhc3MgRHVuZ2VvbkZsb29yIGV4dGVuZHMgVGlsZSB7IGNvbnN0cnVjdG9yKCkgeyBzdXBlcihHbHlwaHMuRmxvb3IpOyB9fVxuXG5leHBvcnQgY2xhc3MgQ29ycmlkb3IgZXh0ZW5kcyBUaWxlIHsgY29uc3RydWN0b3IoKSB7IHN1cGVyKEdseXBocy5Db3JyaWRvcik7IH0gfSIsIlxuaW1wb3J0IFRpbGUgZnJvbSAnLi4vLi4vZGVmaW5pdGlvbnMvdGlsZSc7XG5pbXBvcnQgR2FtZVN0YXRlIGZyb20gJy4uLy4uL2luaXQvZ2FtZXN0YXRlJztcbmltcG9ydCB7IFNlbHlrQ2VsbGFyS2V5IH0gZnJvbSAnLi4vLi4vY29udGVudC9pdGVtcy9fc3BlY2lhbCc7XG5pbXBvcnQgeyBUaWxlcyBhcyBHbHlwaHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2x5cGhzJztcbmltcG9ydCB7IFNwZWNpYWwgYXMgU3BlY2lhbEdseXBoQ29sb3JzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dseXBoQ29sb3JzJztcblxuY2xhc3MgU3RhaXJzIGV4dGVuZHMgVGlsZSB7XG4gIGNhbkludGVyYWN0KGVudGl0eSkge1xuICAgIHJldHVybiB0aGlzLmRpc3RCZXR3ZWVuKGVudGl0eSkgPT09IDA7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBTdGFpcnNEb3duIGV4dGVuZHMgU3RhaXJzIHtcbiAgY29uc3RydWN0b3IoKSB7IHN1cGVyKEdseXBocy5TdGFpcnNEb3duKTsgfVxuXG4gIGNhbkludGVyYWN0KGVudGl0eSkge1xuICAgIHJldHVybiBzdXBlci5jYW5JbnRlcmFjdChlbnRpdHkpICYmIGVudGl0eS5kZXNjZW5kICYmIHRoaXMueiAhPT0gR2FtZVN0YXRlLndvcmxkLmRlcHRoIC0gMTtcbiAgfVxuXG4gIGludGVyYWN0KGVudGl0eSkge1xuICAgIGVudGl0eS5kZXNjZW5kKCk7XG4gICAgcmV0dXJuIGAke2VudGl0eS5uYW1lfSBkZXNjZW5kZWQgdGhlIHN0YWlycy5gO1xuICB9XG59XG5leHBvcnQgY2xhc3MgU2VseWtTdGFpcnNEb3duIGV4dGVuZHMgU3RhaXJzIHtcbiAgY29uc3RydWN0b3IoKSB7IHN1cGVyKEdseXBocy5TdGFpcnNEb3duLCBTcGVjaWFsR2x5cGhDb2xvcnMuU2VseWspOyB9XG5cbiAgY2FuSW50ZXJhY3QoZW50aXR5KSB7XG4gICAgcmV0dXJuIGVudGl0eS5oYXNJbkludmVudG9yeShTZWx5a0NlbGxhcktleSkgJiYgZW50aXR5LmRlc2NlbmQ7XG4gIH1cblxuICBpbnRlcmFjdChlbnRpdHkpIHtcbiAgICBlbnRpdHkuZGVzY2VuZCgpO1xuICAgIHJldHVybiBgJHtlbnRpdHkubmFtZX0gZGVzY2VuZGVkIHRoZSBzdGFpcnMgdG8gU2VseWsncyBDZWxsYXIuYDtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFN0YWlyc1VwIGV4dGVuZHMgU3RhaXJzIHtcbiAgY29uc3RydWN0b3IoKSB7IHN1cGVyKEdseXBocy5TdGFpcnNVcCk7IH1cblxuICBjYW5JbnRlcmFjdCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gcmV0dXJuIHN1cGVyLmNhbkludGVyYWN0KGVudGl0eSkgJiYgdGhpcy56ICE9PSAwO1xuICB9XG5cbiAgaW50ZXJhY3QoZW50aXR5KSB7XG4gICAgZW50aXR5LmFzY2VuZCgpO1xuICAgIHJldHVybiBgJHtlbnRpdHkubmFtZX0gYXNjZW5kZWQgdGhlIHN0YWlycy5gO1xuICB9XG59IiwiXG5pbXBvcnQgVGlsZSBmcm9tICcuLi8uLi9kZWZpbml0aW9ucy90aWxlJztcbmltcG9ydCB7IFRpbGVzIGFzIEdseXBocyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbHlwaHMnO1xuXG5leHBvcnQgY2xhc3MgRHVuZ2Vvbkhvcml6b250YWxXYWxsIGV4dGVuZHMgVGlsZSB7IGNvbnN0cnVjdG9yKCkgeyBzdXBlcihHbHlwaHMuV2FsbEhvcml6b250YWwpOyB0aGlzLmRlbnNpdHkgPSB0aGlzLm9wYWNpdHkgPSAxOyB0aGlzLnJlZmxlY3QgPSAwOyB9fVxuZXhwb3J0IGNsYXNzIER1bmdlb25WZXJ0aWNhbFdhbGwgZXh0ZW5kcyBUaWxlIHsgY29uc3RydWN0b3IoKSB7IHN1cGVyKEdseXBocy5XYWxsVmVydGljYWwpOyB0aGlzLmRlbnNpdHkgPSB0aGlzLm9wYWNpdHkgPSAxOyB0aGlzLnJlZmxlY3QgPSAwOyB9fSIsIlxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBST1QgZnJvbSAncm90LWpzJztcbmltcG9ydCAqIGFzIFRpbGVzIGZyb20gJy4vdGlsZXMvX2FsbCc7XG5pbXBvcnQgRHVuZ2VvbiBmcm9tICcuL21hcHR5cGVzL2R1bmdlb24nO1xuaW1wb3J0IEdhbWVTdGF0ZSBmcm9tICcuLi9pbml0L2dhbWVzdGF0ZSc7XG5pbXBvcnQgSXRlbUdlbmVyYXRvciBmcm9tICcuL2l0ZW0tZ2VuZXJhdG9yJztcbmltcG9ydCBMb2cgZnJvbSAnLi4vbGliL2xvZ2dlcic7XG5cbmNvbnN0IGJhZFRpbGUgPSBuZXcgVGlsZXMuVm9pZCgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JsZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGlsZXMgPSBbXTtcbiAgICBcbiAgICB0aGlzLnN0YWlycyA9IFtdO1xuICAgIFxuICAgIHRoaXMuZW50aXRpZXMgPSBbXTtcbiAgICB0aGlzLml0ZW1zID0gW107XG4gICAgXG4gICAgdGhpcy5mb3YgPSBbXTtcbiAgICB0aGlzLmxpZ2h0aW5nID0gW107XG4gICAgdGhpcy5leHBsb3JlZCA9IFtdO1xuICB9XG5cbiAgc2V0TWFwQXQoZmxvb3IsIGkpIHtcbiAgICBjb25zdCB7IG1hcCwgbWFwTmFtZSwgcm9vbXMsIHNob3J0TWFwTmFtZSwgc3RhaXJzIH0gPSBmbG9vcjtcbiAgICB0aGlzLnRpbGVzW2ldID0gbWFwO1xuICAgIHRoaXMudGlsZXNbaV0ubWFwTmFtZSA9IG1hcE5hbWU7XG4gICAgdGhpcy50aWxlc1tpXS5zaG9ydE1hcE5hbWUgPSBzaG9ydE1hcE5hbWU7XG4gICAgdGhpcy50aWxlc1tpXS5yb29tcyA9IHJvb21zO1xuICAgIGNvbnN0IFt1cFN0YWlycywgZG93blN0YWlyc10gPSBzdGFpcnM7XG5cbiAgICB0aGlzLnN0YWlyc1tpXSA9IHt9O1xuICAgIGlmKHVwU3RhaXJzKSB0aGlzLnN0YWlyc1tpXS51cCA9IFt1cFN0YWlycy54LCB1cFN0YWlycy55XTtcbiAgICBpZihkb3duU3RhaXJzKSB0aGlzLnN0YWlyc1tpXS5kb3duID0gW2Rvd25TdGFpcnMueCwgZG93blN0YWlycy55XTtcblxuICAgIHRoaXMucGxhY2VJdGVtc09uTWFwKGkpO1xuICB9XG4gIFxuICBnZW5lcmF0ZVdvcmxkKG9wdHMgPSB7fSkge1xuICAgIF8uZGVmYXVsdHMob3B0cywgeyB3aWR0aDogNzAsIGhlaWdodDogNzAsIGRlcHRoOiAxMCB9KTtcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgZGVwdGggfSA9IG9wdHM7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIFxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkZXB0aDsgaSsrKSB7XG4gICAgICBjb25zdCBnZW5PcHRzID0geyB3OiB3aWR0aCwgaDogaGVpZ2h0LCB6OiBpIH07XG4gICAgICB0aGlzLnNldE1hcEF0KER1bmdlb24uZ2VuZXJhdGUoZ2VuT3B0cyksIGkpO1xuICAgIH1cblxuICAgIGlmKEdhbWVTdGF0ZS53aW5Db25kaXRpb24ubWFwQWRkaXRpb25zKCkpIHtcbiAgICAgIHRoaXMuZGVwdGggPSB0aGlzLnRpbGVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwKCk7XG4gIH1cblxuICAvLyByZWdpb24gU2V0dXAgZnVuY3Rpb25zXG4gIHNldHVwKCkge1xuICAgIHRoaXMuc2V0dXBFeHBsb3JlZCgpO1xuICAgIHRoaXMuc2V0dXBGT1YoKTtcbiAgfVxuXG4gIHNldHVwRXhwbG9yZWQoKSB7XG4gICAgZm9yKGxldCB6PTA7IHo8dGhpcy5kZXB0aDsgeisrKSB7XG4gICAgICB0aGlzLmV4cGxvcmVkW3pdID0gW107XG4gICAgICBmb3IobGV0IHg9MDsgeDx0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgdGhpcy5leHBsb3JlZFt6XVt4XSA9IFtdO1xuICAgICAgICBmb3IobGV0IHk9MDsgeTx0aGlzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgdGhpcy5leHBsb3JlZFt6XVt4XVt5XSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBzZXR1cEZPVigpIHtcbiAgICBmb3IobGV0IHogPSAwOyB6IDwgdGhpcy5kZXB0aDsgeisrKSB7XG4gICAgICB0aGlzLmZvdlt6XSA9IG5ldyBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcoXG4gICAgICAgICh4LCB5KSA9PiB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLmdldFRpbGUoeCwgeSwgeikuaXNCbG9ja2luZ0xpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8vIHJlZ2lvbiBFeHBsb3JhdGlvbiBmdW5jdGlvbnNcbiAgc2V0RXhwbG9yZWQoeCwgeSwgeiwgc3RhdGUgPSB0cnVlKSB7XG4gICAgaWYodGhpcy5pc1ZvaWQoeCwgeSwgeikpIHJldHVybjtcbiAgICB0aGlzLmV4cGxvcmVkW3pdW3hdW3ldID0gc3RhdGU7XG4gIH1cblxuICBpc0V4cGxvcmVkKHgsIHksIHopIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZvaWQoeCwgeSwgeikgPyBmYWxzZSA6IHRoaXMuZXhwbG9yZWRbel1beF1beV07XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFRpbGUgZnVuY3Rpb25zXG4gIGdldFRpbGUoeCwgeSwgeikge1xuICAgIGlmKHogPCAwIHx8IHogPiB0aGlzLnRpbGVzLmxlbmd0aCB8fFxuICAgICAgeCA8IDAgfHwgeCA+PSB0aGlzLnRpbGVzW3pdLmxlbmd0aCB8fFxuICAgICAgeSA8IDAgfHwgeSA+PSB0aGlzLnRpbGVzW3pdW3hdLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJhZFRpbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGlsZXNbel1beF1beV07XG4gIH1cblxuICBwbGFjZU5ld1RpbGUodGlsZVByb3RvLCB4LCB5LCB6KSB7XG4gICAgY29uc3QgdGlsZSA9IG5ldyB0aWxlUHJvdG8oKTtcbiAgICB0aWxlLnggPSB4O1xuICAgIHRpbGUueSA9IHk7XG4gICAgdGlsZS56ID0gejtcbiAgICB0aGlzLnRpbGVzW3pdW3hdW3ldID0gdGlsZTtcbiAgfVxuICBcbiAgaXNWb2lkKHgsIHksIHopIHtcbiAgICBjb25zdCB0aWxlID0gdGhpcy5nZXRUaWxlKHgsIHksIHopO1xuICAgIHJldHVybiAhdGlsZSB8fCAhdGhpcy5nZXRUaWxlKHgsIHksIHopLmdseXBoLmtleTtcbiAgfVxuICBcbiAgaXNUaWxlRW1wdHkoeCwgeSwgeikge1xuICAgIGNvbnN0IHRpbGUgPSB0aGlzLmdldFRpbGUoeCwgeSwgeik7XG4gICAgcmV0dXJuIHRpbGUgJiYgIXRpbGUuaXNEZW5zZSgpICYmICF0aGlzLmdldEVudGl0eSh4LCB5LCB6KSAmJiAhdGhpcy5pc1ZvaWQoeCwgeSwgeik7XG4gIH1cbiAgXG4gIGlzVGlsZVBhc3NhYmxlKHgsIHksIHosIGluY2xBSVBhc3MgPSB0cnVlKSB7XG4gICAgY29uc3QgdGlsZSA9IHRoaXMuZ2V0VGlsZSh4LCB5LCB6KTtcbiAgICBjb25zdCBhaVBhc3MgPSBpbmNsQUlQYXNzID8gdGlsZS5faXNBSVBhc3NhYmxlIDogdHJ1ZTtcbiAgICByZXR1cm4gdGlsZSAmJiBhaVBhc3MgfHwgdGhpcy5pc1RpbGVFbXB0eSh4LCB5LCB6KTtcbiAgfVxuXG4gIGdldEFsbFRpbGVzSW5SYW5nZSh4LCB5LCB6LCByYWRpdXMpIHtcbiAgICBjb25zdCB0aWxlcyA9IFtdO1xuXG4gICAgLy8gbGluZSB0aGVzZSB0aWxlcyB1cCB3aXRoIHRoZSBudW1wYWRcbiAgICBmb3IobGV0IG5ld1kgPSB5ICsgcmFkaXVzOyBuZXdZID49IHkgLSByYWRpdXM7IG5ld1ktLSkge1xuICAgICAgZm9yKGxldCBuZXdYID0geCAtIHJhZGl1czsgbmV3WCA8PSB4ICsgcmFkaXVzOyBuZXdYKyspIHtcbiAgICAgICAgY29uc3QgdGlsZSA9IHRoaXMudGlsZXNbel1bbmV3WF1bbmV3WV07XG4gICAgICAgIHRpbGVzLnB1c2godGlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbGVzO1xuICB9XG5cbiAgZ2V0VmFsaWRUaWxlc0luUmFuZ2UoeCwgeSwgeiwgcmFkaXVzLCBmaWx0ZXIgPSAoKSA9PiB0cnVlKSB7XG4gICAgY29uc3QgdGlsZXMgPSBbXTtcblxuICAgIGNvbnN0IGxvd2VyWCA9IE1hdGgubWF4KHggLSByYWRpdXMsIDApO1xuICAgIGNvbnN0IHVwcGVyWCA9IE1hdGgubWluKHggKyByYWRpdXMsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGxvd2VyWSA9IE1hdGgubWF4KHkgLSByYWRpdXMsIDApO1xuICAgIGNvbnN0IHVwcGVyWSA9IE1hdGgubWluKHkgKyByYWRpdXMsIHRoaXMuaGVpZ2h0KTtcblxuICAgIGZvcihsZXQgbmV3WCA9IGxvd2VyWDsgbmV3WCA8PSB1cHBlclg7IG5ld1grKykge1xuICAgICAgZm9yKGxldCBuZXdZID0gbG93ZXJZOyBuZXdZIDw9IHVwcGVyWTsgbmV3WSsrKSB7XG4gICAgICAgIGlmKCF0aGlzLnRpbGVzW3pdW25ld1hdKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdGlsZSA9IHRoaXMudGlsZXNbel1bbmV3WF1bbmV3WV07XG4gICAgICAgIGlmKCF0aWxlKSBjb250aW51ZTtcbiAgICAgICAgaWYoIXRoaXMuaXNUaWxlRW1wdHkobmV3WCwgbmV3WSwgeikpIGNvbnRpbnVlO1xuICAgICAgICB0aWxlcy5wdXNoKHRpbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfLmZpbHRlcih0aWxlcywgZmlsdGVyKTtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gRHVhbC1wdXJwb3NlIGdldHRlcnMvc2V0dGVyc1xuICBnZXRXaXRob3V0SW5pdHMoeCwgeSwgeiwgbGlzdCA9ICdlbnRpdGllcycpIHtcbiAgICBpZighdGhpc1tsaXN0XVt6XSkgcmV0dXJuIG51bGw7XG4gICAgaWYoIXRoaXNbbGlzdF1bel1beF0pIHJldHVybiBudWxsO1xuICAgIGlmKCF0aGlzW2xpc3RdW3pdW3hdW3ldKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICByZXR1cm4gdGhpc1tsaXN0XVt6XVt4XVt5XTtcbiAgfVxuICBcbiAgZW5zdXJlTG9jYXRpb24oeCwgeSwgeiwgbGlzdCA9ICdlbnRpdGllcycsIHNldFRvID0gbnVsbCkge1xuICAgIGlmKCF0aGlzW2xpc3RdW3pdKSB0aGlzW2xpc3RdW3pdID0gW107XG4gICAgaWYoIXRoaXNbbGlzdF1bel1beF0pIHRoaXNbbGlzdF1bel1beF0gPSBbXTtcbiAgICBpZighdGhpc1tsaXN0XVt6XVt4XVt5XSkgdGhpc1tsaXN0XVt6XVt4XVt5XSA9IHNldFRvO1xuICB9XG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8vIHJlZ2lvbiBJdGVtIGZ1bmN0aW9uc1xuICBwbGFjZUl0ZW1zT25NYXAoeiwgaXRlbXNSZW1haW5pbmcgPSBHYW1lU3RhdGUudXBncmFkZXMuaXRlbXNJbkR1bmdlb24pIHtcbiAgICB3aGlsZShpdGVtc1JlbWFpbmluZyA+IDAgJiYgUk9ULlJORy5nZXRQZXJjZW50YWdlKCkgPD0gR2FtZVN0YXRlLnVwZ3JhZGVzLml0ZW1Ecm9wQ2hhbmNlKSB7XG4gICAgICBpdGVtc1JlbWFpbmluZy0tO1xuICAgICAgR2FtZVN0YXRlLndvcmxkLnBsYWNlSXRlbUF0UmFuZG9tTG9jYXRpb24oSXRlbUdlbmVyYXRvci5zcGF3bigpLCB6KTtcbiAgICB9XG4gIH1cblxuICBnZXRJdGVtc0F0KHgsIHksIHopIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXaXRob3V0SW5pdHMoeCwgeSwgeiwgJ2l0ZW1zJyk7XG4gIH1cblxuICByZW1vdmVJdGVtKGl0ZW0pIHtcbiAgICBjb25zdCBteUl0ZW1zID0gdGhpcy5nZXRJdGVtc0F0KGl0ZW0ueCwgaXRlbS55LCBpdGVtLnopO1xuICAgIGlmKCFfLmNvbnRhaW5zKG15SXRlbXMsIGl0ZW0pKSB7XG4gICAgICBMb2coJ1dvcmxkJywgYEludmFsaWQgaXRlbSByZW1vdmFsIGF0dGVtcHQuICR7aXRlbS5uYW1lfSBub3QgZm91bmQgaW4gbGlzdDogJHtfLnBsdWNrKG15SXRlbXMsICduYW1lJykuam9pbignLCAnKX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pdGVtc1tpdGVtLnpdW2l0ZW0ueF1baXRlbS55XSA9IF8ud2l0aG91dCh0aGlzLml0ZW1zW2l0ZW0uel1baXRlbS54XVtpdGVtLnldLCBpdGVtKTtcbiAgICBpdGVtLnggPSBpdGVtLnkgPSBpdGVtLnogPSB1bmRlZmluZWQ7XG4gIH1cbiAgXG4gIG1vdmVJdGVtKGl0ZW0sIHgsIHksIHopIHtcbiAgICB0aGlzLmVuc3VyZUxvY2F0aW9uKHgsIHksIHosICdpdGVtcycsIFtdKTtcbiAgICBcbiAgICBpZihpdGVtLnggJiYgaXRlbS55ICYmIGl0ZW0ueikge1xuICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgIH1cbiAgICBcbiAgICBpdGVtLnggPSB4O1xuICAgIGl0ZW0ueSA9IHk7XG4gICAgaXRlbS56ID0gejtcbiAgICB0aGlzLml0ZW1zW3pdW3hdW3ldLnB1c2goaXRlbSk7XG4gIH1cblxuICBwbGFjZUl0ZW1BdFJhbmRvbUxvY2F0aW9uKGl0ZW0sIHopIHtcbiAgICBjb25zdCB0aWxlID0gXyh0aGlzLnRpbGVzW3pdKS5mbGF0dGVuKCkuZmlsdGVyKHRpbGUgPT4gdGlsZS5nbHlwaC5rZXkpLnJlamVjdCh0aWxlID0+IHRpbGUuaXNEZW5zZSgpKS5zYW1wbGUoKTtcbiAgICB0aGlzLm1vdmVJdGVtKGl0ZW0sIHRpbGUueCwgdGlsZS55LCB6KTtcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gRW50aXR5IGZ1bmN0aW9uc1xuICBtb3ZlRW50aXR5KGVudGl0eSwgeCwgeSwgeikge1xuICAgIGlmKCF0aGlzLmlzVGlsZUVtcHR5KHgsIHksIHopKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgdGhpcy5lbnN1cmVMb2NhdGlvbih4LCB5LCB6KTtcbiAgICB0aGlzLmVuc3VyZUxvY2F0aW9uKGVudGl0eS54LCBlbnRpdHkueSwgZW50aXR5LnopO1xuICAgIFxuICAgIHRoaXMuZW50aXRpZXNbZW50aXR5LnpdW2VudGl0eS54XVtlbnRpdHkueV0gPSBudWxsO1xuICAgIFxuICAgIGVudGl0eS54ID0geDtcbiAgICBlbnRpdHkueSA9IHk7XG4gICAgZW50aXR5LnogPSB6O1xuICAgIHRoaXMuZW50aXRpZXNbel1beF1beV0gPSBlbnRpdHk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZW1vdmVFbnRpdHkoZW50aXR5KSB7XG4gICAgY29uc3QgbXlFbnRpdHkgPSB0aGlzLmdldEVudGl0eShlbnRpdHkueCwgZW50aXR5LnksIGVudGl0eS56KTtcbiAgICBpZihteUVudGl0eSAhPT0gZW50aXR5KSB7XG4gICAgICBMb2coJ1dvcmxkJywgYEludmFsaWQgZW50aXR5IHJlbW92YWwgYXR0ZW1wdC4gJHtlbnRpdHkgPyBlbnRpdHkubmFtZSA6IG51bGx9IHRyaWVkIHRvIHJlbW92ZSAke215RW50aXR5ID8gbXlFbnRpdHkubmFtZSA6IG51bGx9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZW50aXRpZXNbZW50aXR5LnpdW2VudGl0eS54XVtlbnRpdHkueV0gPSBudWxsO1xuICB9XG4gIFxuICBnZXRFbnRpdHkoeCwgeSwgeikge1xuICAgIHJldHVybiB0aGlzLmdldFdpdGhvdXRJbml0cyh4LCB5LCB6KTtcbiAgfVxuICBcbiAgcGxhY2VFbnRpdHlBdFJhbmRvbUxvY2F0aW9uKGVudGl0eSwgeiA9IGVudGl0eS56KSB7XG4gICAgY29uc3QgdGlsZSA9IF8odGhpcy50aWxlc1t6XSkuZmxhdHRlbigpLmZpbHRlcih0aWxlID0+IHRpbGUuZ2x5cGgua2V5KS5yZWplY3QodGlsZSA9PiB0aWxlLmlzRGVuc2UoKSkuc2FtcGxlKCk7XG4gICAgdGhpcy5tb3ZlRW50aXR5KGVudGl0eSwgdGlsZS54LCB0aWxlLnksIHopO1xuICB9XG4gIFxuICBnZXRWYWxpZEVudGl0aWVzSW5SYW5nZSh4LCB5LCB6LCByYWRpdXMsIGZpbHRlciA9ICgpID0+IHRydWUpIHtcbiAgICBjb25zdCBlbnRpdGllcyA9IFtdO1xuICAgIFxuICAgIGNvbnN0IGxvd2VyWCA9IE1hdGgubWF4KHggLSByYWRpdXMsIDApO1xuICAgIGNvbnN0IHVwcGVyWCA9IE1hdGgubWluKHggKyByYWRpdXMsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGxvd2VyWSA9IE1hdGgubWF4KHkgLSByYWRpdXMsIDApO1xuICAgIGNvbnN0IHVwcGVyWSA9IE1hdGgubWluKHkgKyByYWRpdXMsIHRoaXMuaGVpZ2h0KTtcbiAgICBcbiAgICBmb3IobGV0IG5ld1ggPSBsb3dlclg7IG5ld1ggPD0gdXBwZXJYOyBuZXdYKyspIHtcbiAgICAgIGZvcihsZXQgbmV3WSA9IGxvd2VyWTsgbmV3WSA8PSB1cHBlclk7IG5ld1krKykge1xuICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmdldEVudGl0eShuZXdYLCBuZXdZLCB6KTtcbiAgICAgICAgaWYoIWVudGl0eSkgY29udGludWU7XG4gICAgICAgIGVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXy5maWx0ZXIoZW50aXRpZXMsIGZpbHRlcik7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIExpZ2h0aW5nIGZ1bmN0aW9uc1xuICBhZGRMaWdodGluZyhsaWdodFNvdXJjZSkge1xuICAgIGlmKCF0aGlzLmxpZ2h0aW5nW2xpZ2h0U291cmNlLnpdKSB0aGlzLmxpZ2h0aW5nW2xpZ2h0U291cmNlLnpdID0gW107XG4gICAgdGhpcy5saWdodGluZ1tsaWdodFNvdXJjZS56XS5wdXNoKGxpZ2h0U291cmNlKTtcbiAgfVxuXG4gIHJlbW92ZUxpZ2h0aW5nKGxpZ2h0U291cmNlKSB7XG4gICAgdGhpcy5saWdodGluZ1tsaWdodFNvdXJjZS56XSA9IF8ud2l0aG91dCh0aGlzLmxpZ2h0aW5nW2xpZ2h0U291cmNlLnpdLCBsaWdodFNvdXJjZSk7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgZGVzY2VuZCgpIHtcbiAgICBpZighR2FtZVN0YXRlLndpbkNvbmRpdGlvbi5zaG91bGRUcmlnZ2VyKCkpIHJldHVybjtcbiAgICBHYW1lU3RhdGUud2luQ29uZGl0aW9uLnRyaWdnZXIoKTtcbiAgfVxuXG4gIGNsZWFuVXAoKSB7XG4gICAgXy5lYWNoKF8uY29tcGFjdChfLmZsYXR0ZW5EZWVwKHRoaXMuZW50aXRpZXMpKSwgZSA9PiBlLnJlbW92ZVNlbGYoKSAmJiBlLmNsZWFuVXAoKSk7XG5cbiAgICBmb3IobGV0IHogPSAwOyB6IDwgdGhpcy50aWxlcy5sZW5ndGg7IHorKykge1xuICAgICAgZm9yKGxldCB4ID0gMDsgeCA8IHRoaXMudGlsZXNbel0ubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgZm9yKGxldCB5ID0gMDsgeSA8IHRoaXMudGlsZXNbel1beF0ubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICB0aGlzLnRpbGVzW3pdW3hdW3ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbGVzW3pdW3hdID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudGlsZXNbel0gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudGlsZXMgPSBudWxsO1xuICAgIHRoaXMuc3RhaXJzID0gbnVsbDtcbiAgICB0aGlzLmVudGl0aWVzID0gbnVsbDtcbiAgICB0aGlzLml0ZW1zID0gbnVsbDtcbiAgICB0aGlzLmZvdiA9IG51bGw7XG4gICAgdGhpcy5saWdodGluZyA9IG51bGw7XG4gICAgdGhpcy5leHBsb3JlZCA9IG51bGw7XG4gIH1cbn0iXX0=
